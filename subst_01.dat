-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint64_t ConvertStringTo64Bit(const char* idstring);
	const char* FormatDateTimeString(int64_t time, const char* uiformat);
	const char* GetChatAuthorColor2(const char* authorname);
	int64_t GetCurrentUTCDataTime(void);
	const char* GetUserData(const char* name);
	bool IsVentureSeasonSupported(void);
	void NotifyChatMessageRead(void);
	void SetUserData(const char* name, const char* value);
	void TriggerInputFeedback(const char* type, const char* idname, const char* triggerid, const char* contextid);
]]

local menu = {
	name = "ChatWindow",
	active = false,
	userColors = {},
	mouseover = {},
	editboxstate = { text = "" },
	privatemessages = {},
	privateMessageIndex = 0,
	selectedPrivateMessages = 0,
}

local function init()
	-- register callbacks
	registerForEvent("chatMessageReceived", getElement("Scene.UIContract"), menu.onChatMessageReceived)
	RegisterEvent("announcementReceived", menu.onAnnouncementReceived)
	RegisterEvent("chatreported", menu.onChatReported)
	RegisterEvent("showchatwindow", function () return menu.toggleChatWindow() end)

	-- init variables
	menu.isStartmenu = C.IsStartmenu()

	SetScript("onHotkey", menu.onHotkey)

	-- register menu
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
end


--- config ---

local config = {
	layer = 3,
	contextLayer = 2,
	width = 400,
	frameBackgroundFactor = 1.3,
	currentVersion = 3,
	frameXDefault = 50,
	frameYDefault = Helper.viewHeight / 2,
	frameSizeDefault = "normal",
	timeout = 5,
	fadeout = 2,
	mouseOutRange = 100,
	contextMenuWidth = 260,
	announcementAgeCutOff = 3600,
}

-- __CORE_CHAT_WINDOW = {
--		version = number	-- data version
--		x = number			-- frame x offset
--		y = number			-- frame y offset
--		size = number		-- frame size
--		announcements = {}	-- announcement buffer
-- }
__CORE_CHAT_WINDOW = __CORE_CHAT_WINDOW or { version = config.currentVersion, x = config.frameXDefault, y = config.frameYDefault, size = config.frameSizeDefault, announcements = {} }
-- patch
if __CORE_CHAT_WINDOW.version <= 1 then
	__CORE_CHAT_WINDOW = { version = 2, x = config.frameXDefault, y = config.frameYDefault, size = config.frameSizeDefault }
end
if __CORE_CHAT_WINDOW.version <= 2 then
	__CORE_CHAT_WINDOW.announcements = {}
end
__CORE_CHAT_WINDOW.version = config.currentVersion


--- widget hooks ---

function menu.onHotkey(action)
	if action == "INPUT_ACTION_SHOW_CHAT_WINDOW" then
		local active = (not menu.shown) or (not menu.active) or next(Helper.chatParams)
		C.TriggerInputFeedback("action", "INPUT_ACTION_SHOW_CHAT_WINDOW", active and "active" or "inactive", "")
		menu.toggleChatWindow()
	end
end

function menu.onChatMessageReceived()
	if menu.shown then
		menu.messagesOutdated = true

		local messagetexts = menu.messagetexts
		if menu.selectedPrivateMessages > 0 then
			messagetexts = menu.privatemessages[menu.selectedPrivateMessages].messages
		end

		if menu.active then
			local toprow = GetTopRow(menu.chatTable)
			if toprow == ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines)) then
				menu.settoprow = nil
			else
				menu.settoprow = toprow
			end
		else
			if menu.fadetoprow == ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines)) then
				menu.settoprow = nil
			end
		end
		if not menu.dragging then
			if menu.typing then
				menu.activateeditbox = true
			end
			menu.onShowMenu()
		end
	end
end

function menu.onAnnouncementReceived(_, message)
	if (#__CORE_CHAT_WINDOW.announcements == 0) or (__CORE_CHAT_WINDOW.announcements[#__CORE_CHAT_WINDOW.announcements].text ~= message) then
		-- have to convert timestamp to string for saving in uidata.xml
		table.insert(__CORE_CHAT_WINDOW.announcements, { text = message, prefix = ColorText["text_chat_message_server"] .. ReadText(1001, 12109) .. ReadText(1001, 120) .. " ", timestamp = tostring(C.GetCurrentUTCDataTime() * 1000), announcement = true })
		if not menu.shown then
			menu.toggleChatWindow(true)
		end
	end
end

function menu.onChatReported(_, timestamp)
	if menu.shown then
		menu.messagesOutdated = true
		menu.onShowMenu()
	end
end

--- helper functions ---

function menu.toggleChatWindow(noeditboxactivation)
	if (not menu.shown) or (not menu.active) or next(Helper.chatParams) then
		menu.active = true
		menu.lastInteraction = getElapsedTime()
		Helper.setChatUpdateHandler(menu)
		menu.messagesOutdated = true
		menu.settoprow = nil

		if (not menu.shown) and (not noeditboxactivation) then
			menu.activateeditbox = true
		end

		if next(Helper.chatParams) then
			_, menu.selectedPrivateMessages = menu.getPrivateMessages(Helper.chatParams.id, Helper.chatParams.name)
			if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
				menu.privateMessageIndex = menu.selectedPrivateMessages - 2
			elseif menu.selectedPrivateMessages < menu.privateMessageIndex then
				menu.privateMessageIndex = menu.selectedPrivateMessages
			end
			Helper.chatParams = {}
		end

		menu.onShowMenu()
	else
		menu.closeMenu("close")
	end
end

function menu.cleanup()
	menu.chatFrame = nil
	menu.active = false
	menu.dragging = nil
	menu.fadefactor = nil
	menu.islocked = nil

	menu.contextMenuMode = nil
	menu.contextMenuData = {}
	menu.mouseOutBox = nil
	
	menu.shown = nil
	menu.mouseover = {}
end

function menu.getChatColor(author, authorid, userid)
	if not menu.userColors[author] then
		if authorid == userid then
			menu.userColors[author] = Color["text_player"]
		else
			local colorid = ffi.string(C.GetChatAuthorColor2(author))
			menu.userColors[author] = Color[colorid]
		end
	end
	return menu.userColors[author]
end

function menu.getMessageReceiverID(userid, groupid)
	menu.chatgroups = menu.chatgroups or {}
	if not menu.chatgroups[groupid] then
		menu.chatgroups[groupid] = OnlineGetChatGroupUsers(groupid)
		if not next(menu.chatgroups[groupid]) then
			menu.chatgroups[groupid] = nil
			return -1, ""
		end
	end
	for _, user in ipairs(menu.chatgroups[groupid]) do
		if user.id ~= userid then
			return user.id, user.name
		end
	end
	return -1, ""
end

function menu.getPrivateMessages(receiverid, receivername, groupid, timestamp)
	local currentlastmessageread = groupid and C.ConvertStringTo64Bit(C.GetUserData("chat_group_" .. groupid)) or 0

	for i, entry in ipairs(menu.privatemessages) do
		if entry.receiverid == receiverid then
			if groupid and (menu.privatemessages[i].groupid == nil) then
				menu.privatemessages[i].groupid = groupid
			end
			if menu.privatemessages[i].hidden and ((not timestamp) or (timestamp > currentlastmessageread)) then
				menu.privatemessages[i].hidden = false
			end
			return menu.privatemessages[i].messages, i
		end
	end

	table.insert(menu.privatemessages, { receiverid = receiverid, name = receivername, groupid = groupid, hiden = (not timestamp) or (timestamp > currentlastmessageread), messages = {} })
	return menu.privatemessages[#menu.privatemessages].messages, #menu.privatemessages
end

function menu.getChatMessages()
	if menu.messagesOutdated then
		local username, userid = OnlineGetUserName()
		local fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		menu.messagetexts = {}
		for i in ipairs(menu.privatemessages) do
			menu.privatemessages[i].messages = {}
		end

		local prevdate = ""
		local messages = OnlineGetChatMessages()

		-- kuertee start:
		if not messages then
			messages = {}
		end
		-- kuertee end

		for i, message in ipairs(messages) do
			local color = menu.getChatColor(message.author, message.authorid, userid)

			local timestamp = C.ConvertStringTo64Bit(tostring(message.time))
			local date = ffi.string(C.FormatDateTimeString(timestamp / 1000, "%Y-%m-%d"))
			if date ~= prevdate then
				prevdate = date
				table.insert(menu.messagetexts, { line = -1, text = "--- " .. date .. " ---", prefix = nil, timestamp = timestamp, authorid = message.authorid, datedivider = true })
			end

			local prefix = ffi.string(C.FormatDateTimeString(timestamp / 1000, "%H:%M")) .. " " .. Helper.convertColorToText(color) .. message.author .. "\27X" .. ReadText(1001, 120) .. " "
			local indent = C.GetTextWidth(prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)

			local lines = GetTextLines(message.reported and ReadText(1001, 12116) or message.text, Helper.standardFont, fontsize, menu.width - indent - Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
			for j, line in ipairs(lines) do
				local text = message.reported and (ColorText["text_inactive"] .. line .. "\27X") or line

				if message.isprivate then
					local receiverid, receivername = menu.getMessageReceiverID(userid, message.groupid)
					if receiverid >= 0 then
						local messages, receiverid = menu.getPrivateMessages(receiverid, receivername, message.groupid, timestamp)
						table.insert(messages, { line = j, text = text, prefix = (j == 1) and prefix or nil, timestamp = timestamp, author = message.author, authorcolor = color, reported = message.reported, authorid = message.authorid })
					end
				else
					table.insert(menu.messagetexts, { line = j, text = text, prefix = (j == 1) and prefix or nil, timestamp = timestamp, author = message.author, authorcolor = color, reported = message.reported, authorid = message.authorid })
				end
			end
		end

		local announcementagecutoff = (C.GetCurrentUTCDataTime() - config.announcementAgeCutOff) * 1000
		for i = #__CORE_CHAT_WINDOW.announcements, 1, -1 do
			local announcement = Helper.tableCopy(__CORE_CHAT_WINDOW.announcements[i])
			announcement.timestamp = C.ConvertStringTo64Bit(announcement.timestamp)
			if announcement.timestamp < announcementagecutoff then
				table.remove(__CORE_CHAT_WINDOW.announcements, i)
			else
				local indent = C.GetTextWidth(announcement.prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)
				local lines = GetTextLines(announcement.text, Helper.standardFont, fontsize, menu.width - indent - Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
				for j, line in ipairs(lines) do
					local announcementline = Helper.tableCopy(announcement)
					announcementline.text = ColorText["text_chat_message_server"] .. line .. "\27X"
					if j > 1 then
						announcementline.prefix = nil
					end
					announcementline.line = j
					table.insert(menu.messagetexts, announcementline)
				end
			end
		end
		table.sort(menu.messagetexts, menu.sortMessages)

		menu.messagesOutdated = nil
	end
end

function menu.sortMessages(a, b)
	if a.timestamp == b.timestamp then
		if a.authorid == b.authorid then
			return a.line < b.line
		end
		return a.authorid < b.authorid
	end
	return a.timestamp < b.timestamp
end

function menu.buttonDrag()
	local x, y = GetLocalMousePosition()
	local framex, framey = GetFramePosition(menu.chatFrame.id)

	menu.dragoffset = { x = x + Helper.viewWidth / 2 - framex, y = Helper.viewHeight / 2 - y - framey }
	menu.dragging = not menu.dragging
end

function menu.buttonReportMessage(timestamp, author)
	OpenMenu("MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "chat", "Inappropriate chat message", ConvertStringToLuaID(tostring(timestamp)), author } }, nil) -- hardcoded text only visible in venture server moderator interface
	menu.mouseover = {}
	menu.islocked = true
	menu.closeContextMenu(true)
end

function menu.buttonReportUser(userid)
	OpenMenu("MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "user", "Offensive user name", nil, nil, nil, userid } }, nil) -- hardcoded text only visible in venture server moderator interface
	menu.mouseover = {}
	menu.islocked = true
	menu.closeContextMenu(true)
end

function menu.buttonContactMessage(menu, userid, username)
	_, menu.selectedPrivateMessages = menu.getPrivateMessages(userid, username)
	if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
		menu.privateMessageIndex = menu.selectedPrivateMessages - 2
	elseif menu.selectedPrivateMessages < menu.privateMessageIndex then
		menu.privateMessageIndex = menu.selectedPrivateMessages
	end
	menu.closeContextMenu(true)
	menu.onShowMenu()
end

function menu.buttonNextChannel()
	menu.selectedPrivateMessages = math.min(#menu.privatemessages, menu.selectedPrivateMessages + 1)
	if menu.selectedPrivateMessages > menu.privateMessageIndex + 2 then
		menu.privateMessageIndex = menu.selectedPrivateMessages - 2
	end
	menu.settoprow = nil
	menu.onShowMenu()
end

function menu.buttonPrevChannel()
	menu.selectedPrivateMessages = math.max(0, menu.selectedPrivateMessages - 1)
	if menu.selectedPrivateMessages < menu.privateMessageIndex then
		menu.privateMessageIndex = menu.selectedPrivateMessages
	end
	menu.settoprow = nil
	menu.onShowMenu()
end

function menu.buttonClosePrivateChat(idx)
	local entry = menu.privatemessages[idx]
	table.remove(menu.privatemessages, idx)
	menu.selectedPrivateMessages = math.min(menu.selectedPrivateMessages, #menu.privatemessages)
	if entry.groupid then
		C.SetUserData("chat_group_" .. entry.groupid, tostring(entry.messages[#entry.messages].timestamp))
		C.NotifyChatMessageRead()
	end
	menu.onShowMenu()
end

function menu.checkboxMute(_, checked)
	local userdataid = "chat_general_muted"
	if menu.selectedPrivateMessages > 0 then
		local entry = menu.privatemessages[menu.selectedPrivateMessages]
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
	end
	C.SetUserData(userdataid, checked and "1" or "0")
end

function menu.editboxActivated()
	if not menu.activateeditbox then
		C.TriggerInputFeedback("state", "INPUT_STATE_ADDON_CHATWINDOW_COMMANDBAR", "active", "")
	end
	menu.typing = true
	if menu.normalBackground then
		menu.activateeditbox = true
		menu.onShowMenu()
	end
end

function menu.editboxMessageChanged(_, text)
	menu.editboxstate.text = text
end

function menu.editboxMessageCursorChanged(_, cursorpos, shiftstartpos)
	menu.editboxstate.cursorpos = cursorpos
	menu.editboxstate.shiftstartpos = shiftstartpos
end

function menu.editboxSendMessage(_, text, textchanged, isconfirmed, wastableclick)
	menu.typing = nil
	if not wastableclick then
		menu.editboxstate = { text = "" }
	end
	if (text == "") or wastableclick then
		menu.onShowMenu()
		return
	end

	-- kuertee start: signal md
	AddUITriggeredEvent("Chat_Window_API", "text_entered", {terms = {""}, text = text})
	DebugError("uix: chatwindow.xpl.editboxSendMessage text_entered: " .. tostring(text))
	-- kuertee end

	local parameter = ""
	if string.sub(text, 1, 1) ~= "/" then
		-- no special command - interpret as chat message
		local userid = 0
		if menu.selectedPrivateMessages > 0 then
			userid = menu.privatemessages[menu.selectedPrivateMessages].receiverid
		end
		OnlineSendChatMessage(text, userid)
	elseif #text == 1 then
		DebugError("Invalid syntax. No command specified.")
		return -- abort command execution
	elseif string.sub(text, 2, 2) == " " then
		DebugError("Invalid syntax. A command must not be prefixed by whitespaces.")
		return -- abort command execution
	else
		-- otherwise we have a command
		-- check if we have (a) command parameter(s)
		local pos = string.find(text, " ") or 0

		-- subsitude the parameter (if any)
		if pos ~= 0 then
			parameter = string.sub(text, pos + 1) -- skip " "
		end

		-- substitude the command (strip the leading / and the parameter(s))
		text = string.sub(text, 2, pos - 1)

		-- finally execute the command	
		ExecuteDebugCommand(text, parameter)
	end

	menu.onShowMenu()
end

function menu.tabIconColor(messageindex)
	local userdataid = "chat_general_muted"
	if messageindex > 0 then
		local entry = menu.privatemessages[messageindex]
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
	end
	local muted = ffi.string(C.GetUserData(userdataid)) == "1"
	return muted and Color["icon_normal"] or Color["icon_hidden"]
end

function menu.closeContextMenu(skiptoplevelmenu)
	if menu.contextMenuMode then
		Helper.clearFrame(menu, config.contextLayer)
		menu.contextMenuMode = nil
		menu.mouseOutBox = nil

		if not skiptoplevelmenu then
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
				OpenMenu("TopLevelMenu", { 0, 0 }, nil)
			end
		end
	end
end

--- menus ---

function menu.displayChat()
	Helper.clearDataForRefresh(menu, config.layer)

	local framebackgroundcolor = Helper.tableCopy(Color["chat_background"])
	local textcolor = Helper.tableCopy(Color["text_inactive"])
	local boxtextcolor = Helper.tableCopy(Color["row_background_unselectable"])
	local linecolor = Helper.tableCopy(Color["row_background_blue"])
	if menu.fadefactor then
		framebackgroundcolor.a = menu.fadefactor * framebackgroundcolor.a
		textcolor.a = math.max(1, menu.fadefactor * textcolor.a)
		boxtextcolor.a = menu.fadefactor * boxtextcolor.a
		linecolor.a = menu.fadefactor * linecolor.a
	end

	menu.chatFrame = Helper.createFrameHandle(menu, {
		layer = config.layer,
		x = __CORE_CHAT_WINDOW.x,
		y = __CORE_CHAT_WINDOW.y,
		width = menu.width,
		height = menu.height,
		standardButtons = {},
		startAnimation = false,
		playerControls = true,
		viewHelperType = "Chat",
	})

	menu.table = {
		width = menu.width,
		x = 0,
	}

	local numcols = 10
	local ftable = menu.chatFrame:addTable(numcols, {
		tabOrder = menu.active and 2 or 0,
		x = menu.table.x,
		width = menu.table.width,
		highlightMode = "off",
		reserveScrollBar = false
	})
	local buttonWidth = Helper.scaleY(Helper.standardButtonHeight)
	local remainingWidth = menu.table.width - 4 * (buttonWidth + Helper.borderSize)
	local tabWidth = math.floor((remainingWidth - 2 * Helper.borderSize) / 3)
	ftable:setColWidth(1, buttonWidth, false)
	ftable:setColWidth(3, buttonWidth, false)
	ftable:setColWidth(4, tabWidth - buttonWidth - Helper.borderSize, false)
	ftable:setColWidth(5, buttonWidth, false)
	ftable:setColWidth(6, tabWidth - buttonWidth - Helper.borderSize, false)
	ftable:setColWidth(7, buttonWidth, false)
	ftable:setColWidth(8, buttonWidth, false)
	ftable:setColWidth(9, buttonWidth, false)
	ftable:setColWidth(10, math.max(buttonWidth, Helper.scrollbarWidth), false)

	-- header
	local row = ftable:addRow(menu.active, { fixed = true })
	row[1]:createButton({ active = menu.active and (menu.selectedPrivateMessages > 0) }):setIcon("widget_arrow_left_01")
	row[1].handlers.onClick = menu.buttonPrevChannel

	menu.privateMessageIndex = math.max(0, math.min(#menu.privatemessages, menu.privateMessageIndex))
	local col = 2
	local shown = 0
	local messageindex = menu.privateMessageIndex
	while (shown < 3) and (messageindex <= #menu.privatemessages) do
		if messageindex == 0 then
			row[col]:setColSpan(2):createButton({ active = menu.active, bgColor = (menu.selectedPrivateMessages == 0) and Color["row_background_blue"] or nil }):setText(C.IsVentureSeasonSupported() and ReadText(1001, 11648) or ReadText(1001, 12101)):setIcon("menu_sound_off", { scaling = false, color = function () return menu.tabIconColor(0) end, width = buttonWidth, height = buttonWidth, x = tabWidth - buttonWidth })
			row[col].handlers.onClick = function () menu.selectedPrivateMessages = 0; menu.settoprow = nil; menu.onShowMenu() end
			col = col + 2
			shown = shown + 1
			messageindex = messageindex + 1
		else
			local i = messageindex
			local entry = menu.privatemessages[i]
			if not entry.hidden then
				local width = row[col]:getWidth() + Helper.borderSize
				row[col]:setBackgroundColSpan(2):createButton({ scaling = false, active = menu.active, bgColor = (menu.selectedPrivateMessages == i) and Color["row_background_blue"] or nil, width = width, height = Helper.scaleY(Helper.standardButtonHeight) }):setText(entry.name, { scaling = true }):setIcon("menu_sound_off", { color = function () return menu.tabIconColor(i) end, width = buttonWidth, height = buttonWidth, x = width - buttonWidth })
				row[col].handlers.onClick = function () menu.selectedPrivateMessages = i; menu.settoprow = nil; menu.onShowMenu() end
				row[col + 1]:createButton({ active = menu.active, bgColor = (menu.selectedPrivateMessages == i) and Color["row_background_blue"] or nil, width = Helper.standardButtonHeight }):setIcon("widget_cross_01")
				row[col + 1].handlers.onClick = function () menu.buttonClosePrivateChat(i) end
				col = col + 2
				shown = shown + 1
			end
			messageindex = messageindex + 1
		end
	end

	row[8]:createButton({ active = menu.active and (menu.selectedPrivateMessages < #menu.privatemessages) }):setIcon("widget_arrow_right_01")
	row[8].handlers.onClick = menu.buttonNextChannel

	row[9]:createButton({
		active = menu.active,
		bgColor = function () return menu.dragging and Color["chat_move_background"] or Color["button_background_default"] end,
		highlightColor = function () return menu.dragging and Color["chat_move_background"] or Color["button_highlight_default"] end,
		mouseOverText = ReadText(1026, 12101),
	}):setIcon("menu_move")
	row[9].handlers.onClick = menu.buttonDrag

	row[10]:createButton({ active = menu.active, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 12102), ReadText(1001, 2670))), width = Helper.standardButtonHeight }):setIcon("widget_cross_01")
	row[10].handlers.onClick = function () menu.closeMenu() end

	-- line
	local row = ftable:addRow(false, { fixed = true, bgColor = linecolor })
	row[1]:setColSpan(numcols):createText(" ", { fontsize = 1, minRowHeight = 2 })

	local headerheight = ftable:getFullHeight()
	local messagetexts = menu.messagetexts
	if menu.selectedPrivateMessages > 0 then
		messagetexts = menu.privatemessages[menu.selectedPrivateMessages].messages
	end

	-- empty lines
	if #messagetexts < menu.numchatlines then
		for i = 1, menu.numchatlines - #messagetexts do
			local row = ftable:addRow(menu.active, {  })
			row[1]:setColSpan(numcols):createText("")
		end
	end

	-- message lines
	local indent = 0
	local fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
	for i, entry in ipairs(messagetexts) do
		if menu.active or (i >= menu.fadetoprow - 2) and (i < menu.fadetoprow - 2 + menu.numchatlines) then
			local row = ftable:addRow((menu.active and (not entry.datedivider) and (not entry.announcement)) and { timestamp = entry.timestamp, author = entry.author, authorcolor = entry.authorcolor, reported = entry.reported, announcement = entry.announcement, authorid = entry.authorid } or nil, {  })
			if entry.prefix then
				indent = C.GetTextWidth(entry.prefix, Helper.standardFont, fontsize) + Helper.scaleX(Helper.standardTextOffsetx)
				row[1]:setColSpan(numcols):createText(entry.prefix .. entry.text, { color = menu.active and Color["text_normal"] or textcolor })
			elseif entry.datedivider then
				
				row[1]:setColSpan(numcols):createText(entry.text, { color = menu.active and Color["text_normal"] or textcolor, halign = "center" })
			else
				row[1]:setColSpan(numcols):createText(entry.text, { scaling = false, x = indent, fontsize = fontsize, minRowHeight = Helper.scaleY(Helper.standardTextHeight), color = menu.active and Color["text_normal"] or textcolor })
			end
		end
	end

	menu.settoprow = menu.settoprow or ((#messagetexts < menu.numchatlines) and 3 or (#messagetexts + 3 - menu.numchatlines))

	ftable:setTopRow(menu.settoprow)
	ftable:setSelectedRow(#messagetexts + 2)

	ftable.properties.maxVisibleHeight = headerheight + menu.numchatlines * (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize)

	if menu.chatFrame.properties.y + ftable.properties.maxVisibleHeight > Helper.viewHeight then
		__CORE_CHAT_WINDOW.y = Helper.viewHeight - ftable.properties.maxVisibleHeight
		menu.chatFrame.properties.y = __CORE_CHAT_WINDOW.y
		menu.chatFrame.properties.height = ftable.properties.maxVisibleHeight
	end

	-- editbox and options
	numcols = 4
	local ftable2 = menu.chatFrame:addTable(numcols, { tabOrder = menu.active and 1 or 0, x = menu.table.x, width = menu.table.width })
	ftable2:setColWidth(1, Helper.standardButtonHeight)

	local row = ftable2:addRow(menu.active, { fixed = true })
	if menu.active then
		row[1]:setColSpan(numcols):createEditBox({ height = Helper.standardButtonHeight, description = ReadText(1001, 12108), maxChars = 255, selectTextOnActivation = false }):setText(menu.editboxstate.text, {  }):setHotkey("INPUT_STATE_ADDON_CHATWINDOW_COMMANDBAR", { displayIcon = true })
		row[1].handlers.onEditBoxActivated = menu.editboxActivated
		row[1].handlers.onTextChanged = menu.editboxMessageChanged
		row[1].handlers.onCursorChanged = menu.editboxMessageCursorChanged
		row[1].handlers.onEditBoxDeactivated = menu.editboxSendMessage
	else
		row[1]:setColSpan(numcols):createBoxText("", { boxColor = boxtextcolor })
	end

	--local row = ftable2:addRow(menu.active, { fixed = true })
	--row[1]:createButton({ active = menu.active }):setText(ReadText(1001, 12106), { halign = "center" })
	--row[1].handlers.onClick = function () menu.options = not menu.options; menu.onShowMenu() end

	--if menu.options then
		local row = ftable2:addRow(menu.active, { fixed = true })
		local userdataid = "chat_general_muted"
		if menu.selectedPrivateMessages > 0 then
			local entry = menu.privatemessages[menu.selectedPrivateMessages]
			userdataid = entry.groupid and ("chat_group_" .. entry.groupid .. "_muted") or ""
		end
		local muted = ffi.string(C.GetUserData(userdataid)) == "1"
		row[1]:createCheckBox(muted, { active = menu.active, width = Helper.standardButtonHeight })
		row[1].handlers.onClick = menu.checkboxMute
		row[2]:createText(ReadText(1001, 12107), { halign = "left" })

		local sizeoptions = {
			{ id = "small",		text = ReadText(1001, 12102),	icon = "", displayremoveoption = false },
			{ id = "normal",	text = ReadText(1001, 12103),	icon = "", displayremoveoption = false },
			{ id = "large",		text = ReadText(1001, 12104),	icon = "", displayremoveoption = false },
		}
		row[4]:createDropDown(sizeoptions, { startOption = __CORE_CHAT_WINDOW.size, height = Helper.standardButtonHeight, textOverride = ReadText(1001, 12105), active = menu.active }):setTextProperties({ halign = "center" })
		row[4].handlers.onDropDownConfirmed = function (_, id) __CORE_CHAT_WINDOW.size = id; menu.messagesOutdated = true; menu.settoprrow = nil; menu.onShowMenu() end
	--end

	ftable.properties.nextTable = ftable2.index
	ftable2.properties.prevTable = ftable.index

	local height = ftable:getVisibleHeight()
	ftable2.properties.y = ftable.properties.y + height + Helper.borderSize

	local height2 = ftable2:getFullHeight()
	menu.height = ftable2.properties.y + height2
	ftable2.properties.y = ftable.properties.y + height + Helper.borderSize
	menu.chatFrame.properties.height = menu.height
	if menu.activateeditbox then
		menu.chatFrame:setBackground("solid", { color = Color["frame_background_semitransparent"], width = 2 * Helper.viewWidth, height = 2 * Helper.viewHeight })
		menu.chatFrame.properties.playerControls = false
		menu.normalBackground = false
	else
		menu.chatFrame:setBackground("gui_chat_background_01", { color = framebackgroundcolor, width = menu.width * config.frameBackgroundFactor, height = menu.height * config.frameBackgroundFactor })
		menu.normalBackground = true
	end

	if menu.chatFrame.properties.x + menu.chatFrame.properties.width > Helper.viewWidth then
		__CORE_CHAT_WINDOW.x = Helper.viewWidth - menu.chatFrame.properties.width
		menu.chatFrame.properties.x = __CORE_CHAT_WINDOW.x
	end

	if menu.chatFrame.properties.y + menu.chatFrame.properties.height > Helper.viewHeight then
		__CORE_CHAT_WINDOW.y = Helper.viewHeight - menu.chatFrame.properties.height
		menu.chatFrame.properties.y = __CORE_CHAT_WINDOW.y
	end

	menu.chatFrame:display()
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	if Helper.topLevelMenu then
		local topLevelMenu = Helper.topLevelMenu
		Helper.closeMenu(topLevelMenu, "close")
		topLevelMenu.cleanup()
	end
	Helper.topLevelMenu = nil

	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
		startAnimation = false,
		playerControls = true,
		viewHelperType = "Chat",
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	if menu.contextMenuMode == "report" then
		menu.createReportContext(menu.contextFrame)
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	end
end

function menu.createReportContext(frame)
	local data = menu.contextMenuData.rowdata

	local ftable = frame:addTable(1, { tabOrder = 4, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(data.author, Helper.headerRowCenteredProperties)
	row[1].properties.color = data.authorcolor

	local _, userid = OnlineGetUserName()
	if data.authorid ~= userid then
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({  }):setText(ReadText(1001, 12115))
		row[1].handlers.onClick = function () return menu.buttonContactMessage(menu, data.authorid, data.author) end
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	local row = ftable:addRow(nil, { fixed = true })
	row[1]:createText(ReadText(1001, 12110), Helper.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({  }):setText(ReadText(1001, 12111))
	row[1].handlers.onClick = function () return menu.buttonReportUser(data.authorid) end
	
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = (not data.reported) and (not data.announcement) }):setText(ReadText(1001, 12112))
	row[1].handlers.onClick = function () return menu.buttonReportMessage(data.timestamp, data.author) end
end

--- Helper hooks ---

function menu.onShowMenu()
	menu.shown = true
	menu.typing = nil

	menu.width = Helper.scaleX(config.width)
	menu.numchatlines = 9
	if __CORE_CHAT_WINDOW.size == "small" then
		menu.width = math.floor(menu.width * 2 / 3)
		menu.numchatlines = 6
	elseif __CORE_CHAT_WINDOW.size == "large" then
		menu.width = math.floor(menu.width * 5 / 3)
		menu.numchatlines = 15
	end
	menu.height = Helper.viewHeight - __CORE_CHAT_WINDOW.y

	menu.getChatMessages()

	menu.displayChat()
end

function menu.viewCreated(layer, ...)
	if layer == config.layer then
		menu.chatTable, menu.optionTable = ...
	end
end

menu.updateInterval = 0.01
function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.dragging then
		menu.lastInteraction = curtime

		local x, y = GetLocalMousePosition()
		__CORE_CHAT_WINDOW.x = math.max(0, math.min(Helper.viewWidth - menu.width, Helper.viewWidth / 2 + x - menu.dragoffset.x))
		__CORE_CHAT_WINDOW.y = math.max(0, math.min(Helper.viewHeight - menu.height, Helper.viewHeight / 2 - y - menu.dragoffset.y))

		if menu.settoprow then
			menu.settoprow = GetTopRow(menu.chatTable)
		end
		menu.onShowMenu()
		return
	end

	if menu.typing then
		menu.lastInteraction = curtime
	end

	if next(menu.mouseover) then
		menu.lastInteraction = curtime
	end

	if menu.islocked then
		menu.lastInteraction = curtime
	end

	if menu.lastInteraction + config.timeout + config.fadeout < curtime then
		menu.closeMenu()
		return
	elseif menu.lastInteraction + config.timeout < curtime then
		if menu.active then
			menu.active = false
			menu.closeContextMenu()
			menu.fadetoprow = GetTopRow(menu.chatTable)
		end

		menu.fadefactor = 1 - (curtime - menu.lastInteraction - config.timeout) / config.fadeout
		menu.onShowMenu()
		return
	elseif menu.fadefactor then
		menu.active = true
		menu.fadefactor = nil
		menu.onShowMenu()
		return
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.activateeditbox then
		Helper.activateEditBox(menu.optionTable, 1, 1, menu.editboxstate.cursorpos, menu.editboxstate.shiftstartpos)
		menu.activateeditbox = nil
	end

	menu.chatFrame:update()
end

function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	if not menu.fadefactor then
		menu.lastInteraction = getElapsedTime()
	end
	local messagetexts = menu.messagetexts
	local userdataid = "chat_general"
	if menu.selectedPrivateMessages > 0 then
		local entry = menu.privatemessages[menu.selectedPrivateMessages]
		messagetexts = entry.messages
		userdataid = entry.groupid and ("chat_group_" .. entry.groupid) or ""
	end
	if (userdataid ~= "") and (#messagetexts > 0) then
		local toprow = GetTopRow(menu.chatTable)
		local lastshownline = math.max(1, math.min(#messagetexts, toprow + menu.numchatlines - 1))
		local lastmessageread = messagetexts[lastshownline].timestamp

		local currentlastmessageread = C.ConvertStringTo64Bit(C.GetUserData(userdataid))
		if lastmessageread > currentlastmessageread then
			C.SetUserData(userdataid, tostring(lastmessageread))
			C.NotifyChatMessageRead()
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if uitable == menu.chatTable then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
		if type(rowdata) == "table" then
			local username, userid = OnlineGetUserName()
			if rowdata.authorid ~= userid then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end

				menu.contextMenuMode = "report"
				menu.contextMenuData = { rowdata = rowdata }
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(config.contextMenuWidth))
			end
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.mouseover[uitable] = true
end

function menu.onTableMouseOut(uitable, row)
	menu.mouseover[uitable] = nil
end

function menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input, source)
	if not menu.dragging then
		PlaySound("ui_positive_hover_normal")
	end
end

function menu.onButtonOverSound(uitable, row, col, button, input)
	if not menu.dragging then
		if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
			if input == "mouse" then
				if (not menu.sound_buttonOverLock) then
					PlaySound("ui_positive_hover_normal")
					menu.sound_buttonOverLock = true
				end
			end
		end
		menu.sound_selectedelement = button
	end
end

function menu.closeMenu()
	Helper.clearChatUpdateHandler()
	Helper.clearFrame(menu, config.layer)
	menu.closeContextMenu()
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer)
	if layer == config.contextLayer then
		menu.closeContextMenu()
		return
	end
	menu.closeMenu()
end

function menu.callback(param)
	if param == "unlock" then
		menu.islocked = nil
	end
end

--- init ---

init()
﻿-- param == { 0, 0 }

-- modes:

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* id;
		const char* name;
		bool possible;
	} DroneModeInfo;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetConnectionName;
		uint32_t messageID;
	} SofttargetDetails2;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	bool CanActivateSeta(bool checkcontext);
	bool CanCancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanPerformLongRangeScan(void);
	bool CanPlayerStandUp(void);
	bool CanStartTravelMode(UniverseID objectid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	const char* GetCurrentAmmoOfWeapon(UniverseID weaponid);
	const char* GetCurrentDroneMode(UniverseID defensibleid, const char* dronetype);
	UILogo GetCurrentPlayerLogo(void);
	uint32_t GetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetDroneModes(DroneModeInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* dronetype);
	UniverseID GetEnvironmentObject();
	const char* GetGameStartName();
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDroneModes(UniverseID defensibleid, const char* dronetype);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumUnavailableUnits(UniverseID defensibleid, const char* cat);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	const char* GetObjectCoverAbilityFaction(UniverseID shipid);
	const char* GetObjectIDCode(UniverseID objectid);
	const char* GetPlayerCoverFaction(void);
	const char* GetPlayerCurrentControlGroup(void);
	UniverseID GetPlayerID(void);
	UniverseID GetPlayerObjectID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	SofttargetDetails2 GetSofttarget2(void);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	const char* GetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool GetUp(void);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetUserTransportDroneMode(UniverseID defensibleid);
	const char* GetWeaponMode(UniverseID weaponid);
	bool HasShipFlightAssist(UniverseID shipid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsDroneTypeArmed(UniverseID defensibleid, const char* dronetype);
	bool IsDroneTypeBlocked(UniverseID defensibleid, const char* dronetype);
	bool IsPlayerControlGroupValid(void);
	bool IsTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool IsWeaponArmed(UniverseID weaponid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	bool QuickDock();
	bool RequestDockAt(UniverseID containerid, bool checkonly);
	void SetAllTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllTurretModes(UniverseID defensibleid, const char* mode);
	void SetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary, uint32_t groupidx);
	void SetDroneMode(UniverseID defensibleid, const char* dronetype, const char* mode);
	void SetDroneTypeArmed(UniverseID defensibleid, const char* dronetype, bool arm);
	void SetObjectCoverFaction(UniverseID objectid, const char* factionid);
	void SetSubordinateGroupDockAtCommander(UniverseID controllableid, int group, bool value);
	void SetTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, bool arm);
	void SetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, const char* mode);
	void SetWeaponArmed(UniverseID weaponid, bool arm);
	void SetWeaponGroup(UniverseID defensibleid, UniverseID weaponid, bool primary, uint32_t groupidx, bool value);
	void SetWeaponMode(UniverseID weaponid, const char* mode);
	bool ShouldSubordinateGroupDockAtCommander(UniverseID controllableid, int group);
	void StartPlayerActivity(const char* activityid);
	void StopPlayerActivity(const char* activityid);
	bool ToggleAutoPilot(bool checkonly);
	void ToggleFlightAssist();
	const char* UndockPlayerShip(bool checkonly);
]]

-- menu variable - used by Helper and used for dynamic variables (e.g. inventory content, etc.)
local menu = {
	name = "DockedMenu"
}

-- config variable - put all static setup here
local config = {
	modes = {
		[1] = { id = "travel",			name = ReadText(1002, 1158),	stoptext = ReadText(1002, 1159),	action = 303 },
		[2] = { id = "scan",			name = ReadText(1002, 1156),	stoptext = ReadText(1002, 1157),	action = 304 },
		[3] = { id = "scan_longrange",	name = ReadText(1002, 1155),	stoptext = ReadText(1002, 1160),	action = 305 },
		[4] = { id = "seta",			name = ReadText(1001, 1132),	stoptext = ReadText(1001, 8606),	action = 225 },
	},
	consumables = {
		{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites,		callback = C.LaunchSatellite },
		{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons,		callback = C.LaunchNavBeacon },
		{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes,	callback = C.LaunchResourceProbe },
		{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers,		callback = C.LaunchLaserTower },
		{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines,			callback = C.LaunchMine },
	},
	inactiveButtonProperties = { bgColor = Color["button_background_inactive"], highlightColor = Color["button_highlight_inactive"] },
	activeButtonTextProperties = { halign = "center" },
	inactiveButtonTextProperties = { halign = "center", color = Color["text_inactive"] },
	dronetypes = {
		{ id = "orecollector",	name = ReadText(20214, 500) },
		{ id = "gascollector",	name = ReadText(20214, 400) },
		{ id = "defence",		name = ReadText(20214, 300) },
		{ id = "transport",		name = ReadText(20214, 900) },
	},
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	--print("Initializing")
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.init = true
	registerForEvent("gameplanchange", getElement("Scene.UIContract"), menu.onGamePlanChange)
	RegisterEvent("conversationCancelled", menu.onConvEnds)
	RegisterEvent("conversationFinished", menu.onConvEnds)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.onGamePlanChange(_, mode)
	if menu.init then
		if (mode == "cockpit") or (mode == "external") then
			local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if ((occupiedship ~= 0) and GetComponentData(occupiedship, "isdocked")) or ((controlpost ~= "") and (controlpost ~= "pilotcontrol")) then
				OpenMenu("DockedMenu", { 0, 0 }, nil)
			end
			menu.init = nil
		elseif (mode == "firstperson") or (mode == "externalfirstperson") then
			menu.init = nil
		end
	end
end

function menu.onPlayerActivityChanged()
	menu.refresh = getElapsedTime() - 1
end

function menu.onConvEnds()
	if not Helper.hasConversationReturnHandler then
		local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
		local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
		if ((occupiedship ~= 0) and GetComponentData(occupiedship, "isdocked")) or ((controlpost ~= "") and (controlpost ~= "pilotcontrol")) then
			OpenMenu("DockedMenu", { 0, 0 }, nil)
		end
	end
end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.topLevelOffsetY = nil

	--print("Cleaning Up")
	UnregisterEvent("playerUndock", menu.close)
	UnregisterEvent("playerGetUp", menu.close)
	menu.currentcontainer = nil
	--menu.topcontainer = nil
	menu.currentplayership = nil
	menu.secondarycontrolpost = nil
	menu.mode = nil
	menu.buildInProgress = nil
	menu.buildToCancel = nil
	menu.turrets = {}
	menu.turretgroups = {}

	menu.frame = nil
	menu.table_toplevel = nil
	menu.table_topleft = nil
	menu.table_header = nil

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

function menu.onShowMenu()
	if not menu.hasPlayerActivityCallback then
		local contract = getElement("Scene.UIContract")
		registerForEvent("playerActivityChanged", contract, menu.onPlayerActivityChanged)
		NotifyOnPlayerActivityChanged(contract)
		menu.hasPlayerActivityCallback = true
	end

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	-- close the menu if player either undocks or gets up while the menu is open.
	RegisterEvent("playerUndock", menu.close)
	RegisterEvent("playerGetUp", menu.close)

	--print("Showing Menu")
	menu.currentplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	local controlpost = ffi.string(C.GetPlayerCurrentControlGroup())
	if (controlpost ~= "") and (controlpost ~= "pilotcontrol") then
		menu.secondarycontrolpost = true
	end

	if menu.currentplayership ~= 0 then
		if GetComponentData(menu.currentplayership, "isdocked") then
			menu.mode = "docked"
			menu.currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(menu.currentplayership, "container", false)))
		else
			menu.mode = "cockpit"
			menu.currentcontainer = menu.currentplayership
		end
	else
		menu.currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(C.GetPlayerID(), "container", false)))
		if C.IsComponentClass(menu.currentcontainer, "ship") and (not GetComponentData(menu.currentcontainer, "isdocked")) then
			menu.mode = "cockpit"
		else
			menu.mode = "docked"
		end
	end
	--menu.topcontainer = ConvertStringTo64Bit(tostring(C.GetTopLevelContainer(menu.currentplayership)))
	--print("current player ship: " .. ffi.string(C.GetComponentName(menu.currentplayership)) .. ", currentcontainer: " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. ", topcontainer: " .. ffi.string(C.GetComponentName(menu.topcontainer)))

	menu.selectedRows = {}
	menu.selectedCols = {}
	-- init selection
	local curtime = getElapsedTime()
	menu.firsttime = curtime + 0.35

	-- add content
	menu.display()

	-- we might have just started the game, check things again (e.g. shiptrader existing) after a short time
	if curtime < 30 then
		menu.refresh = curtime + 1
	end
end

function menu.display()
	Helper.removeAllWidgetScripts(menu)

	local width = Helper.viewWidth
	local height = Helper.viewHeight
	local xoffset = 0
	local yoffset = 0

	menu.frame = Helper.createFrameHandle(menu, { width = width, x = xoffset, y = yoffset, standardButtons = (((menu.mode == "docked") and (menu.currentplayership ~= 0)) or menu.secondarycontrolpost) and {} or { close = true, back = true }, showTickerPermanently = true })
	menu.frame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.createTopLevel(menu.frame)

	local table_topleft, table_header, table_button, row

	local isdocked = (menu.currentplayership ~= 0) and GetComponentData(menu.currentplayership, "isdocked")
	local ownericon, owner, shiptrader, isdock, canbuildships, isplayerowned, issupplyship, canhavetradeoffers, aipilot = GetComponentData(menu.currentcontainer, "ownericon", "owner", "shiptrader", "isdock", "canbuildships", "isplayerowned", "issupplyship", "canhavetradeoffers", "aipilot")
	local cantrade = canhavetradeoffers and isdock

	local isbuilderbusy = false
	local numorders = C.GetNumOrders(menu.currentcontainer)
	local currentorders = ffi.new("Order[?]", numorders)
	numorders = C.GetOrders(currentorders, numorders, menu.currentcontainer)
	for i = 1, numorders do
		if ffi.string(currentorders[i - 1].orderdef) == "DeployToStation" then
			if ffi.string(currentorders[i - 1].state) == "critical" then
				isbuilderbusy = true
				break
			end
		end
	end
	local canwareexchange = isplayerowned and ((not C.IsComponentClass(menu.currentcontainer, "ship")) or aipilot) and (not isbuilderbusy)

	--NB: equipment docks currently do not have ship traders
	local dockedplayerships = {}
	Helper.ffiVLA(dockedplayerships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.currentcontainer, "player")
	local canequip = false
	local cansupply = false
	for _, ship in ipairs(dockedplayerships) do
		if C.CanContainerEquipShip(menu.currentcontainer, ship) then
			canequip = true
		end
		if isplayerowned and C.CanContainerSupplyShip(menu.currentcontainer, ship) then
			cansupply = true
		end
	end
	local canmodifyship = (shiptrader ~= nil) and (canequip or cansupply) and isdock
	local canbuyship = (shiptrader ~= nil) and canbuildships and isdock
	local istimelineshub = ffi.string(C.GetGameStartName()) == "x4ep1_gamestart_hub"
	--print("cantrade: " .. tostring(cantrade) .. ", canbuyship: " .. tostring(canbuyship) .. ", canmodifyship: " .. tostring(canmodifyship))

	width = (width / 3) - Helper.borderSize

	-- set up a new table
	table_topleft = menu.frame:addTable(1, { tabOrder = 0, width = Helper.playerInfoConfig.width, height = Helper.playerInfoConfig.height, x = Helper.playerInfoConfig.offsetX, y = Helper.playerInfoConfig.offsetY, scaling = false })

	row = table_topleft:addRow(false, { fixed = true, bgColor = Color["player_info_background"] })
	local icon = row[1]:createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = Helper.playerInfoConfig.height, height = Helper.playerInfoConfig.height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, Helper.playerInfoConfig.width - Helper.playerInfoConfig.height - Helper.borderSize))
	icon:setText(Helper.playerInfoConfigTextLeft,	{ fontsize = Helper.playerInfoConfig.fontsize, halign = "left",  x = Helper.playerInfoConfig.height + Helper.borderSize, y = (Helper.playerInfoConfig.height - textheight) / 2 })
	icon:setText2(Helper.playerInfoConfigTextRight,	{ fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize,          y = (Helper.playerInfoConfig.height - textheight) / 2 })

	local xoffset = (Helper.viewWidth - width) / 2
	local yoffset = 25

	table_header = menu.frame:addTable(11, { tabOrder = 1, width = width, x = xoffset, y = menu.topLevelOffsetY + Helper.borderSize + yoffset })
	table_header:setColWidth(1, math.floor((width - 2 * Helper.borderSize) / 3), false)
	table_header:setColWidth(3, Helper.standardTextHeight)
	table_header:setColWidth(4, Helper.standardTextHeight)
	table_header:setColWidth(5, Helper.standardTextHeight)
	table_header:setColWidth(6, Helper.standardTextHeight)
	table_header:setColWidth(8, Helper.standardTextHeight)
	table_header:setColWidth(9, Helper.standardTextHeight)
	table_header:setColWidth(10, Helper.standardTextHeight)
	table_header:setColWidth(11, Helper.standardTextHeight)
	table_header:setDefaultColSpan(1, 1)
	table_header:setDefaultColSpan(2, 5)
	table_header:setDefaultColSpan(7, 5)
	table_header:setDefaultBackgroundColSpan(1, 11)

	local row = table_header:addRow(false, { fixed = true })
	local color = Color["text_normal"]
	if isplayerowned then
		if menu.currentcontainer == C.GetPlayerObjectID() then
			color = Color["text_player_current"]
		else
			color = Color["text_player"]
		end
	end
	row[1]:setColSpan(11):createText(menu.currentcontainer and ffi.string(C.GetComponentName(menu.currentcontainer)) or "", Helper.headerRowCenteredProperties)
	row[1].properties.color = color

	height = Helper.scaleY(Helper.standardTextHeight)

	local row = table_header:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	if menu.mode == "cockpit" then
		row[2]:createText(ffi.string(C.GetObjectIDCode(menu.currentcontainer)), { halign = "center", color = color })
	else
		row[1]:createIcon(ownericon, { width = height, height = height, x = row[1]:getWidth() - height, scaling = false })
		row[2]:createText(function() return GetComponentData(menu.currentcontainer, "ownername") end, { halign = "center" })
		row[7]:createText(function() return "[" .. GetUIRelation(GetComponentData(menu.currentcontainer, "owner")) .. "]" end, { halign = "left" })
	end

	table_header:addEmptyRow(yoffset)

	if menu.mode == "cockpit" then
		local row = table_header:addRow("buttonRow1", { fixed = true })
		-- cover button
		local coverfaction = ""
		if menu.currentplayership ~= 0 then
			coverfaction = ffi.string(C.GetObjectCoverAbilityFaction(menu.currentplayership))
		end
		local currentcoverfaction = ffi.string(C.GetPlayerCoverFaction())
		if coverfaction ~= "" then
			local mouseovertext = ReadText(1026, 8611) .. ReadText(1001, 120) .. " " .. ColorText["licence"] .. GetFactionData(coverfaction, "name") .. "\27X"
			local shortcut = GetLocalizedKeyName("action", 377)
			if shortcut ~= "" then
				mouseovertext = mouseovertext .. " (" .. shortcut .. ")"
			end
			row[1]:createButton({ mouseOverText = mouseovertext, helpOverlayID = "docked_cover", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "docked_cover" }):setText((currentcoverfaction == "") and ReadText(1001, 8640) or ReadText(1001, 8641), config.activeButtonTextProperties)	-- "Enable Cover"
			row[1].handlers.onClick = function () return menu.buttonCover((currentcoverfaction == "") and coverfaction or "") end
		else
			row[1]:createButton(config.inactiveButtonProperties):setText("", config.inactiveButtonTextProperties)	-- dummy
		end

		local active = ((menu.currentplayership ~= 0) or menu.secondarycontrolpost) and C.CanPlayerStandUp()
		row[2]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 277), helpOverlayID = "docked_getup", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 20014), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Get Up"
		if active then
			row[2].handlers.onClick = menu.buttonGetUp
		end
		row[7]:createButton({ mouseOverText = GetLocalizedKeyName("action", 316), helpOverlayID = "docked_shipinformation", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8602), { halign = "center" })	-- "Ship Information"
		row[7].handlers.onClick = menu.buttonShipInfo

		local row = table_header:addRow("buttonRow3", { fixed = true })
		local currentactivity = GetPlayerActivity()
		if currentactivity ~= "none" then
			local text = ""
			for _, entry in ipairs(config.modes) do
				if entry.id == currentactivity then
					text = entry.stoptext
					break
				end
			end
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			row[2]:createButton(active and {helpOverlayID = "docked_stopmode", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(text, active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Stop Mode"
			if active then
				row[2].handlers.onClick = menu.buttonStopMode
				row[2].properties.uiTriggerID = "stopmode"
			end
		else
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			local modes = {}
			if active then
				for _, entry in ipairs(config.modes) do
					local entryactive = menu.currentplayership ~= 0
					local visible = true
					if entry.id == "travel" then
						entryactive = entryactive and C.CanStartTravelMode(menu.currentplayership)
					elseif entry.id == "scan_longrange" then
						entryactive = entryactive and C.CanPerformLongRangeScan()
					elseif entry.id == "seta" then
						entryactive = true
						visible = C.CanActivateSeta(false)
					end
					local mouseovertext = GetLocalizedKeyName("action", entry.action)
					if visible then
						table.insert(modes, { id = entry.id, text = entry.name, icon = "", displayremoveoption = false, active = entryactive, mouseovertext = mouseovertext, helpOverlayID = "docked_mode_dropdown_" .. entry.id, helpOverlayText = " ", helpOverlayHighlightOnly = true })
					end
				end
			end
			row[2]:createDropDown(modes, {
				helpOverlayID = "docked_modes",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				height = Helper.standardButtonHeight,
				startOption = "",
				textOverride = ReadText(1002, 1001),
				bgColor = active and Color["dropdown_background_default"] or Color["dropdown_background_inactive"],
				highlightColor = active and Color["dropdown_highlight_default"] or Color["dropdown_highlight_inactive"]
			}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Modes
			if active then
				row[2].handlers.onDropDownConfirmed = menu.dropdownMode
				row[2].properties.uiTriggerID = "startmode"
			end
		end
		local civilian, military, isinhighway = {}, {}, false
		if menu.currentplayership ~= 0 then
			for _, consumabledata in ipairs(config.consumables) do
				local numconsumable = consumabledata.getnum(menu.currentplayership)
				if numconsumable > 0 then
					local consumables = ffi.new("AmmoData[?]", numconsumable)
					numconsumable = consumabledata.getdata(consumables, numconsumable, menu.currentplayership)
					for j = 0, numconsumable - 1 do
						if consumables[j].amount > 0 then
							local macro = ffi.string(consumables[j].macro)
							if consumabledata.type == "civilian" then
								table.insert(civilian, { id = consumabledata.id .. ":" .. macro, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", icon = "", displayremoveoption = false, helpOverlayID = "docked_deploy_civ_dropdown_" .. consumabledata.id, helpOverlayText = " ", helpOverlayHighlightOnly = true })
							else
								table.insert(military, { id = consumabledata.id .. ":" .. macro, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", icon = "", displayremoveoption = false, helpOverlayID = "docked_deploy_mil_dropdown_" .. consumabledata.id, helpOverlayText = " ", helpOverlayHighlightOnly = true })
							end
						end
					end
				end
			end
			isinhighway = C.GetContextByClass(menu.currentplayership, "highway", false) ~= 0
		end
		local active = (#civilian > 0) and (not isinhighway)
		local mouseovertext = ""
		if #civilian == 0 then
			mouseovertext = ReadText(1026, 7818)
		elseif isinhighway then
			mouseovertext = ReadText(1026, 7845)
		end
		row[1]:createDropDown(civilian, {
			helpOverlayID = "docked_deploy_civ",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
			height = Helper.standardButtonHeight,
			startOption = "",
			textOverride = ReadText(1001, 8607),
			text2Override = " ",
			bgColor = active and Color["dropdown_background_default"] or Color["dropdown_background_inactive"],
			highlightColor = active and Color["dropdown_highlight_default"] or Color["dropdown_highlight_inactive"],
			mouseOverText = mouseovertext,
		}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties):setText2Properties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Deploy Civilian
		row[1].properties.text2.halign = "right"
		row[1].properties.text2.x = Helper.standardTextOffsetx
		if active then
			row[1].handlers.onDropDownConfirmed = menu.dropdownDeploy
		end
		local active = (#military > 0) and (not isinhighway)
		local mouseovertext = ""
		if #military == 0 then
			mouseovertext = ReadText(1026, 7819)
		elseif isinhighway then
			mouseovertext = ReadText(1026, 7845)
		end
		row[7]:createDropDown(military, {
			helpOverlayID = "docked_deploy_mil",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
			height = Helper.standardButtonHeight,
			startOption = "",
			textOverride = ReadText(1001, 8608),
			text2Override = " ",
			bgColor = active and Color["dropdown_background_default"] or Color["dropdown_background_inactive"],
			highlightColor = active and Color["dropdown_highlight_default"] or Color["dropdown_highlight_inactive"],
			mouseOverText = mouseovertext,
		}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties):setText2Properties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Deploy Military
		row[7].properties.text2.halign = "right"
		row[7].properties.text2.x = Helper.standardTextOffsetx
		if active then
			row[7].handlers.onDropDownConfirmed = menu.dropdownDeploy
		end

		local row = table_header:addRow("buttonRow2", { fixed = true })
		local active = (menu.currentplayership ~= 0) and C.HasShipFlightAssist(menu.currentplayership)
		row[1]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 221), helpOverlayID = "docked_flightassist", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8604), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Flight Assist"
		if active then
			row[1].handlers.onClick = menu.buttonFlightAssist
		end
		row[2]:createButton({ bgColor = menu.dockButtonBGColor, highlightColor = menu.dockButtonHighlightColor, helpOverlayID = "docked_dock", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8605), { halign = "center", color = menu.dockButtonTextColor })	-- "Dock"
		row[2].properties.mouseOverText = GetLocalizedKeyName("action", 175)
		row[2].handlers.onClick = menu.buttonDock
		local active = (menu.currentplayership ~= 0) and C.ToggleAutoPilot(true)
		row[7]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 179), helpOverlayID = "docked_autopilot", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8603), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Autopilot"
		if active then
			row[7].handlers.onClick = menu.buttonAutoPilot
		end

		-- start: kuertee call-back
		if menu.uix_callbacks ["display_on_after_main_interactions"] then
  			for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_main_interactions"]) do
  				uix_callback (table_header)
  			end
  		end
		-- end: kuertee call-back

		if menu.currentplayership ~= 0 then
			local weapons = {}
			local numslots = tonumber(C.GetNumUpgradeSlots(menu.currentplayership, "", "weapon"))
			for j = 1, numslots do
				local current = C.GetUpgradeSlotCurrentComponent(menu.currentplayership, "weapon", j)
				if current ~= 0 then
					table.insert(weapons, current)
				end
			end
			local pilot = GetComponentData(menu.currentplayership, "assignedpilot")
			menu.currentammo = {}
			if #weapons > 0 then
				table_header:addEmptyRow(yoffset)

				local titlerow = table_header:addRow(false, {  })
				titlerow[1]:setColSpan(11):createText(ReadText(1001, 9409), Helper.headerRowCenteredProperties)
				titlerow[1].properties.helpOverlayID = "docked_weaponconfig"
				titlerow[1].properties.helpOverlayText = " "
				titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
				titlerow[1].properties.helpOverlayHighlightOnly = true
				titlerow[1].properties.helpOverlayScaling = false

				local row = table_header:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:createText(ReadText(1001, 9410), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 9411), { font = Helper.standardFontBold, halign = "center" })
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

				-- active weapon groups
				local row = table_header:addRow("weaponconfig_active", {  })
				row[1]:setColSpan(2):createText(ReadText(1001, 11218))
				row[7]:setColSpan(1)
				for j = 1, 4 do
					row[2 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(menu.currentplayership, true) == j end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight, symbol = "arrow", bgColor = function () return menu.checkboxWeaponGroupColor(j, true) end, helpOverlayID = "docked_weaponconfig_primary_" .. j .. "_active", helpOverlayText = " ", helpOverlayHighlightOnly = true })
					row[2 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(menu.currentplayership, true, j) end
				end
				for j = 1, 4 do
					row[7 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(menu.currentplayership, false) == j end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight, symbol = "arrow", bgColor = function () return menu.checkboxWeaponGroupColor(j, false) end, helpOverlayID = "docked_weaponconfig_secondary_" .. j .. "_active", helpOverlayText = " ", helpOverlayHighlightOnly = true })
					row[7 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(menu.currentplayership, false, j) end
				end
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

				local row = table_header:addEmptyRow(Helper.standardTextHeight / 2)
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

				for i, weapon in ipairs(weapons) do
					local numweapongroups = C.GetNumWeaponGroupsByWeapon(menu.currentplayership, weapon)
					local rawweapongroups = ffi.new("UIWeaponGroup[?]", numweapongroups)
					numweapongroups = C.GetWeaponGroupsByWeapon(rawweapongroups, numweapongroups, menu.currentplayership, weapon)
					local uiweapongroups = { primary = {}, secondary = {} }
					for j = 0, numweapongroups-1 do
						if rawweapongroups[j].primary then
							uiweapongroups.primary[rawweapongroups[j].idx] = true
						else
							uiweapongroups.secondary[rawweapongroups[j].idx] = true
						end
					end

					local row = table_header:addRow("weaponconfig", {  })
					row[1]:setColSpan(2):createText(ffi.string(C.GetComponentName(weapon)))
					row[7]:setColSpan(1)
					for j = 1, 4 do
						row[2 + j]:createCheckBox(uiweapongroups.primary[j], { width = Helper.standardTextHeight, height = Helper.standardTextHeight, bgColor = function () return menu.checkboxWeaponGroupColor(j, true) end, helpOverlayID = "docked_weaponconfig_primary_" .. j .. "_" .. i, helpOverlayText = " ", helpOverlayHighlightOnly = true })
						row[2 + j].handlers.onClick = function() menu.checkboxWeaponGroup(menu.currentplayership, weapon, true, j, not uiweapongroups.primary[j]) end
					end
					for j = 1, 4 do
						row[7 + j]:createCheckBox(uiweapongroups.secondary[j], { width = Helper.standardTextHeight, height = Helper.standardTextHeight, bgColor = function () return menu.checkboxWeaponGroupColor(j, false) end, helpOverlayID = "docked_weaponconfig_secondary_" .. j .. "_" .. i, helpOverlayText = " ", helpOverlayHighlightOnly = true })
						row[7 + j].handlers.onClick = function() menu.checkboxWeaponGroup(menu.currentplayership, weapon, false, j, not uiweapongroups.secondary[j]) end
					end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

					if C.IsComponentClass(weapon, "missilelauncher") then
						local nummissiletypes = C.GetNumAllMissiles(menu.currentplayership)
						local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
						nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, menu.currentplayership)

						local weaponmacro = GetComponentData(ConvertStringTo64Bit(tostring(weapon)), "macro")
						local dropdowndata = {}
						for j = 0, nummissiletypes - 1 do
							local ammomacro = ffi.string(missilestoragetable[j].macro)
							if C.IsAmmoMacroCompatible(weaponmacro, ammomacro) then
								table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(missilestoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false})
							end
						end

						-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
						menu.currentammo[tostring(weapon)] = "empty"
						local dropdownactive = true
						if #dropdowndata == 0 then
							dropdownactive = false
							table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
						else
							-- NB: currentammomacro can be null
							menu.currentammo[tostring(weapon)] = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
						end

						local row = table_header:addRow("ammo_config", {  })
						row[1]:createText("    " .. ReadText(1001, 2800) .. ReadText(1001, 120))	-- Ammunition, :
						row[2]:setColSpan(10):createDropDown(dropdowndata, { startOption = function () return menu.getDropDownOption(weapon) end, helpOverlayID = "docked_ammo_config", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = dropdownactive })
						row[2].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(weapon, newammomacro) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					elseif pilot and C.IsComponentClass(weapon, "bomblauncher") then
						local pilot64 = ConvertIDTo64Bit(pilot)
						local numbombtypes = C.GetNumAllInventoryBombs(pilot64)
						local bombstoragetable = ffi.new("AmmoData[?]", numbombtypes)
						numbombtypes = C.GetAllInventoryBombs(bombstoragetable, numbombtypes, pilot64)

						local weaponmacro = GetComponentData(ConvertStringTo64Bit(tostring(weapon)), "macro")
						local dropdowndata = {}
						for j = 0, numbombtypes - 1 do
							local ammomacro = ffi.string(bombstoragetable[j].macro)
							if C.IsAmmoMacroCompatible(weaponmacro, ammomacro) then
								table.insert(dropdowndata, { id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(bombstoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false })
							end
						end

						-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
						menu.currentammo[tostring(weapon)] = "empty"
						local dropdownactive = true
						if #dropdowndata == 0 then
							dropdownactive = false
							table.insert(dropdowndata, { id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false })	-- Out of ammo
						else
							-- NB: currentammomacro can be null
							menu.currentammo[tostring(weapon)] = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
						end

						local row = table_header:addRow("ammo_config", {  })
						row[1]:createText("    " .. ReadText(1001, 2800) .. ReadText(1001, 120))	-- Ammunition, :
						row[2]:setColSpan(10):createDropDown(dropdowndata, { startOption = function () return menu.getDropDownOption(weapon) end, helpOverlayID = "docked_ammo_config", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = dropdownactive })
						row[2].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(weapon, newammomacro) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				end
			end

			local hasonlytugturrets = true
			menu.turrets = {}
			local numslots = tonumber(C.GetNumUpgradeSlots(menu.currentplayership, "", "turret"))
			for j = 1, numslots do
				local groupinfo = C.GetUpgradeSlotGroup(menu.currentplayership, "", "turret", j)
				if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
					local current = C.GetUpgradeSlotCurrentComponent(menu.currentplayership, "turret", j)
					if current ~= 0 then
						table.insert(menu.turrets, current)
						if not GetComponentData(ConvertStringTo64Bit(tostring(current)), "istugweapon") then
							hasonlytugturrets = false
						end
					end
				end
			end

			menu.turretgroups = {}
			local groups = {}
			local turretsizecounts = {}
			local n = C.GetNumUpgradeGroups(menu.currentplayership, "")
			local buf = ffi.new("UpgradeGroup2[?]", n)
			n = C.GetUpgradeGroups2(buf, n, menu.currentplayership, "")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
					table.insert(groups, { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
				end
			end
			table.sort(groups, function (a, b) return a.group < b.group end)
			for _, group in ipairs(groups) do
				local groupinfo = C.GetUpgradeGroupInfo2(menu.currentplayership, "", group.context, group.path, group.group, "turret")
				if (groupinfo.count > 0) then
					group.operational = groupinfo.operational
					group.currentcomponent = groupinfo.currentcomponent
					group.currentmacro = ffi.string(groupinfo.currentmacro)
					group.slotsize = ffi.string(groupinfo.slotsize)
					group.sizecount = 0

					if group.slotsize ~= "" then
						if turretsizecounts[group.slotsize] then
							turretsizecounts[group.slotsize] = turretsizecounts[group.slotsize] + 1
						else
							turretsizecounts[group.slotsize] = 1
						end
						group.sizecount = turretsizecounts[group.slotsize]
					end

					table.insert(menu.turretgroups, group)

					if not GetComponentData(ConvertStringTo64Bit(tostring(group.currentcomponent)), "istugweapon") then
						hasonlytugturrets = false
					end
				end
			end

			if #menu.turretgroups > 0 then
				table.sort(menu.turretgroups, Helper.sortSlots)
			end

			if (#menu.turrets > 0) or (#menu.turretgroups > 0) then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, {  })
				row[1]:setColSpan(11):createText(ReadText(1001, 8612), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:createText(ReadText(1001, 8620), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 12),   { font = Helper.standardFontBold, halign = "center" })

				local row = table_header:addRow("turret_config", {  })
				row[1]:createText(ReadText(1001, 2963))

				-- Start Subsystem Targeting Orders callback
				local sto_callbackVal
				if menu.uix_callbacks ["sto_addTurretBehavioursDockMenu"] then
				  for uix_id, uix_callback in pairs (menu.uix_callbacks ["sto_addTurretBehavioursDockMenu"]) do
				    sto_callbackVal = uix_callback (row)
				  end
				end
				if not sto_callbackVal then
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(nil, not hasonlytugturrets, "docked_turretconfig_modes_dropdown_"), { startOption = function () return menu.getDropDownTurretModeOption(menu.currentplayership, "all") end, helpOverlayID = "docked_turretconfig_modes", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "docked_turretconfig_modes"  })
					row[2].properties.helpOverlayID = "docked_turretconfig_modes_dropdown"
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetAllTurretModes(menu.currentplayership, newturretmode) end
				end
				-- End Subsystem Targeting Orders callback

				row[7]:setColSpan(5):createButton({ helpOverlayID = "docked_turretconfig_arm", helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(function () return menu.areTurretsArmed(menu.currentplayership) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
				row[7].handlers.onClick = function () return C.SetAllTurretsArmed(menu.currentplayership, not menu.areTurretsArmed(menu.currentplayership)) end

				local turretscounter = 0
				for i, turret in ipairs(menu.turrets) do
					local row = table_header:addRow("turret_config", {  })
					turretscounter = turretscounter + 1
					local turretname = ffi.string(C.GetComponentName(turret))
					local mouseovertext = ""
					local textwidth = C.GetTextWidth(turretname, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + Helper.scaleX(Helper.standardTextOffsetx)
					if (textwidth > row[1]:getWidth()) then
						mouseovertext = turretname
					end
					row[1]:createText(turretname, { mouseOverText = mouseovertext })
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(turret, nil, "docked_turrets_modes_dropdown_", turretscounter), { startOption = function () return menu.getDropDownTurretModeOption(turret) end, helpOverlayID = "docked_turrets_modes".. turretscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "docked_turrets_modes" .. turretscounter  })
					row[2].properties.helpOverlayID = "docked_turrets_modes_dropdown" .. turretscounter
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetWeaponMode(turret, newturretmode) end
					row[7]:setColSpan(5):createButton({helpOverlayID = "docked_turrets_arm" .. turretscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true   }):setText(function () return C.IsWeaponArmed(turret) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetWeaponArmed(turret, not C.IsWeaponArmed(turret)) end
				end

				local turretgroupscounter = 0
				for i, group in ipairs(menu.turretgroups) do
					local row = table_header:addRow("turret_config", {  })
					turretgroupscounter = turretgroupscounter + 1
					local groupname = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")
					local mouseovertext = ""
					local textwidth = C.GetTextWidth(groupname, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + Helper.scaleX(Helper.standardTextOffsetx)
					if (textwidth > row[1]:getWidth()) then
						mouseovertext = groupname
					end
					row[1]:createText(groupname, { color = (group.operational > 0) and Color["text_normal"] or Color["text_error"], mouseOverText = mouseovertext })
					row[2]:setColSpan(5):createDropDown(Helper.getTurretModes(group.currentcomponent ~= 0 and group.currentcomponent or nil, nil, "docked_turretgroups_modes_dropdown_", turretgroupscounter), { startOption = function () return menu.getDropDownTurretModeOption(menu.currentplayership, group.context, group.path, group.group) end, active = group.operational > 0, helpOverlayID = "docked_turretgroups_modes".. turretgroupscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "docked_turretgroups_modes" .. turretgroupscounter  })
					row[2].properties.helpOverlayID = "docked_turretgroups_modes_dropdown" .. turretgroupscounter
					row[2].handlers.onDropDownConfirmed = function(_, newturretmode) C.SetTurretGroupMode2(menu.currentplayership, group.context, group.path, group.group, newturretmode) end
					row[7]:setColSpan(5):createButton({ helpOverlayID = "docked_turretgroups_arm" .. turretgroupscounter, helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(function () return C.IsTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group, not C.IsTurretGroupArmed(menu.currentplayership, group.context, group.path, group.group)) end
				end
			end

			menu.drones = {}
			for _, dronetype in ipairs(config.dronetypes) do
				if C.GetNumStoredUnits(menu.currentplayership, dronetype.id, false) > 0 then
					local entry = {
						type = dronetype.id,
						name = dronetype.name,
						modes = {},
					}

					local n = C.GetNumDroneModes(menu.currentplayership, dronetype.id)
					local buf = ffi.new("DroneModeInfo[?]", n)
					n = C.GetDroneModes(buf, n, menu.currentplayership, dronetype.id)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						if id ~= "trade" then
							table.insert(entry.modes, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
						end
					end
					table.insert(menu.drones, entry)
				end
			end

			if #menu.drones > 0 then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, {  })
				row[1]:setColSpan(11):createText(ReadText(1001, 8619), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:createText(ReadText(1001, 8620), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 12), { font = Helper.standardFontBold, halign = "center" })

				for _, entry in ipairs(menu.drones) do
					local isblocked = C.IsDroneTypeBlocked(menu.currentplayership, entry.type)
					local row = table_header:addRow("drone_config", {  })
					row[1]:createText(function () return entry.name .. " (" .. (C.IsDroneTypeArmed(menu.currentplayership, entry.type) and (C.GetNumUnavailableUnits(menu.currentplayership, entry.type) .. "/") or "") .. C.GetNumStoredUnits(menu.currentplayership, entry.type, false) ..")" end, { color = isblocked and Color["text_warning"] or nil })
					row[2]:setColSpan(5):createDropDown(entry.modes, { startOption = function () return menu.dropdownDroneStartOption(menu.currentplayership, entry.type) end, active = not isblocked })
					row[2].handlers.onDropDownConfirmed = function (_, newdronemode) C.SetDroneMode(menu.currentplayership, entry.type, newdronemode) end
					row[7]:setColSpan(5):createButton({ active = not isblocked }):setText(function () return C.IsDroneTypeArmed(menu.currentplayership, entry.type) and ReadText(1001, 8622) or ReadText(1001, 8623) end, { halign = "center" })
					row[7].handlers.onClick = function () return C.SetDroneTypeArmed(menu.currentplayership, entry.type, not C.IsDroneTypeArmed(menu.currentplayership, entry.type)) end
					row[7].properties.helpOverlayID = "docked_drones_" .. entry.type
					row[7].properties.helpOverlayText = " "
					row[7].properties.helpOverlayHighlightOnly = true
				end
			end
			-- subordinates
			local subordinates = GetSubordinates(menu.currentplayership)
			local groups = {}
			local usedassignments = {}
			for _, subordinate in ipairs(subordinates) do
				local purpose, shiptype = GetComponentData(subordinate, "primarypurpose", "shiptype")
				local group = GetComponentData(subordinate, "subordinategroup")
				if group and group > 0 then
					if groups[group] then
						table.insert(groups[group].subordinates, subordinate)
						if shiptype == "resupplier" then
							groups[group].numassignableresupplyships = groups[group].numassignableresupplyships + 1
						end
						if purpose == "mine" then
							groups[group].numassignableminingships = groups[group].numassignableminingships + 1
						end
						if shiptype == "tug" then
							groups[group].numassignabletugships = groups[group].numassignabletugships + 1
						end
					else
						local assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.currentplayership, group))
						usedassignments[assignment] = i
						groups[group] = { assignment = assignment, subordinates = { subordinate }, numassignableresupplyships = (shiptype == "resupplier") and 1 or 0, numassignableminingships = (purpose == "mine") and 1 or 0, numassignabletugships= (shiptype == "tug") and 1 or 0 }
					end
				end
			end

			if #subordinates > 0 then
				table_header:addEmptyRow(yoffset)

				local row = table_header:addRow(false, {  })
				row[1]:setColSpan(11):createText(ReadText(1001, 8626), Helper.headerRowCenteredProperties)

				local row = table_header:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[1]:createText(ReadText(1001, 8627), { font = Helper.standardFontBold, halign = "center" })
				row[2]:createText(ReadText(1001, 8373), { font = Helper.standardFontBold, halign = "center" })
				row[7]:createText(ReadText(1001, 8628), { font = Helper.standardFontBold, halign = "center" })

				local subordinatecounter = 0
				for i = 1, 10 do
					if groups[i] then
						subordinatecounter = subordinatecounter + 1
						local supplyactive = (groups[i].numassignableresupplyships == #groups[i].subordinates) and ((not usedassignments["supplyfleet"]) or (usedassignments["supplyfleet"] == i))
						local subordinateassignments = {
							[1] = { id = "defence",			text = ReadText(20208, 40301),	icon = "",	displayremoveoption = false },
							[2] = { id = "supplyfleet",		text = ReadText(20208, 40701),	icon = "",	displayremoveoption = false, active = supplyactive, mouseovertext = supplyactive and "" or ReadText(1026, 8601) },
						}

						local isstation = C.IsComponentClass(menu.currentplayership, "station")
						if isstation then
							local miningactive = (groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i))
							table.insert(subordinateassignments, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false, active = miningactive, mouseovertext = miningactive and "" or ReadText(1026, 8602) })
							local tradeactive = (not usedassignments["trade"]) or (usedassignments["trade"] == i)
							table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, active = tradeactive, mouseovertext = tradeactive and ((groups[i].numassignableminingships > 0) and (ColorText["text_warning"] .. ReadText(1026, 8607)) or "") or ReadText(1026, 7840) })
							local tradeforbuildstorageactive = (groups[i].numassignableminingships == 0) and ((not usedassignments["tradeforbuildstorage"]) or (usedassignments["tradeforbuildstorage"] == i))
							table.insert(subordinateassignments, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false, active = tradeforbuildstorageactive, mouseovertext = tradeforbuildstorageactive and "" or ReadText(1026, 8603) })
							local salvageactive = (groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i))
							table.insert(subordinateassignments, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false, active = salvageactive, mouseovertext = salvageactive and "" or ReadText(1026, 8610) })
						elseif C.IsComponentClass(menu.currentplayership, "ship") then
							-- position defence
							local shiptype = GetComponentData(menu.currentplayership, "shiptype")
							local parentcommander = ConvertIDTo64Bit(GetCommander(menu.currentplayership))
							local isfleetcommander = (not parentcommander) and (#subordinates > 0)
							if (shiptype == "carrier") and isfleetcommander then
								table.insert(subordinateassignments, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false })
							end
							table.insert(subordinateassignments, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
							table.insert(subordinateassignments, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
							local active = true
							local mouseovertext = ""
							local buf = ffi.new("Order")
							if not C.GetDefaultOrder(buf, menu.currentplayership) then
								active = false
								mouseovertext = ReadText(1026, 8606)
							end
							table.insert(subordinateassignments, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
							if shiptype == "resupplier" then
								table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false })
							end
						end

						for _, entry in ipairs(subordinateassignments) do
							entry.helpOverlayID = "docked_subordinate_role_dropdown_" .. entry.id .. subordinatecounter
							entry.helpOverlayText = " "
							entry.helpOverlayHighlightOnly = true
						end

						local isdockingpossible = false
						for _, subordinate in ipairs(groups[i].subordinates) do
							if IsDockingPossible(subordinate, menu.currentplayership) then
								isdockingpossible = true
								break
							end
						end
						local active = function () return menu.buttonActiveSubordinateGroupLaunch(i) end
						local mouseovertext = ""
						if isstation then
							active = false
						elseif not GetComponentData(menu.currentplayership, "hasshipdockingbays") then
							active = false
							mouseovertext = ReadText(1026, 8604)
						elseif not isdockingpossible then
							active = false
							mouseovertext = ReadText(1026, 8605)
						end

						local row = table_header:addRow("subordinate_config", {  })
						row[1]:createText(function () menu.updateSubordinateGroupInfo(); return ReadText(20401, i) .. (menu.subordinategroups[i] and (" (" .. ((not C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i)) and ((#menu.subordinategroups[i].subordinates - menu.subordinategroups[i].numdockedatcommander) .. "/") or "") .. #menu.subordinategroups[i].subordinates ..")") or "") end, { color = isblocked and Color["text_warning"] or nil })
						row[2]:setColSpan(5):createDropDown(subordinateassignments, { startOption = function () menu.updateSubordinateGroupInfo(); return menu.subordinategroups[i] and menu.subordinategroups[i].assignment or "" end, uiTriggerID = "subordinate_group_role_" .. i, helpOverlayID = "docked_subordinate_role" .. subordinatecounter, helpOverlayText = " ", helpOverlayHighlightOnly = true })
						row[2].handlers.onDropDownConfirmed = function(_, newassignment) Helper.dropdownAssignment(_, nil, i, menu.currentplayership, newassignment) end
						
						-- Start Reactive Docking callback
						local rd_callbackVal
						if menu.uix_callbacks ["rd_addReactiveDockingDockMenu"] then
				  			for uix_id, uix_callback in pairs (menu.uix_callbacks ["rd_addReactiveDockingDockMenu"]) do
				    				rd_callbackVal = uix_callback (row, menu.currentplayership, i, active, mouseovertext)
				  			end
						end
						if not rd_callbackVal then
							row[7]:setColSpan(5):createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "docked_subordinate_arm" .. subordinatecounter, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(function () return C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i) and ReadText(1001, 8630) or ReadText(1001, 8629) end, { halign = "center" })
							row[7].handlers.onClick = function () return C.SetSubordinateGroupDockAtCommander(menu.currentplayership, i, not C.ShouldSubordinateGroupDockAtCommander(menu.currentplayership, i)) end
						end
						-- End Reactive Docking callback

					end
				end
			end
		end
	else
		local row = table_header:addRow("buttonRow1", { fixed = true })
		local active = canwareexchange
		local mouseovertext
		if (not active) and isplayerowned then
			if C.IsComponentClass(menu.currentcontainer, "ship") then
				mouseovertext = isbuilderbusy and ReadText(1001, 7939) or ReadText(1026, 7830)
			end
		end
		row[1]:createButton(active and { helpOverlayID = "docked_transferwares", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8618), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Transfer Wares"
		if active then
			row[1].handlers.onClick = function() return menu.buttonTrade(true) end
		else
			row[1].properties.mouseOverText = mouseovertext
		end
		local active = (menu.currentplayership ~= 0) or menu.secondarycontrolpost
		row[2]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 277), helpOverlayID = "docked_getup", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 20014), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Get Up"
		if active then
			row[2].handlers.onClick = menu.buttonGetUp
		end
		local active = menu.currentplayership ~= 0
		row[7]:createButton(active and { mouseOverText = GetLocalizedKeyName("action", 316), helpOverlayID = "docked_shipinfo", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1001, 8602), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Ship Information"
		if active then
			row[7].handlers.onClick = menu.buttonDockedShipInfo
		end

		local row = table_header:addRow("buttonRow2", { fixed = true })

		local doessellshipstoplayer = GetFactionData(owner, "doessellshipstoplayer")
		local active = canbuyship and doessellshipstoplayer
		local mouseovertext = ""
		if not doessellshipstoplayer then
			mouseovertext = ReadText(1026, 7865)
		end

		row[1]:createButton(active and { helpOverlayID = "docked_buyships", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 8008), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Buy Ships"
		row[1].properties.mouseOverText = mouseovertext
		if active then
			row[1].handlers.onClick = menu.buttonBuyShip
		end

		local hastradeoffers = GetFactionData(owner, "hastradeoffers")
		local active = cantrade and hastradeoffers and (not istimelineshub)
		local mouseovertext = ""
		if not hastradeoffers then
			mouseovertext = ReadText(1026, 7866)
		end

		row[2]:createButton(active and {helpOverlayID = "docked_trade", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(ReadText(1002, 9005), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Trade"
		row[2].properties.mouseOverText = mouseovertext
		if active then
			row[2].handlers.onClick = function() return menu.buttonTrade(false) end
			row[2].properties.uiTriggerID = "docked_trade"
		end
		local active = canmodifyship and doessellshipstoplayer
		row[7]:createButton(active and {helpOverlayID = "docked_upgrade_repair", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(issupplyship and ReadText(1001, 7877) or ReadText(1001, 7841), active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Upgrade / Repair Ship
		if not doessellshipstoplayer then
			row[7].properties.mouseOverText = ReadText(1026, 7865)
		elseif dockedplayerships[1] and (not canequip) then
			row[7].properties.mouseOverText = (C.IsComponentClass(dockedplayerships[1], "ship_l") or C.IsComponentClass(dockedplayerships[1], "ship_xl")) and ReadText(1026, 7807) or ReadText(1026, 7806)
		elseif not isdock then
			row[7].properties.mouseOverText = ReadText(1026, 8014)
		end
		if active then
			row[7].handlers.onClick = menu.buttonModifyShip
		end

		local row = table_header:addRow("buttonRow3", { fixed = true })
		local currentactivity = GetPlayerActivity()
		if currentactivity ~= "none" then
			local text = ""
			for _, entry in ipairs(config.modes) do
				if entry.id == currentactivity then
					text = entry.stoptext
					break
				end
			end
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			row[1]:createButton(active and {helpOverlayID = "docked_stopmode", helpOverlayText = " ", helpOverlayHighlightOnly = true } or config.inactiveButtonProperties):setText(text, active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- "Stop Mode"
			if active then
				row[1].handlers.onClick = menu.buttonStopMode
				row[1].properties.uiTriggerID = "stopmode"
			end
		else
			local active = (menu.currentplayership ~= 0) or C.IsPlayerControlGroupValid()
			local modes = {}
			if active then
				for _, entry in ipairs(config.modes) do
					local entryactive = menu.currentplayership ~= 0
					local visible = true
					if entry.id == "travel" then
						entryactive = entryactive and C.CanStartTravelMode(menu.currentplayership)
					elseif entry.id == "scan_longrange" then
						entryactive = entryactive and C.CanPerformLongRangeScan()
					elseif entry.id == "seta" then
						entryactive = true
						visible = C.CanActivateSeta(false)
					end
					local mouseovertext = GetLocalizedKeyName("action", entry.action)
					if visible then
						table.insert(modes, { id = entry.id, text = entry.name, icon = "", displayremoveoption = false, active = entryactive, mouseovertext = mouseovertext })
					end
				end
			end
			row[1]:createDropDown(modes, {
				helpOverlayID = "docked_modes",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				height = Helper.standardButtonHeight,
				startOption = "",
				textOverride = ReadText(1002, 1001),
				bgColor = active and Color["button_background_default"] or Color["button_background_inactive"],
				highlightColor = active and Color["button_highlight_default"] or Color["button_highlight_inactive"],
			}):setTextProperties(active and config.activeButtonTextProperties or config.inactiveButtonTextProperties)	-- Modes
			if active then
				row[1].handlers.onDropDownConfirmed = menu.dropdownMode
				row[1].properties.uiTriggerID = "startmode"
			end
		end
		if not istimelineshub then
			if menu.currentplayership ~= 0 then
				row[2]:createButton({ mouseOverText = GetLocalizedKeyName("action", 175), bgColor = menu.undockButtonBGColor, highlightColor = menu.undockButtonHighlightColor, helpOverlayID = "docked_undock", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1002, 20013), { halign = "center", color = menu.undockButtonTextColor })	-- "Undock"
				row[2].handlers.onClick = menu.buttonUndock
			else
				row[2]:createButton({ mouseOverText = GetLocalizedKeyName("action", 175), helpOverlayID = "docked_gotoship", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 7305), { halign = "center" })	-- "Go to Ship"
				row[2].handlers.onClick = menu.buttonGoToShip
			end
		else
			row[2]:createButton(config.inactiveButtonProperties):setText(ReadText(1001, 7305), config.inactiveButtonTextProperties)	-- dummy
		end
		row[7]:createButton(config.inactiveButtonProperties):setText("", config.inactiveButtonTextProperties)	-- dummy

		-- start: kuertee call-back
		if menu.uix_callbacks ["display_on_after_main_interactions"] then
  			for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_main_interactions"]) do
  				uix_callback (table_header)
  			end
  		end
		-- end: kuertee call-back

		local row = table_header:addRow(false, { fixed = true })
		row[1]:setColSpan(11):createBoxText(menu.infoText, { halign = "center", color = Color["icon_warning"], boxColor = menu.infoBoxColor })
	end


	if menu.table_header then
		table_header:setTopRow(GetTopRow(menu.table_header))
		table_header:setSelectedRow(menu.selectedRows.header or Helper.currentTableRow[menu.table_header])
		table_header:setSelectedCol(menu.selectedCols.header or Helper.currentTableCol[menu.table_header] or 0)
	else
		table_header:setSelectedRow(menu.selectedRows.header)
		table_header:setSelectedCol(menu.selectedCols.header or 0)
	end
	menu.selectedRows.header = nil
	menu.selectedCols.header = nil

	table_header.properties.maxVisibleHeight = Helper.viewHeight - table_header.properties.y - Helper.frameBorder
	menu.frame.properties.height = math.min(Helper.viewHeight, table_header:getVisibleHeight() + table_header.properties.y + Helper.scaleY(Helper.standardButtonHeight))

	-- display view/frame
	menu.frame:display()
end

function menu.dropdownDroneStartOption(ship, type)
	local curmode = ffi.string(C.GetCurrentDroneMode(ship, type))

	-- trade mode is a temporary, not user available setting, show the stored user setting instead
	if curmode == "trade" then
		curmode = ffi.string(C.GetUserTransportDroneMode(ship))
	end

	return curmode
end

-- handle created frames
function menu.viewCreated(layer, ...)
	menu.table_toplevel, menu.table_topleft, menu.table_header = ...
end

function menu.isDockButtonActive()
	local docktarget = 0
	local softtarget = C.GetSofttarget2().softtargetID
	local environmenttarget = C.GetEnvironmentObject()
	if softtarget ~= 0 then
		docktarget = C.GetContextByClass(softtarget, "container", true)
	elseif environmenttarget ~= 0 then
		docktarget = C.GetContextByClass(environmenttarget, "container", true)
	end
	return (menu.currentplayership ~= 0) and (GetComponentData(menu.currentplayership, "isdocking") or ((docktarget ~= 0) and C.RequestDockAt(docktarget, true)))
end

function menu.dockButtonBGColor()
	return menu.isDockButtonActive() and Color["button_background_default"] or Color["button_background_inactive"]
end

function menu.dockButtonHighlightColor()
	return menu.isDockButtonActive() and Color["button_highlight_default"] or Color["button_highlight_inactive"]
end

function menu.dockButtonTextColor()
	return menu.isDockButtonActive() and Color["text_normal"] or Color["text_inactive"]
end

function menu.isUndockButtonActive()
	return (menu.currentplayership ~= 0) and GetComponentData(menu.currentplayership, "isdocked") and (ffi.string(C.UndockPlayerShip(true)) == "granted") and ((not menu.buildInProgress) or C.CanCancelConstruction(menu.currentcontainer, menu.buildInProgress))
end

function menu.undockButtonBGColor()
	return menu.isUndockButtonActive() and Color["button_background_default"] or Color["button_background_inactive"]
end

function menu.undockButtonHighlightColor()
	return menu.isUndockButtonActive() and Color["button_highlight_default"] or Color["button_highlight_inactive"]
end

function menu.undockButtonTextColor()
	return menu.isUndockButtonActive() and Color["text_normal"] or Color["text_inactive"]
end

function menu.updateSubordinateGroupInfo()
	local curtime = getElapsedTime()
	if (not menu.lastSubordinateGroupUpdate) or (curtime > menu.lastSubordinateGroupUpdate) then
		menu.lastSubordinateGroupUpdate = curtime
		local subordinates = GetSubordinates(menu.currentplayership)
		menu.subordinategroups = {}
		for _, subordinate in ipairs(subordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if menu.subordinategroups[group] then
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == menu.currentplayership
					if isdocked then
						menu.subordinategroups[group].numdockedatcommander = menu.subordinategroups[group].numdockedatcommander + 1
					end
					table.insert(menu.subordinategroups[group].subordinates, subordinate)
				else
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == menu.currentplayership
					menu.subordinategroups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.currentplayership, group)), subordinates = { subordinate }, numdockedatcommander = isdocked and 1 or 0 }
				end
			end
		end
	end
end

function menu.buttonActiveSubordinateGroupLaunch(i)
	menu.updateSubordinateGroupInfo()
	if menu.subordinategroups[i] then
		return (menu.subordinategroups[i].assignment ~= "trade") and (menu.subordinategroups[i].assignment ~= "mining") and (menu.subordinategroups[i].assignment ~= "follow") and (menu.subordinategroups[i].assignment ~= "assist") and (menu.subordinategroups[i].assignment ~= "supplyfleet")
	end
	return false
end

function menu.infoText()
	if ffi.string(C.UndockPlayerShip(true)) == "tradecomputerbusy" then
		menu.haswarning = true
		return ReadText(1001, 8609)
	end
	if menu.currentplayership ~= 0 then
		local constructions = {}
		-- builds in progress
		local n = C.GetNumBuildTasks(menu.currentcontainer, 0, true, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.currentcontainer, 0, true, true)
		for i = 0, n - 1 do
			table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
		end
		-- other builds
		menu.buildInProgress, menu.buildToCancel = nil, nil
		local n = C.GetNumBuildTasks(menu.currentcontainer, 0, false, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.currentcontainer, 0, false, true)
		for i = 0, n - 1 do
			table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
		end
		for _, entry in ipairs(constructions) do
			if (entry.component == menu.currentplayership) then
				menu.haswarning = true
				if entry.inprogress then
					menu.buildInProgress = entry.id
					if C.CanCancelConstruction(menu.currentcontainer, menu.buildInProgress) then
						-- warning but allow undock
						menu.buildToCancel = { entry.id, tonumber(entry.price) }
						return ReadText(1001, 8611)
					else
						-- may not be aborted
						return ReadText(1001, 8610) .. " (" .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(entry.buildercomponent), "%h:%M:%S") .. ")"
					end
				else
					-- warning but allow undock
					menu.buildToCancel = { entry.id, tonumber(entry.price) }
					return ReadText(1001, 8611)
				end
			end
		end
	end
	menu.haswarning = nil
	return ""
end

function menu.infoBoxColor()
	if menu.haswarning then
		return Color["icon_warning"]
	end
	return Color["boxtext_box_hidden"]
end

function menu.checkboxWeaponGroupColor(groupidx, primary)
	return (C.GetDefensibleActiveWeaponGroup(menu.currentplayership, primary) == groupidx) and Color["weapon_group_highlight"] or Color["checkbox_background_default"]
end

function menu.getDropDownOption(weapon)
	local currentweapon = ffi.string(C.GetCurrentAmmoOfWeapon(weapon))
	if menu.currentammo[tostring(weapon)] ~= currentweapon then
		menu.currentammo[tostring(weapon)] = currentweapon
	end
	return menu.currentammo[tostring(weapon)]
end

function menu.getDropDownTurretModeOption(defensibleorturret, context, path, group)
	if (context == nil) and (path == nil) and (group == nil) then
		return ffi.string(C.GetWeaponMode(defensibleorturret))
	elseif context == "all" then
		local allmode
		for i, turret in ipairs(menu.turrets) do
			local mode = ffi.string(C.GetWeaponMode(turret))
			if allmode == nil then
				allmode = mode
			elseif allmode ~= mode then
				allmode = ""
				break
			end
		end
		for i, group in ipairs(menu.turretgroups) do
			if group.operational > 0 then
				local mode = ffi.string(C.GetTurretGroupMode2(defensibleorturret, group.context, group.path, group.group))
				if allmode == nil then
					allmode = mode
				elseif allmode ~= mode then
					allmode = ""
					break
				end
			end
		end
		return allmode or ""
	end
	return ffi.string(C.GetTurretGroupMode2(defensibleorturret, context, path, group))
end

function menu.areTurretsArmed(defensibleorturret)
	local alldisarmed = true
	for i, turret in ipairs(menu.turrets) do
		if C.IsWeaponArmed(turret) then
			alldisarmed = false
			break
		end
	end
	for i, group in ipairs(menu.turretgroups) do
		if group.operational > 0 then
			if C.IsTurretGroupArmed(defensibleorturret, group.context, group.path, group.group) then
				alldisarmed = false
				break
			end
		end
	end
	return not alldisarmed
end

function menu.createTopLevel(frame)
	menu.topLevelOffsetY = Helper.createTopLevelTab(menu, menu.mode, frame, "", nil, (menu.mode == "cockpit") or (menu.currentplayership == 0))
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, menu.mode, 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, menu.mode, -1)
	end
end

function menu.onInputModeChanged(_, mode)
	menu.display()
end

-- widget scripts
function menu.buttonGetUp()
	if not C.GetUp() then
		DebugError("failed getting up.")
	end
end

function menu.buttonGoToShip()
	Helper.closeMenuAndOpenNewMenu(menu, "PlatformUndockMenu", { 0, 0 }, true)
	menu.cleanup()
end

function menu.buttonBuyShip()
	local shiptrader = GetComponentData(menu.currentcontainer, "shiptrader")
	if not shiptrader then
		DebugError("menu.buttonBuyShip called but " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. " has no shiptrader.")
		return
	end
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.currentcontainer, "purchase", {} })
	menu.cleanup()
end

function menu.buttonModifyShip()
	local shiptrader = GetComponentData(menu.currentcontainer, "shiptrader")
	if not shiptrader then
		DebugError("menu.buttonModifyShip called but " .. ffi.string(C.GetComponentName(menu.currentcontainer)) .. " has no shiptrader.")
		return
	end
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.currentcontainer, "upgrade", {}, true })
	menu.cleanup()
end

function menu.buttonTrade(iswareexchange)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "tradecontext", {menu.currentcontainer, nil, iswareexchange} })
	menu.cleanup()
end

function menu.buttonUndock()
	if menu.isUndockButtonActive() then
		if menu.buildToCancel then
			Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "abortupgrade", { menu.currentcontainer, menu.buildToCancel[1], menu.buildToCancel[2] } }, true)
			menu.cleanup()
		else
			Helper.closeMenu(menu, "close")
			menu.cleanup()
			if ffi.string(C.UndockPlayerShip(false)) ~= "granted" then
				DebugError("failed undocking.")
			end
		end
	end
end

function menu.buttonShipInfo()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", menu.currentcontainer } })
	menu.cleanup()
end

function menu.buttonDockedShipInfo()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", menu.currentplayership } })
	menu.cleanup()
end

function menu.buttonAutoPilot()
	C.ToggleAutoPilot(false)
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

function menu.buttonDock()
	if menu.isDockButtonActive() then
		C.QuickDock()
	end
end

function menu.buttonFlightAssist()
	C.ToggleFlightAssist()
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

function menu.buttonStopMode()
	local currentactivity = GetPlayerActivity()
	C.StopPlayerActivity(currentactivity)
	menu.display()
end

function menu.buttonCover(faction)
	local coverfaction = ""
	if menu.currentplayership ~= 0 then
		coverfaction = ffi.string(C.GetObjectCoverAbilityFaction(menu.currentplayership))
	end
	if (faction == coverfaction) or (faction == "") then
		C.SetObjectCoverFaction(menu.currentplayership, faction)
	end
	menu.display()
end

function menu.dropdownMode(_, id)
	C.StartPlayerActivity(id)
	menu.refresh = getElapsedTime() + 0.11
end

function menu.dropdownDeploy(_, idstring)
	local id, macro = string.match(idstring, "(.+):(.+)")
	for _, entry in ipairs(config.consumables) do
		if entry.id == id then
			entry.callback(menu.currentplayership, macro)
			PlaySound("ui_ship_interaction_deploy")
		end
	end
	menu.display()
end

function menu.checkboxWeaponGroup(objectid, weaponid, primary, group, active)
	C.SetWeaponGroup(objectid, weaponid, primary, group, active)
	menu.display()
end

menu.updateInterval = 0.1

-- hook to update the menu while it is being displayed
function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.secondarycontrolpost then
		if C.IsComponentClass(menu.currentcontainer, "ship") then
			local docked = GetComponentData(menu.currentcontainer, "isdocked")
			if docked ~= (menu.mode == "docked") then
				menu.mode = docked and "docked" or "cockpit"
				menu.refresh = curtime - 1
			end
		end
	end

	if menu.refresh and (menu.refresh < curtime) then
		menu.refresh = nil
		menu.display()
		return
	end

	if menu.firsttime and (menu.firsttime < curtime) then
		SelectRow(menu.table_header, 5)
		SelectColumn(menu.table_header, 2)
		menu.firsttime = nil
	end

	--print("On Update")
	menu.frame:update()
end

-- hook if the highlighted row is changed (is also called on menu creation)
function menu.onRowChanged(row, rowdata)
	--print("Row Changed")
	menu.frame:update()
end

-- hook if the highlighted row is selected
function menu.onSelectElement()
	--print("Element Selected")
end

function menu.close()
	Helper.closeMenu(menu, "close")
	menu.cleanup()
end

-- hook if the menu is being closed
function menu.onCloseElement(dueToClose)
	if ((menu.mode == "docked") and (menu.currentplayership ~= 0)) or menu.secondarycontrolpost then
		if dueToClose == "back" then
			Helper.closeMenuAndOpenNewMenu(menu, "OptionsMenu", nil)
			menu.cleanup()
		end
	else
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
	end
end

-- kuetee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuerte end

init()
﻿-- param == { 0, 0, mode, library, id, object }
-- modes are: "Galaxy", "Factions", "Stations", "Ships", "Weapons", "Equipment", "Licences", and "Wares"
-- see menu.data initialization for libaries

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t UniverseID;
	typedef struct {
		const char* id;
		const char* name;
		double productiontime;
		double productionamount;
	} ProductionMethodInfo2;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* name;
		const char* typeclass;
		const char* geology;
		const char* atmosphere;
		const char* population;
		const char* settlements;
		uint32_t nummoons;
		bool hasterraforming;
	} UICelestialBodyInfo2;
	typedef struct {
		double time;
		int64_t price;
		int amount;
		int limit;
	} UITradeOfferStatData;
	typedef struct {
		const char* wareid;
		bool isSellOffer;
		UITradeOfferStatData* data;
		uint32_t numdata;
	} UITradeOfferStat;
	typedef struct {
		const char* environment;
	} UISpaceInfo;
	typedef struct {
		const char* name;
		const char* typeclass;
	} UISunInfo;
	typedef struct {
		uint32_t numsuns;
		uint32_t numplanets;
	} UISystemInfoCounts;
	typedef struct {
		UISpaceInfo space;
		uint32_t numsuns;
		UISunInfo* suns;
		uint32_t numplanets;
		UICelestialBodyInfo2* planets;
	} UISystemInfo2;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		const char* sourcetype;
		const char* sourcelocation;
	} WareSource;
	typedef struct {
		const char* transport;
		const char* name;
		int value;
	} WareTransportInfo;
	typedef struct {
		const char* ware;
		int32_t current;
		int32_t max;
	} WareYield;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	const char* GenerateFactionRelationText(const char* factionid);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	uint32_t GetDefaultMissileStorageCapacity(const char* macroname);
	uint32_t GetDiscoveredSectorResources(WareYield* result, uint32_t resultlen, UniverseID sectorid);
	UniverseID GetFactionRepresentative(const char* factionid);
	uint32_t GetFixedStations(UniverseID* result, uint32_t resultlen, UniverseID spaceid);
	uint32_t GetHQs(UniverseID* result, uint32_t resultlen, const char* factionid);
	UniverseID GetLastPlayerControlledShipID(void);
	uint32_t GetLibraryEntryAliases(const char** result, uint32_t resultlen, const char* librarytypeid, const char* id);
	const char* GetMacroClass(const char* macroname);
	uint32_t GetMoonInfo2(UICelestialBodyInfo2* result, uint32_t resultlen, UniverseID clusterid, uint32_t planetidx);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	uint32_t GetNumContainedKnownSpaces(UniverseID spaceid);
	uint32_t GetNumContainedKnownUnreadSpaces(UniverseID spaceid);
	uint32_t GetNumDiscoveredSectorResources(UniverseID sectorid);
	uint32_t GetNumFixedStations(UniverseID spaceid);
	uint32_t GetNumHQs(const char* factionid);
	uint32_t GetNumLibraryEntryAliases(const char* librarytypeid, const char* id);
	uint32_t GetNumProductionMethodResources(const char* wareid, const char* productionmethod);
	uint32_t GetNumSectorsByOwner(const char* factionid);
	uint32_t GetNumTerraformingProjects(UniverseID clusterid, bool useevents);
	uint32_t GetNumTradeOfferStatistics(UniverseID containerorspaceid, double starttime, double endtime, size_t numdatapoints);
	UISystemInfoCounts GetNumUISystemInfo(UniverseID clusterid);
	uint32_t GetNumUnreadLibraryEntries(const char* libraryid);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetNumWareSources(const char* wareid);
	uint32_t GetNumWareTransportTypes(void);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includepilot);
	UniverseID GetPlayerZoneID(void);
	ProductionMethodInfo2 GetProductionMethodInfo(const char* wareid, const char* productionmethod);
	uint32_t GetProductionMethodResources(UIWareAmount* result, uint32_t resultlen, const char* wareid, const char* productionmethod);
	uint32_t GetSectorsByOwner(UniverseID* result, uint32_t resultlen, const char* factionid);
	uint32_t GetTradeOfferStatistics(UITradeOfferStat* result, uint32_t resultlen, size_t numdatapoints);
	bool GetUISystemInfo2(UISystemInfo2* result, UniverseID clusterid);
	uint32_t GetUpgradeGroups(UpgradeGroup* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetUpgradeSlotCurrentMacro(UniverseID defensibleid, UniverseID moduleid, const char* upgradetypename, size_t slot);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetWareSources(WareSource* result, uint32_t resultlen, const char* wareid);
	uint32_t GetWareTransportTypes(WareTransportInfo* result, uint32_t resultlen);
	bool HasDefaultLoadout2(const char* macroname, bool allowloadoutoverride);
	bool InstallPaintMod(UniverseID objectid, const char* wareid, bool useinventory);
	bool IsFactionAllyToFaction(const char* factionid, const char* otherfactionid);
	bool IsFactionEnemyToFaction(const char* factionid, const char* otherfactionid);
	bool IsFactionHostileToFaction(const char* factionid, const char* otherfactionid);
	bool IsKnownItemRead(const char* libraryid, const char* itemid);
	bool IsKnownRead(UniverseID componentid);
	bool IsKnownToPlayer(UniverseID componentid);
	bool IsUpgradeMacroCompatible(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool IsVirtualUpgradeMacroCompatible(UniverseID defensibleid, const char* macroname, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	void ReadAllKnownItems(void);
	void ReadAllKnownSpaces(UniverseID spaceid);
	void ReadKnownItem(const char* libraryid, const char* itemid, bool read);
	void SetCheckBoxChecked2(const int checkboxid, bool checked, bool update);
	void SetKnownRead(UniverseID componentid, bool read);
]]

local utf8 = require("utf8")

-- menu variable - used by Helper and used for dynamic variables (e.g. inventory content, etc.)
local menu = {
	name = "EncyclopediaMenu",
	encyclopediaMode = "encyclopedia",
	productionmethod = "default",
}

local config = {
	leftBar = {
		[1] = { name = ReadText(1001, 2400),	icon = "tlt_encyclopedia",			mode = "encyclopedia",		helpOverlayID = "encyclopedia_sidebar_encyclopedia",		helpOverlayText = ReadText(1028, 2401) },
		[2] = { name = ReadText(1001, 8201),	icon = "ency_timeline_01",			mode = "timeline",			helpOverlayID = "encyclopedia_sidebar_timeline_01",			helpOverlayText = ReadText(1028, 2402) },
		[3] = { name = ReadText(1001, 3700),	icon = "ency_ship_comparison_01",	mode = "shipcomparison",	helpOverlayID = "encyclopedia_sidebar_ship_comparison_01",	helpOverlayText = ReadText(1028, 2403)},
	},
	graph = {
		maxshowndata = 4,
		numdatapoints = 21,
		factors = { 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000 },
		datarecordcolors = {
			[1] = { buy = Color["graph_data_1"], sell = Color["graph_data_2"] },
			[2] = { buy = Color["graph_data_3"], sell = Color["graph_data_4"] },
			[3] = { buy = Color["graph_data_5"], sell = Color["graph_data_6"] },
			[4] = { buy = Color["graph_data_7"], sell = Color["graph_data_8"] },
		},
		point = {
			type = "square",
			size = 8,
			highlightSize = 8,
		},
		line = {
			type = "normal",
			size = 2,
			highlightSize = 4,
		},
	},
	librarynames = {
		["moduletypes_production"]		= ReadText(1001, 2421),
		["moduletypes_build"]			= ReadText(1001, 2439),
		["moduletypes_storage"]			= ReadText(1001, 2422),
		["moduletypes_habitation"]		= ReadText(1001, 2451),
		["moduletypes_welfare"]			= ReadText(1001, 9620),
		["moduletypes_defence"]			= ReadText(1001, 2424),
		["moduletypes_dock"]			= ReadText(1001, 2452),
		["moduletypes_processing"]		= ReadText(1001, 9621),
		["moduletypes_other"]			= ReadText(1001, 2453),
		["moduletypes_venture"]			= ReadText(1001, 2454),
		["weapons_lasers"]				= ReadText(1001, 1301),	-- Weapons
		["weapons_missilelaunchers"]	= ReadText(1001, 9030),	-- Missile Launchers
		["weapons_turrets"]				= ReadText(1001, 1319),	-- Turrets
		["weapons_missileturrets"]		= ReadText(1001, 9031),	-- Missile Turrets
		["missiletypes"]				= ReadText(1001, 1304),	-- Missiles
		["mines"]						= ReadText(1001, 1326),	-- Mines
		["bombs"]						= ReadText(1001, 1330),	-- Bombs
		["enginetypes"]					= ReadText(1001, 1103),	-- Engines
		["thrustertypes"]				= ReadText(1001, 8001),	-- Thrusters
		["shieldgentypes"]				= ReadText(1001, 1317),	-- Shield generators
		["satellites"]					= ReadText(1001, 1327),	-- Satellites
		["navbeacons"]					= ReadText(1001, 1328),	-- Navigation Beacons
		["resourceprobes"]				= ReadText(1001, 1329),	-- Resource Probes
		["lasertowers"]					= ReadText(1001, 1333),	-- Laser Towers
		["software"]					= ReadText(1001,   87),	-- Software
		["paintmods"]					= ReadText(1001, 8510),	-- Paint Modifications
		["countermeasures"]				= ReadText(1001, 8063),	-- Countermeasures
	},
	equipmenttags = { "weapon", "turret", "shield", "engine", "thruster", "missile", "drone", "consumables", "countermeasure" },
	consumabletags = { "lasertower", "satellite", "mine", "navbeacon", "resourceprobe" },
	stateKeys = {
		{"mode"},
		{"library"},
		{"id"},
		{"object"},
		{ "searchtext" },
	},
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	--print("Initializing Encyclopedia")
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.topLevelOffsetY = nil

	UnregisterAddonBindings("ego_detailmonitor")

	HideAllShapes()

	menu.title = nil
	menu.mode = nil
	menu.data = {}
	menu.library = nil
	menu.id = nil
	menu.expanded = {}
	menu.details = {}
	menu.object = nil
	menu.selectedrow = nil
	menu.toprow = nil
	menu.activatecutscene = nil
	menu.sortedpurposelist = {}
	menu.printedshipdata = {}
	menu.printedshipsizes = {}

	-- start: alexandretk call-back
	if menu.uix_callbacks ["cleanup"] then		
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
	    end		
	end
	-- end: alexandretk call-back

	menu.rendertargetmode = nil
	menu.refresh = nil
	menu.delayrendertarget = nil
	menu.delayedrenderobject = {}
	menu.numDetailRows = nil
	menu.encyclopediaMode = "encyclopedia"
	menu.oldobject = nil
	menu.oldlibrary = nil
	menu.oldid = nil
	menu.searchtext = nil
	menu.noupdate = nil

	menu.table_toplevel = nil
	menu.table_sidebar = nil
	menu.table_index = nil
	menu.table_description = nil
	menu.table_detail = nil

	menu.cleanupRenderTarget()

	menu.frame = nil

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

-- Menu member functions

-- assemble initial data
function menu.onShowMenu(state)
	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	menu.noupdate = nil

	menu.transporttypes = {}
	local n = C.GetNumWareTransportTypes()
	local buf = ffi.new("WareTransportInfo[?]", n)
	n = C.GetWareTransportTypes(buf, n)
	for i = 0, n - 1 do
		menu.transporttypes[buf[i].value] = { transport = ffi.string(buf[i].transport), name = ffi.string(buf[i].name) }
	end

	menu.holomapcolor = Helper.getHoloMapColors()

	menu.data = {
					["Galaxy"] = {},
					["Races"] = { ["races"] = {} },
					["Factions"] = { ["factions"] = {} },
					["FixedStations"] = {},
					["Stations"] = {
						["moduletypes_production"] = {},
						["moduletypes_build"] = {},
						["moduletypes_storage"] = {},
						["moduletypes_habitation"] = {},
						["moduletypes_welfare"] = {},
						["moduletypes_defence"] = {},
						["moduletypes_dock"] = {},
						["moduletypes_processing"] = {},
						["moduletypes_other"] = { additionalcategories = { "moduletypes_radar" } },
						["moduletypes_venture"] = {},
					},
					["Ships"] = {
						["shiptypes_xl"] = {},
						["shiptypes_l"] = {},
						["shiptypes_m"] = {},
						["shiptypes_s"] = {},
						["shiptypes_xs"] = {}
					},
					["Weapons"] = {
						["weapons_lasers"] = {},
						["weapons_missilelaunchers"] = {},
						["weapons_turrets"] = {},
						["weapons_missileturrets"] = {},
						["missiletypes"] = {},
						["mines"] = {},
						["bombs"] = {}
					},
					["Equipment"] = {
						["enginetypes"] = {},
						["thrustertypes"] = {},
						["shieldgentypes"] = {},
						["satellites"] = {},
						["navbeacons"] = {},
						["resourceprobes"] = {},
						["lasertowers"] = {},
						["software"] = {},
						["paintmods"] = {}
					},
					["Licences"] = { ["licences"] = {} },
					["Wares"] = {
						["wares"] = {},
						["inventory_wares"] = {}
					},
					["Blueprints"] = {
						["modules"]		= {},
						["ships"]		= {},
						["equipment"]	= {},
					},
				}

	menu.sortedpurposelist = { "fight", "trade", "mine", "build", "misc" }

	-- start: alexandretk call-back
	if menu.uix_callbacks ["onShowMenu_override_menu_printed_variables"] then		
		local printedshipdata_override = {}
		local printedshipsizes_override = {}
		local printedmilxlcapshiptype_override = {}
		local printedmillcapshiptypes_override = {}
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_override_menu_printed_variables"]) do
			printedshipsizes_override,printedshipdata_override,printedmilxlcapshiptype_override,printedmillcapshiptypes_override = uix_callback()
			menu.printedshipdata = printedshipdata_override
			menu.printedshipsizes = printedshipsizes_override
			menu.printedmilitaryxlcapitalshiptypes =  printedmilxlcapshiptype_override
			menu.printedmilitarylcapitalshiptypes =  printedmillcapshiptypes_override
		end
		-- end: alexandretk call-back
	else

		menu.printedshipsizes = { "capital", "noncapital" }
		menu.printedshipdata = { 
								trade = {
									text = ReadText(1001, 9010),								-- "Trading Ships"
									capital = {text = ReadText(1001, 9022), ships = {}},			-- "Heavy Freighters"
									noncapital = {text = ReadText(1001, 9023), ships = {}}},		-- "Light Freighters"
								fight = {
									text = ReadText(1001, 9011),								-- "Combat Ships"
									capital = {text = ReadText(1001, 9024), ships = {}},			-- "Carriers and Destroyers"
									noncapital = {text = ReadText(1001, 9025), ships = {}}},		-- "Fighters and Support Ships"
								build = {
									text = ReadText(1001, 9012),								-- "Construction Ships"
									capital = {text = ReadText(1001, 9026), ships = {}},			-- "Heavy Construction Ships"
									noncapital = {text = ReadText(1001, 9027), ships = {}}},		-- "Light Construction Ships"
								mine = {
									text = ReadText(1001, 9013),								-- "Mining Ships"
									capital = {text = ReadText(1001, 9028), ships = {}},			-- "Heavy Mining Ships"
									noncapital = {text = ReadText(1001, 9029), ships = {}}},		-- "Light Mining Ships"
								misc = {
									text = ReadText(1001, 9014),								-- "Other Ships"
									capital = {text = ReadText(1001, 9020), ships = {}},			-- "Heavy"
									noncapital = {text = ReadText(1001, 9021), ships = {}}}			-- "Light"
							}
	end

	menu.index = {
		["Stations"] = {
			name = ReadText(1001, 9610),
			{ key = "moduletypes_production" },
			{ key = "moduletypes_build" },
			{ key = "moduletypes_storage" },
			{ key = "moduletypes_habitation" },
			{ key = "moduletypes_welfare" },
			{ key = "moduletypes_defence" },
			{ key = "moduletypes_dock" },
			{ key = "moduletypes_processing" },
			{ key = "moduletypes_other" },
			{ key = "moduletypes_venture" },
		},
		["Weapons"] = {
			name = ReadText(1001, 2417),
			{ key = "weapons_lasers" },
			{ key = "weapons_missilelaunchers" },
			{ key = "weapons_turrets" },
			{ key = "weapons_missileturrets" },
			{ key = "missiletypes" },
			{ key = "mines" },
			{ key = "bombs" },
		},
		["Equipment"] = {
			name = ReadText(1001, 7935),
			{ key = "enginetypes" },
			{ key = "thrustertypes" },
			{ key = "shieldgentypes" },
			{ key = "satellites" },
			{ key = "navbeacons" },
			{ key = "resourceprobes" },
			{ key = "lasertowers" },
			{ key = "software" },
			{ key = "paintmods" },
		},
		["Blueprints"] = {
			name = ReadText(1001, 98),
			[1] = { key = "modules",	name = ReadText(1001, 7924),	description = ReadText(1001, 9095), subcategories = {
				{ key = "moduletypes_production" },
				{ key = "moduletypes_build" },
				{ key = "moduletypes_storage" },
				{ key = "moduletypes_habitation" },
				{ key = "moduletypes_welfare" },
				{ key = "moduletypes_defence" },
				{ key = "moduletypes_dock" },
				{ key = "moduletypes_processing" },
				{ key = "moduletypes_other", additionalcategories = { "moduletypes_radar" } },
				{ key = "moduletypes_venture" },
			}},
			[2] = { key = "ships",		name = ReadText(1001, 6),		description = ReadText(1001, 9096), subcategories = {
				{ key = "ship_xl" },
				{ key = "ship_l" },
				{ key = "ship_m" },
				{ key = "ship_s" },
			}},
			[3] = { key = "equipment",	name = ReadText(1001, 7935),	description = ReadText(1001, 9097), subcategories = {
				{ key = "weapons_lasers" },
				{ key = "weapons_missilelaunchers" },
				{ key = "weapons_turrets" },
				{ key = "weapons_missileturrets" },
				{ key = "missiletypes" },
				{ key = "mines" },
				{ key = "bombs" },
				{ key = "enginetypes" },
				{ key = "thrustertypes" },
				{ key = "shieldgentypes" },
				{ key = "satellites" },
				{ key = "navbeacons" },
				{ key = "resourceprobes" },
				{ key = "lasertowers" },
				{ key = "countermeasures" },
				{ key = "software" },
				{ key = "paintmods" },
			}},
		},
	}

	-- Galaxy
	local clusters = GetClusters(true)
	local sectors = {}
	for _, cluster in ipairs(clusters) do
		local name, description, systemid = GetComponentData(cluster, "name", "description", "systemid")
		sectors = GetSectors(cluster)
		for i, sector in ipairs(sectors) do
			sectors[i] = { sector = sector, name = GetComponentData(sector, "name") }
		end
		--print("INIT cluster: " .. tostring(cluster))
		if systemid ~= 0 then
			local idx
			for i, entry in ipairs(menu.data["Galaxy"]) do
				if entry.systemid == systemid then
					idx = i
					break
				end
			end
			if idx then
				table.insert(menu.data["Galaxy"][idx].clusters, cluster)
				for _, sector in ipairs(sectors) do
					table.insert(menu.data["Galaxy"][idx].sectors, sector)
				end
			else
				table.insert(menu.data["Galaxy"], { name = name, description = description, systemid = systemid, clusters = { cluster }, sectors = sectors, systeminfo = menu.getSystemInfo(ConvertStringTo64Bit(tostring(cluster))) })
			end
		else
			table.insert(menu.data["Galaxy"], { name = name, description = description, systemid = systemid, clusters = { cluster }, sectors = sectors, systeminfo = menu.getSystemInfo(ConvertStringTo64Bit(tostring(cluster))) })
		end
		--print("numclusters: " .. #menu.data["Galaxy"] .. " cluster: " .. tostring(cluster) .. " numsectors: " .. #sectors)
		--print("registered " .. #menu.data["Galaxy"][cluster] .. " sectors in " .. GetComponentData(cluster, "name") .. ".")
	end
	table.sort(menu.data["Galaxy"], Helper.sortName)
	for _, entry in ipairs(menu.data["Galaxy"]) do
		table.sort(entry.sectors, Helper.sortName)
	end

	-- licences of known factions are known as well (see playerinfo menu)
	local factionlibrary = GetLibrary("factions")
	for i, faction in ipairs(factionlibrary) do
		if faction.id ~= "player" then
			local licences = GetOwnLicences(faction.id)
			for i, licence in ipairs(licences) do
				AddKnownItem("licences", licence.id)
			end
		end
	end

	-- Fixed stations
	local stationlibrary = GetLibrary("stationtypes")
	for _, stationentry in ipairs(stationlibrary) do
		if GetMacroData(stationentry.id, "isfixedstation") then
			table.insert(menu.data["FixedStations"], { macro = stationentry.id, name = stationentry.name })
		end
	end
	local n = C.GetNumFixedStations(0)
	if n > 0 then
		local buf = ffi.new("UniverseID[?]", n)
		n = C.GetFixedStations(buf, n, 0)
		for i = 0, n - 1 do
			if C.IsKnownToPlayer(buf[i]) then
				table.insert(menu.data["FixedStations"], { component = buf[i], name = ffi.string(C.GetComponentName(buf[i])) })
			end
		end
	end
	table.sort(menu.data["FixedStations"], Helper.sortName)
	for i = #menu.data["FixedStations"] - 1, 1, -1 do
		if menu.data["FixedStations"][i].name == menu.data["FixedStations"][i + 1].name then
			table.remove(menu.data["FixedStations"], i)
		end
	end

	local numblueprints = C.GetNumBlueprints("", "", "")
	local blueprints = ffi.new("UIBlueprint[?]", numblueprints)
	numblueprints = C.GetBlueprints(blueprints, numblueprints, "", "", "")
	local playerblueprints = {}
	for i = 0, numblueprints - 1 do
		local ware = ffi.string(blueprints[i].ware)
		playerblueprints[ware] = true
		--[[
		local isship, isequipment, ismodule, macro, name = GetWareData(ware, "isship", "isequipment", "ismodule", "component", "name")
		if macro ~= "" then
			local macroclass = ffi.string(C.GetMacroClass(macro))
			local librarytype = GetMacroData(macro, "infolibrary")
			if isship then
				if menu.data["Blueprints"]["ships"][macroclass] then
					table.insert(menu.data["Blueprints"]["ships"][macroclass], { ware = ware, name = name, owned = true, unlocked = true })
				else
					local sizename
					if macroclass == "ship_xl" then
						sizename = ReadText(1001, 11003)
					elseif macroclass == "ship_l" then
						sizename = ReadText(1001, 11002)
					elseif macroclass == "ship_m" then
						sizename = ReadText(1001, 11001)
					elseif macroclass == "ship_s" then
						sizename = ReadText(1001, 11000)
					end
					if sizename then
						menu.data["Blueprints"]["ships"][macroclass] = { name = sizename, { ware = ware, name = name, owned = true, unlocked = true } }
					end
				end
			elseif isequipment then
				if menu.data["Blueprints"]["equipment"][librarytype] then
					table.insert(menu.data["Blueprints"]["equipment"][librarytype], { ware = ware, name = name, owned = true, unlocked = true })
				else
					menu.data["Blueprints"]["equipment"][librarytype] = { name = config.librarynames[librarytype], { ware = ware, name = name, owned = true, unlocked = true } }
				end
			elseif ismodule then
				if menu.data["Blueprints"]["modules"][librarytype] then
					table.insert(menu.data["Blueprints"]["modules"][librarytype], { ware = ware, name = name, owned = true, unlocked = true })
				else
					menu.data["Blueprints"]["modules"][librarytype] = { name = config.librarynames[librarytype], { ware = ware, name = name, owned = true, unlocked = true } }
				end
			end
		end--]]
	end

	-- equipment
	for i, equipmenttag in ipairs(config.equipmenttags) do
		local concattag = equipmenttag
		if equipmenttag == "consumables" then
			concattag = ""
			for _, tag in ipairs(config.consumabletags) do
				concattag = concattag .. " " .. tag
			end
		end
		local numwares = C.GetNumWares(concattag, false, nil, "noplayerblueprint")
		local wares = ffi.new("const char*[?]", numwares)
		numwares = C.GetWares(wares, numwares, concattag, false, nil, "noplayerblueprint")
		for j = 0, numwares - 1 do
			local locware = ffi.string(wares[j])
			local macro, name, ismissiononly = GetWareData(locware, "component", "name", "ismissiononly")
			local hasinfoalias, librarytype
			if macro ~= "" then
				hasinfoalias, librarytype = GetMacroData(macro, "hasinfoalias", "infolibrary")
			end
			if equipmenttag == "countermeasure" then
				librarytype = "countermeasures"
			end
			if not hasinfoalias and librarytype then
				local owned = playerblueprints[locware]
				if menu.data["Blueprints"]["equipment"][librarytype] then
					table.insert(menu.data["Blueprints"]["equipment"][librarytype], { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) })
				else
					menu.data["Blueprints"]["equipment"][librarytype] = { name = config.librarynames[librarytype], { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) } }
				end
			end
		end
	end
	-- modules, ships
	local blueprinttags = { "module", "ship" }
	for _, tag in ipairs(blueprinttags) do
		local numwares = C.GetNumWares(tag, false, nil, "noplayerblueprint")
		local wares = ffi.new("const char*[?]", numwares)
		numwares = C.GetWares(wares, numwares, tag, false, nil, "noplayerblueprint")
		for i = 0, numwares-1 do
			local locware = ffi.string(wares[i])
			local hasblueprint, macro, name, ismissiononly = GetWareData(locware, "hasblueprint", "component", "name", "ismissiononly")
			local macroclass, librarytype, macroicon
			if macro ~= "" then
				macroclass = ffi.string(C.GetMacroClass(macro)) or ""
				librarytype, macroicon = GetMacroData(macro, "infolibrary", "icon")
			end
			if hasblueprint then
				local owned = playerblueprints[locware]
				if tag == "ship" then
					if macroicon then
						name = "\27[" .. macroicon .. "] " .. name
					end
					if menu.data["Blueprints"]["ships"][macroclass] then
						table.insert(menu.data["Blueprints"]["ships"][macroclass], { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) })
					else
						local sizename
						if macroclass == "ship_xl" then
							sizename = ReadText(1001, 11003)
						elseif macroclass == "ship_l" then
							sizename = ReadText(1001, 11002)
						elseif macroclass == "ship_m" then
							sizename = ReadText(1001, 11001)
						elseif macroclass == "ship_s" then
							sizename = ReadText(1001, 11000)
						end
						if sizename then
							menu.data["Blueprints"]["ships"][macroclass] = { name = sizename, { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) } }
						end
					end
				else
					if menu.data["Blueprints"]["modules"][librarytype] then
						table.insert(menu.data["Blueprints"]["modules"][librarytype], { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) })
					else
						menu.data["Blueprints"]["modules"][librarytype] = { name = config.librarynames[librarytype], { ware = locware, name = name, owned = owned, unlocked = IsKnownItem(librarytype, macro), hidden = ismissiononly and (not owned) } }
					end
				end
			end
		end
	end

	for _, entry in pairs(menu.data["Blueprints"]) do
		for _, data in pairs(entry) do
			table.sort(data, Helper.sortName)
		end
	end

	for category in pairs(menu.data) do
		if (category ~= "Factions") and (category ~= "Galaxy") and (category ~= "Blueprints") and (category ~= "FixedStations") then
			for subcategory, entry in pairs(menu.data[category]) do
				--print("category: " .. tostring(category) .. ", subcategory: " .. tostring(subcategory))
				menu.data[category][subcategory] = GetLibrary(subcategory)
				if entry.additionalcategories then
					for _, additionalcategory in ipairs(entry.additionalcategories) do
						local data = GetLibrary(additionalcategory)
						for _, v in ipairs(data) do
							table.insert(menu.data[category][subcategory], v)
						end
					end
				end
				table.sort(menu.data[category][subcategory], Helper.sortName)
			end
		end
	end

	-- Factions
	for i, faction in ipairs(factionlibrary) do
		if faction.id == "player" then
			C.ReadKnownItem("factions", faction.id, true)
		else
			local factionlicences = {}
			for _, licence in pairs(menu.data.Licences.licences) do
				if licence.parent == faction.id and type(licence) == "table" then
					table.insert(factionlicences, licence)
				end
			end
			factionlibrary[i].numlicences = #factionlicences
			factionlibrary[i].licences = factionlicences
			local allies = {}
			local enemies = {}
			local hostiles = {}
			for j, faction2 in ipairs(factionlibrary) do
				if faction.id ~= faction2.id then
					if C.IsFactionHostileToFaction(faction.id, faction2.id) then
						table.insert(hostiles, { id = faction2.id, name = GetFactionData(faction2.id, "name") })
						--print(tostring(faction.id) .. " enemies with " .. tostring(faction2.id))
					elseif C.IsFactionEnemyToFaction(faction.id, faction2.id) then
						table.insert(enemies, { id = faction2.id, name = GetFactionData(faction2.id, "name") })
						--print(tostring(faction.id) .. " enemies with " .. tostring(faction2.id))
					elseif C.IsFactionAllyToFaction(faction.id, faction2.id) then
						table.insert(allies, { id = faction2.id, name = GetFactionData(faction2.id, "name") })
						--print(tostring(faction.id) .. " allied with " .. tostring(faction2.id))
					end
				end
			end
			table.sort(hostiles, Helper.sortName)
			table.sort(enemies, Helper.sortName)
			table.sort(allies, Helper.sortName)
			factionlibrary[i].allies = allies
			factionlibrary[i].enemies = enemies
			factionlibrary[i].hostiles = hostiles
			local sectors = {}
			Helper.ffiVLA(sectors, "UniverseID", C.GetNumSectorsByOwner, C.GetSectorsByOwner, faction.id)
			for i = #sectors, 1, -1 do
				if not C.IsKnownToPlayer(ConvertStringTo64Bit(tostring(sectors[i]))) then
					table.remove(sectors, i)
				end
			end
			factionlibrary[i].numsectors = #sectors
			factionlibrary[i].sectors = sectors
			table.insert(menu.data.Factions.factions, factionlibrary[i])
		end
	end
	table.sort(menu.data.Factions.factions, function (a, b) return a.name < b.name end)
	--print("registered " .. #menu.data["Factions"] .. " factions.")

	local sortedsizelist = { "shiptypes_xl", "shiptypes_l", "shiptypes_m", "shiptypes_s", "shiptypes_xs" }
	for _, size in ipairs(sortedsizelist) do
		for _, shipdata in ipairs(menu.data.Ships[size]) do

			-- start: alexandretk call-back
			if menu.uix_callbacks ["onShowMenu_override_sizecategory"] then
				local purpose, shiptypename, shipicon = GetMacroData(shipdata.id, "primarypurpose", "shiptypename", "icon")
				local sizecategory = "noncapital"
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_override_sizecategory"]) do
					uix_callback(menu,shipdata,size,purpose,typecategory,sizecategory,shiptypename,shipicon)
				end
			else
			-- end: alexandretk call-back

				local purpose = GetMacroData(shipdata.id, "primarypurpose")
				local sizecategory = "noncapital"
				if size == "shiptypes_xl" or size == "shiptypes_l" then
					sizecategory = "capital"
				end
				if purpose == "auxiliary" then
					-- sic! We want auxiliary ships to show up in the "support" category under combat
					purpose = "fight"
					sizecategory = "noncapital"
				elseif not menu.printedshipdata[purpose] then
					purpose = "misc"
				end
				shipdata.librarycategory = size
				table.insert(menu.printedshipdata[purpose][sizecategory].ships, shipdata)
			end
		end

	end

	menu.title = ReadText(1001, 2400)	-- Encyclopedia
	menu.mode = menu.param[3]
	menu.library = menu.param[4]
	menu.id = menu.param[5]
	if menu.mode == "Galaxy" then
		menu.object = menu.param[6]
	end
	menu.expanded = {}
	menu.details = {}

	if state then
		menu.onRestoreState(state)
	end

	if menu.mode == "Galaxy" then
		menu.expanded["Galaxy"] = true
		for i, entry in ipairs(menu.data["Galaxy"]) do
			if type(menu.object) == "number" then
				if i == menu.object then
					menu.details = entry
					break
				end
			else
				for _, cluster in ipairs(entry.clusters) do
					if IsSameComponent(cluster, menu.object) then
						menu.object = i
						menu.details = entry
						break
					end
				end
				if next(menu.details) then
					break
				end
				for _, sector in ipairs(entry.sectors) do
					if IsSameComponent(sector.sector, menu.object) then
						menu.expanded[i] = true
						menu.details = entry
						break
					end
				end
				if next(menu.details) then
					break
				end
			end
		end
		--print("menu.object: " .. tostring(menu.object))
		if (type(menu.object) ~= "number") and IsComponentClass(menu.object, "sector") then
			local cluster = GetComponentData(menu.object, "clusterid")
			menu.expanded[cluster] = true
			--print("INPUT cluster: " .. tostring(cluster) .. ", expanded? " .. tostring(menu.expanded[cluster]))
		end
	elseif menu.mode == "Blueprints" then
		for object, entry in pairs(menu.index["Blueprints"]) do
			if entry.key == menu.library then
				menu.library = nil
				menu.object = object
				menu.details = menu.data["Blueprints"][entry.key]
				menu.expanded["Blueprints"] = true
				break
			end
		end
	elseif menu.library and menu.id then
		if menu.mode == nil then
			for mode, data in pairs(menu.data) do
				for library in pairs(data) do
					if library == menu.library then
						menu.mode = mode
						break
					end
				end
				if menu.mode then
					break
				end
			end
		end
		if menu.mode then
			menu.expanded[menu.mode] = true
			menu.object = GetLibraryEntry(menu.library, menu.id)
			menu.details.id = menu.param[5]
			if (menu.mode ~= "Factions") and (menu.mode ~= "Licences") and (menu.mode ~= "Races") then
				local locware = menu.id
				if (menu.library ~= "inventory_wares") and (menu.library ~= "wares") and (menu.library ~= "software") and (menu.library ~= "paintmods") then
					locware = GetMacroData(locware, "ware")
				end

				if locware then
					menu.initWareData(locware)
				end

				if (menu.mode == "Stations") and (menu.library ~= "stationtypes") then
					menu.details.turrettotal = 0
					menu.details.shieldtotal = 0

					local n = C.GetNumUpgradeGroups(0, menu.id)
					local buf = ffi.new("UpgradeGroup[?]", n)
					n = C.GetUpgradeGroups(buf, n, 0, menu.id)
					for i = 0, n - 1 do
						if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
							local group = { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }

							local groupinfo = C.GetUpgradeGroupInfo(0, menu.id, group.path, group.group, "turret")
							menu.details.turrettotal = menu.details.turrettotal + groupinfo.total

							groupinfo = C.GetUpgradeGroupInfo(0, menu.id, group.path, group.group, "shield")
							menu.details.shieldtotal = menu.details.shieldtotal + groupinfo.total
						end
					end
				end

				if menu.mode == "Ships" then
					local purpose = GetMacroData(menu.id, "primarypurpose")
					local sizecategory = "noncapital"
					if IsMacroClass(menu.id, "ship_xl") or IsMacroClass(menu.id, "ship_l") then
						sizecategory = "capital"
					end

					-- start: alexandretk call-backs
					if sizecategory == "capital" and menu.uix_callbacks ["onShowMenu_override_capitalsizecategory"] then
						local purpose, shiptypename, shipicon = GetMacroData(shipdata.id, "primarypurpose", "shiptypename", "icon")
						local sizecategory = "noncapital"
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_override_capitalsizecategory"]) do
							uix_callback(menu,size,purpose,typecategory,sizecategory,shiptypename,shipicon)
						end
					else
					-- end: alexandretk call-backs

						if purpose == "auxiliary" then
							-- sic! We want auxiliary ships to show up in the "support" category under combat
							purpose = "fight"
							sizecategory = "noncapital"
						elseif not menu.printedshipdata[purpose] then
							purpose = "misc"
						end
						menu.expanded[purpose] = true
						menu.expanded[purpose .. sizecategory] = true

					end
				else
					menu.expanded[menu.library] = true
				end
			elseif menu.mode == "Factions" then
				for _, entry in ipairs(menu.data["Factions"][menu.library]) do
					if entry.id == menu.id then
						menu.details = entry
					end
				end
			end
		else
			print("menu_encyclopedia.lua, menu.onShowMenu(): No matching mode for given encyclopedia entry found! Probably an unsupported infolibrary type. (" .. menu.library .. ", " .. menu.id .. ")")
			menu.library = nil
			menu.id = nil
			menu.object = nil
		end
	else
		menu.object = nil
	end
	menu.toprow = nil
	menu.delayrendertarget = true

	--print("registered " .. #menu.data["Stations"]["stationtypes"] .. " station types, " .. #menu.data["Stations"]["moduletypes_production"] .. " production modules, " .. #menu.data["Stations"]["moduletypes_build"] .. " build modules, " .. #menu.data["Stations"]["moduletypes_storage"] .. " storage modules, " .. #menu.data["Stations"]["moduletypes_habitation"] .. " habitation modules, " .. #menu.data["Stations"]["moduletypes_welfare"] .. " welfare modules, " .. #menu.data["Stations"]["moduletypes_defence"] .. " defence modules, " .. #menu.data["Stations"]["moduletypes_dock"] .. " dock modules, " .. #menu.data["Stations"]["moduletypes_processing"] .. " processing modules, and " .. #menu.data["Stations"]["moduletypes_other"] .. " miscellaneous modules.")
	--print("registered " .. #menu.data["Ships"]["shiptypes_xl"] .. " XL ship types, " .. #menu.data["Ships"]["shiptypes_l"] .. " L ship types, " .. #menu.data["Ships"]["shiptypes_m"] .. " M ship types, " .. #menu.data["Ships"]["shiptypes_s"] .. " S ship types, and " .. #menu.data["Ships"]["shiptypes_xs"] .. " XS ship types.")
	--print("registered " .. #menu.data["Weapons"]["weapons_lasers"] .. " primary weapons, " .. #menu.data["Weapons"]["weapons_turrets"] .. " turrets, " .. #menu.data["Weapons"]["weapons_missileturrets"] .. " missile turrets, and " .. #menu.data["Weapons"]["missiletypes"] .. " missiles.")
	--print("registered " .. #menu.data["Equipment"]["enginetypes"] .. " engines, " .. #menu.data.Equipment.thrustertypes .. " thrusters, " .. #menu.data["Equipment"]["shieldgentypes"] .. " shield generators, and " .. #menu.data["Equipment"]["software"] .. " software.")
	--print("registered " .. #menu.data["Wares"]["wares"] .. " economy wares and " .. #menu.data["Wares"]["inventory_wares"] .. " inventory wares.")

	--print("The player knows of " .. tostring(numclusters) .. " clusters, " .. tostring(numfactions) .. " factions, " .. tostring(numstations) .. " station types, " .. tostring(numships) .. " ship types, " .. tostring(numweapons) .. " weapon types, and " .. tostring(numwares) .. " ware types.")

	AddUITriggeredEvent(menu.name, menu.encyclopediaMode)

	local curtime = C.GetCurrentGameTime()
	menu.timeframe = "day"
	menu.xStart = math.max(0, curtime - 86400)
	menu.xEnd = curtime
	menu.xGranularity = 7200
	if menu.xEnd > menu.xStart then
		while (menu.xEnd - menu.xStart) < menu.xGranularity do
			menu.xGranularity = menu.xGranularity / 2
		end
	end
	menu.xScale = 3600
	menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 102) .. "]"
	menu.yTitle = ReadText(1001, 6521)
	menu.hiddenData = { buy = {}, sell = {} }

	menu.display()
end

function menu.getSystemInfo(cluster)
	local counts = C.GetNumUISystemInfo(cluster)
	local info = ffi.new("UISystemInfo2")
	info.space = Helper.ffiNewHelper("UISpaceInfo")
	info.numsuns = counts.numsuns
	info.suns = Helper.ffiNewHelper("UISunInfo[?]", info.numsuns)
	info.numplanets = counts.numplanets
	info.planets = Helper.ffiNewHelper("UICelestialBodyInfo2[?]", info.numplanets)

	local result = {}
	if C.GetUISystemInfo2(info, cluster) then
		local numterraformingprojects = false
		if GetComponentData(ConvertStringTo64Bit(tostring(cluster)), "hasterraforming") then
			numterraformingprojects = C.GetNumTerraformingProjects(cluster, false) > 0
		end

		result.space = { environment = ffi.string(info.space.environment) }
		result.suns = {}
		for i = 0, info.numsuns - 1 do
			table.insert(result.suns, { name = ffi.string(info.suns[i].name), class = ffi.string(info.suns[i].typeclass) })
		end
		result.planets = {}
		for i = 0, info.numplanets - 1 do
			local moons = {}
			if info.planets[i].nummoons > 0 then
				local buf = ffi.new("UICelestialBodyInfo2[?]", info.planets[i].nummoons)
				info.planets[i].nummoons = C.GetMoonInfo2(buf, info.planets[i].nummoons, cluster, i + 1)
				for j = 0, info.planets[i].nummoons - 1 do
					table.insert(moons, { name = ffi.string(buf[j].name), class = ffi.string(buf[j].typeclass), geology = ffi.string(buf[j].geology), atmosphere = ffi.string(buf[j].atmosphere), population = ffi.string(buf[j].population), settlements = ffi.string(buf[j].settlements), hasterraforming = numterraformingprojects and buf[j].hasterraforming })
				end
			end
			table.insert(result.planets, { name = ffi.string(info.planets[i].name), class = ffi.string(info.planets[i].typeclass), geology = ffi.string(info.planets[i].geology), atmosphere = ffi.string(info.planets[i].atmosphere), population = ffi.string(info.planets[i].population), settlements = ffi.string(info.planets[i].settlements), moons = moons, hasterraforming = numterraformingprojects and info.planets[i].hasterraforming })
		end
	end
	return result
end

function menu.onSaveState()
	local state = {}

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
	end

	return state
end

function menu.onRestoreState(state)
	for _, key in ipairs(config.stateKeys) do
		if key[2] == "UniverseID" then
			menu[key[1]] = ConvertIDTo64Bit(state[key[1]])
		else
			menu[key[1]] = state[key[1]]
		end
	end
end

function menu.addIndexEntry(array, item, name, rowdata, indent, numentries, expanded)
	local numunread = 0
	local isunread = false

	if numentries then
		if (rowdata == "Galaxy") or (rowdata[1] == "Galaxy") then
			if type(rowdata) == "table" then
				if rowdata[2] == "system" then
					for _, cluster in ipairs(rowdata[#rowdata].clusters) do
						isunread = isunread or (not C.IsKnownRead(ConvertIDTo64Bit(cluster)))
						numunread = numunread + C.GetNumContainedKnownUnreadSpaces(ConvertIDTo64Bit(cluster))
					end
				else
					numunread = C.GetNumContainedKnownUnreadSpaces(ConvertIDTo64Bit(rowdata[3]))
				end
			else
				for i, entry in pairs(menu.data["Galaxy"]) do
					for _, cluster in ipairs(entry.clusters) do
						if not C.IsKnownRead(ConvertIDTo64Bit(cluster)) and C.GetNumContainedKnownSpaces(ConvertIDTo64Bit(cluster)) > 1 then
							numunread = numunread + 1
						end
						numunread = numunread + C.GetNumContainedKnownUnreadSpaces(ConvertIDTo64Bit(cluster))
					end
				end
			end
		elseif (type(rowdata) == "table") and (rowdata[1] == "Ships") then
			if type(rowdata[2]) == "table" and not menu.printedshipdata[rowdata[2]] then

				-- start: alexandretk call-back
				if menu.uix_callbacks ["onShowMenu_addingTypeIndexEntries"] then
					local addthis
					for uix_id, uix_callback in pairs (menu.uix_callbacks["onShowMenu_addingTypeIndexEntries"]) do
						addthis = uix_callback(menu,rowdata, numunread,C)
						numunread = numunread + addthis
					end
				else
				-- end: alexandretk call-back

					for sizeclass, sizeclassdata in pairs(menu.printedshipdata[rowdata[2][1]]) do
						if sizeclass == rowdata[2][2] then
							for _, shipentry in ipairs(sizeclassdata.ships) do
								if not C.IsKnownItemRead(shipentry.librarycategory, shipentry.id) then
									numunread = numunread + 1
								end
							end
							break
						end
					end

				end
			else

				-- start: alexandretk call-back
				if menu.uix_callbacks ["onShowMenu_addingIndexEntries"] then
					local addthis
					for uix_id, uix_callback in pairs (menu.uix_callbacks["onShowMenu_addingIndexEntries"]) do
						addthis = uix_callback(menu, numunread,rowdata,C)
						numunread = numunread + addthis
					end
				else
				-- end: alexandretk call-back

					for sizeclass, sizeclassdata in pairs(menu.printedshipdata[rowdata[2]]) do
						if sizeclass ~= "text" then
							for _, shipentry in ipairs(sizeclassdata.ships) do
								if not C.IsKnownItemRead(shipentry.librarycategory, shipentry.id) then
									numunread = numunread + 1
								end
							end
						end
					end

				end

			end
		elseif rowdata == "Factions" then
			_, numunread = menu.getNumEntries(rowdata)
		elseif rowdata[1] == "Factions" then
			if not C.IsKnownItemRead(rowdata[2], rowdata[3].id) then
				isunread = true
			end
			for _, licence in ipairs(rowdata[3].licences) do
				if not C.IsKnownItemRead("licences", licence.id) then
					numunread = numunread + 1
				end
			end
		elseif (rowdata == "Blueprints") or (rowdata[1] == "Blueprints") then
			
		elseif rowdata == "FixedStations" then
			for _, entry in ipairs(menu.data["FixedStations"]) do
				if entry.macro then
					if not C.IsKnownItemRead("stationtypes", entry.macro) then
						numunread = numunread + 1
					end
				else
					if not C.IsKnownRead(entry.component) then
						numunread = numunread + 1
					end
				end
			end
		else
			if type(rowdata) == "table" then
				numunread = C.GetNumUnreadLibraryEntries(rowdata[2])
			else
				_, numunread = menu.getNumEntries(rowdata)
			end
		end
	elseif item then
		if rowdata == "Galaxy" or rowdata[1] == "Galaxy" then
			isunread = not C.IsKnownRead(ConvertIDTo64Bit(item))
		elseif rowdata[1] == "FixedStations" then
			if rowdata[3].macro then
				isunread = not C.IsKnownItemRead("stationtypes", rowdata[3].macro)
			else
				isunread = not C.IsKnownRead(rowdata[3].component)
			end
		else
			isunread = not C.IsKnownItemRead(rowdata[2], item)
		end
	end

	table.insert(array, { item = item, name = name, rowdata = rowdata, indent = indent, numentries = numentries, numunread = numunread, isunread = isunread, expanded = expanded })
	return array[#array]
end

function menu.createIndex()
	local index = {}
	local numentries = 0

	-- Galaxy
	for i, entry in pairs(menu.data["Galaxy"]) do
		numentries = numentries + #entry.sectors + ((#entry.sectors > 1) and 1 or 0)
	end
	local gal_index = menu.addIndexEntry(index, nil, ReadText(20002, 1), "Galaxy", 0, numentries, menu.expanded["Galaxy"])
	for i, entry in ipairs(menu.data["Galaxy"]) do
		local numsectors = #entry.sectors
		if numsectors > 1 then
			local system_index = menu.addIndexEntry(gal_index, nil, entry.name, { "Galaxy", "system", i, entry }, 1, numsectors, menu.expanded[i])
			for _, sector in ipairs(entry.sectors) do
				menu.addIndexEntry(system_index, sector.sector, sector.name, { "Galaxy", "space", sector.sector, entry }, 2)
			end
		else
			menu.addIndexEntry(gal_index, entry.sectors[1].sector, entry.sectors[1].name, { "Galaxy", "space", entry.sectors[1].sector, entry }, 1)
		end
	end

	-- Races
	numentries = menu.getNumEntries("Races")
	local race_index = menu.addIndexEntry(index, nil, ReadText(1001, 99), "Races", 0, numentries, menu.expanded["Races"])
	for subcategory, _ in pairs(menu.data["Races"]) do
		for _, race in ipairs(menu.data["Races"][subcategory]) do
			menu.addIndexEntry(race_index, race.id, race.name, { "Races", subcategory, race }, 1)
		end
	end

	-- Factions
	numentries = menu.getNumEntries("Factions")
	local fac_index = menu.addIndexEntry(index, nil, ReadText(1001, 44), "Factions", 0, numentries, menu.expanded["Factions"])
	for subcategory, _ in pairs(menu.data["Factions"]) do
		for _, faction in ipairs(menu.data["Factions"][subcategory]) do
			local lic_index = menu.addIndexEntry(fac_index, nil, faction.name, { "Factions", subcategory, faction }, 1, faction.numlicences, menu.expanded[faction.id])
			-- Licences
			for _, licence in ipairs(faction.licences) do
				menu.addIndexEntry(lic_index, licence.id, licence.name, { "Licences", "licences", licence, faction.id }, 2)
			end
		end
	end

	-- FixedStations
	numentries = #menu.data["FixedStations"]
	local sta_index = menu.addIndexEntry(index, nil, ReadText(1001, 4), "FixedStations", 0, numentries, menu.expanded["FixedStations"])
	for _, entry in ipairs(menu.data["FixedStations"]) do
		menu.addIndexEntry(sta_index, entry.macro or entry.component, entry.name, { "FixedStations", entry.macro and "stationtypes" or "stationcomponent", entry }, 1)
	end

	-- Stations
	numentries = menu.getNumEntries("Stations")
	local sta_index = menu.addIndexEntry(index, nil, menu.index["Stations"].name, "Stations", 0, numentries, menu.expanded["Stations"])
	for _, entry in ipairs(menu.index["Stations"]) do
		local stationcategory = entry.key
		if stationcategory then
			numentries = #menu.data["Stations"][stationcategory]
			local mod_index = menu.addIndexEntry(sta_index, nil, config.librarynames[stationcategory], { "Stations", stationcategory }, 1, numentries, menu.expanded[stationcategory])
			for _, entry in ipairs(menu.data["Stations"][stationcategory]) do
				menu.addIndexEntry(mod_index, entry.id, entry.name, { "Stations", stationcategory, entry }, 2)
			end
		end
	end

	-- Ships
	numentries = menu.getNumEntries("Ships")
	local ship_index = menu.addIndexEntry(index, nil, ReadText(1001, 6), "Ships", 0, numentries, menu.expanded["Ships"])
	for _, purpose in ipairs(menu.sortedpurposelist) do
		numentries = 0

		-- start: alexandretk call-back
		if menu.uix_callbacks ["onShowMenu_addingIndexNumEntries"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_addingIndexNumEntries"]) do
				uix_callback(C,ship_index,purpose, menu)
			end
		else
		-- end: alexandretk call-back

			for _, sizeclass in ipairs(menu.printedshipsizes) do
				numentries = numentries + #menu.printedshipdata[purpose][sizeclass].ships
			end
			if numentries > 0 then
				local ship_purpose_index = menu.addIndexEntry(ship_index, nil, menu.printedshipdata[purpose].text, { "Ships", purpose }, 1, numentries, menu.expanded[purpose])
				for _, sizeclass in ipairs(menu.printedshipsizes) do
					numentries = #menu.printedshipdata[purpose][sizeclass].ships
					if numentries > 0 then
						local ship_size_index = menu.addIndexEntry(ship_purpose_index, nil, menu.printedshipdata[purpose][sizeclass].text, { "Ships", { purpose, sizeclass } }, 2, numentries, menu.expanded[purpose .. sizeclass])
						for _, entry in ipairs(menu.printedshipdata[purpose][sizeclass].ships) do
							-- rowdata[2] here has to be the librarycategory for looking up information about that entry, tying into other tables.
							local icon = GetMacroData(entry.id, "icon")
							menu.addIndexEntry(ship_size_index, entry.id, "\27[" .. (C.IsIconValid(icon) and icon or "solid") .. "]" .. entry.name, { "Ships", entry.librarycategory, entry }, 3)
						end
					end
				end
			end

		end
	end

	-- Weapons
	numentries = menu.getNumEntries("Weapons")
	local wea_index = menu.addIndexEntry(index, nil, menu.index["Weapons"].name, "Weapons", 0, numentries, menu.expanded["Weapons"])
	for _, entry in ipairs(menu.index["Weapons"]) do
		local weaponcategory = entry.key
		numentries = #menu.data["Weapons"][weaponcategory]
		local wea_cat_index = menu.addIndexEntry(wea_index, nil, config.librarynames[weaponcategory], { "Weapons", weaponcategory }, 1, numentries, menu.expanded[weaponcategory])
		for _, entry in ipairs(menu.data["Weapons"][weaponcategory]) do
			menu.addIndexEntry(wea_cat_index, entry.id, entry.name, { "Weapons", weaponcategory, entry }, 2)
		end
	end

	-- Equipment
	numentries = menu.getNumEntries("Equipment")
	local equ_index = menu.addIndexEntry(index, nil, menu.index["Equipment"].name, "Equipment", 0, numentries, menu.expanded["Equipment"])
	for _, entry in ipairs(menu.index["Equipment"]) do
		local equipmentcategory = entry.key
		numentries = #menu.data["Equipment"][equipmentcategory]
		local equ_cat_index = menu.addIndexEntry(equ_index, nil, config.librarynames[equipmentcategory], { "Equipment", equipmentcategory }, 1, numentries, menu.expanded[equipmentcategory])
		for _, entry in ipairs(menu.data["Equipment"][equipmentcategory]) do
			menu.addIndexEntry(equ_cat_index, entry.id, entry.name, { "Equipment", equipmentcategory, entry }, 2)
		end
	end

	-- Wares
	numentries = menu.getNumEntries("Wares")
	local ware_index = menu.addIndexEntry(index, nil, ReadText(1001, 46), "Wares", 0, numentries, menu.expanded["Wares"])
	for i = 1, 2 do
		local warecategory = nil
		local loctext = nil
		if i == 1 then
			warecategory = "wares"
			loctext = ReadText(1001, 46)
		elseif i == 2 then
			warecategory = "inventory_wares"
			loctext = ReadText(1001, 2434)
		end
		numentries = #menu.data["Wares"][warecategory]
		local ware_cat_index = menu.addIndexEntry(ware_index, nil, loctext, { "Wares", warecategory }, 1, numentries, menu.expanded[warecategory])
		for _, entry in ipairs(menu.data["Wares"][warecategory]) do
			menu.addIndexEntry(ware_cat_index, entry.id, entry.name, { "Wares", warecategory, entry }, 2)
		end
	end

	-- Blueprints
	local bp_index = menu.addIndexEntry(index, nil, menu.index["Blueprints"].name, "Blueprints", 0, 3, menu.expanded["Blueprints"])
	for i, entry in ipairs(menu.index["Blueprints"]) do
		local numentries = 0
		for _, data in pairs(menu.data["Blueprints"][entry.key]) do
			numentries = numentries + #data
		end
		menu.addIndexEntry(bp_index, i, entry.name, { "Blueprints", i, menu.data["Blueprints"][entry.key] }, 1, numentries)
	end

	return index
end

function menu.filterIndexCategory(text, entry, first)
	if text == nil then
		return true
	end

	text = utf8.lower(text)
	local show = false
	local count, unreadcount = 0, 0

	if string.find(utf8.lower(entry.name), text, 1, true) then
		show = true
		if not first then
			count = count + 1
			if entry.isunread then
				unreadcount = unreadcount + 1
			end
		end
	end

	for _, entry2 in ipairs(entry) do
		local locshow, loccount, locunreadcount = menu.filterIndexCategory(text, entry2)
		show = show or locshow
		count = count + loccount
		unreadcount = unreadcount + locunreadcount
	end

	return show, count, unreadcount
end

function menu.displayIndexRow(inputtable, entry)
	local show, searchcount, searchunread = menu.filterIndexCategory(menu.searchtext, entry, true)
	if show then
		local locrow = inputtable:addRow(entry.rowdata, {  })
	
		local arrow
		if (type(entry.rowdata) == "table") and (#entry.rowdata >= 3) then
			arrow = "widget_arrow_right_01"
		end
		local coloffset = math.min(2, entry.indent)
		if entry.numentries then
			local numentries = searchcount or entry.numentries
			local numentriestext = " (" .. numentries .. (numentries == 1 and " " .. ReadText(1001, 2401) .. ")" or " " .. ReadText(1001, 2402) .. ")")
			if menu.searchtext then
				numentriestext = (numentries > 0) and string.format(ReadText(1001, 9619), numentries) or ""
			end
			local numunread = searchunread or entry.numunread
			local numunreadtext = ((numunread ~= 0) and (" " .. ColorText["text_positive"] .. "(" .. numunread .. " " .. ReadText(1001, 9001) .. ")") or "")
			locrow[5]:createText(numentriestext .. numunreadtext, { halign = "right" })
			locrow[2 + coloffset]:setColSpan(3 - coloffset):setBackgroundColSpan(4 - coloffset)

			local expandentry = entry.rowdata
			if type(entry.rowdata) == "table" then
				if entry.rowdata[1] == "Galaxy" then
					expandentry = entry.rowdata[3]
				elseif entry.rowdata[1] == "Factions" then
					expandentry = entry.rowdata[#entry.rowdata].id
				elseif entry.rowdata[1] == "Blueprints" then
					numentries = 0
				else
					expandentry = entry.rowdata[#entry.rowdata]
					if type(expandentry) == "table" then
						expandentry = ""
						for _, val in ipairs(entry.rowdata[#entry.rowdata]) do
							expandentry = (expandentry .. val)
						end
					end
				end
			end
			if numentries > 0 then
				locrow[1 + coloffset]:createButton({ height = Helper.standardTextHeight }):setText(entry.expanded and "-" or "+", { halign = "center" })
				locrow[1 + coloffset].handlers.onClick = function() return menu.buttonExpand(expandentry, locrow.index) end
			end
		elseif entry.item then
			if entry.isunread then
				locrow[5]:createText(ColorText["text_positive"] .. "(" .. ReadText(1001, 9001) .. ")", { halign = "right" })
				locrow[2 + coloffset]:setColSpan(3 - coloffset):setBackgroundColSpan(4 - coloffset)
			else
				locrow[2 + coloffset]:setColSpan(4 - coloffset)
			end
		else
			locrow[2 + coloffset]:setColSpan(4 - coloffset)
		end
		local offsetx = Helper.standardTextOffsetx
		if entry.indent > 2 then
			offsetx = offsetx + (entry.indent - 2) * Helper.standardTextHeight
		end
		locrow[2 + coloffset]:createText(entry.name, { x = offsetx })
		if arrow then
			locrow[6]:createIcon(arrow, { height = Helper.standardTextHeight })
		end
	 
		if not menu.selectedrow and type(entry.rowdata) == "table" then
			if ((menu.mode ~= "Galaxy") and menu.id and (menu.id == entry.rowdata[#entry.rowdata].id)) or (menu.object and (menu.object == entry.rowdata[3])) then
				menu.selectedrow = locrow.index
				menu.toprow = GetTopRow(menu.table_index)
			elseif (menu.mode ~= "Galaxy") and menu.id and entry.rowdata[#entry.rowdata].id then
				-- check all aliases due to collision / no-collision compatibilities
				local n = C.GetNumLibraryEntryAliases(entry.rowdata[2], entry.rowdata[#entry.rowdata].id)
				local buf = ffi.new("const char*[?]", n)
				n = C.GetLibraryEntryAliases(buf, n, entry.rowdata[2], entry.rowdata[#entry.rowdata].id)
				for j = 0, n - 1 do
					local aliasid = ffi.string(buf[j])
					if menu.id == aliasid then
						menu.selectedrow = locrow.index
						menu.toprow = GetTopRow(menu.table_index)
						break
					end
				end
			elseif (menu.mode == "Galaxy") and IsSameComponent(menu.object, entry.rowdata[3]) then
				menu.selectedrow = locrow.index
				menu.toprow = GetTopRow(menu.table_index)
			end
		end

		if entry.expanded then
			for _, entry2 in ipairs(entry) do
				menu.displayIndexRow(inputtable, entry2)
			end
		end
	end
end

-- assemble the menu
function menu.display()
	-- kuertee start: callback
	if menu.uix_callbacks ["display_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_start"]) do
			uix_callback (menu.infoFrame, tableProperties)
		end
	end
	-- kuertee end: callback

	--print("Displaying Menu")
	menu.displayRunning = true

	-- remove old data
	Helper.clearDataForRefresh(menu)
	HideAllShapes()

	-- Organize Visual Menu
	local framewidth = Helper.viewWidth
	local frameheight = Helper.viewHeight
	local xoffset = 0
	local yoffset = 0

	menu.frame = Helper.createFrameHandle(menu, { height = frameheight, width = framewidth, x = xoffset, y = yoffset, standardButtons = { back = true, close = true, help = true  } })
	menu.frame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.sidebarWidth = Helper.scaleX(Helper.sidebarWidth)

	menu.createTopLevel(menu.frame)

	-- sideBar
	menu.createSideBar(menu.frame)

	if menu.encyclopediaMode == "encyclopedia" then
		local table_index, table_detail, table_description, row
		local tablewidth = (framewidth - 2 * Helper.frameBorder - menu.sidebarWidth - Helper.borderSize) / 7
		local topborder = menu.topLevelOffsetY + Helper.borderSize
		--print("framewidth: " .. framewidth .. ", tablewidth: " .. tablewidth)

		-- set up a new table
		table_index = menu.frame:addTable( 6, { width = tablewidth * 2 - Helper.borderSize, height = frameheight - topborder, x = Helper.frameBorder + menu.sidebarWidth + Helper.borderSize, y = yoffset + topborder, tabOrder = 1, maxVisibleHeight = frameheight - yoffset - topborder } )
		if menu.setdefaulttable then
			table_index.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		table_index:setColWidth(1, Helper.standardTextHeight)
		table_index:setColWidth(2, Helper.standardTextHeight)
		table_index:setColWidth(3, Helper.standardTextHeight)
		table_index:setColWidthPercent(5, 33)
		table_index:setColWidth(6, Helper.standardTextHeight)

		row = table_index:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(6):createText(ReadText(1001, 9000), Helper.headerRow1Properties)	-- "Encyclopedia Index"

		local row = table_index:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(5):createEditBox({ height = Helper.standardTextHeight }):setText(menu.searchtext or "", {  }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxActivated = function () menu.noupdate = true end
		row[1].handlers.onEditBoxDeactivated = menu.editboxSearchUpdateText
		row[6]:createButton({ scaling = false, height = row[1]:getHeight() }):setText("X", { scaling = true, halign = "center", font = Helper.standardFontBold })
		row[6].handlers.onClick = function () return menu.buttonClearEditbox(row.index) end

		table_index:addEmptyRow(Helper.standardTextHeight / 2)

		local index = menu.createIndex()
		for _, entry in ipairs(index) do
			if entry.numentries > 0 then
				menu.displayIndexRow(table_index, entry)
			end
		end

		local descriptiontablewidth = 2 * tablewidth - Helper.borderSize
		table_description = menu.frame:addTable( 1, { tabOrder = 5, width = descriptiontablewidth, x = framewidth - descriptiontablewidth - Helper.frameBorder, highlightMode = "off" } )
		
		local rendertargetproperties = { width = table_description.properties.width, height = table_description.properties.width, x = table_description.properties.x, y = topborder }
		if table_description.properties.width > (0.8 * Helper.viewHeight - topborder) then
			-- secure some space for the description table
			rendertargetproperties.width = 0.8 * Helper.viewHeight - topborder
			rendertargetproperties.height = 0.8 * Helper.viewHeight - topborder
			if (menu.mode == "Galaxy") and menu.object then
				-- re-check for 16:10 format
				if rendertargetproperties.height * 1.6 > table_description.properties.width then
					rendertargetproperties.width = table_description.properties.width
				else
					rendertargetproperties.width = rendertargetproperties.height * 1.6
				end
			end
		end

		if (menu.mode == "Galaxy") and menu.object then
			rendertargetproperties.height = rendertargetproperties.width * 10 / 16
		end
		-- position in the center of the right side
		rendertargetproperties.x = table_description.properties.x + (table_description.properties.width - rendertargetproperties.width) / 2

		table_description.properties.y = rendertargetproperties.y + rendertargetproperties.height

		row = table_description:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:createText(ReadText(1001, 2404), Helper.headerRow1Properties)
		table_description.properties.maxVisibleHeight = Helper.viewHeight - Helper.frameBorder - table_description.properties.y

		local numdescrows = math.floor((table_description.properties.maxVisibleHeight - row:getHeight()) / (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize))
		local descriptiontext = menu.getDescriptionText()
		local description = GetTextLines(descriptiontext, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptiontablewidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
		if #description > numdescrows then
			-- scrollbar case
			description = GetTextLines(descriptiontext, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptiontablewidth - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
		end
		for linenum, descline in ipairs(description) do
			local row = table_description:addRow(true, {  })
			row[1]:createText(descline)
		end

		table_detail = menu.frame:addTable( 4, { maxVisibleHeight = frameheight - topborder, y = yoffset + topborder, tabOrder = 2 } )
		table_detail.properties.x = table_index.properties.x + table_index.properties.width + Helper.borderSize * 2.5
		table_detail.properties.width = tablewidth * 3 - Helper.borderSize * 2.5

		if (menu.mode == "Galaxy") and menu.object and (type(menu.object) ~= "number") then
			table_detail.properties.maxVisibleHeight = frameheight / 2 - topborder - Helper.borderSize / 2
		end
		table_detail:setColWidth(1, Helper.headerRow1Height)
		table_detail:setColWidthMin(2, 0, 60)
		table_detail:setColWidthMin(3, 0, 20)
		table_detail:setColWidthMin(4, 0, 20)

		row = table_detail:addRow(false, {  })
		row[1]:createIcon(function () return menu.detailIcon(false) end, { width = Helper.headerRow1Height, height = Helper.headerRow1Height, color = function () return menu.detailIconColor(false) end })
		row[2]:setColSpan(3):createText(menu.detailText, Helper.headerRow1Properties)

		menu.numDetailRows = 0
		menu.addDetailRows(table_detail)

		-- graph
		if (menu.mode == "Galaxy") and menu.object and (type(menu.object) ~= "number") then
			menu.createGraph(tablewidth * 3 - Helper.borderSize * 2.5, math.floor((frameheight - topborder) / 2 - Helper.borderSize / 2), table_index.properties.x + table_index.properties.width + Helper.borderSize * 2.5, frameheight / 2 + Helper.borderSize / 2)
		end

		local gapcenter = Helper.borderSize * 1.25
		Helper.drawLine( {x = table_detail.properties.x - gapcenter, y = topborder}, {x = table_detail.properties.x - gapcenter, y = frameheight}, nil, nil, Color["row_separator_encyclopedia"], true )
		Helper.drawLine( {x = table_description.properties.x - gapcenter, y = topborder}, {x = table_description.properties.x - gapcenter, y = frameheight}, nil, nil, Color["row_separator_encyclopedia"], true )

		local createrendertarget = true
		if menu.rendertargetmode then
			if menu.rendertargetmode == "icon" then
				local factor = 0.7
				if (menu.mode == "Galaxy") and menu.object then
					factor = 1
				end

				local table_rendertarget = menu.frame:addTable(1, rendertargetproperties)
				row = table_rendertarget:addRow(false, {  })
				row[1]:createIcon(function () return menu.detailIcon(true) end, { width = table_rendertarget.properties.width * factor, height = table_rendertarget.properties.height * factor, x = (table_rendertarget.properties.width * (1 - factor)) / 2, y = table_rendertarget.properties.height * (1 - factor) / 4, scaling = false, color = function () return menu.detailIconColor(true) end })
				createrendertarget = false
			end
		else
			menu.activatecutscene = true
		end

		if createrendertarget then
			rendertargetproperties.alpha = 90
			menu.rendertarget = menu.frame:addRenderTarget(rendertargetproperties)
		end

		if menu.selectedrow then
			table_index:setSelectedRow(menu.selectedrow)
			if menu.toprow then
				table_index:setTopRow(menu.toprow)
				menu.toprow = nil
			end
		end

		local table_button = menu.frame:addTable(2, { width = tablewidth * 2 - Helper.borderSize, x = Helper.frameBorder + menu.sidebarWidth + Helper.borderSize, y = yoffset + topborder, tabOrder = 1 } )

		local row = table_button:addRow(nil, { fixed = true })
		row[1]:setColSpan(2):createText("")
		local row = table_button:addRow(true, { fixed = true })
		row[2]:createButton({ active = menu.hasUnreadEntries }):setText(ReadText(1001, 7744), { halign = "center" })
		row[2].handlers.onClick = menu.buttonReadAll

		local maxVisibleHeight = table_index.properties.maxVisibleHeight - table_button:getFullHeight() - Helper.frameBorder
		table_button.properties.y = table_button.properties.y + math.min(maxVisibleHeight, table_index:getFullHeight())
		table_index.properties.maxVisibleHeight = table_button.properties.y - table_index.properties.y
	end

	-- display view/frame
	menu.frame:display()
end

function menu.hasUnreadEntries()
	for i, entry in pairs(menu.data["Galaxy"]) do
		for _, cluster in ipairs(entry.clusters) do
			if not C.IsKnownRead(ConvertIDTo64Bit(cluster)) and C.GetNumContainedKnownSpaces(ConvertIDTo64Bit(cluster)) > 1 then
				return true
			end
			if C.GetNumContainedKnownUnreadSpaces(ConvertIDTo64Bit(cluster)) > 0 then
				return true
			end
		end
	end

	if C.GetNumUnreadLibraryEntries("stationtypes") > 0 then
		return true
	end
	for i, entry in pairs(menu.data["FixedStations"]) do
		if entry.component then
			if not C.IsKnownRead(entry.component) then
				return true
			end
		end
	end

	for category, entry in pairs(menu.data) do
		if (category ~= "Galaxy") and (category ~= "FixedStations") then
			for subcategory in pairs(entry) do
				if C.GetNumUnreadLibraryEntries(subcategory) > 0 then
					return true
				end
			end
		end
	end
	return false
end

-- Suppress icons for licences for now, they are used for the ship config menu and if they should have any, we need to change the setup there first
function menu.detailIcon(isrendertargeticon)
	local icon = "solid"
	if (menu.mode == "Galaxy") and menu.object then
		local object = menu.object
		if type(menu.object) == "number" then
			object = menu.data["Galaxy"][menu.object].clusters[1]
		end
		local image, ownericon = GetComponentData(object, "image", "ownericon")
		if isrendertargeticon then
			icon = image
			if not C.IsIconValid(icon) then
				icon = ownericon or "solid"
			end
		else
			icon = ownericon or "solid"
		end
	elseif menu.library then
		if (menu.library ~= "licences") and (menu.object.icon ~= "") then
			icon = menu.object.icon
		elseif isrendertargeticon then
			if menu.library == "licences" then
				icon = "ency_license_01"
			elseif (menu.library == "weapons_lasers") or (menu.library == "weapons_missilelaunchers") then
				icon = "ency_weapon_01"
			else
				icon = "ency_unknown_01"
			end
		end
	end
	return (icon and (icon ~= "")) and icon or "solid"
end

-- Suppress icons for licences for now, they are used for the ship config menu and if they should have any, we need to change the setup there first
function menu.detailIconColor(isrendertargeticon)
	local color = Color["icon_inactive"]
	if (menu.mode == "Galaxy") and menu.object then
		if isrendertargeticon then
			color = Color["icon_normal"]
		end
	elseif menu.library then
		if (menu.library ~= "licences") and (menu.object.icon ~= "") then
			color = Color["icon_normal"]
		elseif isrendertargeticon then
			if menu.library == "licences" then
				color = Color["icon_normal"]
			elseif (menu.library == "weapons_lasers") or (menu.library == "weapons_missilelaunchers") then
				color = Color["icon_normal"]
			elseif isrendertargeticon then
				color = Color["icon_normal"]
			end
		end
	end
	return color
end

function menu.detailText()
	local text = ""
	if (menu.mode == "Galaxy") and menu.object then
		text = (type(menu.object) == "number") and menu.data["Galaxy"][menu.object].name or GetComponentData(menu.object, "name")
	elseif menu.mode == "FixedStations" and menu.object then
		text = menu.object.name
	elseif menu.library then
		text = menu.object.name
	end
	return text
end

function menu.getDescriptionText()
	if (menu.mode == "Blueprints") and menu.object then
		return menu.index["Blueprints"][menu.object].description
	elseif (menu.mode == "Galaxy") and menu.object then
		return (type(menu.object) == "number") and menu.data["Galaxy"][menu.object].description or GetComponentData(menu.object, "description")
	elseif (menu.mode == "FixedStations") and (menu.object) and (menu.id == nil) then
		return GetComponentData(ConvertStringTo64Bit(tostring(menu.object.component)), "description")
	elseif menu.library and menu.object and menu.object.description then
		return menu.object.description
	end
	return ""
end

function menu.createTopLevel(frame)
	menu.topLevelOffsetY = Helper.createTopLevelTab(menu, "encyclopedia", frame, "", nil, true)
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, "encyclopedia", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, "encyclopedia", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.display()
	else
		menu.inputModeHasChanged = true
	end
end

function menu.createSideBar(frame)
	local ftable = frame:addTable(1, { tabOrder = 3, width = menu.sidebarWidth, x = Helper.frameBorder, y = menu.topLevelOffsetY + Helper.borderSize, scaling = false, borderEnabled = false, reserveScrollBar = false })

	for _, entry in ipairs(config.leftBar) do
		local mode = entry.mode
		local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		local active = true
		local bgcolor = Color["row_title_background"]
		if entry.mode == "encyclopedia" then
			bgcolor = Color["row_background_selected"]
		end
		local color = Color["icon_normal"]
		row[1]:createButton({ active = active, height = menu.sidebarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color })
		row[1].handlers.onClick = function () return menu.buttonToggleEncyclopediaMode(mode) end
	end
end

function menu.viewCreated(layer, ...)
	menu.table_toplevel, menu.table_sidebar, menu.table_index, menu.table_description, menu.table_detail = ...
	menu.displayRunning = getElapsedTime()
end

menu.updateInterval = 0.1

-- hook to update the menu while it is being displayed
function menu.onUpdate()
	if menu.activatecutscene then
		local locparam1, locparam2, locparam3
		if menu.delayedrenderobject then
			locparam1 = menu.delayedrenderobject[1]
			locparam2 = menu.delayedrenderobject[2]
			locparam3 = menu.delayedrenderobject[3]
			locparam4 = menu.delayedrenderobject[4]
		end
		if menu.setupRenderTarget(locparam1, locparam2, locparam3, locparam4) then
			menu.activatecutscene = nil
			menu.delayedrenderobject = {}
		end
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refresh = true
			menu.inputModeHasChanged = nil
		end
	end

	if menu.refresh then
		menu.display()
		menu.refresh = nil
	end
	if type(menu.displayRunning) == "number" then
		if menu.displayRunning + 0.3 < getElapsedTime() then
			menu.displayRunning = nil
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	--print("onRowChanged row: " .. tostring(row) .. " rowdata: " .. tostring(rowdata) .. " uitable: " .. tostring(uitable) .. " table_index: " .. tostring(menu.table_index))
	if (row ~= 1) and (uitable == menu.table_index) then
		menu.setObject(rowdata)

		menu.selectedrow = row
		menu.toprow = GetTopRow(uitable)

		if menu.mode == "Galaxy" and menu.object then
			--print("SetKnownRead. object: " .. tostring(menu.object))
			if type(menu.object) == "number" then
				for _, cluster in ipairs(menu.data["Galaxy"][menu.object].clusters) do
					C.SetKnownRead(ConvertIDTo64Bit(cluster), true)
				end
			else
				C.SetKnownRead(ConvertIDTo64Bit(menu.object), true)
			end
		elseif menu.mode == "FixedStations" then
			if menu.library and menu.id then
				C.ReadKnownItem(menu.library, menu.id, true)
			elseif menu.object then
				C.SetKnownRead(menu.object.component, true)
			end
		elseif menu.library and menu.id then
			--print("ReadKnownItem. library: " .. menu.library .. ", id: " .. menu.id)
			C.ReadKnownItem(menu.library, menu.id, true)
		end

		if (menu.mode == "Galaxy") and (menu.object ~= menu.oldobject) then
			menu.oldobject = menu.object
			menu.hiddenData = { buy = {}, sell = {} }
			menu.refresh = true
		elseif (menu.mode == "Blueprints") and (menu.object ~= menu.oldobject) then
			menu.oldobject = menu.object
			menu.refresh = true
		elseif (menu.mode == "FixedStations") and (menu.id == nil) and (menu.object ~= menu.oldobject) then
			menu.oldobject = menu.object
			menu.refresh = true
		elseif (menu.library ~= menu.oldlibrary) or (menu.id ~= menu.oldid) then
			menu.oldlibrary = menu.library
			menu.oldid = menu.id
			menu.refresh = true
		end
	end
end

-- hook if the highlighted row is selected
function menu.onSelectElement(table, modified)
end

-- hook if the menu is being closed
function menu.onCloseElement(dueToClose)
	if menu.encyclopediaMode and (dueToClose == "back") then
		menu.deactivateEncyclopediaMode()
		return
	end

	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

-- helper functions
function menu.initWareData(funcware)
	menu.details.resources = {}
	menu.details.products = {}
	menu.details.prodresources = {}
	menu.details.waresources = {}
	menu.details.haswaresourcelocation = nil
	menu.details.blueprintowners = {}

	if funcware then
		if (menu.library == "inventory_wares") or (menu.library == "paintmods") then
			local numsources = C.GetNumWareSources(funcware)
			local sources = ffi.new("WareSource[?]", numsources)
			numsources = C.GetWareSources(sources, numsources, funcware)
			for i = 0, numsources-1 do
				table.insert(menu.details.waresources, { type = ffi.string(sources[i].sourcetype), location = ffi.string(sources[i].sourcelocation) })
				--print("location: " .. menu.details.waresources[#menu.details.waresources].location .. ". is empty string: " .. tostring(menu.details.waresources[#menu.details.waresources].location == ""))
				if menu.details.waresources[#menu.details.waresources].location ~= "" then
					menu.details.haswaresourcelocation = true
				end
			end
			table.sort(menu.details.waresources, function(a, b) return a.type < b.type end)
			--[[
			for i, source in ipairs(menu.details.waresources) do
				print(i .. ": source type: " .. source.type .. ", source location: " .. source.location)
			end
			--]]
		end

		if (menu.library ~= "inventory_wares") or GetWareData(funcware, "iscraftable") then
			menu.details.resources, menu.details.productiontime, menu.details.productionamount = menu.getResources(funcware)

			menu.details.productionmethods = {}
			local productionmethods = GetWareData(funcware, "productionmethods")
			for _, productionmethod in ipairs(productionmethods) do
				local n = C.GetNumProductionMethodResources(funcware, productionmethod)
				if n > 0 then
					local info = C.GetProductionMethodInfo(funcware, productionmethod)
					table.insert(menu.details.productionmethods, { method = productionmethod, name = ffi.string(info.name), productiontime = info.productiontime, productionamount = info.productionamount, resources = {} })
					local methodentry = menu.details.productionmethods[#menu.details.productionmethods]
					local buf = ffi.new("UIWareAmount[?]", n)
					n = C.GetProductionMethodResources(buf, n, funcware, productionmethod)
					for i = 0, n - 1 do
						local ware = ffi.string(buf[i].wareid)
						table.insert(methodentry.resources, { ware = ware, name = GetWareData(ware, "name"), amount = buf[i].amount })
					end
				end
			end
			table.sort(menu.details.productionmethods, Helper.sortName)
			for i, entry in ipairs(menu.details.productionmethods) do
				if entry.method == "default" then
					table.insert(menu.details.productionmethods, 1, entry)
					table.remove(menu.details.productionmethods, i + 1)
					break
				end
			end
		end

		local tradelicence, ishiddenwithoutlicence = GetWareData(funcware, "tradelicence", "ishiddenwithoutlicence")
		local n = C.GetNumWareBlueprintOwners(funcware)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWareBlueprintOwners(buf, n, funcware)
		for i = 0, n - 1 do
			local faction = ffi.string(buf[i])

			local hidden = false
			if ishiddenwithoutlicence then
				if not HasLicence("player", tradelicence, faction) then
					hidden = true
				end
			end

			if (not hidden) and IsKnownItem("factions", faction) then
				table.insert(menu.details.blueprintowners, faction)
			end
		end

		if (menu.library == "wares") or ((menu.library == "inventory_wares") and GetWareData(funcware, "iscraftingresource")) or ((menu.mode == "Stations") and (menu.library ~= "stationtypes")) then
			menu.details.products = menu.getProducts(funcware)
		end
	end
end

function menu.setObject(rowdata)
	local renderobject
	local isicon = nil
	local paintmod
	local iscomponent
	menu.library = nil
	menu.id = nil
	menu.object = nil

	-- rowdata is either a lua id or a table.
	if type(rowdata) == "table" then
		menu.mode = rowdata[1]
		if #rowdata >= 3 then
			if menu.mode == "Galaxy" then
				menu.library = nil
				menu.id = nil
				menu.object = rowdata[3]
				menu.details = rowdata[4]
				isicon = true
			elseif menu.mode == "Blueprints" then
				menu.object = rowdata[2]
				menu.details = rowdata[3]
			elseif menu.mode == "FixedStations" then
				if rowdata[2] == "stationtypes" then
					menu.library = rowdata[2]
					menu.id = rowdata[3].macro
					menu.object = GetLibraryEntry(menu.library, menu.id)
					renderobject = rowdata[3].macro
				else
					menu.library = nil
					menu.id = nil
					menu.object = rowdata[3]
					renderobject = rowdata[3].component
					iscomponent = true
				end
			else
				menu.library = rowdata[2]
				menu.id = rowdata[3].id
				menu.object = GetLibraryEntry(menu.library, menu.id)
				menu.details = rowdata[3]

				if (menu.mode ~= "Factions") and (menu.mode ~= "Licences") and (menu.mode ~= "Races") then
					local locware = menu.details.id
					if (menu.library ~= "inventory_wares") and (menu.library ~= "wares") and (menu.library ~= "software") and (menu.library ~= "paintmods") then
						locware = GetMacroData(locware, "ware")
					end

					if locware then
						menu.initWareData(locware)
					end

					if (menu.mode == "Stations") and (menu.library ~= "stationtypes") then
						menu.details.turrettotal = 0
						menu.details.shieldtotal = 0

						local n = C.GetNumUpgradeGroups(0, menu.id)
						local buf = ffi.new("UpgradeGroup[?]", n)
						n = C.GetUpgradeGroups(buf, n, 0, menu.id)
						for i = 0, n - 1 do
							if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
								local group = { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }

								local groupinfo = C.GetUpgradeGroupInfo(0, menu.id, group.path, group.group, "turret")
								menu.details.turrettotal = menu.details.turrettotal + groupinfo.total

								groupinfo = C.GetUpgradeGroupInfo(0, menu.id, group.path, group.group, "shield")
								menu.details.shieldtotal = menu.details.shieldtotal + groupinfo.total
							end
						end
					end
					--print("mode: " .. tostring(mode) .. ", library: " .. tostring(menu.library) .. ", id: " .. tostring(menu.id) .. ", locware: " .. tostring(locware))
					--print("id: " .. tostring(menu.details.id) .. "\n iscrafting: " .. tostring(GetWareData(menu.details.id, "iscrafting")) .. "\n iscraftable: " .. tostring(GetWareData(menu.details.id, "iscraftable")) .. "\n iscraftingresource: " .. tostring(GetWareData(menu.details.id, "iscraftingresource")))
				end

				if (menu.library == "factions") or (menu.library == "licences") or (menu.library == "races") then
					isicon = true
					if menu.library == "licences" then
						menu.object.factionid = rowdata[4]
					end
				elseif (menu.library == "wares") or (menu.library == "inventory_wares") or (menu.library == "software") then
					if menu.object.video ~= "" then
						renderobject = menu.object.video
					else
						-- leave blank. will be set to dummy in menu.setupRenderTarget().
					end
				elseif (menu.library == "weapons_lasers") or (menu.library == "weapons_missilelaunchers") or (menu.library == "enginetypes") then
					local makerrace, ware = GetMacroData(menu.id, "makerraceid", "ware")
					local video = ware and GetWareData(ware, "video") or ""
					if (video ~= "") and (video ~= "ware_noicon_macro") then
						renderobject = video
					else
						local isxenon, iskhaak = false, false
						for _, race in ipairs(makerrace) do
							if race == "xenon" then
								isxenon = true
							end
							if race == "khaak" then
								iskhaak = true
							end
							if isxenon and iskhaak then -- sic! no guarantee that the macro does not define both as makerrace. Also better example if more cases are added.
								break
							end
						end
						if isxenon or iskhaak or (not ware) then
							isicon = true
						else
							renderobject = menu.id
						end
					end
				elseif (menu.library == "shieldgentypes") then
					local makerrace, ware = GetMacroData(menu.id, "makerraceid", "ware")
					local video = ware and GetWareData(ware, "video") or ""
					if (video ~= "") and (video ~= "ware_noicon_macro") then
						renderobject = video
					else
						local iskhaak = false
						for _, race in ipairs(makerrace) do
							if race == "khaak" then
								iskhaak = true
								break
							end
						end
						if iskhaak or (not ware) then
							isicon = true
						else
							renderobject = menu.id
						end
					end
				elseif (menu.library == "paintmods") then
					if GetWareData(menu.id, "ispaintmod") then
						local lastplayership = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
						if lastplayership and (lastplayership ~= 0) and (not C.IsComponentClass(lastplayership, "spacesuit")) then
							renderobject = GetComponentData(lastplayership, "macro")
						end

						if renderobject == nil then
							local playerobjects = GetContainedObjectsByOwner("player")
							for _, object in ipairs(playerobjects) do
								if IsComponentClass(object, "ship") and (not IsComponentClass(object, "spacesuit")) then
									renderobject = GetComponentData(object, "macro")
									break
								end
							end
						end
						paintmod = menu.id
					end
				else
					renderobject = menu.id
				end
				--print("library: " .. tostring(menu.library) .. ", id: " .. tostring(menu.id))
			end
		end
	else
		menu.mode = rowdata
	end

	--print("menu.mode: " .. tostring(menu.mode))
	if not menu.delayrendertarget then
		menu.activatecutscene = nil
		if not menu.setupRenderTarget(renderobject, isicon, paintmod, iscomponent) then
			menu.activatecutscene = true
			menu.delayedrenderobject = { renderobject, isicon, paintmod, iscomponent }
		end
	else
		menu.activatecutscene = true
		menu.delayedrenderobject = { renderobject, isicon, paintmod, iscomponent }
		menu.delayrendertarget = nil
	end
end

function menu.getResources(funcware)
	local result = {}
	if not funcware then
		DebugError("menu.getResources called with no ware set.")
		return result
	end

	local locres, productiontime, productionamount = GetWareData(funcware, "resources", "productiontime", "productionamount")
	if locres and #locres > 0 then
		for _, resource in pairs(locres) do
			if type(resource) == "table" then
				resource.name = GetWareData(resource.ware, "name")
				table.insert(result, resource)
				--print(tostring(resource.ware) .. " used to produce " .. tostring(funcware))
			else
				DebugError("menu.getResources. unhandled else case. resource is not a table. resource: " .. tostring(resource))
			end
		end
	end
	return result, productiontime, productionamount
end

function menu.getProducts(funcware)
	local result = {}
	if not funcware then
		DebugError("menu.getProducts called with no ware set.")
		return result
	end

	local locprod = GetWareData(funcware, "products")
	if locprod and #locprod > 0 then
		for _, product in pairs(locprod) do
			local productentry = {ware = product, amount = 1, name = GetWareData(product, "name")}
			table.insert(result, productentry)
			--print(tostring(productentry.ware) .. " produced by " .. tostring(funcware))
		end
	end
	return result
end

function menu.cleanupRenderTarget()
	if menu.cutsceneid then
		--print("stopping cutscene " .. tostring(menu.cutsceneid))
		StopCutscene(menu.cutsceneid)
	end
	if menu.cutscenedesc then
		--print("releasing cutscene descriptor " .. tostring(menu.cutscenedesc))
		ReleaseCutsceneDescriptor(menu.cutscenedesc)
	end
	if menu.precluster then
		--print("destroying cluster " .. tostring(menu.precluster))
		DestroyPresentationCluster(menu.precluster)
	end
	menu.precluster = nil
	menu.preobject = nil
	menu.cutscenedesc = nil
	menu.cutsceneid = nil
	menu.currentrenderobject = nil
end

function menu.setupRenderTarget(renderobject, isicon, paintmod, iscomponent)
	local oldrendertargetmode = menu.rendertargetmode
	--print("menu.setupRenderTarget. oldrendertargetmode: " .. tostring(oldrendertargetmode) .. ", renderobject: " .. tostring(renderobject) .. ", isicon: " .. tostring(isicon) .. ", cutsceneid: " .. tostring(menu.cutsceneid) .. ", menu.delayrendertarget: " .. tostring(menu.delayrendertarget))

	if menu.cutsceneid then
		if not menu.currentrenderobject or not renderobject or (menu.currentrenderobject ~= renderobject) then
			menu.cleanupRenderTarget()
			return false
		end
	end

	if not renderobject then
		if menu.library and menu.id and (not isicon) then
			print("Encyclopedia: ERROR: no usable video found for " .. tostring(menu.library) .. " library entry " .. tostring(menu.id))
		end
		renderobject = "encyclopedia_dummy_macro"
	end

	if isicon then
		menu.rendertargetmode = "icon"
	else
		menu.rendertargetmode = "cutscene"
	end

	if oldrendertargetmode and menu.rendertargetmode and oldrendertargetmode ~= menu.rendertargetmode then
		menu.refresh = true
		menu.delayrendertarget = true
	end

	if not menu.delayrendertarget then
		if not isicon then
			local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
			--print("rendertarget id: " .. tostring(menu.rendertarget.id) .. ", rendertarget texture: " .. tostring(rendertargetTexture))
			if rendertargetTexture then
				if iscomponent then
					menu.currentrenderobject = ConvertStringTo64Bit(tostring(renderobject))
					menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", { targetobject = menu.currentrenderobject })
					menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
				else
					menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
					menu.currentrenderobject = renderobject
					if menu.preobject then
						if paintmod and IsComponentClass(menu.preobject, "object") then
							C.InstallPaintMod(ConvertIDTo64Bit(menu.preobject), paintmod, false)
						end

						menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", { targetobject = menu.preobject })
						menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
						--print("started cutscene")
					end
				end
			end
		elseif oldrendertargetmode and menu.rendertargetmode and oldrendertargetmode ~= menu.rendertargetmode then
			menu.rendertarget = nil
			menu.refresh = true
		end
	end
	return true
end

function menu.buttonExpand(category, rowindex)
	if menu.expanded[category] then
		menu.expanded[category] = nil
	else
		menu.expanded[category] = true
	end

	menu.selectedrow = rowindex
	menu.toprow = GetTopRow(menu.table_index)

	menu.delayrendertarget = true
	menu.display()
end

function menu.buttonToggleEncyclopediaMode(mode)
	if mode == "encyclopedia" then
		AddUITriggeredEvent(menu.name, mode, menu.encyclopediaMode == mode and "off" or "on")
		if menu.encyclopediaMode then
			PlaySound("ui_negative_back")
			menu.encyclopediaMode = nil
		else
			menu.setdefaulttable = true
			PlaySound("ui_positive_select")
			menu.encyclopediaMode = mode
		end
		menu.refresh = true
	elseif mode == "timeline" then
		Helper.closeMenuAndOpenNewMenu(menu, "TimelineMenu", { 0, 0 }, true)
		menu.cleanup()
	elseif mode == "shipcomparison" then
		Helper.closeMenuAndOpenNewMenu(menu, "ShipComparisonMenu", { 0, 0 }, true)
		menu.cleanup()
	end
end

function menu.buttonReadAll()
	C.ReadAllKnownSpaces(0)
	C.ReadAllKnownItems()
	local n = C.GetNumFixedStations(0)
	if n > 0 then
		local buf = ffi.new("UniverseID[?]", n)
		n = C.GetFixedStations(buf, n, 0)
		for i = 0, n - 1 do
			if C.IsKnownToPlayer(buf[i]) then
				C.SetKnownRead(buf[i], true)
			end
		end
	end
	menu.refresh = true
end

function menu.buttonTerraforming(cluster, name)
	Helper.closeMenuAndOpenNewMenu(menu, "TerraformingMenu", { 0, 0, cluster, name })
	menu.cleanup()
end

function menu.buttonClearEditbox(row)
	Helper.cancelEditBoxInput(menu.slottable, row, 1)
	menu.searchtext = nil

	menu.display()
end

function menu.editboxSearchUpdateText(_, text, textchanged)
	menu.noupdate = nil

	if textchanged then
		menu.searchtext = text
	end

	menu.display()
end

function menu.dropdownProductionMethod(_, id)
	if id ~= menu.productionmethod then
		menu.productionmethod = id
		menu.display()
	end
end

function menu.deactivateEncyclopediaMode()
	PlaySound("ui_negative_back")
	menu.encyclopediaMode = nil
	menu.refresh = true
end

function menu.getNumEntries(category)
	local numentries = 0
	local numunread = 0
	for subcategory in pairs(menu.data[category]) do
		if category ~= "Factions" then
			numentries = numentries + GetLibrarySize(subcategory)
		else
			local factionlibrary = GetLibrary("factions")
			for i, faction in ipairs(factionlibrary) do
				if faction.id == "player" then
					C.ReadKnownItem("factions", faction.id, true)
					table.remove(factionlibrary, i)
					break
				end
			end
			numentries = #factionlibrary
			for subcategory, _ in pairs(menu.data["Factions"]) do
				for _, faction in ipairs(menu.data["Factions"][subcategory]) do
					numentries = numentries + faction.numlicences
					for _, licence in ipairs(faction.licences) do
						if not C.IsKnownItemRead("licences", licence.id) then
							numunread = numunread + 1
						end
					end
				end
			end
		end
		numunread = numunread + C.GetNumUnreadLibraryEntries(subcategory)
	end

	return numentries, numunread
end

function menu.addDetailRow(ftable, col1, col2, col3, offsetx, iswordwrap, properties1, properties2, properties3)
	menu.numDetailRows = menu.numDetailRows + 1

	properties1 = properties1 or {}
	properties1.halign = "left"
	properties1.x = offsetx
	properties1.wordwrap = iswordwrap
	properties2 = properties2 or {}
	properties2.halign = "right"
	properties2.wordwrap = iswordwrap
	properties3 = properties3 or {}
	properties3.halign = "right"
	properties3.wordwrap = iswordwrap

	local row = ftable:addRow(("detailrow_" .. menu.numDetailRows), { interactive = false })
	if col3 then
		row[2]:createText(col1, properties1)
		row[3]:createText(col2, properties2)
		row[4]:createText(col3, properties3)
	elseif col2 then
		row[2]:createText(col1, properties1)
		row[3]:setColSpan(2):createText(col2, properties2)
	else
		row[2]:setColSpan(3):createText(col1, properties1)
	end
end

function menu.addEngineDetailRow(ftable, name, thruster, hasdefaultloadout)
	menu.addDetailRow(ftable, name .. ((not hasdefaultloadout) and " (" .. thruster.name .. ")" or ""), ConvertIntegerString(thruster.value, true, 0, true) .. " " .. thruster.unit)
end

function menu.addProductionMethodDetails(ftable, resourcestring, methodstring, showtime, showamount)
	-- title
	local row = ftable:addRow(false, {  })
	row[2]:setColSpan(3):createText(resourcestring, Helper.subHeaderTextProperties)
	row[2].properties.halign = "center"

	menu.numDetailRows = menu.numDetailRows + 1
	local row = ftable:addRow(("detailrow_" .. menu.numDetailRows), { interactive = false })
	row[2]:createText(methodstring .. ReadText(1001, 120))
	local productionmethodoptions = {}
	local currentMethodIdx = 0
	for i, entry in ipairs(menu.details.productionmethods) do
		table.insert(productionmethodoptions, { id = entry.method, text = entry.name, icon = "", displayremoveoption = false })
		if entry.method == menu.productionmethod then
			currentMethodIdx = i
		end
	end
	if currentMethodIdx == 0 then
		currentMethodIdx = 1
		menu.productionmethod = menu.details.productionmethods[1].method
	end
	row[3]:setColSpan(2):createDropDown(productionmethodoptions, { startOption = menu.productionmethod }):setTextProperties({ halign = "right", x = Helper.standardTextOffsetx })
	row[3].handlers.onDropDownConfirmed = menu.dropdownProductionMethod
	for i, entry in ipairs(menu.details.productionmethods[currentMethodIdx].resources) do
		menu.addDetailRow(ftable, "", ConvertIntegerString(entry.amount, true, 0, true) .. ReadText(1001, 42) .. " " .. entry.name)
	end
	if showamount then
		-- empty line
		menu.addDetailRow(ftable, "")
		-- Production Amount
		menu.addDetailRow(ftable, showamount, ConvertIntegerString(menu.details.productionmethods[currentMethodIdx].productionamount, true, 0, true) .. ReadText(1001, 42) .. " " .. menu.object.name)
	end
	if showtime then
		if not showamount then
			-- empty line
			menu.addDetailRow(ftable, "")
		end
		-- buildtime
		menu.addDetailRow(ftable, showtime .. ReadText(1001, 120), ConvertTimeString(menu.details.productionmethods[currentMethodIdx].productiontime, ReadText(1001, 209)))
	end
end

function menu.addDetailRows(ftable)
	if menu.object then
		if menu.mode == "Galaxy" then
			if type(menu.object) == "number" then
				local clusters = menu.data["Galaxy"][menu.object].clusters
				-- space for sector case
				menu.addDetailRow(ftable, "")
				-- workforce
				local stationtable = {}
				for _, cluster in ipairs(clusters) do
					local stations = GetContainedStations(cluster, true)
					for _, station in ipairs(stations) do
						table.insert(stationtable, station)
					end
				end
				local spacepopulation = 0
				for _, station in ipairs(stationtable) do
					local workforceinfo = C.GetWorkForceInfo(ConvertStringTo64Bit(tostring(station)), "")
					spacepopulation = spacepopulation + workforceinfo.current
				end
				menu.addDetailRow(ftable, ReadText(1001, 2456), ConvertIntegerString(spacepopulation, true, 0, true))
				-- space for sector case
				menu.addDetailRow(ftable, "")
				-- spacing
				menu.addDetailRow(ftable, "")
				-- stations
				local numstations = 0
				for _, cluster in ipairs(clusters) do
					local stations = GetContainedStations(cluster, true)
					numstations = numstations + #stations
				end
				menu.addDetailRow(ftable, ReadText(1001, 9042), ConvertIntegerString(numstations, true, 0, true))
				-- products
				local stationtable = {}
				for _, cluster in ipairs(clusters) do
					local stations = GetContainedStations(cluster, true)
					for _, station in ipairs(stations) do
						table.insert(stationtable, station)
					end
				end
				local productiontable = {}
				local products = {}
				local sortedProducts = {}
				for _, station in ipairs(stationtable) do
					local productionmodules = GetProductionModules(station)
					for _, module in ipairs(productionmodules) do
						table.insert(productiontable, GetComponentData(module, "products"))
					end
				end
				for _, entry in ipairs(productiontable) do
					for _, product in ipairs(entry) do
						local notincremented = true
						for compproduct, count in pairs(products) do
							if compproduct == product then
								products[product] = count + 1
								notincremented = false
								break
							end
						end
						if notincremented then
							products[product] = 1
						end
					end
				end
				local maxproductgrp = ReadText(1001, 9002)	-- "Unknown"
				local maxcount = 0
				for product, count in pairs(products) do
					local name, groupName = GetWareData(product, "name", "groupName")
					if not maxproductgrp or (count > maxcount) then
						maxproductgrp = groupName
						maxcount = count
					end
					table.insert(sortedProducts, { name = name, count = count })
				end
				menu.addDetailRow(ftable, ReadText(1001, 9050), maxproductgrp)
				table.sort(sortedProducts, Helper.sortName)
				for i, entry in pairs(sortedProducts) do
					menu.addDetailRow(ftable, (i == 1) and ReadText(1001, 9094) or "", entry.count .. ReadText(1001, 42) .. " " .. entry.name)
				end

				-- start: kuertee call-back
				if menu.uix_callbacks ["addDetailRow_known_cluster_production_module_entries"] then		
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["addDetailRow_known_cluster_production_module_entries"]) do
						uix_callback(ftable, clusters)
				    end		
				end
				-- end: kuertee call-back

			else
				-- owner
				if IsComponentClass(menu.object, "sector") then
					local owner = GetComponentData(menu.object, "ownername")
					if C.IsContestedSector(ConvertIDTo64Bit(menu.object)) then
						owner = owner .. " " .. ReadText(1001, 3247)
					end
					menu.addDetailRow(ftable, ReadText(1001, 2455), owner)
				end
				-- workforce
				local stationtable = GetContainedStations(menu.object, true)
				local spacepopulation = 0
				for _, station in ipairs(stationtable) do
					local workforceinfo = C.GetWorkForceInfo(ConvertStringTo64Bit(tostring(station)), "")
					spacepopulation = spacepopulation + workforceinfo.current
				end
				menu.addDetailRow(ftable, ReadText(1001, 2456), ConvertIntegerString(spacepopulation, true, 0, true))
				-- spacing
				menu.addDetailRow(ftable, "")
				-- resources
				menu.addDetailRow(ftable, ReadText(1001, 9423) .. ReadText(1001, 120))
				-- sunlight
				local sunlight = GetComponentData(menu.object, "sunlight") * 100 .. "%"
				menu.addDetailRow(ftable, ReadText(1001, 2412), sunlight, nil, 25)
				-- regions
				local resources = {}
				local n = C.GetNumDiscoveredSectorResources(ConvertIDTo64Bit(menu.object))
				local buf = ffi.new("WareYield[?]", n)
				n = C.GetDiscoveredSectorResources(buf, n, ConvertIDTo64Bit(menu.object))
				for i = 0, n - 1 do
					table.insert(resources, { name = GetWareData(ffi.string(buf[i].ware), "name"), current = buf[i].current, max = buf[i].max })
				end
				table.sort(resources, Helper.sortName)

				for _, entry in ipairs(resources) do
					menu.addDetailRow(ftable, entry.name, ConvertIntegerString(entry.current, true, 3, true), nil, 25)
				end
				-- spacing
				menu.addDetailRow(ftable, "")
				-- stations
				local stationtable = GetContainedStations(menu.object, true)
				local numstations = #stationtable
				menu.addDetailRow(ftable, ReadText(1001, 9042), ConvertIntegerString(numstations, true, 0, true))
				-- products
				local stationtable = GetContainedStations(menu.object, true)
				local productiontable = {}
				local products = {}
				local sortedProducts = {}
				for _, station in ipairs(stationtable) do
					local productionmodules = GetProductionModules(station)
					for _, module in ipairs(productionmodules) do
						table.insert(productiontable, GetComponentData(module, "products"))
					end
				end
				for _, entry in ipairs(productiontable) do
					for _, product in ipairs(entry) do
						local notincremented = true
						for compproduct, count in pairs(products) do
							if compproduct == product then
								products[product] = count + 1
								notincremented = false
								break
							end
						end
						if notincremented then
							products[product] = 1
						end
					end
				end
				local maxproductgrp = ReadText(1001, 9002)	-- "Unknown"
				local maxcount = 0
				for product, count in pairs(products) do
					local name, groupName = GetWareData(product, "name", "groupName")
					if not maxproductgrp or (count > maxcount) then
						maxproductgrp = groupName
						maxcount = count
					end
					table.insert(sortedProducts, { name = name, count = count })
				end
				menu.addDetailRow(ftable, ReadText(1001, 9050), maxproductgrp)
				table.sort(sortedProducts, Helper.sortName)
				for i, entry in pairs(sortedProducts) do
					menu.addDetailRow(ftable, (i == 1) and ReadText(1001, 9094) or "", entry.count .. ReadText(1001, 42) .. " " .. entry.name)
				end

				-- start: kuertee call-back
				if menu.uix_callbacks ["addDetailRow_known_sector_production_module_entries"] then		
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["addDetailRow_known_sector_production_module_entries"]) do
						uix_callback(ftable, menu.object)
				    end		
				end
				-- end: kuertee call-back

			end
			if (type(menu.object) == "number") or (#menu.details.sectors == 1) then
				local data = menu.details.systeminfo

				-- empty line
				menu.addDetailRow(ftable, "")
				-- header
				local row = ftable:addRow(false, {  })
				row[2]:setColSpan(3):createText(ReadText(1001, 2491), Helper.headerRow1Properties)
				if data.space then
					-- space environment
					menu.addDetailRow(ftable, ReadText(1001, 2471), data.space.environment)
				end
				if data.suns and (#data.suns > 0) then
					-- suns
					for _, sun in ipairs(data.suns) do
						menu.addDetailRow(ftable, "\27[ency_sun_01]" .. sun.name, sun.class)
					end
				end
				if data.planets and (#data.planets > 0) then
					-- planets
					for i, planet in ipairs(data.planets) do
						if i > 1 then
							-- empty line
							menu.addDetailRow(ftable, "")
						end
						local row = ftable:addRow(true, {  })
						row[2]:createText("\27[ency_planet_01]" .. planet.name, { x = 25 })
						if planet.hasterraforming then
							row[3]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9099), { halign = "center" })
							row[3].handlers.onClick = function () return menu.buttonTerraforming(menu.details.clusters[1], "\27[ency_planet_01]" .. planet.name) end
						end
						if planet.class ~= "" then
							menu.addDetailRow(ftable, ReadText(1001, 9616), planet.class, nil, 50)
						end
						menu.addDetailRow(ftable, ReadText(1001, 2466), planet.population, nil, 50)
						menu.addDetailRow(ftable, ReadText(1001, 2492), planet.settlements, nil, 50)
						menu.addDetailRow(ftable, ReadText(1001, 2469), planet.atmosphere, nil, 50)
						menu.addDetailRow(ftable, ReadText(1001, 2470), planet.geology, nil, 50)
						if planet.moons and (#planet.moons > 0) then
							-- moons
							for _, moon in ipairs(planet.moons) do
								local row = ftable:addRow(true, {  })
								row[2]:createText("\27[ency_moon_01]" .. moon.name, { x = 50 })
								if moon.hasterraforming then
									row[3]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9099), { halign = "center" })
									row[3].handlers.onClick = function () return menu.buttonTerraforming(menu.details.clusters[1], "\27[ency_moon_01]" .. moon.name) end
								end
								if moon.class ~= "" then
									menu.addDetailRow(ftable, ReadText(1001, 9617), moon.class, nil, 75)
								end
								menu.addDetailRow(ftable, ReadText(1001, 2466), moon.population, nil, 75)
								menu.addDetailRow(ftable, ReadText(1001, 2492), moon.settlements, nil, 75)
								menu.addDetailRow(ftable, ReadText(1001, 2469), moon.atmosphere, nil, 75)
								menu.addDetailRow(ftable, ReadText(1001, 2470), moon.geology, nil, 75)
							end
						end
					end
				end
			end

		elseif menu.mode == "Races" then
			-- primary factions
			if #menu.object.primaryfactions > 0 then
				table.sort(menu.object.primaryfactions, Helper.sortFactionName)
				menu.addDetailRow(ftable, ReadText(1001, 2499) .. ReadText(1001, 120))
				for _, faction in ipairs(menu.object.primaryfactions) do
					if faction ~= "player" then
						menu.addDetailRow(ftable, "", GetFactionData(faction, "name"))
					end
				end
			end
			-- food
			if #menu.object.resources > 0 then
				table.sort(menu.object.resources, Helper.sortName)
				menu.addDetailRow(ftable, ReadText(1001, 9098) .. ReadText(1001, 120))
				for _, resourceentry in ipairs(menu.object.resources) do
					menu.addDetailRow(ftable, "", resourceentry.name)
				end
			end

		elseif menu.mode == "Factions" then
			-- representative
			local factionrep = ConvertStringTo64Bit(tostring(C.GetFactionRepresentative(menu.id)))
			local printedtitle = ((factionrep ~= 0) and GetComponentData(factionrep, "isfemale") and ReadText(20208, 10602)) or ReadText(20208, 10601)	-- Faction Representative(female), Faction Representative(male)
			local printedname = ReadText(1001, 9002)		-- Unknown
			if factionrep ~= 0 then
				printedname = ffi.string(C.GetComponentName(factionrep))
			end
			menu.addDetailRow(ftable, printedtitle, printedname)
			-- HQ
			local hqlist = {}
			Helper.ffiVLA(hqlist, "UniverseID", C.GetNumHQs, C.GetHQs, menu.id)
			-- each faction is only supposed to have one HQ, the player included. if a faction is modded to have more, only print the first one.
			local data = ReadText(1001, 9002)		-- Unknown
			if #hqlist > 0 then
				data = ffi.string(C.GetComponentName(ConvertIDTo64Bit(GetComponentData( ConvertStringTo64Bit(tostring(hqlist[1])), "sectorid" ))))
			end
			menu.addDetailRow(ftable, ReadText(1001, 9600), data)
			-- police
			local data = ReadText(1001, 9002)		-- Unknown
			local policefaction = GetFactionData(menu.id, "policefaction")
			if policefaction then
				data = GetFactionData(policefaction, "name")
			end
			menu.addDetailRow(ftable, ReadText(1001, 9601), data)
			-- illegal wares
			if menu.id == policefaction then
				if #menu.object.illegalwares > 0 then
					table.sort(menu.object.illegalwares, Helper.sortName)
					menu.addDetailRow(ftable, ReadText(1001, 2435) .. ReadText(1001, 120))
					for _, wareentry in ipairs(menu.object.illegalwares) do
						menu.addDetailRow(ftable, "", wareentry.name)
					end
				end
			end
			-- Allies
			menu.addDetailRow(ftable, ReadText(1001, 9603) .. ReadText(1001, 120), nil, nil, nil, nil, { mouseOverText = ReadText(1026, 2403) })
			for i, entry in ipairs(menu.details.allies) do
				menu.addDetailRow(ftable, "", entry.name, nil, nil, nil, nil, { font = (entry.id == "player") and Helper.standardFontBold or nil })
			end
			-- Enemies
			menu.addDetailRow(ftable, ReadText(1001, 9604) .. ReadText(1001, 120), nil, nil, nil, nil, { mouseOverText = ReadText(1026, 2402) })
			for i, entry in ipairs(menu.details.enemies) do
				menu.addDetailRow(ftable, "", entry.name, nil, nil, nil, nil, { font = (entry.id == "player") and Helper.standardFontBold or nil, color = menu.holomapcolor.enemycolor })
			end
			-- Hostiles
			menu.addDetailRow(ftable, ReadText(1001, 9632) .. ReadText(1001, 120), nil, nil, nil, nil, { mouseOverText = ReadText(1026, 2401) })
			for i, entry in ipairs(menu.details.hostiles) do
				menu.addDetailRow(ftable, "", entry.name, nil, nil, nil, nil, { font = (entry.id == "player") and Helper.standardFontBold or nil, color = menu.holomapcolor.hostilecolor })
			end
			-- Your Relation
			menu.addDetailRow(ftable, ReadText(1001, 9636) .. ReadText(1001, 120))
			menu.addDetailRow(ftable, ffi.string(C.GenerateFactionRelationText(menu.id)), nil, nil, 25)
			-- empty line
			menu.addDetailRow(ftable, "")
			-- Sectors
			menu.addDetailRow(ftable, ReadText(1001, 2459) .. ReadText(1001, 120))
			for i, entry in ipairs(menu.details.sectors) do
				menu.addDetailRow(ftable, "", ffi.string(C.GetComponentName(entry)))
			end

		elseif menu.mode == "Stations" then
			if menu.library ~= "stationtypes" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- radar range
				if menu.object.radarrange then
					menu.addDetailRow(ftable, ReadText(1001, 2426), ConvertIntegerString(menu.object.radarrange / 1000, true, 0, true) .. " " .. ReadText(1001, 108))
				end
				-- canclaim
				if menu.object.canclaim then
					menu.addDetailRow(ftable, ReadText(1001, 9637), ReadText(1001, 2617))
				end
				-- storage
				if menu.object.storagecapacity and menu.object.storagecapacity > 0 then
					-- storage capacity
					menu.addDetailRow(ftable, ReadText(1001, 9063), ConvertIntegerString(menu.object.storagecapacity, true, 0, true))
					-- storage types
					menu.addDetailRow(ftable, ReadText(1001, 9064), menu.object.storagenames)
				end
				-- workforce
				if menu.object.workforcecapacity and menu.object.workforcecapacity > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9611), menu.object.workforcecapacity)
				end
				-- workforcemax
				if menu.object.maxworkforce and menu.object.maxworkforce > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 7992), menu.object.maxworkforce)
				end
				-- ship storage
				if menu.object.shipstoragecapacity > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9612), menu.object.shipstoragecapacity)
				end
				-- upgrades
				if menu.details.turrettotal > 0 or menu.details.shieldtotal > 0 then
					-- turrets
					menu.addDetailRow(ftable, ReadText(1001, 1319), menu.details.turrettotal)
					-- shields
					menu.addDetailRow(ftable, ReadText(1001, 1317), menu.details.shieldtotal)
				end
				-- units
				if menu.object.unitcapacity > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9062), menu.object.unitcapacity)
				end
				-- missiles
				if menu.object.missilecapacity > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9061), menu.object.missilecapacity)
				end

				-- products
				if menu.object.products and #menu.object.products > 0 then
					menu.addDetailRow(ftable, "")
					local queueduration = 0
					for i, proddata in ipairs(menu.object.products) do
						queueduration = queueduration + proddata.cycle
					end
					for i, proddata in ipairs(menu.object.products) do
						local row = ftable:addRow(false, {  })
						row[2]:setColSpan(3):createText(proddata.name, Helper.subHeaderTextProperties)
						row[2].properties.halign = "center"

						menu.addDetailRow(ftable, ReadText(1001, 9609) .. ReadText(1001, 120), ConvertIntegerString(proddata.amount, true, 0, true) .. ReadText(1001, 42) .. " " .. proddata.name)
						for j, resourcedata in ipairs(proddata.resources) do
							resourcedata.name = GetWareData(resourcedata.ware, "name")
							menu.addDetailRow(ftable, (j == 1) and (ReadText(1001, 9614) .. ReadText(1001, 120)) or "", ConvertIntegerString(resourcedata.amount, true, 0, true) .. ReadText(1001, 42) .. " " .. resourcedata.name)
						end
						if not IsMacroClass(menu.id, "processingmodule") then
							menu.addDetailRow(ftable, ReadText(1001, 2411) .. ReadText(1001, 120), ConvertTimeString(proddata.cycle, ReadText(1001, 209)))
							menu.addDetailRow(ftable, "")
							menu.addDetailRow(ftable, ReadText(1001, 9624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120), Helper.round(3600 / queueduration, 2))
							menu.addDetailRow(ftable, ReadText(1001, 1624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120), ConvertIntegerString((queueduration > 0) and Helper.round(proddata.amount * 3600 / queueduration) or 0, true, 0, true) .. ReadText(1001, 42) .. " " .. proddata.name)
							for j, resourcedata in ipairs(proddata.resources) do
								resourcedata.name = GetWareData(resourcedata.ware, "name")
								menu.addDetailRow(ftable, (j == 1) and (ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120)) or "", ConvertIntegerString((queueduration > 0) and Helper.round(resourcedata.amount * 3600 / queueduration) or 0, true, 0, true) .. ReadText(1001, 42) .. " " .. resourcedata.name)
							end
						end
						if i < #menu.object.products then
							menu.addDetailRow(ftable, "")
						end
					end
				end

				-- build resources
				if menu.details.productionmethods and (#menu.details.productionmethods > 0) then
					-- empty line
					menu.addDetailRow(ftable, "")
					menu.addProductionMethodDetails(ftable, ReadText(1001, 9613), ReadText(1001, 9652), ReadText(1001, 8508))
				end
			end

		elseif menu.mode == "Ships" then
			local hasdefaultloadout = C.HasDefaultLoadout2(menu.id, true)
			local shipmakerraces = GetMacroData(menu.id, "makerraceid")
			-- hull
			menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
			-- ship type

			-- start: alexandretk call-back
			if menu.uix_callbacks ["onShowMenu_addOtherShipTypes"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_addOtherShipTypes"]) do
					uix_callback(menu, ftable)
				end
			else
			-- end: alexandretk call-back

				menu.addDetailRow(ftable, ReadText(1001, 9051), menu.object.shiptypename)

			end


			-- ship size
			local sizename = Helper.getClassText(ffi.string(C.GetMacroClass(menu.id)))
			if sizename ~= "" then
				menu.addDetailRow(ftable, ReadText(1001, 9648), sizename)
			end
			-- mass
			menu.addDetailRow(ftable, ReadText(1001, 9052), ConvertIntegerString(menu.object.mass, true, 0, true) .. " " .. ReadText(1001, 116))
			-- empty line
			menu.addDetailRow(ftable, "")
			-- engine
			local bestengines = {
				["thrust_forward"]			= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_forward",	unit = ReadText(1001, 113) },
				["boost_thrustfactor"]		= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_forward",	unit = ReadText(1001, 113),		multiply_thrust = true },
				["travel_thrustfactor"]		= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_forward",	unit = ReadText(1001, 113),		multiply_thrust = true },
			}

			local numslots = tonumber(C.GetNumUpgradeSlots(0, menu.id, "engine"))
			if hasdefaultloadout and menu.preobject then
				local enginemacro = ffi.string(C.GetUpgradeSlotCurrentMacro(ConvertIDTo64Bit(menu.preobject), 0, "engine", 1))
				if enginemacro ~= "" then
					local bestengine = GetLibraryEntry("enginetypes", enginemacro)
					if next(bestengine) then
						for _, entry in pairs(bestengines) do
							entry.engine = bestengine
						end
					end
				end
			else
				for i = 1, numslots do
					for _, engine in pairs(menu.data.Equipment.enginetypes) do
						local makerrace, ware = GetMacroData(engine.id, "makerraceid", "ware")
						local allowed = menu.isMakerRaceAllowed(makerrace, shipmakerraces)
						if allowed and (not ware or GetWareData(ware, "volatile")) then
							allowed = false
						end
						if allowed then
							if C.IsUpgradeMacroCompatible(0, 0, menu.id, false, "engine", i, engine.id) then
								local evalengine = GetLibraryEntry("enginetypes", engine.id)
								for property, entry in pairs(bestengines) do
									if (not entry.engine) or evalengine[property] * (entry.multiply_thrust and evalengine.thrust_forward or 1) > entry.engine[property] * (entry.multiply_thrust and entry.engine.thrust_forward or 1) then
										entry.engine = evalengine
									end
								end
							end
						end
					end
				end
			end
			local maxaccel = 0
			for property, entry in pairs(bestengines) do
				if type(entry.engine) == "table" then
					entry.value = entry.engine[property] * numslots / menu.object[entry.dragproperty]
					if entry.multiply_thrust then
						entry.value = entry.value * entry.engine.thrust_forward
					end
					entry.name = entry.engine.name

					if property == "thrust_forward" then
						maxaccel = entry.engine[property] * numslots / menu.object.mass
					end
				end
			end

			-- max speed
			menu.addEngineDetailRow(ftable, ReadText(1001, 9054), bestengines["thrust_forward"], hasdefaultloadout)
			-- boost speed
			menu.addEngineDetailRow(ftable, ReadText(1001, 8052), bestengines["boost_thrustfactor"], hasdefaultloadout)
			-- travel speed
			menu.addEngineDetailRow(ftable, ReadText(1001, 8053), bestengines["travel_thrustfactor"], hasdefaultloadout)
			-- max acceleration
			menu.addDetailRow(ftable, ReadText(1001, 9053) .. ((not hasdefaultloadout) and " (" .. bestengines["thrust_forward"].name .. ")" or ""), ConvertIntegerString(maxaccel, true, 0, true) .. " " .. ReadText(1001, 111))
			-- empty line
			menu.addDetailRow(ftable, "")
			-- thruster
			local bestthrusters = {
				["thrust_yaw"]			= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_yaw",			unit = ReadText(1001, 117),		rotational = true },
				["thrust_pitch"]		= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_pitch",		unit = ReadText(1001, 117),		rotational = true },
				["thrust_vertical"]		= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_vertical",		unit = ReadText(1001, 113) },
				["thrust_horizontal"]	= { name = ReadText(1001, 9003),	value = 0,	dragproperty = "drag_horizontal",	unit = ReadText(1001, 113) },
			}

			if hasdefaultloadout and menu.preobject then
				local bestthruster
				if IsComponentClass(menu.preobject, "ship_xs") then
					bestthruster = GetLibraryEntry( "enginetypes", ffi.string(C.GetUpgradeSlotCurrentMacro(ConvertIDTo64Bit(menu.preobject), 0, "engine", 1)) )
				else
					bestthruster = GetLibraryEntry( "enginetypes", ffi.string(C.GetUpgradeSlotCurrentMacro(ConvertIDTo64Bit(menu.preobject), 0, "thruster", 1)) )
				end
				for _, entry in pairs(bestthrusters) do
					entry.thruster = bestthruster
				end
			else
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(0, menu.id, "thruster"))
				for i = 1, numslots do
					for _, thruster in pairs(menu.data.Equipment.thrustertypes) do
						local makerrace, ware = GetMacroData(thruster.id, "makerraceid", "ware")
						local allowed = menu.isMakerRaceAllowed(makerrace, shipmakerraces)
						if allowed and (not ware or GetWareData(ware, "volatile")) then
							allowed = false
						end
						if allowed then
							if C.IsVirtualUpgradeMacroCompatible(0, menu.id, "thruster", i, thruster.id) then
								local evalthruster = GetLibraryEntry("enginetypes", thruster.id)
								for property, entry in pairs(bestthrusters) do
									if (not entry.thruster) or evalthruster[property] > entry.thruster[property] then
										entry.thruster = evalthruster
									end
								end
							end
						end
					end
				end
			end
			local responsiveness = menu.object.drag_yaw / menu.object.inertia_yaw
			for property, entry in pairs(bestthrusters) do
				if type(entry.thruster) == "table" then
					entry.value = entry.thruster[property] / menu.object[entry.dragproperty]
					if entry.rotational then
						entry.value = entry.value * 180 / math.pi
					end
					entry.name = entry.thruster.name
				end
			end

			-- turning rate
			menu.addEngineDetailRow(ftable, ReadText(1001, 9055), bestthrusters["thrust_yaw"], hasdefaultloadout)
			-- pitch rate
			menu.addEngineDetailRow(ftable, ReadText(1001, 9056), bestthrusters["thrust_pitch"], hasdefaultloadout)
			-- responsiveness
			menu.addDetailRow(ftable, ReadText(1001, 9057), Helper.round(responsiveness, 3))
			-- empty line
			menu.addDetailRow(ftable, "")
			-- vertical strafe
			menu.addEngineDetailRow(ftable, ReadText(1001, 9058), bestthrusters["thrust_vertical"], hasdefaultloadout)
			-- horizontal strafe
			menu.addEngineDetailRow(ftable, ReadText(1001, 9059), bestthrusters["thrust_horizontal"], hasdefaultloadout)
			-- empty line
			menu.addDetailRow(ftable, "")
			-- shields
			local numslots = tonumber(C.GetNumUpgradeSlots(0, menu.id, "shield"))
			menu.addDetailRow(ftable, ReadText(1001, 2490), ConvertIntegerString(numslots, true, 0, true))
			-- shield capacity
			-- all known shield generators are in menu.data["Equipment"]["shieldgentypes"]
			local bestshield
			local bestname = ReadText(1001, 9003)	-- "No Known Component"
			local numslots = tonumber(C.GetNumUpgradeSlots(0, menu.id, "shield"))
			for i = numslots, 1, -1 do
				local locgroup = C.GetUpgradeSlotGroup(0, menu.id, "shield", i)
				if (ffi.string(locgroup.path) == "..") and (ffi.string(locgroup.group) == "") then
					for _, shieldgen in pairs(menu.data.Equipment.shieldgentypes) do
						-- check all aliases due to collision / no-collision compatibilities
						local n = C.GetNumLibraryEntryAliases("shieldgentypes", shieldgen.id)
						local buf = ffi.new("const char*[?]", n)
						n = C.GetLibraryEntryAliases(buf, n, "shieldgentypes", shieldgen.id)
						for j = 0, n - 1 do
							local aliasid = ffi.string(buf[j])
							local makerrace = GetMacroData(aliasid, "makerraceid")
							local allowed = menu.isMakerRaceAllowed(makerrace, shipmakerraces)
							if allowed then
								if C.IsUpgradeMacroCompatible(0, 0, menu.id, false, "shield", i, aliasid) then
									local evalshieldgen = GetLibraryEntry("shieldgentypes", aliasid)
									if not bestshield or evalshieldgen.shield > bestshield.shield then
										bestshield = evalshieldgen
									end
								end
							end
						end
					end
				else
					numslots = numslots - 1
				end
			end
			local totalshieldcapacity = 0
			if type(bestshield) == "table" and bestshield.shield then
				totalshieldcapacity = bestshield.shield * numslots
				bestname = bestshield.name
			end
			menu.addDetailRow(ftable, ReadText(1001, 9060) .. ((not hasdefaultloadout) and " (" .. (bestshield and (numslots .. ReadText(1001, 42) .. " ") or "") .. bestname .. ")" or ""), ConvertIntegerString(totalshieldcapacity, true, 0, true) .. " " .. ReadText(1001, 118))
			-- empty line
			menu.addDetailRow(ftable, "")
			-- weapons
			local numslots = tonumber(C.GetNumUpgradeSlots(0, menu.id, "weapon"))
			menu.addDetailRow(ftable, ReadText(1001, 1301), ConvertIntegerString(numslots, true, 0, true))
			-- turrets
			local numslots = tonumber(C.GetNumUpgradeSlots(0, menu.id, "turret"))
			local slotsizes = {
				[1] = { id = "large", text = ReadText(1001, 8081) },
				[2] = { id = "medium", text = ReadText(1001, 8080) },
			}
			local slotspersize = {
				["medium"] = 0,
				["large"] = 0,
			}
			for i = 1, numslots do
				local slotsize = ffi.string(C.GetSlotSize(0, 0, menu.id, false, "turret", i))
				if slotspersize[slotsize] then
					slotspersize[slotsize] = slotspersize[slotsize] + 1
				end
			end
			for _, entry in ipairs(slotsizes) do
				if slotspersize[entry.id] > 0 then
					menu.addDetailRow(ftable, entry.text, ConvertIntegerString(slotspersize[entry.id], true, 0, true))
				end
			end
			-- missile storage
			menu.addDetailRow(ftable, ReadText(1001, 9061), ConvertIntegerString(C.GetDefaultMissileStorageCapacity(menu.id), true, 0, true))

			-- start: kuertee call-back
			if menu.uix_callbacks ["addDetailRow_post_missile_entry"] then		
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["addDetailRow_post_missile_entry"]) do
					uix_callback(ftable, col1, col2, col3, offsetx, iswordwrap, properties1, properties2, properties3, entry)
			    end		
			end
			-- end: kuertee call-back

			-- empty line
			menu.addDetailRow(ftable, "")
			-- crew capacity
			menu.addDetailRow(ftable, ReadText(1001, 9078), ConvertIntegerString(C.GetPeopleCapacity(0, menu.id, true), true, 0, true))
			-- empty line
			menu.addDetailRow(ftable, "")
			-- storage capacity
			menu.addDetailRow(ftable, ReadText(1001, 9063), ConvertIntegerString(menu.object.storagecapacity, true, 0, true))
			-- storage types
			menu.addDetailRow(ftable, ReadText(1001, 9064), menu.object.storagenames)
			-- empty line
			menu.addDetailRow(ftable, "")
			-- m docks
			menu.addDetailRow(ftable, ReadText(1001, 7952), ConvertIntegerString(menu.object.docks_m, true, 0, true))
			-- s docks
			menu.addDetailRow(ftable, ReadText(1001, 7953), ConvertIntegerString(menu.object.docks_s, true, 0, true))
			-- ship storage
			menu.addDetailRow(ftable, ReadText(1001, 9612), ConvertIntegerString(menu.object.shipstoragecapacity, true, 0, true))
			-- units
			menu.addDetailRow(ftable, ReadText(1001, 9062), ConvertIntegerString(menu.object.unitcapacity, true, 0, true))
			-- build resources
			if menu.details.productionmethods and (#menu.details.productionmethods > 0) then
				if #menu.details.blueprintowners > 0 then
					-- empty line
					menu.addDetailRow(ftable, "")
					-- produced by
					menu.addDetailRow(ftable, ReadText(1001, 8391) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.blueprintowners) do
						menu.addDetailRow(ftable, "", GetFactionData(entry, "name"))
					end
				end
				-- resources
				menu.addDetailRow(ftable, "")
				menu.addProductionMethodDetails(ftable, ReadText(1001, 9613), ReadText(1001, 9652))
			end

		elseif menu.mode == "Weapons" then
			-- overridden for component types that have to be constructed in situ or those that have to be crafted with inventory wares
			local prodmethodstring = ReadText(1001, 9607)	-- Resources needed for manufacture, :
			local methodtypestring = ReadText(1001, 2408)
			if menu.library == "weapons_lasers" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				-- burst damage
				menu.addDetailRow(ftable, ReadText(1001, 9092), ConvertIntegerString(menu.object.dps, true, 0, true) .. " " .. ReadText(1001, 119))
				-- sustained damage
				menu.addDetailRow(ftable, ReadText(1001, 9093), ConvertIntegerString(menu.object.sustaineddps, true, 0, true) .. " " .. ReadText(1001, 119))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- shielded target
				menu.addDetailRow(ftable, ReadText(1001, 9642))
				menu.addDetailRow(ftable, ReadText(1001, 2460))
				local miningmultiplier, surfaceelementmultiplier = 0, 0
				if menu.object.isrepairweapon == 0 then
					if menu.object.miningmultiplier and menu.object.miningmultiplier > 1 then
						miningmultiplier = menu.object.miningmultiplier
					end
					if menu.object.surfaceelementmultiplier and menu.object.surfaceelementmultiplier > 1 then
						surfaceelementmultiplier = menu.object.surfaceelementmultiplier
					end
				end
				if menu.object.isrepairweapon == 0 then
					local areadpshot_shield, areadpshot_hull = 0, 0
					if menu.object.hullshieldareadpshot and menu.object.hullshieldareadpshot > 0 then
						areadpshot_shield = areadpshot_shield + menu.object.hullshieldareadpshot
					end
					if menu.object.shieldonlyareadpshot and menu.object.shieldonlyareadpshot > 0 then
						areadpshot_shield = areadpshot_shield + menu.object.shieldonlyareadpshot
					end
					if menu.object.hullonlyareadpshot and menu.object.hullonlyareadpshot > 0 then
						areadpshot_hull = areadpshot_hull + menu.object.hullonlyareadpshot
					end
					if areadpshot_shield > 0 or areadpshot_hull > 0 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2462) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullshielddpshot + menu.object.shieldonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9645) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9644) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullonlyareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						if surfaceelementmultiplier and surfaceelementmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot + menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
						if miningmultiplier and miningmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullonlydpshot + menu.object.shieldonlydamage + menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
					else
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2462), ConvertIntegerString(menu.object.hullshielddpshot + menu.object.shieldonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463), ConvertIntegerString(menu.object.hullonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						if surfaceelementmultiplier and surfaceelementmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
						if miningmultiplier and miningmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
					end
				else
					menu.addDetailRow(ftable, "    " .. ReadText(1001, 2464), ConvertIntegerString(menu.object.hullonlydps, true, 0, true) .. " " .. ReadText(1001, 119))
				end
				-- unshielded target
				menu.addDetailRow(ftable, ReadText(1001, 2461))
				if menu.object.isrepairweapon == 0 then
					local areadpshot_hull = 0
					if menu.object.hullshieldareadpshot and menu.object.hullshieldareadpshot > 0 then
						areadpshot_hull = areadpshot_hull + menu.object.hullshieldareadpshot
					end
					if menu.object.hullonlyareadpshot and menu.object.hullonlyareadpshot > 0 then
						areadpshot_hull = areadpshot_hull + menu.object.hullonlyareadpshot
					end
					if menu.object.hullnoshieldareadpshot and menu.object.hullnoshieldareadpshot > 0 then
						areadpshot_hull = areadpshot_hull + menu.object.hullnoshieldareadpshot
					end
					if areadpshot_hull > 0 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9644) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullshieldareadpshot + menu.object.hullonlyareadpshot + menu.object.hullnoshieldareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						if surfaceelementmultiplier and surfaceelementmultiplier > 0 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot + menu.object.hullshieldareadamage + menu.object.hullonlyareadamage + menu.object.hullnoshieldareadamage) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
						if miningmultiplier and miningmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot + menu.object.hullshieldareadamage + menu.object.hullonlyareadamage + menu.object.hullnoshieldareadamage) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
					else
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463), ConvertIntegerString(menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot, true, 0, true) .. " " .. ReadText(1001, 118))
						if surfaceelementmultiplier and surfaceelementmultiplier > 0 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
						if miningmultiplier and miningmultiplier > 1 then
							menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
						end
					end
				else
					menu.addDetailRow(ftable, "    " .. ReadText(1001, 2464), ConvertIntegerString(menu.object.hullshielddps + menu.object.hullonlydps + menu.object.hullnoshielddps, true, 0, true) .. " " .. ReadText(1001, 119))
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				-- rate
				if menu.object.isbeamweapon == 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9084), Helper.round(menu.object.reloadrate, 2) .. " " .. ReadText(1001, 121))
				end
				-- initial heat
				if menu.object.initialheat > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 2465), ConvertIntegerString(menu.object.initialheat, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- heat buildup
				menu.addDetailRow(ftable, ReadText(1001, 9085), ConvertIntegerString(menu.object.maxheatrate, true, 0, true) .. " " .. ReadText(1001, 119))
				-- cooling rate
				if menu.object.coolingrate and menu.object.coolingrate > -1 then
					menu.addDetailRow(ftable, ReadText(1001, 9626), Helper.round(menu.object.coolingrate, 2) .. " " .. ReadText(1001, 119))
				end
				-- charge time
				if menu.object.chargetime and menu.object.chargetime > -1 then
					menu.addDetailRow(ftable, ReadText(1001, 9627), Helper.round(menu.object.chargetime, 2) .. " " .. ReadText(1001, 100))
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				-- projectile speed
				if menu.object.isbeamweapon == 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9086), ConvertIntegerString(menu.object.bulletspeed, true, 0, true) .. " " .. ReadText(1001, 113))
				end
				-- range
				menu.addDetailRow(ftable, ReadText(1001, 9087), menu.formatRange(menu.object.range) .. " " .. ReadText(1001, 108))
				-- influence
				if menu.object.influencename then
					menu.addDetailRow(ftable, "")
					menu.addDetailRow(ftable, ReadText(1001, 9628), tostring(menu.object.influencename))
					menu.addDetailRow(ftable, "", tostring(menu.object.influencedescription), null, null, true)
				end

			elseif menu.library == "weapons_missilelaunchers" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				-- storage capacity
				menu.addDetailRow(ftable, ReadText(1001, 9063), "+" .. ConvertIntegerString(menu.object.storagecapacity, true, 0, true))

			elseif menu.library == "weapons_turrets" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- dps
				menu.addDetailRow(ftable, ReadText(1001, 9077), ConvertIntegerString(menu.object.dps, true, 0, true) .. " " .. ReadText(1001, 119))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- shielded target
				menu.addDetailRow(ftable, ReadText(1001, 9642))
				menu.addDetailRow(ftable, ReadText(1001, 2460))
				local miningmultiplier, surfaceelementmultiplier = 0, 0
				if menu.object.miningmultiplier and menu.object.miningmultiplier > 1 then
					miningmultiplier = menu.object.miningmultiplier
				end
				if menu.object.surfaceelementmultiplier and menu.object.surfaceelementmultiplier > 1 then
					surfaceelementmultiplier = menu.object.surfaceelementmultiplier
				end
				local areadpshot_shield, areadpshot_hull = 0, 0
				if menu.object.hullshieldareadpshot and menu.object.hullshieldareadpshot > 0 then
					areadpshot_shield = areadpshot_shield + menu.object.hullshieldareadpshot
				end
				if menu.object.shieldonlyareadpshot and menu.object.shieldonlyareadpshot > 0 then
					areadpshot_shield = areadpshot_shield + menu.object.shieldonlyareadpshot
				end
				if menu.object.hullonlyareadpshot and menu.object.hullonlyareadpshot > 0 then
					areadpshot_hull = areadpshot_hull + menu.object.hullonlyareadpshot
				end
				if areadpshot_shield > 0 or areadpshot_hull > 0 then
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2462) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullshielddpshot + menu.object.shieldonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 9645) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 9644) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullonlyareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					if surfaceelementmultiplier and surfaceelementmultiplier > 0 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot + menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
					if miningmultiplier and miningmultiplier > 1 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot + menu.object.hullshieldareadpshot + menu.object.shieldonlyareadpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
				else
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2462), ConvertIntegerString(menu.object.hullshielddpshot + menu.object.shieldonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463), ConvertIntegerString(menu.object.hullonlydpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					if surfaceelementmultiplier and surfaceelementmultiplier > 1 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
					if miningmultiplier and miningmultiplier > 1 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.shieldonlydpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
				end
				-- unshielded target
				menu.addDetailRow(ftable, ReadText(1001, 2461))
				local areadpshot_hull = 0
				if menu.object.hullshieldareadpshot and menu.object.hullshieldareadpshot > 0 then
					areadpshot_hull = areadpshot_hull + menu.object.hullshieldareadpshot
				end
				if menu.object.hullonlyareadpshot and menu.object.hullonlyareadpshot > 0 then
					areadpshot_hull = areadpshot_hull + menu.object.hullonlyareadpshot
				end
				if menu.object.hullnoshieldareadpshot and menu.object.hullnoshieldareadpshot > 0 then
					areadpshot_hull = areadpshot_hull + menu.object.hullnoshieldareadpshot
				end
				if areadpshot_hull > 0 then
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463) .. " (" .. ReadText(1001, 9643) .. ")", ConvertIntegerString(menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 9644) .. " (" .. ReadText(1001, 9640) .. ")", ConvertIntegerString(menu.object.hullshieldareadpshot + menu.object.hullonlyareadpshot + menu.object.hullnoshieldareadpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					if surfaceelementmultiplier and surfaceelementmultiplier > 0 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot + menu.object.hullshieldareadpshot + menu.object.hullonlyareadpshot + menu.object.hullnoshieldareadpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
					if miningmultiplier and miningmultiplier > 1 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot + menu.object.hullshieldareadpshot + menu.object.hullonlyareadpshot + menu.object.hullnoshieldareadpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
				else
					menu.addDetailRow(ftable, "        " .. ReadText(1001, 2463), ConvertIntegerString(menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot, true, 0, true) .. " " .. ReadText(1001, 118))
					if surfaceelementmultiplier and surfaceelementmultiplier > 0 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9646), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot) * surfaceelementmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
					if miningmultiplier and miningmultiplier > 1 then
						menu.addDetailRow(ftable, "        " .. ReadText(1001, 9647), ConvertIntegerString((menu.object.hullshielddpshot + menu.object.hullonlydpshot + menu.object.hullnoshielddpshot) * miningmultiplier, true, 0, true) .. " " .. ReadText(1001, 118))
					end
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				if menu.object.isbeamweapon == 0 then
					-- rate
					menu.addDetailRow(ftable, ReadText(1001, 9084), Helper.round(menu.object.reloadrate, 2) .. " " .. ReadText(1001, 121))
				end
				-- charge time
				if menu.object.chargetime and menu.object.chargetime > -1 then
					menu.addDetailRow(ftable, ReadText(1001, 9627), Helper.round(menu.object.chargetime, 2) .. " " .. ReadText(1001, 100))
				end
				if menu.object.isbeamweapon == 0 then
					-- empty line
					menu.addDetailRow(ftable, "")
					-- projectile speed
					menu.addDetailRow(ftable, ReadText(1001, 9086), ConvertIntegerString(menu.object.bulletspeed, true, 0, true) .. " " .. ReadText(1001, 113))
				end
				-- range
				menu.addDetailRow(ftable, ReadText(1001, 9087), menu.formatRange(menu.object.range) .. " " .. ReadText(1001, 108))
				-- rotation speed
				local printedrot = (menu.object.rotation > 1 and ConvertIntegerString(menu.object.rotation, true, 0, true)) or (menu.object.rotation > 0.1 and Helper.round(menu.object.rotation, 1)) or Helper.round(menu.object.rotation, 2)
				menu.addDetailRow(ftable, ReadText(1001, 2419), printedrot .. " " .. ReadText(1001, 117))
				-- influence
				if menu.object.influencename then
					menu.addDetailRow(ftable, "")
					menu.addDetailRow(ftable, ReadText(1001, 9628), tostring(menu.object.influencename))
					menu.addDetailRow(ftable, "", tostring(menu.object.influencedescription), null, null, true)
				end

			elseif menu.library == "weapons_missileturrets" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- storage capacity
				menu.addDetailRow(ftable, ReadText(1001, 9063), "+" .. ConvertIntegerString(menu.object.storagecapacity, true, 0, true))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- rotation speed
				local printedrot = (menu.object.rotation > 1 and ConvertIntegerString(menu.object.rotation, true, 0, true)) or (menu.object.rotation > 0.1 and Helper.round(menu.object.rotation, 1)) or Helper.round(menu.object.rotation, 2)
				menu.addDetailRow(ftable, ReadText(1001, 2419), printedrot .. " " .. ReadText(1001, 117))

			elseif menu.library == "missiletypes" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- explosion
				if menu.object.explosiondamage > 0 or (menu.object.hullexplosiondamage < 1 and menu.object.shieldexplosiondamage < 1) then
					menu.addDetailRow(ftable, ReadText(1001, 9088), ConvertIntegerString(menu.object.explosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- hull explosion
				if menu.object.hullexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 1) .. ")", ConvertIntegerString(menu.object.hullexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- shield explosion
				if menu.object.shieldexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 2) .. ")", ConvertIntegerString(menu.object.shieldexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- range
				menu.addDetailRow(ftable, ReadText(1001, 9087), menu.formatRange(menu.object.range) .. " " .. ReadText(1001, 108))
				if menu.object.locktime > 0 then
					-- lock range
					menu.addDetailRow(ftable, ReadText(1001, 9649), menu.formatRange(menu.object.maxlockrange) .. " " .. ReadText(1001, 108))
					-- lock time
					menu.addDetailRow(ftable, ReadText(1001, 9650), ConvertIntegerString(menu.object.locktime, true, 0, true) .. " " .. ReadText(1001, 100))
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				-- speed
				menu.addDetailRow(ftable, ReadText(1001, 9054), ConvertIntegerString(menu.object.speed, true, 0, true) .. " " .. ReadText(1001, 113))
				-- turning rate
				local printedyaw = (menu.object.yawspeed > 1 and ConvertIntegerString(menu.object.yawspeed, true, 0, true)) or (menu.object.yawspeed > 0.1 and Helper.round(menu.object.yawspeed, 1)) or Helper.round(menu.object.yawspeed, 2)
				menu.addDetailRow(ftable, ReadText(1001, 9055), printedyaw .. " " .. ReadText(1001, 117))
				-- pitch rate
				local printedpitch = (menu.object.pitchspeed > 1 and ConvertIntegerString(menu.object.pitchspeed, true, 0, true)) or (menu.object.pitchspeed > 0.1 and Helper.round(menu.object.pitchspeed, 1)) or Helper.round(menu.object.pitchspeed, 2)
				menu.addDetailRow(ftable, ReadText(1001, 9056), printedpitch .. " " .. ReadText(1001, 117))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- vertical strafe
				menu.addDetailRow(ftable, ReadText(1001, 9058), ConvertIntegerString(menu.object.verticalstrafespeed, true, 0, true) .. " " .. ReadText(1001, 113))
				-- horizontal strafe
				menu.addDetailRow(ftable, ReadText(1001, 9059), ConvertIntegerString(menu.object.horizontalstrafespeed, true, 0, true) .. " " .. ReadText(1001, 113))
				-- influence
				if menu.object.influencename then
					menu.addDetailRow(ftable, "")
					menu.addDetailRow(ftable, ReadText(1001, 9628), tostring(menu.object.influencename))
					menu.addDetailRow(ftable, "", tostring(menu.object.influencedescription), null, null, true)
				end
				-- counter measure resilience
				if menu.object.guided then
					menu.addDetailRow(ftable, "")
					menu.addDetailRow(ftable, ReadText(1001, 9651), ConvertIntegerString(menu.object.countermeasureresilience * 100, true, 0, true) .. "%")
				end

			elseif menu.library == "mines" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- explosion
				if menu.object.explosiondamage > 0 or (menu.object.hullexplosiondamage < 1 and menu.object.shieldexplosiondamage < 1) then
					menu.addDetailRow(ftable, ReadText(1001, 9088), ConvertIntegerString(menu.object.explosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- hull explosion
				if menu.object.hullexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 1) .. ")", ConvertIntegerString(menu.object.hullexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- shield explosion
				if menu.object.shieldexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 2) .. ")", ConvertIntegerString(menu.object.shieldexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				-- tracking
				menu.addDetailRow(ftable, ReadText(1001, 9089), menu.object.istracking and ReadText(1001, 2617) or ReadText(1001, 2618))
				-- friend/foe
				menu.addDetailRow(ftable, ReadText(1001, 9090), menu.object.isfriendfoe and ReadText(1001, 2617) or ReadText(1001, 2618))
				-- proximity
				menu.addDetailRow(ftable, ReadText(1001, 9091), (menu.object.proximityrange > 0) and (Helper.round(menu.object.proximityrange) .. " " .. ReadText(1001, 107)) or ReadText(1001, 2618))

			elseif menu.library == "bombs" then
				prodmethodstring = ReadText(1001, 9605)	-- Resources needed to craft, :
				-- explosion
				if menu.object.explosiondamage > 0 or (menu.object.hullexplosiondamage < 1 and menu.object.shieldexplosiondamage < 1) then
					menu.addDetailRow(ftable, ReadText(1001, 9088), ConvertIntegerString(menu.object.explosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- hull explosion
				if menu.object.hullexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 1) .. ")", ConvertIntegerString(menu.object.hullexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end
				-- shield explosion
				if menu.object.shieldexplosiondamage > 0 then
					menu.addDetailRow(ftable, ReadText(1001, 9088) .. " (" .. ReadText(1001, 2) .. ")", ConvertIntegerString(menu.object.shieldexplosiondamage, true, 0, true) .. " " .. ReadText(1001, 118))
				end

			end
			-- build resources
			if menu.details.productionmethods and (#menu.details.productionmethods > 0) then
				-- empty line
				menu.addDetailRow(ftable, "")
				menu.addProductionMethodDetails(ftable, prodmethodstring, methodtypestring)
			end

		elseif menu.mode == "Equipment" then
			-- TODO #nick: add equipment mods?
			-- overridden for component types that have to be constructed in situ
			local prodmethodstring = ReadText(1001, 9607)	-- Resources needed for manufacture, :
			local methodtypestring = ReadText(1001, 2408)
			if menu.library == "enginetypes" or menu.library == "thrustertypes" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				local isvirtual = GetMacroData(menu.details.id, "isvirtual")
				if not isvirtual then
					-- hull
					menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
					-- empty line
					menu.addDetailRow(ftable, "")
				end
				if menu.object.thrust_forward > 0 then
					-- forward
					menu.addDetailRow(ftable, ReadText(1001, 9065), ConvertIntegerString(menu.object.thrust_forward, true, 0, true) .. " " .. ReadText(1001, 115))
					-- reverse
					if menu.object.thrust_reverse > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9066), ConvertIntegerString(menu.object.thrust_reverse, true, 0, true) .. " " .. ReadText(1001, 115))
					end
					-- empty line
					menu.addDetailRow(ftable, "")
					-- boost
					if menu.object.boost_thrustfactor > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9067), ConvertIntegerString(menu.object.thrust_forward * menu.object.boost_thrustfactor, true, 0, true) .. " " .. ReadText(1001, 115))
					end
					-- boost duration
					if menu.object.boost_maxduration > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9068), ConvertIntegerString(menu.object.boost_maxduration, true, 0, true) .. " " .. ReadText(1001, 100))
					end
					if menu.object.boost_chargetime > 0 or menu.object.boost_rechargetime > 1 then
						-- boost charge
						if menu.object.boost_chargetime > 0 then
							menu.addDetailRow(ftable, ReadText(1001, 9070), ConvertIntegerString(menu.object.boost_chargetime, true, 0, true) .. " " .. ReadText(1001, 100))
						elseif menu.object.boost_rechargetime > 1 then
							menu.addDetailRow(ftable, ReadText(1001, 9070), ConvertIntegerString(menu.object.boost_rechargetime, true, 0, true) .. " " .. ReadText(1001, 100))
						end
						-- immediate boost
						menu.addDetailRow(ftable, ReadText(1001, 9071), (menu.object.boost_chargetime == 0 and menu.object.boost_rechargetime > 1) and ReadText(1001, 2617) or ReadText(1001, 2618))
					end
					if menu.object.travel_thrustfactor and menu.object.travel_thrustfactor > 0 then
						menu.addDetailRow(ftable, "")
						-- travel mode: max thrust
						menu.addDetailRow(ftable, ReadText(1001, 9629), ConvertIntegerString(menu.object.thrust_forward * menu.object.travel_thrustfactor, true, 0, true) .. " " .. ReadText(1001, 115))
						-- travel mode: charge time
						menu.addDetailRow(ftable, ReadText(1001, 9630), ConvertIntegerString(menu.object.travel_chargetime, true, 0, true) .. " " .. ReadText(1001, 100))
						-- travel mode: attack time
						menu.addDetailRow(ftable, ReadText(1001, 9631), ConvertIntegerString(menu.object.travel_attacktime, true, 0, true) .. " " .. ReadText(1001, 100))
					end
					-- empty line
					menu.addDetailRow(ftable, "")
				end
				if menu.object.thrust_yaw > 0 then
					-- turning thrust
					if menu.object.thrust_yaw > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9072), Helper.round(menu.object.thrust_yaw * 180 / math.pi) .. " " .. ReadText(1001, 115))
					end
					-- pitch thrust
					if menu.object.thrust_pitch > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9073), Helper.round(menu.object.thrust_pitch * 180 / math.pi) .. " " .. ReadText(1001, 115))
					end
					-- empty line
					menu.addDetailRow(ftable, "")
					-- horizontal strafe
					if menu.object.thrust_horizontal > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9074), ConvertIntegerString(menu.object.thrust_horizontal, true, 0, true) .. " " .. ReadText(1001, 115))
					end
					-- vertical strafe
					if menu.object.thrust_vertical > 0 then
						menu.addDetailRow(ftable, ReadText(1001, 9075), ConvertIntegerString(menu.object.thrust_horizontal, true, 0, true) .. " " .. ReadText(1001, 115))
					end
				end

			elseif menu.library == "shieldgentypes" then
				prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
				methodtypestring = ReadText(1001, 9652)
				if not GetMacroData(menu.details.id, "isintegrated") then
					-- hull
					menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
					-- empty line
					menu.addDetailRow(ftable, "")
				end
				-- shield capacity
				menu.addDetailRow(ftable, ReadText(1001, 9060), ConvertIntegerString(menu.object.shield, true, 0, true) .. " " .. ReadText(1001, 118))
				-- shield recharge
				menu.addDetailRow(ftable, ReadText(1001, 9079), ConvertIntegerString(menu.object.recharge, true, 0, true) .. " " .. ReadText(1001, 119))
				-- shield recharge delay
				menu.addDetailRow(ftable, ReadText(1001, 9618), menu.object.rechargedelay .. " " .. ReadText(1001, 100))

			elseif menu.library == "satellites" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- radar range
				menu.addDetailRow(ftable, ReadText(1001, 2426), ConvertIntegerString(menu.object.radarrange / 1000, true, 0, true) .. " " .. ReadText(1001, 108))

			elseif menu.library == "navbeacons" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))

			elseif menu.library == "resourceprobes" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))
				-- empty line
				menu.addDetailRow(ftable, "")
				-- detection range
				menu.addDetailRow(ftable, ReadText(1001, 9082), ConvertIntegerString(GetMacroData(menu.details.id, "resourcedetectionrange") / 1000, true, 0, true) .. " " .. ReadText(1001, 108))

			elseif menu.library == "lasertowers" then
				-- hull
				menu.addDetailRow(ftable, ReadText(1001, 9083), ConvertIntegerString(menu.object.hull, true, 0, true) .. " " .. ReadText(1001, 118))

			elseif menu.library == "software" then
				if menu.object.isscanner then
					prodmethodstring = ReadText(1001, 9613)	-- Resources needed for construction, :
					methodtypestring = ReadText(1001, 9652)
					-- scan resolution
					menu.addDetailRow(ftable, ReadText(1001, 9080), menu.object.scanlevel)
					-- long range
					menu.addDetailRow(ftable, ReadText(1001, 9081), menu.object.islongrange and ReadText(1001, 2617) or ReadText(1001, 2618))

					if menu.object.islongrange then
						-- empty line
						menu.addDetailRow(ftable, "")
						menu.addDetailRow(ftable, ReadText(1001, 9633), ConvertIntegerString(menu.object.maxrange / 1000, true, 0, true) .. " " .. ReadText(1001, 108))
						menu.addDetailRow(ftable, ReadText(1001, 9634), Helper.round(2 * menu.object.maxyawangle) .. ReadText(1001, 109))
						menu.addDetailRow(ftable, ReadText(1001, 9635), Helper.round(2 * menu.object.maxpitchangle) .. ReadText(1001, 109))
					end
				end

			elseif menu.library == "paintmods" then
				local locware = menu.object
				local first = true
				-- ware source
				if #menu.details.waresources > 0 then
					if not first then
						-- empty line
						menu.addDetailRow(ftable, "")
					end
					first = false
					-- title
					menu.addDetailRow(ftable, ReadText(1001, 9615) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.waresources) do
						if menu.details.haswaresourcelocation then
							menu.addDetailRow(ftable, "", entry.type, entry.location)
						else
							menu.addDetailRow(ftable, "", entry.type)
						end
					end
				end
				if not first then
					-- empty line
					menu.addDetailRow(ftable, "")
				end
				first = false
				-- average price
				menu.addDetailRow(ftable, ReadText(1001, 2980), ConvertMoneyString(locware.avgprice, false, true, 0, true) .. " " .. ReadText(1001, 101))

			end
			-- build resources
			if menu.details.productionmethods and (#menu.details.productionmethods > 0) then
				-- empty line
				menu.addDetailRow(ftable, "")
				menu.addProductionMethodDetails(ftable, prodmethodstring, methodtypestring)
			end

		elseif menu.mode == "Licences" then
			-- min relation
			menu.addDetailRow(ftable, ReadText(1001, 2458), menu.object.minrelation)
			-- issellable
			if menu.object.issellable then
				if menu.object.precursor ~= "" then
					local licenceinfo = ffi.new("LicenceInfo")
					C.GetLicenceInfo(licenceinfo, menu.object.factionid, menu.object.precursor)
					local precursorname = ffi.string(licenceinfo.name)

					menu.addDetailRow(ftable, ReadText(1001, 2493), string.format(ReadText(1001, 2495), precursorname))
				end
				menu.addDetailRow(ftable, ReadText(1001, 2457), ReadText(20208, 10601))
			elseif menu.object.precursor ~= "" then
				local licenceinfo = ffi.new("LicenceInfo")
				C.GetLicenceInfo(licenceinfo, menu.object.factionid, menu.object.precursor)
				local precursorname = ffi.string(licenceinfo.name)

				menu.addDetailRow(ftable, ReadText(1001, 2494), string.format(ReadText(1001, 2495), precursorname))
			elseif menu.object.minrelation < 0 then
				menu.addDetailRow(ftable, ReadText(1001, 2497), ReadText(1001, 2498))
			else
				menu.addDetailRow(ftable, ReadText(1001, 2494), ReadText(1001, 2496))
			end

		elseif menu.mode == "Wares" then
			local locware = menu.object
			if menu.library == "wares" then
				-- volume
				menu.addDetailRow(ftable, ReadText(1001, 1407), locware.volume .. " " .. ReadText(1001, 110))
				-- storage
				menu.addDetailRow(ftable, ReadText(1001, 2415), menu.transporttypes[locware.transporttype].name)
				-- resources
				if menu.details.productionmethods and (#menu.details.productionmethods > 0) then
					-- empty line
					menu.addDetailRow(ftable, "")
					menu.addProductionMethodDetails(ftable, ReadText(1001, 9421), ReadText(1001, 2408), ReadText(1001, 2411), ReadText(1001, 9418))
				end
				-- products
				if menu.details.products and (#menu.details.products > 0) then
					-- empty line
					menu.addDetailRow(ftable, "")
					-- title
					menu.addDetailRow(ftable, ReadText(1001, 9608) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.products) do
						menu.addDetailRow(ftable, "", entry.name)
					end
				end
				-- illegal
				local first = true
				for i, entry in ipairs(menu.object.illegalto) do
					if entry.known then
						if first then
							-- empty line
							menu.addDetailRow(ftable, "")
							-- title
							menu.addDetailRow(ftable, ReadText(1001, 2437) .. ReadText(1001, 120))
							first = false
						end
						menu.addDetailRow(ftable, "", entry.name)
					end
				end
				-- empty line
				menu.addDetailRow(ftable, "")
				-- average price
				menu.addDetailRow(ftable, ReadText(1001, 2980), ConvertMoneyString(locware.avgprice, false, true, 0, true) .. " " .. ReadText(1001, 101))

			elseif menu.library == "inventory_wares" then
				local first = true
				-- build resources
				if menu.details.resources and (#menu.details.resources > 0) then
					if not first then
						-- empty line
						menu.addDetailRow(ftable, "")
					end
					first = false
					-- title
					menu.addDetailRow(ftable, ReadText(1001, 9605) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.resources) do
						menu.addDetailRow(ftable, "", entry.amount .. ReadText(1001, 42) .. " " .. entry.name)
					end
				end
				-- products
				if menu.details.products and (#menu.details.products > 0) then
					if not first then
						-- empty line
						menu.addDetailRow(ftable, "")
					end
					first = false
					-- title
					menu.addDetailRow(ftable, ReadText(1001, 9606) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.products) do
						menu.addDetailRow(ftable, "", entry.name)
					end
				end
				-- illegal
				local firstillegal = true
				for _, entry in ipairs(menu.object.illegalto) do
					if entry.known then
						if firstillegal then
							if not first then
								-- empty line
								menu.addDetailRow(ftable, "")
							end
							first = false
							-- title
							menu.addDetailRow(ftable, ReadText(1001, 2437) .. ReadText(1001, 120))
							firstillegal = false
						end
						menu.addDetailRow(ftable, "", entry.name)
					end
				end
				-- ware source
				if #menu.details.waresources > 0 then
					if not first then
						-- empty line
						menu.addDetailRow(ftable, "")
					end
					first = false
					-- title
					menu.addDetailRow(ftable, ReadText(1001, 9615) .. ReadText(1001, 120))
					for i, entry in ipairs(menu.details.waresources) do
						if menu.details.haswaresourcelocation then
							menu.addDetailRow(ftable, "", entry.type, entry.location)
						else
							menu.addDetailRow(ftable, "", entry.type)
						end
					end
				end
				if not first then
					-- empty line
					menu.addDetailRow(ftable, "")
				end
				first = false
				-- average price
				menu.addDetailRow(ftable, ReadText(1001, 2980), ConvertMoneyString(locware.avgprice, false, true, 0, true) .. " " .. ReadText(1001, 101))

			else
				DebugError("Unhandled. Ware is neither an economy ware nor an inventory ware.")
			end
		elseif menu.mode == "Blueprints" then
			for i, subcategory in ipairs(menu.index["Blueprints"][menu.object].subcategories) do
				local data = Helper.tableCopy(menu.details[subcategory.key])
				if subcategory.additionalcategories then
					for _, additionalcategory in ipairs(subcategory.additionalcategories) do
						for _, v in ipairs(menu.details[additionalcategory]) do
							table.insert(data, v)
						end
					end
					table.sort(data, Helper.sortName)
				end
				if data then
					if i > 1 then
						-- empty line
						menu.addDetailRow(ftable, "")
					end
					-- header
					local row = ftable:addRow(false, {  })
					row[2]:setColSpan(2):setBackgroundColSpan(3):createText(data.name, Helper.headerRow1Properties)
					local unlocked, count, owned = 0, 0, 0
					for i, entry in ipairs(data) do
						if entry.unlocked then
							unlocked = unlocked + 1
						end
						if not entry.hidden then
							count = count + 1
						end
						if entry.owned then
							owned = owned + 1
						end
					end
					row[4]:createText(owned .. " / " .. count, Helper.headerRow1Properties)
					row[4].properties.halign = "right"

					for i, entry in ipairs(data) do
						if entry.unlocked then
							menu.numDetailRows = menu.numDetailRows + 1
							local row = ftable:addRow(("detailrow_" .. menu.numDetailRows), { interactive = false })
							row[2]:createText(entry.name, { color = entry.owned and Color["text_normal"] or Color["text_inactive"], mouseOverText = entry.owned and "" or ReadText(1001, 9622) })
							row[3]:setColSpan(2):createText(entry.owned and (ColorText["text_player"] .. ReadText(1001, 84)) or "", { halign = "right" })
						end
					end

					if unlocked < count then
						menu.addDetailRow(ftable, string.format(ReadText(1001, 9623), count - unlocked))
					end
				end
			end
		end
	end
end

function menu.createGraph(width, height, x, y)
	-- data
	menu.graphdata = {}
	local buyDataWeights = {}
	local sellDataWeights = {}
	local ffiHelper = {}
	local numstats = C.GetNumTradeOfferStatistics(ConvertIDTo64Bit(menu.object), menu.xStart, menu.xEnd, config.graph.numdatapoints)
	if numstats > 0 then
		local result = ffi.new("UITradeOfferStat[?]", numstats)
		for i = 0, numstats - 1 do
			table.insert(ffiHelper, 1, ffi.new("UITradeOfferStatData[?]", config.graph.numdatapoints))
			result[i].data = ffiHelper[1]
		end
		numstats = C.GetTradeOfferStatistics(result, numstats, config.graph.numdatapoints)
		for i = 0, numstats - 1 do
			local ware = ffi.string(result[i].wareid)
			local text = GetWareData(ware, "name")
			local dataIdx = menu.getDataIdxByWare(ware)
			if not dataIdx then
				table.insert(menu.graphdata, { shown = false, text = text, ware = ware, selldata = {}, buydata = {} })
				dataIdx = #menu.graphdata
			end
			buyDataWeights[dataIdx]  = buyDataWeights[dataIdx]  or { ware = ware, dataIdx = dataIdx, count = 0, amount = 0 }
			sellDataWeights[dataIdx] = sellDataWeights[dataIdx] or { ware = ware, dataIdx = dataIdx, count = 0, amount = 0 }
			for j = 0, result[i].numdata - 1 do
				local y = tonumber(result[i].data[j].amount)
				if result[i].isSellOffer then
					menu.graphdata[dataIdx].selldata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					sellDataWeights[dataIdx].count = sellDataWeights[dataIdx].count + 1
					sellDataWeights[dataIdx].amount = sellDataWeights[dataIdx].amount + y
				else
					menu.graphdata[dataIdx].buydata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					buyDataWeights[dataIdx].count = buyDataWeights[dataIdx].count + 1
					buyDataWeights[dataIdx].amount = buyDataWeights[dataIdx].amount + y
				end
			end
		end
	end

	for _, data in ipairs(buyDataWeights) do
		if data.count > 0 then
			data.amount = data.amount / data.count
		end
	end
	table.sort(buyDataWeights, function (a, b) return a.amount > b.amount end)
	for _, data in ipairs(sellDataWeights) do
		if data.count > 0 then
			data.amount = data.amount / data.count
		end
	end
	table.sort(sellDataWeights, function (a, b) return a.amount > b.amount end)

	-- table
	local table_graph = menu.frame:addTable(9, { y = y, tabOrder = 4, width = width, x = x })
	for i = 1, 4 do
		table_graph:setColWidth(2 * i, Helper.standardTextHeight)
	end

	local row = table_graph:addRow(false, { fixed = true })
	row[1]:setColSpan(9):createText(ReadText(1001, 2489), Helper.headerRow1Properties)

	local graphrow = table_graph:addRow(false, { fixed = true })

	local row = table_graph:addRow(true, { fixed = true })
	row[1]:createText(ReadText(1001, 2954) .. ReadText(1001, 120))
	for i = 1, 4 do
		if buyDataWeights[i] and (buyDataWeights[i].amount > 0) then
			row[2 * i]:createCheckBox(not menu.hiddenData.buy[i])
			row[2 * i].handlers.onClick = function (id) return menu.checkboxGraphData(id, "buy", i) end
			row[2 * i + 1]:createText(GetWareData(buyDataWeights[i].ware, "name"), { color = config.graph.datarecordcolors[i].buy })
		end
	end

	local row = table_graph:addRow(true, { fixed = true })
	row[1]:createText(ReadText(1001, 2955) .. ReadText(1001, 120))
	for i = 1, 4 do
		if sellDataWeights[i] and (sellDataWeights[i].amount > 0) then
			row[2 * i]:createCheckBox(not menu.hiddenData.sell[i])
			row[2 * i].handlers.onClick = function (id) return menu.checkboxGraphData(id, "sell", i) end
			row[2 * i + 1]:createText(GetWareData(sellDataWeights[i].ware, "name"), { color = config.graph.datarecordcolors[i].sell })
		end
	end

	local graph = graphrow[1]:setColSpan(9):createGraph({ height = height - table_graph:getFullHeight(), scaling = false })

	-- graph setup
	local minY, maxY = 0, 1
	for i = 1, 4 do
		if buyDataWeights[i] and (buyDataWeights[i].amount > 0) and (not menu.hiddenData.buy[i]) then
			if next(menu.graphdata[buyDataWeights[i].dataIdx].buydata) then
				local highlight = menu.selectedrowdata == entry
				local color = config.graph.datarecordcolors[i].buy
				if hashighlight and (not highlight) then
					color.a = 50
				end
				local datarecord = graph:addDataRecord({
					markertype = config.graph.point.type,
					markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
					markercolor = color,
					linetype = config.graph.line.type,
					linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
					linecolor = color,
					mouseOverText = ReadText(1001, 2916) .. ReadText(1001, 120) .. " " .. menu.graphdata[buyDataWeights[i].dataIdx].text,
				})

				for i, point in pairs(menu.graphdata[buyDataWeights[i].dataIdx].buydata) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
				end
			end
		end
		
		if sellDataWeights[i] and (sellDataWeights[i].amount > 0) and (not menu.hiddenData.sell[i]) then
			if next(menu.graphdata[sellDataWeights[i].dataIdx].selldata) then
				local highlight = menu.selectedrowdata == entry
				local color = config.graph.datarecordcolors[i].sell
				if hashighlight and (not highlight) then
					color.a = 50
				end
				local datarecord = graph:addDataRecord({
					markertype = config.graph.point.type,
					markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
					markercolor = color,
					linetype = config.graph.line.type,
					linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
					linecolor = color,
					mouseOverText = ReadText(1001, 2917) .. ReadText(1001, 120) .. " " .. menu.graphdata[sellDataWeights[i].dataIdx].text,
				})

				for i, point in pairs(menu.graphdata[sellDataWeights[i].dataIdx].selldata) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
				end
			end
		end
	end

	local mingranularity = maxY / 12
	local maxgranularity = maxY / 8
	local granularity = 0.1
	for _, factor in ipairs(config.graph.factors) do
		local testgranularity = math.ceil(mingranularity / factor) * factor
		if testgranularity >= maxgranularity then
			break;
		end
		granularity = testgranularity
	end
	maxY = (math.ceil(maxY / granularity) + 0.5) * granularity

	local xRange = (menu.xEnd - menu.xStart) / menu.xScale
	local xGranularity = Helper.round(menu.xGranularity / menu.xScale, 3)
	local xOffset = xRange % xGranularity

	graph:setXAxis({ startvalue = -xRange, endvalue = 0, granularity = xGranularity, offset = xOffset, gridcolor = Color["graph_grid"] })
	graph:setXAxisLabel(menu.xTitle, { fontsize = 9 })
	graph:setYAxis({ startvalue = 0, endvalue = maxY, granularity = granularity, offset = 0, gridcolor = Color["graph_grid"] })
	graph:setYAxisLabel(menu.yTitle, { fontsize = 9 })
end

function menu.getDataIdxByWare(ware)
	for i, data in ipairs(menu.graphdata) do
		if data.ware == ware then
			return i
		end
	end

	return nil
end

function menu.checkboxGraphData(id, type, i)
	if (not menu.displayRunning) then
		menu.hiddenData[type][i] = not menu.hiddenData[type][i]
		menu.refresh = true
	else
		C.SetCheckBoxChecked(id, not menu.hiddenData[type][i], true)
	end
end

function menu.isMakerRaceAllowed(makerraces, objectmakerraces)
	local allowed = true
	for _, race in ipairs(makerraces) do
		if objectmakerraces then
			local raceallowed = false		
			for _, objectrace in ipairs(objectmakerraces) do
				if objectrace == race then
					raceallowed = true
					break
				end
			end
			if raceallowed then
				-- always allow the equipment if the maker race matches the maker race of the object it is for
				allowed = true
				break
			end
		end
		if (race == "xenon") or (race == "khaak") then
			allowed = false
			break
		end
	end
	return (next(makerraces) == nil) or allowed
end

-- input in m
function menu.formatRange(range)
	return (range > 10000) and ConvertIntegerString(range / 1000, true, 0, true) or Helper.round(range / 1000, (range > 1000) and 1 or 3)
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿
-- section == gMain_map
-- param == { 0, 0, showzone, focuscomponent [, history] [, mode, modeparam] [, showmultiverse] [, focusoffset] }

-- modes: - "orderparam_object",	param: { returnfunction, paramdata, toprow, ordercontrollable }
--		  - "orderparam_position",	param: { returnfunction, paramdata, toprow, ordercontrollable }
--		  - "selectbuildlocation",	param: { returnsection, { 0, 0, trader, buildership_or_module, object, macro } }
--		  - "tradecontext",			param: { station, initialtradingship, iswareexchange, shadyOnly, loop, trader }
--		  - "selectCV",				param: { buildstorage }
--		  - "infomode",				param: { mode, ... }
--		  - "boardingcontext",		param: { target, boardingships }
--		  - "hire",					param: { returnsection, npc_or_context, ishiring[, npctemplate] }
--		  - "sellships",			param: { shipyard, ships }
--		  - "dropwarescontext",		param: { mode, entity }
--		  - "renamecontext",		param: { component, renamefleet }

--        -- kuertee start: multi-rename: requires menu_interactmenu.uix_forcedShowMenu
--		  - "renamecontext",		param: { component, renamefleet, uix_multiRename_objects }
--        -- kuertee end: multi-rename

--		  - "changelogocontext",	param: { component }
--		  - "selectComponent",		param: { returnsection, classlist[, category][, playerowned][, customheading] }
--		  - "crewtransfercontext",	param: { othership, ship }
--		  - "ventureconsole",		param: { ventureplatform }
--		  - "venturepatroninfo",	param: { ventureplatform }
--		  - "venturereport",		param: { mode, reason[, timestamp, author][, transactionid] }
--		  - "behaviourinspection",	param: { target }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t AIOrderID;
	typedef int32_t BlacklistID;
	typedef uint64_t BuildTaskID;
	typedef int32_t FightRuleID;
	typedef uint64_t FleetUnitID;
	typedef uint64_t MissionID;
	typedef uint64_t NPCSeed;
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingBehaviour;
	typedef struct {
		const char* id;
		const char* text;
	} BoardingPhase;
	typedef struct {
		uint32_t approach;
		uint32_t insertion;
	} BoardingRiskThresholds;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		UniverseID controllableid;
		FleetUnitID fleetunitid;
		int32_t groupindex;
	} CommanderInfo;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
	} CrewTransferContainer;
	typedef struct {
		const char* id;
		const char* name;
	} ControlPostInfo;
	typedef struct {
		UniverseID entity;
		UniverseID personcontrollable;
		NPCSeed personseed;
	} GenericActor;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
	} ResponseInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		uint32_t numresponses;
		const char* defaultresponse;
		bool ask;
	} SignalInfo;
	typedef struct {
		const char* name;
		const char* transport;
		uint32_t spaceused;
		uint32_t capacity;
	} StorageInfo;
	typedef struct {
		int x;
		int y;
	} Coord2D;
	typedef struct {
		float x;
		float y;
		float z;
	} Coord3D;
	typedef struct {
		float dps;
		uint32_t quadranttextid;
	} DPSData;
	typedef struct {
		const char* id;
		const char* name;
		bool possible;
	} DroneModeInfo;
	typedef struct {
		const char* factionID;
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		FleetUnitID fleetunitid;
		const char* name;
		const char* idcode;
		const char* macro;
		BuildTaskID buildtaskid;
		UniverseID replacementid;
	} FleetUnitInfo;
	typedef struct {
		const char* icon;
		const char* caption;
	} MissionBriefingIconInfo;
	typedef struct {
		const char* missionName;
		const char* missionDescription;
		int difficulty;
		int upkeepalertlevel;
		const char* threadType;
		const char* mainType;
		const char* subType;
		const char* subTypeName;
		const char* faction;
		int64_t reward;
		const char* rewardText;
		size_t numBriefingObjectives;
		int activeBriefingStep;
		const char* opposingFaction;
		const char* license;
		float timeLeft;
		double duration;
		bool abortable;
		bool hasObjective;
		UniverseID associatedComponent;
		UniverseID threadMissionID;
	} MissionDetails;
	typedef struct {
		const char* id;
		const char* name;
	} MissionGroupDetails;
	typedef struct {
		MissionID missionid;
		uint32_t amount;
		uint32_t numskills;
		SkillInfo* skills;
	} MissionNPCInfo;
	typedef struct {
		const char* text;
		const char* actiontext;
		const char* detailtext;
		int step;
		bool failed;
		bool completedoutofsequence;
	} MissionObjectiveStep3;
	typedef struct {
		uint32_t id;
		bool ispin;
		bool ishome;
	} MultiverseMapPickInfo;
	typedef struct {
		NPCSeed seed;
		const char* roleid;
		int32_t tierid;
		const char* name;
		int32_t combinedskill;
	} NPCInfo;
	typedef struct {
		const char* chapter;
		const char* onlineid;
	} OnlineMissionInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* icon;
		const char* description;
		const char* category;
		const char* categoryname;
		bool infinite;
		uint32_t requiredSkill;
	} OrderDefinition;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
		bool isoverride;
	} Order2;
	typedef struct {
		uint32_t id;
		AIOrderID orderid;
		const char* orderdef;
		const char* message;
		double timestamp;
		bool wasdefaultorder;
		bool wasinloop;
	} OrderFailure;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		UniverseID context;
		const char* group;
		UniverseID component;
	} ShieldGroup;
	typedef struct {
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
	} Skill2;
	typedef struct {
		UniverseID softtargetID;
		const char* softtargetConnectionName;
		uint32_t messageID;
	} SofttargetDetails2;
	typedef struct {
		const char* max;
		const char* current;
	} SoftwareSlot;
	typedef struct {
		UniverseID controllableid;
		int group;
	} SubordinateGroup;
	typedef struct {
		uint32_t id;
		UniverseID owningcontrollable;
		size_t owningorderidx;
		bool reached;
	} SyncPointInfo2;
	typedef struct {
		const char* reason;
		NPCSeed person;
		NPCSeed partnerperson;
	} UICrewExchangeResult;
	typedef struct {
		const char* shape;
		const char* name;
		uint32_t requiredSkill;
		float radius;
		bool rollMembers;
		bool rollFormation;
		size_t maxShipsPerLine;
	} UIFormationInfo;
	typedef struct {
		const char* macro;
		uint32_t amount;
		bool optional;
	} UILoadoutAmmoData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
	} UILoadoutGroupData;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
	} UILoadoutMacroData;
	typedef struct {
		const char* ware;
	} UILoadoutSoftwareData;
	typedef struct {
		const char* macro;
		bool optional;
	} UILoadoutVirtualMacroData;
	typedef struct {
		UILoadoutMacroData* weapons;
		uint32_t numweapons;
		UILoadoutMacroData* turrets;
		uint32_t numturrets;
		UILoadoutMacroData* shields;
		uint32_t numshields;
		UILoadoutMacroData* engines;
		uint32_t numengines;
		UILoadoutGroupData* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
	} UILoadout;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		const char* icon;
		Color color;
		uint32_t volume_s;
		uint32_t volume_m;
		uint32_t volume_l;
	} UIMapTradeVolumeParameter;
	typedef struct {
		const char* id;
		const char* name;
	} UIModuleSet;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	typedef struct {
		bool primary;
		uint32_t idx;
	} UIWeaponGroup;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		const char* id;
		const char* icon;
		const char* factoryname;
		const char* factorydesc;
		const char* factorymapicon;
		const char* factoryhudicon;
		uint32_t tier;
	} WareGroupInfo;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;
	typedef struct {
		const char* ware;
		int32_t current;
		int32_t max;
	} WareYield;
	typedef struct {
		const char* id;
		const char* name;
		bool active;
	} WeaponSystemInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	typedef struct {
		const char* wareid;
		int32_t amount;
	} YieldInfo;

	typedef struct {
		UIPosRot offset;
		float cameradistance;
	} HoloMapState;
	typedef struct {
		UniverseID target;
		UIWareAmount* wares;
		uint32_t numwares;
	} MissionWareDeliveryInfo;
	typedef struct {
		UniverseID shipid;
		const char* macroname;
		UILoadout loadout;
		uint32_t amount;
	} UIBuildOrderList;
	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	typedef struct {
		const char* objectiveText;
		float timeout;
		const char* progressname;
		uint32_t curProgress;
		uint32_t maxProgress;
		size_t numTargets;
	} MissionObjective2;
	bool AbortBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void AbortMission(MissionID missionid);
	bool AddAttackerToBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	UniverseID AddHoloMap(const char* texturename, float x0, float x1, float y0, float y1, float aspectx, float aspecty);
	void AddPlayerMoney(int64_t money);
	void AddResearch(const char* wareid);
	void AddSimilarMapComponentsToSelection(UniverseID holomapid, UniverseID componentid);
	bool AdjustOrder(UniverseID controllableid, size_t idx, size_t newidx, bool enabled, bool forcestates, bool checkonly);
	bool AreVenturesCompatible(void);
	bool AreVenturesEnabled(void);
	const char* AssignHiredActor(GenericActor actor, UniverseID targetcontrollableid, const char* postid, const char* roleid, bool checkonly);
	bool GetAskToSignalForControllable(const char* signalid, UniverseID controllableid);
	bool GetAskToSignalForFaction(const char* signalid, const char* factionid);
	uint32_t GetAttackersOfBoardingOperation(UniverseID* result, uint32_t resultlen, UniverseID defensibletargetid, const char* boarderfactionid);
	bool CanContainerMineTransport(UniverseID containerid, const char* transportname);
	bool CanContainerTransport(UniverseID containerid, const char* transportname);
	bool CanControllableHaveAnyTrainees(UniverseID controllableid);
	bool CanControllableHaveControlEntity(UniverseID controllableid, const char* postid);
	bool CanPlayerCommTarget(UniverseID componentid);
	const char* CanTeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool force);
	void ChangeMapBuildPlot(UniverseID holomapid, float x, float y, float z);
	void CheatDockingTraffic(void);
	void CheatLiveStreamViewChannels(void);
	void ClearSelectedMapComponents(UniverseID holomapid);
	void ClearMapBuildPlot(UniverseID holomapid);
	void ClearMapObjectFilter(UniverseID holomapid);
	void ClearMapOrderParamObjectFilter(UniverseID holomapid);
	void ClearMapTradeFilterByMinTotalVolume(UniverseID holomapid);
	void ClearMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch);
	void ClearMapTradeFilterByWare(UniverseID holomapid);
	void ClearMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint64_t ConvertStringTo64Bit(const char* idstring);
	bool CreateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	uint32_t CreateDeployToStationOrder(UniverseID controllableid);
	UniverseID CreateNPCFromPerson(NPCSeed person, UniverseID controllableid);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool default);
	uint32_t CreateOrder3(UniverseID controllableid, const char* orderid, bool defaultorder, bool isoverride, bool istemp);
	bool DropCargo(UniverseID containerid, const char* wareid, uint32_t amount);
	void EnableAllCheats(void);
	bool EnableOrder(UniverseID controllableid, size_t idx);
	bool EnablePlannedDefaultOrder(UniverseID controllableid, bool checkonly);
	void EndGuidance(void);
	bool ExtendBuildPlot(UniverseID stationid, Coord3D poschange, Coord3D negchange, bool allowreduction);
	bool FilterComponentByText(UniverseID componentid, uint32_t numtexts, const char** textarray, bool includecontainedobjects);
	bool FilterComponentForDefaultOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	bool FilterComponentForMapMode(UniverseID componentid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	bool FilterComponentForOrderParamObjectMode(UniverseID componentid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	bool FilterFleetUnitByText(FleetUnitID fleetunitid, uint32_t numtexts, const char** textarray);
	uint64_t GetActiveMissionID();
	uint32_t GetAllBoardingBehaviours(BoardingBehaviour* result, uint32_t resultlen);
	uint32_t GetAllBoardingPhases(BoardingPhase* result, uint32_t resultlen);
	uint32_t GetAllCommanders(CommanderInfo* result, uint32_t resultlen, UniverseID controllableid, FleetUnitID fleetunitid);
	uint32_t GetAllControlPosts(ControlPostInfo* result, uint32_t resultlen);
	uint32_t GetAllCountermeasures(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllFleetUnits(FleetUnitID* result, uint32_t resultlen, UniverseID controllableid);
	uint32_t GetAllInventoryBombs(AmmoData* result, uint32_t resultlen, UniverseID entityid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMissiles(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllModuleSets(UIModuleSet* result, uint32_t resultlen);
	uint32_t GetAllowedWeaponSystems(WeaponSystemInfo* result, uint32_t resultlen, UniverseID defensibleid, size_t orderidx, bool usedefault);
	uint32_t GetAllResponsesToSignal(ResponseInfo* result, uint32_t resultlen, const char* signalid);
	uint32_t GetAllSignals(SignalInfo* result, uint32_t resultlen);
	uint32_t GetAllWareGroups(WareGroupInfo* result, uint32_t resultlen);
	const char* GetBoardingActionOfAttacker(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	uint32_t GetBoardingCasualtiesOfTier(int32_t marinetierskilllevel, UniverseID defensibletargetid, const char* boarderfactionid);
	bool GetBoardingMarineTierAmountsFromAttacker(uint32_t* resultmarinetieramounts, int32_t* inputmarinetierskilllevels, uint32_t inputnummarinetiers, UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid);
	BoardingRiskThresholds GetBoardingRiskThresholds(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetBoardingStrengthOfControllableTierAmounts(UniverseID controllableid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	int64_t GetBuilderHiringFee(void);
	UniverseID GetBuildMapStationLocation2(UniverseID holomapid, UIPosRot* location);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	Coord3D GetBuildPlotCenterOffset(UniverseID stationid);
	int64_t GetBuildPlotPayment(UniverseID stationid, bool* positionchanged);
	int64_t GetBuildPlotPrice(UniverseID sectorid, UIPosRot location, float x, float y, float z, const char* factionid);
	Coord3D GetBuildPlotSize(UniverseID stationid);
	double GetBuildTaskDuration(UniverseID containerid, BuildTaskID id);
	BuildTaskInfo GetBuildTaskInfo(BuildTaskID id);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetCargoTransportTypes(StorageInfo* result, uint32_t resultlen, UniverseID containerid, bool merge, bool aftertradeorders);
	Coord2D GetCenteredMousePos(void);
	UniverseID GetCommonContext(UniverseID componentid, UniverseID othercomponentid, bool includeself, bool includeother, UniverseID limitid, bool includelimit);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	int GetConfigSetting(const char*const setting);
	const char* GetContainerBuildMethod(UniverseID containerid);
	uint32_t GetContainerCriticalWares(const char** result, uint32_t resultlen, UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	UniverseID GetContextByRealClass(UniverseID componentid, const char* classname, bool includeself);
	BlacklistID GetControllableBlacklistID(UniverseID controllableid, const char* listtype, const char* defaultgroup);
	FightRuleID GetControllableFightRuleID(UniverseID controllableid, const char* listtype);
	uint32_t GetControllableSubordinateFleetUnits(FleetUnitID* result, uint32_t resultlen, UniverseID controllableid, int subordinategroupid);
	const char* GetCurrentAmmoOfWeapon(UniverseID weaponid);
	const char* GetCurrentBoardingPhase(UniverseID defensibletargetid, const char* boarderfactionid);
	float GetCurrentBuildProgress(UniverseID containerid);
	const char* GetCurrentDroneMode(UniverseID defensibleid, const char* dronetype);
	UILogo GetCurrentFleetLogo(UniverseID controllableid);
	uint32_t GetCurrentMissionOffers(uint64_t* result, uint32_t resultlen, bool showninbbs);
	UILogo GetCurrentPlayerLogo(void);
	int64_t GetCurrentUTCDataTime(void);
	bool GetDefaultOrder(Order* result, UniverseID controllableid);
	bool GetDefaultOrderFailure(OrderFailure* result, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	const char* GetDefaultResponseToSignalForFaction2(const char* signalid, const char* factionid, const char* purposeid);
	uint32_t GetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary);
	uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	uint32_t GetDefensibleDeployableCapacity(UniverseID defensibleid);
	float GetDefensibleWeaponFireRange(UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeinactive);
	float GetDefensibleLoadoutLevel(UniverseID defensibleid);
	uint32_t GetDiscoveredSectorResources(WareYield* result, uint32_t resultlen, UniverseID sectorid);
	const char* GetDisplayedModifierKey(const char* uimodifier);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetDroneModes(DroneModeInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* dronetype);
	int32_t GetEntityCombinedSkill(UniverseID entityid, const char* role, const char* postid);
	FactionDetails GetFactionDetails(const char* factionid);
	const char* GetFleetName(UniverseID controllableid);
	FleetUnitID GetFleetUnit(UniverseID controllableid);
	const char* GetFleetUnitBuildIssues(FleetUnitID fleetunitid);
	UniverseID GetFleetUnitFirstCommanderComponent(FleetUnitID fleetunitid);
	const char* GetFleetUnitFleetName(FleetUnitID fleetunitid);
	FleetUnitInfo GetFleetUnitInfo(FleetUnitID fleetunitid);
	uint32_t GetFleetUnitProblematicEquipmentWares(const char** result, uint32_t resultlen, FleetUnitID fleetunitid);
	uint32_t GetFleetUnitSubordinateFleetUnits(FleetUnitID* result, uint32_t resultlen, FleetUnitID fleetunitid, int subordinategroupid);
	int32_t GetFleetUnitSubordinateGroup(FleetUnitID fleetunitid);
	const char* GetFleetUnitSubordinateGroupAssignment(FleetUnitID fleetunitid, int32_t group);
	uint32_t GetFleetUnitSubordinates(UniverseID* result, uint32_t resultlen, FleetUnitID fleetunitid, int32_t subordinategroupid);
	uint32_t GetFormationShapes(UIFormationInfo* result, uint32_t resultlen);
	uint32_t GetFreeCountermeasureStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeDeployableStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreeMissileStorageAfterTradeOrders(UniverseID defensibleid);
	uint32_t GetFreePeopleCapacity(UniverseID controllableid);
	int32_t GetGroupOfFleetUnitSubordinate(UniverseID controllableid, FleetUnitID fleetunitid);
	uint32_t GetIllegalToFactions(const char** result, uint32_t resultlen, const char* wareid);
	UniverseID GetInstantiatedPerson(NPCSeed person, UniverseID controllableid);
	const char* GetMacroClass(const char* macroname);
	uint32_t GetMapComponentMissions(MissionID* result, uint32_t resultlen, UniverseID holomapid, UniverseID componentid);
	UniverseID GetMapFocusComponent(UniverseID holomapid);
	UniverseID GetMapPositionOnEcliptic2(UniverseID holomapid, UIPosRot* position, bool adaptiveecliptic, UniverseID eclipticsectorid, UIPosRot eclipticoffset);
	uint32_t GetMapRenderedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	uint32_t GetMapSelectedComponents(UniverseID* result, uint32_t resultlen, UniverseID holomapid);
	void GetMapState(UniverseID holomapid, HoloMapState* state);
	UIMapTradeVolumeParameter GetMapTradeVolumeParameter(void);
	uint32_t GetMaxProductionStorage(UIWareAmount* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetMineablesAtSectorPos(YieldInfo* result, uint32_t resultlen, UniverseID sectorid, Coord3D position);
	Coord3D GetMinimumBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetMinimumBuildPlotSize(UniverseID stationid);
	const char* GetMissionBriefingButton(MissionID missionid);
	MissionBriefingIconInfo GetMissionBriefingIcon(MissionID missionid);
	uint32_t GetMissingBuildProcessorResources(UIWareInfo* result, uint32_t resultlen);
	uint32_t GetMissingBuildResources(UIWareInfo* result, uint32_t resultlen);
	void GetMissionDeliveryWares(MissionWareDeliveryInfo* result, MissionID missionid);
	MissionGroupDetails GetMissionGroupDetails(MissionID missionid);
	const char* GetMissionHelpOverlayID(MissionID missionid);
	MissionObjective2 GetMissionIDObjective2(uint64_t missionid);
	MissionDetails GetMissionIDDetails(uint64_t missionid);
	MissionObjectiveStep3 GetMissionObjectiveStep3(uint64_t missionid, size_t objectiveIndex);
	OnlineMissionInfo GetMissionOnlineInfo(MissionID missionid);
	uint32_t GetMissionThreadSubMissions(MissionID* result, uint32_t resultlen, MissionID missionid);
	uint32_t GetNumAllBoardingBehaviours(void);
	uint32_t GetNumAllBoardingPhases(void);
	uint32_t GetNumAllCommanders(UniverseID controllableid, FleetUnitID fleetunitid);
	uint32_t GetNumAllControlPosts(void);
	uint32_t GetNumAllCountermeasures(UniverseID defensibleid);
	uint32_t GetNumAllFleetUnits(UniverseID controllableid);
	uint32_t GetNumAllInventoryBombs(UniverseID entityid);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllMissiles(UniverseID defensibleid);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumAllModuleSets();
	uint32_t GetNumAllowedWeaponSystems(void);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAllResponsesToSignal(const char* signalid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllSignals(void);
	uint32_t GetNumAllWareGroups(void);
	uint32_t GetNumAttackersOfBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBoardingMarinesFromOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumCargoTransportTypes(UniverseID containerid, bool merge);
	uint32_t GetNumContainerCriticalWares(UniverseID containerid);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumControllableSubordinateFleetUnits(UniverseID controllableid, int subordinategroupid);
	uint32_t GetNumCurrentMissionOffers(bool showninbbs);
	uint32_t GetNumDiscoveredSectorResources(UniverseID sectorid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDroneModes(UniverseID defensibleid, const char* dronetype);
	uint32_t GetNumFleetUnitProblematicEquipmentWares(FleetUnitID fleetunitid);
	uint32_t GetNumFleetUnitSubordinateFleetUnits(FleetUnitID fleetunitid, int subordinategroupid);
	uint32_t GetNumFleetUnitSubordinates(FleetUnitID fleetunitid, int32_t subordinategroupid);
	uint32_t GetNumFormationShapes(void);
	uint32_t GetNumIllegalToFactions(const char* wareid);
	uint32_t GetNumMapComponentMissions(UniverseID holomapid, UniverseID componentid);
	uint32_t GetNumMapRenderedComponents(UniverseID holomapid);
	uint32_t GetNumMapSelectedComponents(UniverseID holomapid);
	uint32_t GetNumMaxProductionStorage(UniverseID containerid);
	uint32_t GetNumMineablesAtSectorPos(UniverseID sectorid, Coord3D position);
	uint32_t GetNumMissingBuildProcessorResources(UniverseID containerid, UniverseID buildprocessorid);
	uint32_t GetNumMissingBuildResources2(UniverseID containerid, UIBuildOrderList* orders, uint32_t numorders, bool playercase);
	uint32_t GetNumMissionDeliveryWares(MissionID missionid);
	uint32_t GetNumMissionThreadSubMissions(MissionID missionid);
	uint32_t GetNumObjectsWithSyncPoint(uint32_t syncid, bool onlyreached);
	uint32_t GetNumOrderDefinitions(void);
	uint32_t GetNumOrderFailures(UniverseID controllableid, bool includelooporders);
	uint32_t GetNumOrderLocationData(UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetNumOrders(UniverseID controllableid);
	uint32_t GetNumPeopleAfterOrders(UniverseID controllableid, int32_t numorders);
	uint32_t GetNumPersonSuitableControlPosts(UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	size_t GetNumPlannedStationModules(UniverseID defensibleid, bool includeall);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumPlayerLogos(bool includestandard, bool includecustom);
	uint32_t GetNumPlayerShipBuildTasks(bool isinprogress, bool includeupgrade);
	uint32_t GetNumRequestedMissionNPCs(UniverseID containerid);
	uint32_t GetNumSkills(void);
	uint32_t GetNumShieldGroups(UniverseID defensibleid);
	uint32_t GetNumSoftwareSlots(UniverseID controllableid, const char* macroname);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumSubordinatesOfGroup(UniverseID commanderid, int group);
	uint32_t GetNumSuitableControlPosts(UniverseID controllableid, UniverseID entityid, bool free);
	uint32_t GetNumTiersOfRole(const char* role);
	size_t GetNumTradeComputerOrders(UniverseID controllableid);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumWareBlueprintOwners(const char* wareid);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetNumWeaponGroupsByWeapon(UniverseID defensibleid, UniverseID weaponid);
	const char* GetObjectIDCode(UniverseID objectid);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	bool GetOrderDefinition(OrderDefinition* result, const char* orderdef);
	uint32_t GetOrderDefinitions(OrderDefinition* result, uint32_t resultlen);
	uint32_t GetOrderFailures(OrderFailure* result, uint32_t resultlen, UniverseID controllableid, bool includelooporders);
	AIOrderID GetOrderID(UniverseID controllableid, size_t orderidx);
	uint32_t GetOrderLocationData(UniverseID* result, uint32_t resultlen, UniverseID controllableid, size_t orderidx, bool usedefault);
	uint32_t GetOrderLoopSkillLimit();
	size_t GetOrderQueueCurrentIdx(UniverseID controllableid);
	size_t GetOrderQueueFirstLoopIdx(UniverseID controllableid, bool* isvalid);
	uint32_t GetOrders(Order* result, uint32_t resultlen, UniverseID controllableid);
	uint32_t GetOrders2(Order2* result, uint32_t resultlen, UniverseID controllableid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	Coord3D GetPaidBuildPlotCenterOffset(UniverseID stationid);
	Coord3D GetPaidBuildPlotSize(UniverseID stationid);
	UniverseID GetParentComponent(UniverseID componentid);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPeopleAfterOrders(NPCInfo* result, uint32_t resultlen, UniverseID controllableid, int32_t numorders);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includepilot);
	int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
	const char* GetPersonName(NPCSeed person, UniverseID controllableid);
	const char* GetPersonRole(NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkills3(SkillInfo* result, uint32_t resultlen, NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkillsForAssignment(Skill2* result, NPCSeed person, UniverseID controllableid, const char* role, const char* postid);
	uint32_t GetPersonSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID personcontrollableid, NPCSeed person, bool free);
	int32_t GetPersonTier(NPCSeed npc, const char* role, UniverseID controllableid);
	UniverseID GetPickedMapComponent(UniverseID holomapid);
	SubordinateGroup GetPickedMapInterSectorDefence(UniverseID holomapid);
	MissionID GetPickedMapMission(UniverseID holomapid);
	UniverseID GetPickedMapMissionOffer(UniverseID holomapid);
	UniverseID GetPickedMapOrder(UniverseID holomapid, Order* result, bool* intermediate);
	uint32_t GetPickedMapSyncPoint(UniverseID holomapid);
	UniverseID GetPickedMapSyncPointOwningOrder(UniverseID holomapid, Order* result);
	TradeID GetPickedMapTradeOffer(UniverseID holomapid);
	MultiverseMapPickInfo GetPickedMultiverseMapPlayer(UniverseID holomapid);
	bool GetPlannedDefaultOrder(Order* result, UniverseID controllableid);
	size_t GetPlannedStationModules(UIConstructionPlanEntry* result, uint32_t resultlen, UniverseID defensibleid, bool includeall);
	const char* GetPlayerBuildMethod(void);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	UniverseID GetPlayerComputerID(void);
	UniverseID GetPlayerContainerID(void);
	UniverseID GetPlayerControlledShipID(void);
	float GetPlayerGlobalLoadoutLevel(void);
	UniverseID GetPlayerID(void);
	uint32_t GetPlayerLogos(UILogo* result, uint32_t resultlen, bool includestandard, bool includecustom);
	UniverseID GetPlayerObjectID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetPlayerShipBuildTasks(BuildTaskInfo* result, uint32_t resultlen, bool isinprogress, bool includeupgrade);
	UniverseID GetPlayerShipID(void);
	bool GetPlayerGlobalTradeLoopCargoReservationSetting(void);
	UIPosRot GetPlayerTargetOffset(void);
	const char* GetRealComponentClass(UniverseID componentid);
	uint32_t GetRequestedMissionNPCs(MissionNPCInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	uint32_t GetRoleTiers2(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role, bool includearriving);
	UniverseID GetSectorControlStation(UniverseID sectorid);
	uint64_t GetSectorPopulation(UniverseID sectorid);
	uint32_t GetShieldGroups(ShieldGroup* result, uint32_t resultlen, UniverseID defensibleid);
	int32_t GetShipCombinedSkill(UniverseID shipid);
	bool GetShipTradeLoopCargoReservationSetting(UniverseID shipid);
	SofttargetDetails2 GetSofttarget2(void);
	uint32_t GetSoftwareSlots(SoftwareSlot* result, uint32_t resultlen, UniverseID controllableid, const char* macroname);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	UIPosRot GetSubordinateGroupProtectedPosition(UniverseID controllableid, int group);
	UniverseID GetSubordinateGroupProtectedSector(UniverseID controllableid, int group);
	uint32_t GetSubordinatesOfGroup(UniverseID* result, uint32_t resultlen, UniverseID commanderid, int group);
	uint32_t GetSuitableControlPosts(ControlPostInfo* result, uint32_t resultlen, UniverseID controllableid, UniverseID entityid, bool free);
	bool GetSyncPointAutoRelease(uint32_t syncid, bool checkall);
	bool GetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool checkall);
	bool GetSyncPointInfo2(UniverseID controllableid, size_t orderidx, SyncPointInfo2* result);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	uint32_t GetTiersOfRole(RoleTierData* result, uint32_t resultlen, const char* role);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	int64_t GetTradeWareBudget(UniverseID containerid);
	const char* GetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	const char* GetUserTransportDroneMode(UniverseID defensibleid);
	const char* GetVirtualUpgradeSlotCurrentMacro(UniverseID defensibleid, const char* upgradetypename, size_t slot);
	uint32_t GetWareBlueprintOwners(const char** result, uint32_t resultlen, const char* wareid);
	uint32_t GetWareReservationsForWare(UniverseID containerid, const char* wareid, bool buy);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetWeaponGroupsByWeapon(UIWeaponGroup* result, uint32_t resultlen, UniverseID defensibleid, UniverseID weaponid);
	const char* GetWeaponMode(UniverseID weaponid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	UniverseID GetZoneAt(UniverseID sectorid, UIPosRot* uioffset);
	bool HasAcceptedOnlineMission(void);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasControllableAnyOrderFailures(UniverseID controllableid);
	bool HasControllableOwnBlacklist(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnFightRule(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnResponse(UniverseID controllableid, const char* signalid);
	bool HasPersonArrived(UniverseID controllableid, NPCSeed person);
	bool HasShipTradeLoopCargoReservationOverride(UniverseID shipid);
	bool HasSubordinateAssignment(UniverseID controllableid, const char* assignment);
	bool IsAmmoMacroCompatible(const char* weaponmacroname, const char* ammomacroname);
	bool IsBuilderBusy(UniverseID shipid);
	bool IsComponentBlacklisted(UniverseID componentid, const char* listtype, const char* defaultgroup, UniverseID controllableid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsComponentWrecked(UniverseID componentid);
	bool IsContainerTradingWithFactionRescricted(UniverseID containerid, const char* factionid);
	bool IsContestedSector(UniverseID sectorid);
	bool IsControlPressed(void);
	bool IsCurrentBuildMapPlotPositionDiscovered(UniverseID sectorid, UIPosRot location, float x, float y, float z);
	bool IsCurrentBuildMapPlotValid(UniverseID holomapid);
	bool IsCurrentOrderCritical(UniverseID controllableid);
	bool IsDefensibleBeingBoardedBy(UniverseID defensibleid, const char* factionid);
	bool IsDroneTypeArmed(UniverseID defensibleid, const char* dronetype);
	bool IsDroneTypeBlocked(UniverseID defensibleid, const char* dronetype);
	bool IsExternalTargetMode();
	bool IsExternalViewActive();
	bool IsExternalViewDisabled();
	bool IsIconValid(const char* iconid);
	bool IsInfoUnlockedForPlayer(UniverseID componentid, const char* infostring);
	bool IsKnownToPlayer(UniverseID componentid);
	bool IsMasterVersion(void);
	bool IsMissionLimitReached(bool includeupkeep, bool includeguidance, bool includeplot);
	bool IsNewGame(void);
	bool IsObjectKnown(const UniverseID componentid);
	bool IsOrderLoopable(const char* orderdefid);
	bool IsOrderSelectableFor(const char* orderdefid, UniverseID controllableid);
	bool IsPerson(NPCSeed person, UniverseID controllableid);
	bool IsPersonTransferScheduled(UniverseID controllableid, NPCSeed person);
	bool IsPlayerCameraTargetViewPossible(UniverseID targetid, bool force);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
	bool IsShiftPressed(void);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsStoryFeatureUnlocked(const char* featureid);
	bool IsTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group);
	bool IsUICoverOverridden(void);
	bool IsUnit(UniverseID controllableid);
	bool IsVentureSeasonSupported(void);
	bool IsWeaponArmed(UniverseID weaponid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	void MissionBriefingInteractButtonClicked(MissionID missionid);
	void PayBuildPlotSize(UniverseID stationid, Coord3D plotsize, Coord3D plotcenter);
	UICrewExchangeResult PerformCrewExchange2(UniverseID controllableid, UniverseID partnercontrollableid, NPCSeed* npcs, uint32_t numnpcs, NPCSeed* partnernpcs, uint32_t numpartnernpcs, NPCSeed captainfromcontainer, NPCSeed captainfrompartner, bool exchangecaptains, bool checkonly);
	bool QuickMenuAccess(const char* menu);
	void ReassignPeople(UniverseID controllableid, CrewTransferContainer* reassignedcrew, uint32_t amount);
	void ReleasePersonFromCrewTransfer(UniverseID controllableid, NPCSeed person);
	void ReleaseOrderSyncPoint(uint32_t syncid);
	void ReleaseOrderSyncPointFromOrder(UniverseID controllableid, size_t idx);
	bool RemoveAllOrders(UniverseID controllableid);
	bool RemoveAttackerFromBoardingOperation(UniverseID defensibleboarderid);
	bool RemoveBuildPlot2(UniverseID stationid, bool removebuildstoragecargo);
	bool RemoveBuildStorage(UniverseID buildstorageid);
	bool RemoveCommander2(UniverseID controllableid);
	void RemoveDefaultOrderFailure(UniverseID controllableid);
	void RemoveHoloMap(void);
	bool RemoveOrder(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly);
	void RemoveOrderFailure(UniverseID controllableid, uint32_t id);
	void RemoveOrderSyncPointID(UniverseID controllableid, size_t orderidx);
	void RemovePerson(UniverseID controllableid, NPCSeed person);
	void RemovePlannedDefaultOrder(UniverseID controllableid);
	void RemoveShipTradeLoopCargoReservationOverride(UniverseID shipid);
	UniverseID ReserveBuildPlot(UniverseID sectorid, const char* factionid, const char* set, UIPosRot location, float x, float y, float z);
	void ResetOrderLoop(UniverseID controllableid);
	bool ResetResponseToSignalForControllable(const char* signalid, UniverseID controllableid);
	void RevealEncyclopedia(void);
	void RevealMap(void);
	void RevealStations(void);
	bool SetActiveMission(MissionID missionid);
	void SelectSimilarMapComponents(UniverseID holomapid, UniverseID componentid);
	void SellPlayerShip(UniverseID shipid, UniverseID shipyardid);
	void SetAllMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllNonMissileTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllNonMissileTurretsArmed(UniverseID defensibleid, bool arm);
	void SetAllowedWeaponSystems(UniverseID defensibleid, size_t orderidx, bool usedefault, WeaponSystemInfo* uiweaponsysteminfo, uint32_t numuiweaponsysteminfo);
	void SetAllTurretModes(UniverseID defensibleid, const char* mode);
	void SetAllTurretsArmed(UniverseID defensibleid, bool arm);
	bool SetAmmoOfWeapon(UniverseID weaponid, const char* newammomacro);
	void SetCheckBoxChecked2(const int checkboxid, bool checked, bool update);
	void SetConfigSetting(const char*const setting, const bool value);
	void SetContainerBuildMethod(UniverseID containerid, const char* buildmethodid);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetControllableBlacklist(UniverseID controllableid, BlacklistID id, const char* listtype, bool value);
	void SetControllableFightRule(UniverseID controllableid, FightRuleID id, const char* listtype, bool value);
	void SetCurrentLoopOrder(UniverseID controllableid, size_t idx, bool enabled, bool forcestates, bool checkonly);
	bool SetDefaultResponseToSignalForControllable(const char* newresponse, bool ask, const char* signalid, UniverseID controllableid);
	bool SetDefaultResponseToSignalForFaction2(const char* newresponse, bool ask, const char* signalid, const char* factionid, const char* purposeid);
	void SetDefensibleActiveWeaponGroup(UniverseID defensibleid, bool primary, uint32_t groupidx);
	void SetDefensibleLoadoutLevel(UniverseID defensibleid, float value);
	void SetDroneMode(UniverseID defensibleid, const char* dronetype, const char* mode);
	void SetDroneTypeArmed(UniverseID defensibleid, const char* dronetype, bool arm);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetFleetLogo(UniverseID controllableid, UILogo logo);
	void SetFleetName(UniverseID controllableid, const char* fleetname);
	void SetFocusMapComponent(UniverseID holomapid, UniverseID componentid, bool resetplayerpan);
	void SetFocusMapOrder(UniverseID holomapid, UniverseID controllableid, size_t orderidx, bool resetplayerpan);
	UIFormationInfo SetFormationShape(UniverseID objectid, const char* formationshape);
	bool SetEntityToPost(UniverseID controllableid, UniverseID entityid, const char* postid);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMapBehaviourInspectionComponent(UniverseID holomapid, UniverseID componentid);
	void SetMapDefaultOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, bool planned, size_t paramidx);
	void SetMapFactionRelationColorOption(UniverseID holomapid, bool value);
	void SetMapFilterSectors(UniverseID holomapid, uint32_t numsectorids, UniverseID* sectorids);
	void SetMapFilterString(UniverseID holomapid, uint32_t numtexts, const char** textarray);
	void SetMapObjectFilter(UniverseID holomapid, const char** classes, uint32_t numclasses, int32_t playerowned, bool allowentitydeliverymissionobject);
	void SetMapOrderParamObjectFilter(UniverseID holomapid, UniverseID ordercontrollableid, size_t orderidx, size_t paramidx);
	void SetMapPanOffset(UniverseID holomapid, UniverseID offsetcomponentid);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetMapRelativeMousePosition(UniverseID holomapid, bool valid, float x, float y);
	void SetMapRenderAllAllyOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderAllGateConnections(UniverseID holomapid, bool value);
	void SetMapRenderAllOrderQueues(UniverseID holomapid, bool value);
	void SetMapRenderCivilianShips(UniverseID holomapid, bool value);
	void SetMapRenderEclipticLines(UniverseID holomapid, bool value);
	void SetMapRenderMissionGuidance(UniverseID holomapid, MissionID missionid);
	void SetMapRenderMissionOffers(UniverseID holomapid, bool value);
	void SetMapRenderResourceInfo(UniverseID holomapid, bool value);
	void SetMapRenderSatelliteRadarRange(UniverseID holomapid, bool value);
	void SetMapRenderSelectionLines(UniverseID holomapid, bool value);
	void SetMapRenderTradeOffers(UniverseID holomapid, bool value);
	void SetMapRenderWrecks(UniverseID holomapid, bool value);
	void SetMapSelectedFleetCommander(UniverseID holomapid, UniverseID controllableid);
	void SetMapState(UniverseID holomapid, HoloMapState state);
	void SetMapStationInfoBoxMargin(UniverseID holomapid, const char* margin, uint32_t width);
	void SetMapTargetDistance(UniverseID holomapid, float distance);
	void SetMapTopTradesCount(UniverseID holomapid, uint32_t count);
	void SetMapTradeFilterByMaxPrice(UniverseID holomapid, int64_t price);
	void SetMapTradeFilterByMinTotalVolume(UniverseID holomapid, uint32_t minvolume);
	void SetMapTradeFilterByPlayerOffer(UniverseID holomapid, bool buysellswitch, bool enable);
	void SetMapTradeFilterByWare(UniverseID holomapid, const char** wareids, uint32_t numwareids);
	void SetMapTradeFilterByWareTransport(UniverseID holomapid, const char** transporttypes, uint32_t numtransporttypes);
	void SetMapTradeFilterByWillingToTradeWithPlayer(UniverseID holomapid);
	void SetMapAlertFilter(UniverseID holomapid, uint32_t alertlevel);
	bool SetOrderLoop(UniverseID controllableid, size_t orderidx, bool checkonly);
	bool SetOrderSyncPointID(UniverseID controllableid, size_t orderidx, uint32_t syncid, bool checkonly);
	void SetPlayerCameraCockpitView(bool force);
	void SetPlayerCameraTargetView(UniverseID targetid, bool force);
	void SetSelectedMapComponent(UniverseID holomapid, UniverseID componentid);
	void SetSelectedMapComponents(UniverseID holomapid, UniverseID* componentids, uint32_t numcomponentids);
	void SetShipTradeLoopCargoReservationOverride(UniverseID shipid, bool value);
	bool SetSofttarget(UniverseID componentid, const char*const connectionname);
	void SetSubordinateGroupDockAtCommander(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetSyncPointAutoRelease(uint32_t syncid, bool all, bool any);
	void SetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool all, bool any);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	void SetTurretGroupArmed(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, bool arm);
	void SetTurretGroupMode2(UniverseID defensibleid, UniverseID contextid, const char* path, const char* group, const char* mode);
	void SetUICoverOverride(bool override);
	void SetWeaponArmed(UniverseID weaponid, bool arm);
	void SetWeaponGroup(UniverseID defensibleid, UniverseID weaponid, bool primary, uint32_t groupidx, bool value);
	void SetWeaponMode(UniverseID weaponid, const char* mode);
	bool ShouldSubordinateGroupDockAtCommander(UniverseID controllableid, int group);
	void ShowBuildPlotPlacementMap(UniverseID holomapid, UniverseID sectorid);
	void ShowMultiverseMap(UniverseID holomapid);
	void ShowUniverseMap2(UniverseID holomapid, bool setoffset, bool showzone, bool forcebuildershipicons, UniverseID startsectorid, UIPosRot startpos);
	void SignalObjectWithNPCSeedAndMissionID(UniverseID objecttosignalid, const char* param, MissionID missionid, NPCSeed person, UniverseID controllableid);
	bool StartBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void ZoomMap(UniverseID holomapid, float zoomstep);
	void StartMapBoxSelect(UniverseID holomapid, bool selectenemies);
	void StopMapBoxSelect(UniverseID holomapid);
	bool TeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool instant, bool force);
	bool ToggleAutoPilot(bool checkonly);
	void TriggerInputFeedback(const char* type, const char* idname, const char* triggerid, const char* contextid);
	bool UpdateAttackerOfBoardingOperation(UniverseID defensibletargetid, UniverseID defensibleboarderid, const char* boarderfactionid, const char* actionid, uint32_t* marinetieramounts, int32_t* marinetierskilllevels, uint32_t nummarinetiers);
	bool UpdateBoardingOperation(UniverseID defensibletargetid, const char* boarderfactionid, uint32_t approachthreshold, uint32_t insertionthreshold);
	void UpdateMapBuildPlot(UniverseID holomapid);
	bool WasSessionOnline(void);
]]

local utf8 = require("utf8")

local menu = {
	name = "MapMenu",
	infoTableMode = "objectlist",
	ventureMode = C.IsVentureSeasonSupported() and "ventureseason" or "venturelogbook",
	displayedFilterLayer = "layer_trade",
	mouseCursorOverrides = { [1] = "default" },
	currentMouseCursor = "default",
	picking = true,
	missionOfferMode = "normal",
	missionMode = "plot",
	expandedMissionGroups = {},
	infoMode = { left = "objectinfo", right = "objectinfo" },
	seasonMode = { left = "currentseason", right = "currentseason" },
	highlightLeftBar = {},
	objectMode = "objectall",
	propertyMode = "propertyall",
	objectSorterType = "name",
	propertySorterType = "name",
	crewSort = "role",
	crewRole = "current",
	showMultiverse = false,
	cachedOrderFailures = {},
}

local config = {
	mainFrameLayer = 6,
	infoFrameLayer2 = 5,
	infoFrameLayer = 4,
	contextFrameLayer = 2,

	complexOrderParams = {
		["trade"] = {
			[1] = { id = "trade_location", name = ReadText(1001, 2943), type = "object", inputparams = { class = "sector" }, value = function (data) return next(data) and data.station and GetComponentData(data.station, "zoneid") or nil end },
			[2] = { id = "trade_partner", name = ReadText(1001, 23), type = "object", inputparams = { class = "container" }, value = function (data) return data.station end },
			[3] = { id = "trade_ware", name = ReadText(1001, 7104), type = "trade_ware", value = function (data) return next(data) and data.ware and {data.isbuyoffer, data.ware} or nil end },
			[4] = { id = "trade_amount", name = ReadText(1001, 6521), type = "trade_amount", value = function (data) return data.ware and {data.desiredamount, data.amount} or nil end },
			data = function (value) return (value and IsValidTrade(value) and menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue")) and GetTradeData(value, ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))) or {} end
		}
	},
	moduletypes = {
		{ type = "moduletypes_production", name = ReadText(1001, 2421) },
		{ type = "moduletypes_build",      name = ReadText(1001, 2439) },
		{ type = "moduletypes_storage",    name = ReadText(1001, 2422) },
		{ type = "moduletypes_habitation", name = ReadText(1001, 2451) },
		{ type = "moduletypes_welfare",    name = ReadText(1001, 9620) },
		{ type = "moduletypes_dock",       name = ReadText(1001, 2452) },
		{ type = "moduletypes_defence",    name = ReadText(1001, 2424) },
		{ type = "moduletypes_processing", name = ReadText(1001, 9621) },
		{ type = "moduletypes_other",      name = ReadText(1001, 2453),		additionaltypes = { "moduletypes_radar" } },
		{ type = "moduletypes_venture",    name = ReadText(1001, 2454) },
	},
	stateKeys = {
		{"mode"},
		{"modeparam"},
		{"lastactivetable"},
		{"focuscomponent", "UniverseID"},
		{"currentsector", "UniverseID"},
		{"selectedcomponents"},
		{"searchtext"},
		{"infoTableMode"},
		{"ventureMode"},
		{"searchTableMode"},
		{"infoSubmenuObject", "UniverseID"},
		{"showMultiverse", "bool"},
		{"objectMode"},
		{"propertyMode"},
		{"seasonMode"},
	},
	leftBar = {
		{ name = ReadText(1001, 3224),	icon = "mapst_objectlist",			mode = "objectlist",	helpOverlayID = "map_sidebar_objectlist",			helpOverlayText = ReadText(1028, 3201) },
		{ name = ReadText(1001, 1000),	icon = "mapst_propertyowned",		mode = "propertyowned",	helpOverlayID = "map_sidebar_propertyowned",		helpOverlayText = ReadText(1028, 3203) },
		{ spacing = true },
		{ name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		mode = "missionoffer",	helpOverlayID = "map_sidebar_mission_offers",		helpOverlayText = ReadText(1028, 3205) },
		{ name = ReadText(1001, 3323),	icon = "mapst_mission_accepted",	mode = "mission",		helpOverlayID = "map_sidebar_mission_accepted",		helpOverlayText = ReadText(1028, 3207) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information",			helpOverlayText = ReadText(1028, 3209) },
		{ spacing = true },
		{ name = ReadText(1001, 3226),	icon = "mapst_plotmanagement",		mode = "plots",			helpOverlayID = "map_sidebar_plotmanagement",		helpOverlayText = ReadText(1028, 3211) },
		{ spacing = true,																			condition = IsCheatVersion }, -- (cheats only)
		{ name = "Cheats",				icon = "mapst_cheats",				mode = "cheats",		condition = IsCheatVersion }, -- (cheats only)
	},
	leftBarMultiverse = {
		{ name = ReadText(1001, 11288),	icon = "vt_season",					mode = "ventureseason",		helpOverlayID = "multimap_season",				helpOverlayText = ReadText(1028, 3263),		condition = C.IsVentureSeasonSupported },
		{ spacing = true,		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11318),	icon = "vt_mission",				mode = "ventureoperation",	helpOverlayID = "multimap_operation",			helpOverlayText = ReadText(1028, 3266),		condition = C.IsVentureSeasonSupported },
		{ name = ReadText(1001, 11319),	icon = "vt_logbook",				mode = "venturelogbook",	helpOverlayID = "multimap_logbook",				helpOverlayText = ReadText(1028, 3267) },
		{ spacing = true, },
		{ name = ReadText(1001, 7720),	icon = "vt_inventory",				mode = "ventureinventory",	helpOverlayID = "multimap_inventory",			helpOverlayText = ReadText(1028, 3269) },
		{ name = ReadText(1001, 11386),	icon = "vt_contactlist",			mode = "venturecontacts",	helpOverlayID = "multimap_contacts",			helpOverlayText = ReadText(1028, 3275) },
	},
	rightBar = {
		{ name = ReadText(1001, 3227),	icon = "mapst_filtersystem",		mode = "filter",		helpOverlayID = "mapst_filter",						helpOverlayText = ReadText(1028, 3212) },
		{ name = ReadText(1001, 9801),	icon = "mapst_legend",				mode = "legend",		helpOverlayID = "mapst_legend",						helpOverlayText = ReadText(1028, 3213) },
		{ spacing = true },
		{ name = ReadText(1001, 2427),	icon = "mapst_information",			mode = "info",			helpOverlayID = "map_sidebar_information2",			helpOverlayText = ReadText(1028, 3209) },
	},
	infoCategories = {
		{ category = "objectinfo",				name = ReadText(1001, 2427),	icon = "mapst_information",			helpOverlayID = "mapst_ao_information",			helpOverlayText = ReadText(1028, 3234) },
		{ category = "objectcrew",				name = ReadText(1001, 80),		icon = "shipbuildst_crew",			helpOverlayID = "mapst_ao_info_crew",			helpOverlayText = ReadText(1028, 3237) },
		{ category = "objectloadout",			name = ReadText(1001, 9413),	icon = "mapst_loadout",				helpOverlayID = "mapst_ao_info_loadout",		helpOverlayText = ReadText(1028, 3238) },
		{ category = "objectlogbook",			name = ReadText(1001, 5700),	icon = "pi_logbook",				helpOverlayID = "mapst_ao_info_logbook",		helpOverlayText = ReadText(1028, 3238) },
		{ empty = true },
		{ category = "orderqueue",				name = ReadText(1001, 8360),	icon = "mapst_ao_orderqueue",		helpOverlayID = "mapst_ao_orderqueue",			helpOverlayText = ReadText(1028, 3235) },
		{ category = "orderqueue_advanced",		name = ReadText(1001, 8361),	icon = "mapst_orderqueue_advanced",	helpOverlayID = "mapst_ao_orderqueue_advanced",	helpOverlayText = ReadText(1028, 3236) },
		{ category = "standingorders",			name = ReadText(1001, 8396),	icon = "mapst_standing_orders",		helpOverlayID = "mapst_ao_standing_orders",		helpOverlayText = ReadText(1028, 3239) },
	},
	objectCategories = {
		{ category = "objectall",				name = ReadText(1001, 8380),	icon = "mapst_objectlist",			helpOverlayID = "mapst_ol_objectlist",			helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_ol_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "ships",					name = ReadText(1001, 6),		icon = "mapst_ol_ships",			helpOverlayID = "mapst_ol_fleets",				helpOverlayText = ReadText(1028, 3222) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_ol_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	propertyCategories = {
		{ category = "propertyall",				name = ReadText(1001, 8380),	icon = "mapst_propertyowned",		helpOverlayID = "mapst_po_propertyowned",		helpOverlayText = ReadText(1028, 3220) },
		{ category = "stations",				name = ReadText(1001, 8379),	icon = "mapst_ol_stations",			helpOverlayID = "mapst_po_stations",			helpOverlayText = ReadText(1028, 3221) },
		{ category = "fleets",					name = ReadText(1001, 8326),	icon = "mapst_ol_fleets",			helpOverlayID = "mapst_po_fleets",				helpOverlayText = ReadText(1028, 3223) },
		{ category = "unassignedships",			name = ReadText(1001, 8327),	icon = "mapst_ol_unassigned",		helpOverlayID = "mapst_po_unassigned",			helpOverlayText = ReadText(1028, 3224) },
		{ category = "inventoryships",			name = ReadText(1001, 8381),	icon = "mapst_ol_inventory",		helpOverlayID = "mapst_po_inventory",			helpOverlayText = ReadText(1028, 3225) },
		{ category = "deployables",				name = ReadText(1001, 1332),	icon = "mapst_ol_deployables",		helpOverlayID = "mapst_po_deployables",			helpOverlayText = ReadText(1028, 3226) },
	},
	seasonCategories = {
		{ category = "currentseason",			name = ReadText(1001, 11322),	icon = "vt_season_current",			helpOverlayID = "mapst_ven_curseason",			helpOverlayText = ReadText(1028, 3270) },
		{ category = "coalition",				name = ReadText(1001, 11323),	icon = "vt_guild",					helpOverlayID = "mapst_ven_coalitions",			helpOverlayText = ReadText(1028, 3271) },
		{ category = "ventureteam",				name = ReadText(1001, 11320),	icon = "vt_team",					helpOverlayID = "multimap_team",				helpOverlayText = ReadText(1028, 3268) },
		{ category = "pastseasons",				name = ReadText(1001, 11324),	icon = "vt_season_previous",		helpOverlayID = "mapst_ven_pastseason",			helpOverlayText = ReadText(1028, 3264) },
	},
	layers = {
		{ name = ReadText(1001, 3252),	shortname = ReadText(1001, 11626),	icon = "mapst_fs_trade",		mode = "layer_trade",		helpOverlayID = "layer_trade",		helpOverlayText = ReadText(1028, 3214),		toggleHelpOverlayID = "toggle_trade" },
		{ name = ReadText(1001, 8329),	shortname = ReadText(1001, 11629),	icon = "mapst_fs_mining",		mode = "layer_mining",		helpOverlayID = "layer_mining",		helpOverlayText = ReadText(1028, 3216),		toggleHelpOverlayID = "toggle_mining" },
		{ name = ReadText(1001, 3254),	shortname = ReadText(1001, 11628),	icon = "mapst_fs_other",		mode = "layer_other",		helpOverlayID = "layer_other",		helpOverlayText = ReadText(1028, 3217),		toggleHelpOverlayID = "toggle_other" },
	},
	layersettings = {
		["layer_trade"] = {
			callback = function (value) return C.SetMapRenderTradeOffers(menu.holomap, value) end,
			[1] = {
				caption = ReadText(1001, 46),
				info = ReadText(1001, 3279),
				overrideText = ReadText(1001, 8378),
				type = "multiselectlist",
				id = "trade_wares",
				callback = function (...) return menu.filterTradeWares(...) end,
				listOptions = function (...) return menu.getFilterTradeWaresOptions(...) end,
				displayOption = function (option) return "\27[maptr_supply] " .. GetWareData(option, "name") end,
				helpOverlayID = "tradefilters_wares",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				savegame = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
			},
			[2] = {
				caption = ReadText(1001, 1400),
				type = "checkbox",
				callback = function (...) return menu.filterTradeStorage(...) end,
				helpOverlayID = "tradefilters_storage",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				savegame = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
				[1] = {
					id = "trade_storage_container",
					name = ReadText(20205, 100),
					info = ReadText(1001, 3280),
					param = "container",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
				[2] = {
					id = "trade_storage_solid",
					name = ReadText(20205, 200),
					info = ReadText(1001, 3281),
					param = "solid",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
				[3] = {
					id = "trade_storage_liquid",
					name = ReadText(20205, 300),
					info = ReadText(1001, 3282),
					param = "liquid",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
				[4] = {
					id = "trade_storage_condensate",
					name = ReadText(20205, 1100),
					info = ReadText(1001, 11614),
					param = "condensate",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
			},
			[3] = {
				caption = ReadText(1001, 2808),
				type = "slidercell",
				callback = function (...) return menu.filterTradePrice(...) end,
				helpOverlayID = "tradefilters_price",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
				[1] = {
					id = "trade_price_maxprice",
					name = ReadText(1001, 3284),
					info = ReadText(1001, 3283),
					param = "maxprice",
					scale = {
						min       = 0,
						max       = 10000,
						step      = 1,
						suffix    = ReadText(1001, 101),
						exceedmax = true
					},
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
			},
			[4] = {
				caption = ReadText(1001, 8357),
				type = "dropdown",
				callback = function (...) return menu.filterTradeVolume(...) end,
				helpOverlayID = "tradefilters_volume",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
				[1] = {
					id = "trade_volume",
					info = ReadText(1001, 8358),
					listOptions = function (...) return menu.getFilterTradeVolumeOptions(...) end,
					param = "volume",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
			},
			[5] = {
				caption = ReadText(1001, 11205),
				type = "dropdown",
				callback = function (...) return menu.filterTradePlayerOffer(...) end,
				helpOverlayID = "tradefilters_playeroffer",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
				[1] = {
					id = "trade_playeroffer_buy",
					info = ReadText(1001, 11209),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(true) end,
					param = "playeroffer_buy",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
				[2] = {
					id = "trade_playeroffer_sell",
					info = ReadText(1001, 11210),
					listOptions = function (...) return menu.getFilterTradePlayerOfferOptions(false) end,
					param = "playeroffer_sell",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
			},
			[6] = {
				caption = ReadText(1001, 11240),
				type = "checkbox",
				callback = function (...) return menu.filterTradeRelation(...) end,
				helpOverlayID = "tradefilters_relation",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				active = function () return menu.mode ~= "behaviourinspection" end,
				[1] = {
					id = "trade_relation_enemy",
					name = ReadText(1001, 11241),
					info = ReadText(1001, 11242),
					param = "enemy",
					active = function () return menu.mode ~= "behaviourinspection" end,
				},
			},
			[7] = {
				caption = ReadText(1001, 8343),
				type = "slidercell",
				callback = function (...) return menu.filterTradeOffer(...) end,
				helpOverlayID = "tradefilters_number",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "trade_offer_number",
					name = ReadText(1001, 8344),
					info = ReadText(1001, 8345),
					param = "number",
					scale = {
						min       = 0,
						minSelect = 1,
						max       = 5,
						step      = 1,
						exceedmax = true,
					}
				},
			},
		},
		["layer_fight"] = {},
		["layer_think"] = {},
		["layer_build"] = {},
		["layer_diplo"] = {},
		["layer_mining"] = {
			callback = function (value) return menu.filterMining(value) end,
			[1] = {
				caption = ReadText(1001, 8330),
				type = "checkbox",
				callback = function (...) return menu.filterMiningResources(...) end,
				helpOverlayID = "miningfilters_display",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "mining_resource_display",
					name = ReadText(1001, 8331),
					info = ReadText(1001, 8332),
					param = "display"
				},
			},
		},
		["layer_other"] = {
			callback = function (value) return menu.filterOther(value) end,
			[1] = {
				caption = ReadText(1001, 3285),
				type = "dropdown",
				callback = function (...) return menu.filterThinkAlert(...) end,
				helpOverlayID = "otherfilters_alerts",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					info = ReadText(1001, 3286),
					id = "think_alert",
					listOptions = function (...) return menu.getFilterThinkAlertOptions(...) end,
					param = "alert"
				},
			},
			[2] = {
				caption = ReadText(1001, 11204),
				type = "checkbox",
				callback = function (...) return menu.filterThinkDiplomacy(...) end,
				helpOverlayID = "otherfilters_diplomacy",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "think_diplomacy_factioncolor",
					name = ReadText(1001, 11203),
					param = "factioncolor",
				},
				[2] = {
					id = "think_diplomacy_highlightvisitor",
					name = ReadText(1001, 11216),
					info = ReadText(1001, 11217),
					param = "highlightvisitors",
				},
			},
			[3] = {
				caption = ReadText(1001, 2664),
				type = "checkbox",
				callback = function (...) return menu.filterOtherMisc(...) end,
				helpOverlayID = "otherfilters_misc",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_ecliptic",
					name = ReadText(1001, 3297),
					info = ReadText(1001, 3298),
					param = "ecliptic",
				},
				[2] = {
					id = "other_misc_wrecks",
					name = ReadText(1001, 8382),
					info = ReadText(1001, 8383),
					param = "wrecks",
				},
				[3] = {
					id = "other_misc_selection_lines",
					name = ReadText(1001, 11214),
					info = ReadText(1001, 11215),
					param = "selectionlines",
				},
				[4] = {
					id = "other_misc_gate_connections",
					name = ReadText(1001, 11243),
					info = ReadText(1001, 11244),
					param = "gateconnections",
				},
				[5] = {
					id = "other_misc_opacity",
					name = ReadText(1001, 11245),
					info = ReadText(1001, 11246),
					param = "opacity",
				},
				[6] = {
					id = "other_misc_coveroverride",
					name = ReadText(1001, 11604),
					info = ReadText(1001, 11605),
					param = "coveroverride",
					active = Helper.isPlayerCovered,
				},
				[7] = {
					id = "other_misc_rendersatelliteradarrange",
					name = ReadText(1001, 11637),
					info = ReadText(1001, 11638),
					param = "rendersatelliteradarrange",
				},
			},
			[4] = {
				caption = ReadText(1001, 8336),
				type = "checkbox",
				callback = function (...) return menu.filterOtherShip(...) end,
				helpOverlayID = "otherfilters_shipprops",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_orderqueue",
					name = ReadText(1001, 3287),
					info = ReadText(1001, 8372),
					param = "orderqueue",
				},
				[2] = {
					id = "other_misc_allyorderqueue",
					name = ReadText(1001, 8370),
					info = ReadText(1001, 8371),
					param = "allyorderqueue",
				},
			},
			[5] = {
				caption = ReadText(1001, 8335),
				type = "checkbox",
				callback = function (...) return menu.filterOtherStation(...) end,
				helpOverlayID = "otherfilters_stationprops",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				[1] = {
					id = "other_misc_missions",
					name = ReadText(1001, 3291),
					info = ReadText(1001, 3292),
					param = "missions",
				},
				[2] = {
					id = "other_misc_civilian",
					name = ReadText(1001, 8333),
					info = ReadText(1001, 8334),
					param = "civilian",
				},
			},
		},
	},
	mapfilterversion = 20,
	mapfiltersaveversion = 1,

	-- custom default row properties, different from Helper defaults
	mapRowHeight = Helper.standardTextHeight,
	mapFontSize = Helper.standardFontSize,
	plotPairedDimension = { posX = "negX", negX = "posX", posY = "negY", negY = "posY", posZ = "negZ", negZ = "posZ" },
	maxPlotSize = 20,
	cameraResetThresholdAngle = 2, -- in degrees

	contextBorder = 5,

	classOrder = {
		["station"]		= 1,
		["ship_xl"]		= 2,
		["ship_l"]		= 3,
		["ship_m"]		= 4,
		["ship_s"]		= 5,
		["ship_xs"]		= 6,
		["spacesuit"]	= 7,
	},
	purposeOrder = {
		["fight"]		= 1,
		["auxiliary"]	= 2,
		["build"]		= 3,
		["mine"]		= 4,
		["trade"]		= 5,
	},

	missionMainTypeOrder = {
		["plot"] = 1,
		["tutorial"] = 2,
		["generic"] = 3,
		["upkeep"] = 4,
		["guidance"] = 5,
	},

	missionOfferCategories = {
		{ category = "plot",		name = ReadText(1001, 3340),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_offer_plot",			helpOverlayText = ReadText(1028, 3240) },
		{ category = "guild",		name = ReadText(1001, 3331),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_offer_guild",		helpOverlayText = ReadText(1028, 3227) },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3332),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_offer_other",		helpOverlayText = ReadText(1028, 3228) },
	},

	missionOfferTabs = {
		{ category = "normal",		name = ReadText(1001, 3324),	icon = "mapst_mission_offers",		helpOverlayID = "mapst_mission_offer_tab_normal",		helpOverlayText = ReadText(1028, 3273) },
		{ category = "operation",	name = ReadText(1001, 11318),	icon = "vt_season",					helpOverlayID = "mapst_mission_offer_tab_operation",	helpOverlayText = ReadText(1028, 3274) },
	},

	missionCategories = {
		{ category = "plot",		name = ReadText(1001, 3341),	icon = "mapst_mission_main",		helpOverlayID = "mapst_mission_active_main",		helpOverlayText = ReadText(1028, 3241) },
		{ category = "guild",		name = ReadText(1001, 3333),	icon = "mapst_mission_guild",		helpOverlayID = "mapst_mission_active_guild",		helpOverlayText = ReadText(1028, 3229),	showtab = false },
		{ category = "coalition",	name = ReadText(1001, 8801),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_coalition",	helpOverlayText = "",					showtab = false },
		{ category = "other",		name = ReadText(1001, 3334),	icon = "mapst_mission_other",		helpOverlayID = "mapst_mission_active_other",		helpOverlayText = ReadText(1028, 3230),	showtab = false },
		{ category = "upkeep",		name = ReadText(1001, 3305),	icon = "mapst_mission_upkeep",		helpOverlayID = "mapst_mission_active_upkeep",		helpOverlayText = ReadText(1028, 3231) },
		{ category = "guidance",	name = ReadText(1001, 3329),	icon = "mapst_mission_guidance",	helpOverlayID = "mapst_mission_active_guidance",	helpOverlayText = ReadText(1028, 3232) },
	},

	missionContextWidth = 400,
	missionContextIconWidthFactor = 0.4,

	autopilotmarker = ">> ",
	softtargetmarker_l = "> ",

	tradeContextMenuWidth = math.min(Helper.scaleX(900), 0.5 * Helper.viewWidth + Helper.scrollbarWidth),
	tradeContextMenuInfoBorder = 15,

	legend = {
		-- hexes
		{ icon = "maplegend_hexagon_fog_01",		text = ReadText(10002, 606),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth },														-- Unknown location
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9806),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_mineral"] },				-- Mineral Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9807),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_liquid"]  },				-- Gas Region
		{ icon = "maplegend_hexagon_01",			text = ReadText(1001, 9812),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth,	color = Color["resource_mineral_liquid"]  },		-- Mineral/Gas Region
		-- highways, gates, etc
		{ icon = "solid",							text = ReadText(1001, 9809),	width = Helper.sidebarWidth,	height = Helper.standardTextHeight / 2,	minRowHeight = Helper.sidebarWidth / 2 },	-- Jump Gate Connection
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 601),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "superhighwaycolor" },					-- Superhighway
		{ icon = "maplegend_hw_01",					text = ReadText(20001, 501),	width = Helper.sidebarWidth,	height = Helper.sidebarWidth / 2,	color = "highwaycolor" },						-- Local Highway
		{ icon = "mapob_jumpgate",					text = ReadText(20001, 701),	color = "gatecolor" },			-- Jump Gate
		{ icon = "mapob_transorbital_accelerator",	text = ReadText(20001, 1001),	color = "gatecolor" },			-- Accelarator
		{ icon = "mapob_superhighway",				text = ReadText(1001, 9810),	color = "highwaygatecolor" },	-- Superhighway Gate
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5200),	color = "playercolor" },		-- Owned
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5202),	color = "friendcolor" },		-- Neutral
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5201),	color = "enemycolor" },			-- Enemy
		{ icon = "ship_s_fight_01",					text = ReadText(1001, 5212),	color = "hostilecolor" },		-- Hostile
		-- stations
		{ text = ReadText(1001, 4) },																																					-- Stations
		{ icon = "mapob_playerhq",					text = ReadText(20102, 2011),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "playercolor" },	-- Headquarters
		{ icon = "maplegend_hq_01",					text = ReadText(1001, 9808),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Faction Headquarters
		{ icon = "mapob_shipyard",					text = ReadText(1001, 92),		width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Shipyard
		{ icon = "mapob_wharf",						text = ReadText(1001, 9805),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Wharf
		{ icon = "mapob_equipmentdock",				text = ReadText(1001, 9804),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Equipment Dock
		{ icon = "mapob_tradestation",				text = ReadText(1001, 9803),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Trading Station
		{ icon = "mapob_defensestation",			text = ReadText(1001, 9802),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Defence Platform
		{ icon = "mapob_piratestation",				text = ReadText(20102, 1511),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Free Port
		{ station_factory_placeholder = true },
		{ icon = "mapob_factory",					text = ReadText(20102, 1001),	width = 0.8 * Helper.sidebarWidth,	height = 0.8 * Helper.sidebarWidth,	color = "friendcolor" },	-- Factory
		-- xl ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5041) },					-- Ships: XL
		{ icon = "ship_xl_battleship_01",			text = ReadText(1001, 9822),	color = "friendcolor" },	-- Battleship
		{ icon = "ship_xl_carrier_01",				text = ReadText(1001, 9823),	color = "friendcolor" },	-- Carrier
		{ icon = "ship_xl_destroyer_01",			text = ReadText(1001, 9824),	color = "friendcolor" },	-- Destroyer
		{ icon = "ship_xl_freighter_01",			text = ReadText(1001, 9819),	color = "friendcolor" },	-- Freighter
		{ icon = "ship_xl_resupplier_01",			text = ReadText(1001, 9820),	color = "friendcolor" },	-- Auxiliary
		--{ icon = "ship_xl_miningrig_01",			text = ReadText(20221, 5081),	color = "friendcolor" },	-- Mining Rig
		{ icon = "ship_xl_builder_01",				text = ReadText(1001, 9821),	color = "friendcolor" },	-- Builder
		-- l ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5031) },					-- Ships: L
		{ icon = "ship_l_carrier_01",				text = ReadText(1001, 9823),	color = "friendcolor" },	-- Carrier
		{ icon = "ship_l_destroyer_01",				text = ReadText(1001, 9824),	color = "friendcolor" },	-- Destroyer
		{ icon = "ship_l_scavenger_01",				text = ReadText(1001, 9825),	color = "friendcolor" },	-- Scavenger
		{ icon = "ship_l_expeditionary_01",			text = ReadText(20221, 5091),	color = "friendcolor" },	-- Expeditionary
		{ icon = "ship_l_freighter_01",				text = ReadText(1001, 9819),	color = "friendcolor" },	-- Freighter
		{ icon = "ship_l_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_l_compactor_01",				text = ReadText(1001, 9826),	color = "friendcolor" },	-- Compactor
		-- m ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5021) },					-- Ships: M
		{ icon = "ship_m_frigate_01",				text = ReadText(1001, 9829),	color = "friendcolor" },	-- Frigate
		{ icon = "ship_m_corvette_01",				text = ReadText(1001, 9828),	color = "friendcolor" },	-- Corvette
		{ icon = "ship_m_gunboat_01",				text = ReadText(1001, 9830),	color = "friendcolor" },	-- Gunboat
		{ icon = "ship_m_scavenger_01",				text = ReadText(1001, 9825),	color = "friendcolor" },	-- Scavenger
		{ icon = "ship_m_transporter_01",			text = ReadText(1001, 9817),	color = "friendcolor" },	-- Transporter
		{ icon = "ship_m_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_m_tug_01",					text = ReadText(1001, 9827),	color = "friendcolor" },	-- Tug
		-- s ships
		{ text = ReadText(1001, 6) .. ReadText(1001, 120) .. " " .. ReadText(20111, 5011) },					-- Ships: S
		{ icon = "ship_s_heavyfighter_01",			text = ReadText(1001, 9833),	color = "friendcolor" },	-- Heavy Fighter
		{ icon = "ship_s_fighter_01",				text = ReadText(1001, 9816),	color = "friendcolor" },	-- Fighter
		{ icon = "ship_s_scout_01",					text = ReadText(1001, 9834),	color = "friendcolor" },	-- Scout
		{ icon = "ship_s_lasertower_01",			text = ReadText(1001, 9835),	color = "friendcolor" },	-- Lasertower
		{ icon = "ship_s_drone_fight_01",			text = ReadText(20101, 100401),	color = "friendcolor" },	-- Defence Drone
		{ icon = "ship_s_courier_01",				text = ReadText(1001, 9832),	color = "friendcolor" },	-- Courier
		{ icon = "ship_s_drone_trade_01",			text = ReadText(20101, 100101),	color = "friendcolor" },	-- Cargo Drone
		{ icon = "ship_s_miner_01",					text = ReadText(1001, 9818),	color = "friendcolor" },	-- Miner
		{ icon = "ship_s_drone_mine_01",			text = ReadText(20101, 100501),	color = "friendcolor" },	-- Mining Drone
		{ icon = "ship_s_racer_01",					text = ReadText(1001, 9831),	color = "friendcolor" },	-- Racing
		-- xs ships
		{ text = ReadText(1001, 22) },																			-- Units
		{ icon = "ship_xs_drone_fight_01",			text = ReadText(20101, 100401),	color = "friendcolor" },	-- Defence Drone
		{ icon = "ship_xs_policeship_01",			text = ReadText(20214, 800),	color = "friendcolor" },	-- Police Vehicles
		{ icon = "ship_xs_boardingpod_01",			text = ReadText(20101, 101301),	color = "friendcolor" },	-- Boarding Pod
		{ icon = "ship_xs_distressdrone_01",		text = ReadText(1001, 9836),	color = "friendcolor" },	-- Distress Drone
		{ icon = "ship_xs_lasertower_01_inactive",	text = ReadText(1001, 9835),	color = "friendcolor" },	-- Lasertower
		{ icon = "ship_xs_drone_trade_01",			text = ReadText(20101, 100101),	color = "friendcolor" },	-- Cargo Drone
		{ icon = "ship_xs_personalvehicle_01",		text = ReadText(20101, 110201),	color = "friendcolor" },	-- Civilian Ship
		{ icon = "ship_xs_drone_build_01",			text = ReadText(20101, 100301),	color = "friendcolor" },	-- Building Drone
		-- trade offers
		{ text = ReadText(1001, 1113) },																		-- Trade Offers
		{ icon = "maptr_illegal",					text = ReadText(1001, 9813) },								-- Illegal Trades
		{ icon = "maptr_buildstorage",				text = ReadText(1001, 11032) },								-- Station Construction Trades
		{ icon = "maptr_supply",					text = ReadText(1001, 9814) },								-- Supply Trades
		{ icon = "maptr_hexagon",					text = ReadText(1001, 9815),	color = Color["trade_buyoffer"] },	-- Trade Volume
		-- misc
		{ text = ReadText(1001, 2664) },																								-- Misc
		{ icon = "mapob_lasertower_xs",				text = ReadText(20201, 20501),	color = "friendcolor" },							-- Laser Tower Mk1
		{ icon = "mapob_lasertower_s",				text = ReadText(20201, 20601),	color = "friendcolor" },							-- Laser Tower Mk2
		{ icon = "mapob_mine",						text = ReadText(20201, 20201),	color = "friendcolor" },							-- Mine
		{ icon = "solid",							text = ReadText(1001, 1304),	width = 4,	height = 4,	color = "missilecolor" },	-- Missiles
		{ icon = "mapob_satellite_01",				text = ReadText(20201, 20301),	color = "friendcolor" },							-- Satellite
		{ icon = "mapob_satellite_02",				text = ReadText(20201, 20401),	color = "friendcolor" },							-- Advanced Satellite
		{ icon = "mapob_resourceprobe",				text = ReadText(20201, 20701),	color = "friendcolor" },							-- Resource Probe
		{ icon = "mapob_navbeacon",					text = ReadText(20201, 20801),	color = "friendcolor" },							-- Nav Beacon
		{ icon = "mapob_lockbox",					text = ReadText(20109, 4001),	color = "friendcolor" },							-- Lockbox
		{ icon = "mapob_drop",						text = ReadText(20109, 101),	color = "friendcolor" },							-- Container
		{ icon = "mapob_collectablewarecontainer",	text = ReadText(20109, 1101),	color = "friendcolor" },							-- Ware Container
		{ icon = "mapob_collectableammo",			text = ReadText(20109, 1001),	color = "friendcolor" },							-- Ammo Container
		{ icon = "mapob_asteroid",					text = ReadText(20001, 801),	color = "friendcolor" },							-- Asteroid
		{ icon = "mapob_collectableasteroid",		text = ReadText(1001, 11652),	color = "friendcolor" },							-- Collectable Asteroid
		{ icon = "mapob_poi",						text = ReadText(1001, 9811),	color = "friendcolor" },							-- Point of Interest
		{ icon = "mapob_unknown",					text = ReadText(20109, 5001) },														-- Unknown Object
		{ icon = "npc_factionrep",					text = ReadText(20208, 10601),	color = "friendcolor" },							-- Faction Representative
		{ icon = "npc_missionactor",				text = ReadText(30260, 1901),	color = "missioncolor" },							-- Person of Interest
		{ icon = "npc_shadyguy",					text = ReadText(20208, 10801),	color = "friendcolor" },							-- Black Marketeer
		{ icon = "missiontype_fight",				text = ReadText(1001, 3291),	color = "missioncolor" },							-- Mission Offers
		{ icon = "mapob_missiontarget",				text = ReadText(1001, 3325),	color = "missioncolor" },							-- Accepted Missions
		-- orders
		{ text = ReadText(1001, 8360) },												-- Behaviours
		{ icon = "order_movegeneric",				text = ReadText(1041, 541) },		-- Fly
		{ icon = "order_wait",						text = ReadText(1041, 101) },		-- Hold Position
		{ icon = "order_waitforsignal",				text = ReadText(1041, 111) },		-- Wait for Signal
		{ icon = "order_dockat",					text = ReadText(1041, 441) },		-- Dock
		{ icon = "order_dockandwait",				text = ReadText(1041, 451) },		-- Dock and Wait
		{ icon = "order_undock",					text = ReadText(1041, 531) },		-- Undock
		{ icon = "order_follow",					text = ReadText(1041, 321) },		-- Follow Ship

		{ icon = "order_attack",					text = ReadText(1041, 431) },		-- Attack
		{ icon = "order_attackinrange",				text = ReadText(1041, 631) },		-- Attack targets in range
		{ icon = "order_patrol",					text = ReadText(1041, 391) },		-- Patrol
		{ icon = "order_protectposition",			text = ReadText(1041, 381) },		-- Protect Position
		{ icon = "order_police",					text = ReadText(1041, 671) },		-- Police
		{ icon = "order_plunder",					text = ReadText(1041, 231) },		-- Plunder
		{ icon = "order_board",						text = ReadText(1041, 421) },		-- Board
		{ icon = "order_escort",					text = ReadText(1041, 411) },		-- Escort Ship
		{ icon = "order_recon",						text = ReadText(1041, 291) },		-- Recon
		{ icon = "order_flee",						text = ReadText(1041, 551) },		-- Flee

		{ icon = "order_findbuildtasks",			text = ReadText(1041, 491) },		-- Find Build Tasks
		{ icon = "order_deploytostation",			text = ReadText(1041, 511) },		-- Deploy to Station

		{ icon = "order_explore",					text = ReadText(1041, 311) },		-- Explore
		{ icon = "order_exploreupdate",				text = ReadText(1041, 301) },		-- Revisit known stations

		{ icon = "order_miningroutine",				text = ReadText(1041, 561) },		-- Mine Resources

		{ icon = "order_tradeperform",				text = ReadText(1041, 171) },		-- Execute Trade
		{ icon = "order_tradeexchange",				text = ReadText(1041, 121) },		-- Ware Exchange
		{ icon = "order_traderoutine",				text = ReadText(1041, 161) },		-- AutoTrade
		{ icon = "order_player_docktotrade",		text = ReadText(1041, 461) },		-- Dock to Trade
		{ icon = "order_disitributewares",			text = ReadText(1041, 181) },		-- Distribute Wares
		{ icon = "order_crewexchange",				text = ReadText(1041, 681) },		-- Transfer Crew

		{ icon = "order_supplyfleet",				text = ReadText(1041, 641) },		-- Supply Fleet
		{ icon = "order_getsupplies",				text = ReadText(1041, 621) },		-- Get Supplies
		{ icon = "order_resupply",					text = ReadText(1041, 191) },		-- Repair and Resupply
		{ icon = "order_restocksubordinates",		text = ReadText(1041, 201) },		-- Restock Subordinates
		{ icon = "order_recallsubordinates",		text = ReadText(1041, 221) },		-- Recall Subordinates
		{ icon = "order_assigncommander",			text = ReadText(1041, 521) },		-- Assign to new Commander
		{ icon = "order_equip",						text = ReadText(1041, 501) },		-- Change Equipment

		{ icon = "order_collect",					text = ReadText(1041, 481) },		-- Collect
		{ icon = "order_collectdropsinradius",		text = ReadText(1041, 571) },		-- Collect Drops
		{ icon = "order_collectlockbox",			text = ReadText(1041, 661) },		-- Collect Lockbox
		{ icon = "order_deployobjectatposition",	text = ReadText(1041, 471) },		-- Deploy Object At Position
		{ icon = "order_depositinventory",			text = ReadText(1041, 651) },		-- Deposit Inventory
	},

	dropInventoryWidth = 500,
	crewTransferWidth = 600,
	renameWidth = 300,
	changeLogoWidth = 450,
	orderqueueContextWidth = 350,
	tradeLoopWidth = 500,
	venturePatronWidth = 400,
	hireContextWidth = 350,
	ventureTeamContextWidth = 260,
	ventureContactContextWidth = 260,

	orderDragSupport = {
	--	order name					position parameter
		["MoveWait"]				= 1,
		["CollectDropsInRadius"]	= 1,
		["SalvageInRadius"]			= 1,
		["DeployObjectAtPosition"]	= 1,
		["AttackInRange"]			= 1,
		["RescueInRange"]			= 1,
		["ProtectPosition"]			= 1,
		["MiningCollect"]			= 1,
		["MiningPlayer"]			= 1,
		["Explore"]					= 2,
		["ExploreUpdate"]			= 2,
	},

	assignments = {
		["defence"]					= { name = ReadText(20208, 40301) },
		["positiondefence"]			= { name = ReadText(20208, 41501) },
		["attack"]					= { name = ReadText(20208, 40901) },
		["interception"]			= { name = ReadText(20208, 41001) },
		["bombardment"]				= { name = ReadText(20208, 41601) },
		["follow"]					= { name = ReadText(20208, 41301) },
		["supplyfleet"]				= { name = ReadText(20208, 40701) },
		["mining"]					= { name = ReadText(20208, 40201) },
		["trade"]					= { name = ReadText(20208, 40101) },
		["tradeforbuildstorage"]	= { name = ReadText(20208, 40801) },
		["assist"]					= { name = ReadText(20208, 41201) },
		["salvage"]					= { name = ReadText(20208, 41401) },
	},

	infoLogbook = {
		category = "all",
		pageSize = 100,
		queryLimit = 1000,
	},

	ventureSeasons = {
		maxDescRows = 12,
	},

	plots = {
		maxPlotRows = 10,
	},
}

__CORE_DETAILMONITOR_MAPFILTER = __CORE_DETAILMONITOR_MAPFILTER or {
	version = config.mapfilterversion,
	["layer_trade"] = true,
	["layer_fight"] = false,
	["layer_think"] = true,
	["layer_build"] = false,
	["layer_diplo"] = false,
	["layer_mining"] = true,
	["layer_other"] = true,
	["trade_price_maxprice"] = 0,
	["trade_playeroffer_buy"] = 0,
	["trade_playeroffer_sell"] = 0,
	["trade_offer_number"] = 3,
	["trade_relation_enemy"] = true,
	["trade_volume"] = 0,
	["think_alert"] = 1,
	["think_diplomacy_factioncolor"] = false,
	["think_diplomacy_highlightvisitor"] = true,
	["mining_resource_display"] = true,
	["other_misc_orderqueue"] = true,
	["other_misc_allyorderqueue"] = true,
	["other_misc_missions"] = true,
	["other_misc_ecliptic"] = true,
	["other_misc_civilian"] = true,
	["other_misc_wrecks"] = true,
	["other_misc_selection_lines"] = true,
	["other_misc_opacity"] = false,
	["other_misc_gate_connections"] = false,
	["other_misc_coveroverride"] = false,
	["other_misc_rendersatelliteradarrange"] = true,
}

-- kuertee start:
menu.uix_callbacks = {}
local distanceTool_from_component
local distanceTool_from_posRot
local distanceTool_to_component
local distanceTool_to_posRot
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.extendedmoduletypes = {}
	menu.extendedsubordinates = {}
	menu.extendeddockedships = {}
	menu.extendedconstruction = {}
	menu.extendedproperty = { ships = true, stations = true }
	menu.extendedorders = {}
	menu.extendedinfo = {}
	menu.infoTablePersistentData = {
		left = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
		right = {
			crew = { ["object"] = nil, ["capacity"] = 0, ["total"] = 0, ["current"] = { ["total"] = 0, ["roles"] = {} }, ["reassigned"] = { ["total"] = 0, ["roles"] = {} }, ["unassigned"] = { ["total"] = 0, ["persons"] = {} } },
			cashtransferdetails = {},
			macrostolaunch = {},
			drops = {},
			venturelogbook = { curPage = 1, searchtext = "" },
			pastseasons = { curPage = 1, searchtext = "" },
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
			claimedOutcomes = {},
		},
	}
	menu.holomap = 0

	if __CORE_DETAILMONITOR_MAPFILTER.version < config.mapfilterversion then
		menu.upgradeMapFilterVersion()
	end

	RegisterEvent("mapfilter", menu.filterUpdate)
	registerForEvent("gameLoadingDone", getElement("Scene.UIContract"), menu.onLoadingDone)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

function menu.onLoadingDone()
	__CORE_DETAILMONITOR_MAPFILTER_SAVE = __CORE_DETAILMONITOR_MAPFILTER_SAVE or {
		version = C.IsNewGame() and config.mapfiltersaveversion or 0,
		["trade_storage_container"] = true,
		["trade_storage_solid"] = true,
		["trade_storage_liquid"] = true,
		["trade_storage_condensate"] = true,
	}

	if __CORE_DETAILMONITOR_MAPFILTER_SAVE.version < config.mapfiltersaveversion then
		menu.upgradeMapFilterSaveVersion()
	end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.createLegend()
	if menu.haslegend then
		return
	end
	menu.haslegend = true

	for i = 1, #config.legend do
		local entry = config.legend[i]
		if entry.station_factory_placeholder then
			local waregroups = {}
			local n = C.GetNumAllWareGroups()
			local buf = ffi.new("WareGroupInfo[?]", n)
			n = C.GetAllWareGroups(buf, n)
			for j = 0, n - 1 do
				if buf[j].tier > 0 then
					table.insert(waregroups, { icon = ffi.string(buf[j].factorymapicon), text = ffi.string(buf[j].factoryname), tier = buf[j].tier })
				end
			end
			table.sort(waregroups, menu.sortWareGroupsByTier)

			for j, group in ipairs(waregroups) do
				if j == 1 then
					config.legend[i] = { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" }
				else
					table.insert(config.legend, i + j - 1, { icon = group.icon, text = group.text, width = 0.8 * Helper.sidebarWidth, height = 0.8 * Helper.sidebarWidth, color = "friendcolor" })
				end
			end
		end
	end
end

function menu.sortWareGroupsByTier(a, b)
	if a.tier == b.tier then
		return a.text < b.text
	end
	return a.tier > b.tier
end

function menu.cleanup()
	if not menu.minimized then
		if (menu.mode == nil) or (menu.mode == "selectbuildlocation") then
			menu.state = menu.onSaveState()
		end

		UnregisterAddonBindings("ego_detailmonitor")
		menu.arrowsRegistered = nil
		UnregisterEvent("updateHolomap", menu.updateHolomap)
		UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)

		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
		end
		unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end
	end

	if Helper.hasExtension("multiverse") then
		Helper.callExtensionFunction("multiverse", "cleanup", menu)
	end

	if menu.mode == "hire" then
		menu.searchTableMode = nil
	elseif menu.mode == "selectCV" then
		for k, v in pairs(menu.layerBackup) do
			__CORE_DETAILMONITOR_MAPFILTER[k] = v
			if k == "think_diplomacy_highlightvisitor" then
				C.SetConfigSetting("highlightvisitors", v)
			end
		end
	end

	menu.title = nil
	menu.activatemap = nil
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.mode = nil
	menu.modeparam = {}
	menu.createInfoFrameRunning = nil
	menu.createInfoFrame2Running = nil
	menu.createMainFrameRunning = nil
	menu.lastUpdateHolomapTime = nil
	menu.noupdate = nil
	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end
	menu.autopilottarget = nil
	menu.softtarget = nil
	menu.lastactivetable = nil
	menu.focuscomponent = nil
	menu.behaviourInspectionComponent = nil
	menu.currentsector = nil
	menu.selectedcomponents = {}
	menu.closemapwithmenu = nil
	menu.oldmode = nil
	menu.oldInfoTableMode = nil
	menu.cachedOrderFailures = {}

	menu.boardingData = {}
	menu.boardingtable_shipselection = {}
	menu.queuecontextrefresh = nil
	menu.contexttoprow = nil
	menu.contextselectedrow = nil

	menu.infoSubmenuObject = nil
	menu.infoTablePersistentData.left.crew.object = nil
	menu.infoTablePersistentData.right.crew.object = nil
	menu.infoTablePersistentData.left.resetcrew = nil
	menu.infoTablePersistentData.right.resetcrew = nil
	menu.infoTablePersistentData.left.cashtransferdetails = {}
	menu.infoTablePersistentData.right.cashtransferdetails = {}
	menu.infoTablePersistentData.left.macrostolaunch = {}
	menu.infoTablePersistentData.right.macrostolaunch = {}
	menu.infoTablePersistentData.left.drops = {}
	menu.infoTablePersistentData.right.drops = {}
	menu.infoTablePersistentData.left.planneddefaultorderloop = nil
	menu.infoTablePersistentData.right.planneddefaultorderloop = nil
	menu.infoTablePersistentData.left.planneddefaultorderiscopy = nil
	menu.infoTablePersistentData.right.planneddefaultorderiscopy = nil
	if menu.infoTablePersistentData.left.orderqueuemode and (menu.infoTablePersistentData.left.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.left.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.left.orderqueuemode = nil
	if menu.infoTablePersistentData.right.orderqueuemode and (menu.infoTablePersistentData.right.orderqueuemode.mode == "plandefaultorder") then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData.right.orderqueuemode.curobject)
	end
	menu.infoTablePersistentData.right.orderqueuemode = nil

	menu.plots = {}
	menu.plotDoNotUpdate = nil
	menu.table_plotlist = {}
	menu.plotsliders = {}
	menu.plotbuttons = {}
	menu.plots_initialized = nil
	--menu.setplotrow = nil
	--menu.setplottoprow = nil
	-- do not clean this up to reselect the last selected plot if re-accessing the map. for example, from the station configuration menu.
	--menu.plotData = {}

	menu.missionOfferList = {}
	menu.missionList = {}
	menu.missionDoNotUpdate = nil

	menu.rendertargetWidth = nil
	menu.rendertargetHeight = nil
	menu.editboxHeight = nil
	menu.sideBarWidth = nil

	menu.searchtext = {}
	menu.holomapcolor = {}
	menu.ownerDetails = nil

	menu.buttonline = nil
	menu.orderdefs = {}
	menu.orderdefsbycategory = {}

	menu.turrets = {}
	menu.turretgroups = {}

	menu.mainFrame = nil
	menu.infoFrame = nil
	menu.infoFrame2 = nil
	menu.infoTableData = {}
	menu.contextMenuMode = nil
	menu.contextMenuData = {}
	menu.contextFrame = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	menu.highlightedbordercomponent = nil
	menu.highlightedbordermoduletype = nil
	menu.highlightedplannedmodule = nil
	menu.highlightedbordersection = nil
	menu.highlightedborderstationcategory = nil
	menu.selectedstationcategory = nil
	menu.highlightedconstruction = nil
	menu.selectedconstruction = nil
	menu.selectedfleetcommander = nil
	menu.highlightedfleetunit = nil
	menu.selectedfleetunit = nil

	menu.lock = nil
	menu.leftdown = nil
	menu.rightdown = nil

	menu.panningmap = nil
	menu.rotatingmap = nil
	menu.orderdrag = nil
	menu.intersectordrag = nil

	menu.refreshed = nil
	menu.picking = true
	menu.pickstate = nil

	if menu.map then
		SetMouseOverOverride(menu.map, nil)
	end

	menu.searchField = nil
	menu.sideBar = nil
	selectedShipsTable = nil
	menu.topLevel = nil
	menu.map = nil

	menu.infoTable = nil
	menu.infoTable2 = nil
	menu.infoTable3 = nil
	menu.infoTableRight = nil
	menu.infoTableRight2 = nil
	menu.infoTableRight3 = nil

	menu.contextMenu = nil

	if menu.sound_ambient then
		StopPlayingSound(menu.sound_ambient)
	end
	if menu.sound_panmap then
		StopPlayingSound(menu.sound_panmap)
	end
	if menu.sound_rotatemap and menu.sound_rotatemap.sound then
		StopPlayingSound(menu.sound_rotatemap.sound)
	end
	if menu.sound_zoom then
		StopPlayingSound(menu.sound_zoom)
	end
	menu.sound_ambient = nil
	menu.sound_panmap = nil
	menu.sound_rotatemap = nil
	menu.sound_zoom = nil

	menu.sound_selectedelement = nil

	menu.lastzoom = nil
	menu.zoom_newdir = nil

	menu.clearMouseCursorOverrides()

	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
end

-- Menu member functions

-- button scripts
function menu.updateMapAndInfoFrame()
	if menu.holomap ~= 0 then
		C.ClearSelectedMapComponents(menu.holomap)
	end
	menu.createInfoFrame()
end

function menu.buttonBoardingAddShip()
	-- TODO: implement boarding_selectplayerobject mode and return to boarding menu if object is selected.
	--if not menu.boardingData.contextmenudata then
	--	menu.boardingData.contextmenudata = menu.contextMenuData
	--end
	menu.mode = "boarding_selectplayerobject"
	menu.infoTableMode = "propertyowned"
	menu.boardingData.changed = true
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.buttonBoardingRemoveShip(shipid)
	menu.boardingData.shipdata[shipid] = nil
	for i, locship in ipairs(menu.contextMenuData.boarders) do
		if locship == shipid then
			table.remove(menu.contextMenuData.boarders, i)
			break
		end
	end
	for i, locship in ipairs(menu.boardingData.ships) do
		if locship == shipid then
			table.remove(menu.boardingData.ships, i)
			break
		end
	end
	if not C.RemoveAttackerFromBoardingOperation(shipid) then
		DebugError("Failed to remove " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " from boarding operation.")
	end
	menu.boardingData.changed = true
	if #menu.boardingData.ships > 0 then
		menu.refreshContextFrame()
	else
		menu.closeContextMenu()
	end
end

function menu.buttonUpdateBoardingOperation(alreadystarted)
	--print("risk 1 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold) .. ", risk 2 threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold))
	if not alreadystarted then
		if not C.CreateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold) then
			DebugError("Failed to create boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	else
		C.UpdateBoardingOperation(menu.boardingData.target, "player", menu.boardingData.riskleveldata[menu.boardingData.risk1].threshold, menu.boardingData.riskleveldata[menu.boardingData.risk2].threshold)
	end

	for _, shipid in pairs(menu.boardingData.ships) do
		--print("adding " .. ffi.string(C.GetComponentName(shipid)))
		menu.addShipToBoardingOperation(shipid, menu.boardingData.shipdata[shipid])
	end

	if not alreadystarted then
		if not C.StartBoardingOperation(menu.boardingData.target, "player") then
			DebugError("Failed to start boarding operation involving target: " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	-- reset boarding data to retrieve new information from boarding operation.
	menu.boardingData.ships = {}
	menu.boardingData.shipdata = {}
	menu.boardingData.changed = false
	-- in case of emergency, press below.
	--C.AbortBoardingOperation(menu.boardingData.target, "player")
	menu.refreshContextFrame()
end

function menu.buttonExtendModuleType(station, type)
	menu.extendModuleType(station, type)

	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendSubordinate(name, group)
	if menu.isSubordinateExtended(name, group) then
		if menu.extendedsubordinates[name .. group] == false then
			menu.extendedsubordinates[name .. group] = nil
		else
			menu.extendedsubordinates[name .. group] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "subordinates" .. name .. group
	else
		menu.extendedsubordinates[name .. group] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendDockedShips(name, isstation)
	if menu.isDockedShipsExtended(name, isstation) then
		if isstation then
			menu.extendeddockedships[name] = nil
		else
			menu.extendeddockedships[name] = false
		end
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "dockedships"
	else
		menu.extendeddockedships[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendConstruction(name)
	if menu.isConstructionExtended(name) then
		menu.extendedconstruction[name] = nil
		menu.clearSelectedComponents()
		menu.highlightedbordercomponent = ConvertStringTo64Bit(name)
		menu.highlightedborderstationcategory = "constructions"
	else
		menu.extendedconstruction[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendProperty(name)
	if menu.isPropertyExtended(name) then
		menu.extendedproperty[name] = nil
		local component64 = ConvertStringTo64Bit(name)
		if component64 ~= 0 then
			menu.addSelectedComponent(component64, true)
		end
	else
		menu.extendedproperty[name] = true
	end
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.createInfoFrame()
end

function menu.buttonExtendOrder(controllable, orderidx, instance, row, col)
	menu.extendOrder(controllable, orderidx, instance)
	if instance == "left" then
		menu.refreshInfoFrame(row, col)
	elseif instance == "right" then
		menu.refreshInfoFrame2(row, col)
	end
end

function menu.handlePlannedDefaultOrder(instance, confirmed, callback)
	if ((instance == "left") and (menu.infoTableMode == "info")) or ((instance == "right") and (menu.searchTableMode == "info")) then
		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			if confirmed then
				C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].orderqueuemode = nil

				menu.closeContextMenu()
			else
				menu.contextMenuMode = "userquestion"
				menu.contextMenuData = { mode = "discardplanneddefaultbehaviour", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, callback = callback }

				menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
				return false
			end
		end
	end
	return true
end

function menu.handlePlannedDefaultOrderRendertargetSelect(confirmed)
	if not menu.handlePlannedDefaultOrder("left", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () return menu.handlePlannedDefaultOrderRendertargetSelect(true) end) then
		return false
	end
	if confirmed then
		if menu.infoTableMode == "info" then
			menu.refreshInfoFrame(nil, 0)
		elseif menu.searchTableMode == "info" then
			menu.refreshInfoFrame2(nil, 0)
		end
	end
	return true
end

function menu.buttonToggleObjectList(objectlistparam, confirmed, override)
	-- kuertee start: callback
	if menu.uix_callbacks ["buttonToggleObjectList_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonToggleObjectList_on_start"]) do
			uix_callback (objectlistparam, config)
		end
	end
	-- kuertee end: callback

	local oldidx, newidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
						if mode == objectlistparam then
							newidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
					if entry.mode == objectlistparam then
						newidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx and newidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.buttonToggleObjectList(objectlistparam, true) end) then
		return
	end

	local deactivate = false
	if override == nil then
		if menu.showMultiverse then
			deactivate = menu.ventureMode == objectlistparam
		else
			deactivate = menu.infoTableMode == objectlistparam
		end
	else
		deactivate = not override
	end

	if newidx then
		Helper.updateButtonColor(menu.sideBar, newidx, 1, Color["row_background_selected"])
	end
	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Color["button_background_default"])
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, objectlistparam)
		end
	else
		if (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", objectlistparam)
				end
			end
			menu.missionModeCurrent = nil
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end
	AddUITriggeredEvent(menu.name, objectlistparam, menu.infoTableMode == objectlistparam and "off" or "on")
	if deactivate then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		PlaySound("ui_negative_back")
		if menu.showMultiverse then
			menu.ventureMode = nil
		else
			menu.infoTableMode = nil
		end
		if oldidx then
			SelectRow(menu.sideBar, oldidx)
		end
	else
		menu.settoprow = nil
		menu.topRows.infotableleft = nil
		PlaySound("ui_positive_select")
		if menu.infoTableMode == "objectlist" then
			menu.topRows.objectlist = GetTopRow(menu.infoTable)
			menu.selectedRows.objectlist = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.objectlist = Helper.currentTableCol[menu.infoTable]
		elseif menu.infoTableMode == "propertyowned" then
			menu.topRows.propertyowned = GetTopRow(menu.infoTable)
			menu.selectedRows.propertyowned = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.propertyowned = Helper.currentTableCol[menu.infoTable]
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
		menu.infoTable = nil
		menu.infoTable2 = nil
		if menu.showMultiverse then
			menu.ventureMode = objectlistparam
		else
			menu.infoTableMode = objectlistparam
		end
		if newidx then
			SelectRow(menu.sideBar, newidx)
		end

		local tab
		if menu.infoTableMode == "objectlist" then
			tab = menu.objectMode
		elseif menu.infoTableMode == "propertyowned" then
			tab = menu.propertyMode
		elseif menu.infoTableMode == "info" then
			tab = menu.infoMode
		elseif menu.infoTableMode == "missionoffer" then
			tab = menu.missionOfferMode
		elseif menu.infoTableMode == "mission" then
			tab = menu.missionMode
		end
		if tab then
			AddUITriggeredEvent(menu.name, "infoTableTab", tab)
		end

		if menu.infoTableMode == "plots" then
			menu.behaviourInspectionComponent = nil
			C.SetMapBehaviourInspectionComponent(menu.holomap, 0)

			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			--menu.plotDoNotUpdate = true
			menu.mode = "selectbuildlocation"
			menu.clearSelectedComponents()
			C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		elseif (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") and (menu.mode ~= "behaviourinspection") then
			menu.plots_initialized = nil
			menu.plotData = {}
			menu.mode = nil
			menu.removeMouseCursorOverride(3)
			if not menu.showMultiverse then
				local mapstate = ffi.new("HoloMapState")
				C.GetMapState(menu.holomap, mapstate)
				local startpos = ffi.new("UIPosRot")
				C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)
				C.SetMapState(menu.holomap, mapstate)
			end
		end
		if menu.infoTableMode == "missionoffer" then
			menu.updateMissionOfferList(true)
		end
		menu.setTextFilter()
		menu.applyFilterSettings()
	end
	menu.setrow = nil
	menu.setcol = nil
	menu.selectedRows.infotableleft = nil
	menu.selectedCols.infotableleft = nil
	menu.topRows.infotable2 = nil
	menu.selectedRows.infotable2 = nil
	menu.selectedCols.infotable2 = nil
	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateObjectList(confirmed)
	local oldidx
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local count = 1
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.mode then
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.infoTableMode then
							oldidx = count
						end
					end
				else
					if entry.mode == menu.infoTableMode then
						oldidx = count
					end
				end
			end
			count = count + 1
		end
		if oldidx then
			break
		end
	end

	if not menu.handlePlannedDefaultOrder("left", confirmed, function () menu.deactivateObjectList(true) end) then
		return
	end

	if oldidx then
		Helper.updateButtonColor(menu.sideBar, oldidx, 1, Color["button_background_default"])
	end

	menu.createInfoFrameRunning = true
	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureinventory") or (menu.ventureMode == "ventureseason") or (menu.ventureMode == "venturecontacts") then
			Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, menu.ventureMode, menu.ventureMode)
		end
	else
		if menu.infoTableMode == "objectlist" then
			menu.topRows.objectlist = GetTopRow(menu.infoTable)
			menu.selectedRows.objectlist = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.objectlist = Helper.currentTableCol[menu.infoTable]
		elseif menu.infoTableMode == "propertyowned" then
			menu.topRows.propertyowned = GetTopRow(menu.infoTable)
			menu.selectedRows.propertyowned = Helper.currentTableRow[menu.infoTable]
			menu.selectedCols.propertyowned = Helper.currentTableCol[menu.infoTable]
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
				if Helper.hasExtension("multiverse") then
					Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
					Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureoperation", "ventureoperation")
				end
			end
			if menu.missionModeContext then
				menu.closeContextMenu()
				menu.missionModeContext = nil
			end
		end
	end

	menu.settoprow = GetTopRow(menu.infoTable)
	PlaySound("ui_negative_back")
	if menu.showMultiverse then
		menu.ventureMode = nil
	else
		menu.infoTableMode = nil
	end
	if oldidx then
		SelectRow(menu.sideBar, oldidx)
	end

	menu.refreshMainFrame = true
	menu.createInfoFrame()
end

function menu.deactivateSearchTable()
	menu.searchTableMode = nil
	menu.refreshMainFrame = true
end

function menu.buttonToggleRightBar(searchlistmode, confirmed)
	if not menu.handlePlannedDefaultOrder("right", confirmed, function () menu.buttonToggleRightBar(searchlistmode, true) end) then
		return
	end

	AddUITriggeredEvent(menu.name, searchlistmode, menu.searchTableMode == searchlistmode and "off" or menu.displayedFilterLayer)
	if menu.searchTableMode == searchlistmode then
		PlaySound("ui_negative_back")
		menu.searchTableMode = nil
	else
		PlaySound("ui_positive_select")
		menu.searchTableMode = searchlistmode
		menu.disregardFilterTable = true
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame2()
end

function menu.buttonResetView()
	if menu.holomap and (menu.holomap ~= 0) then
		C.ResetMapPlayerRotation(menu.holomap)
		C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.buttonNewOrder(orderid, default, instance)
	if orderid then
		if orderid == "TradePerform" then
			Helper.closeMenuForNewConversation(menu, "gTrade_offerselect", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), { 0, 0, true, ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)) })
			menu.cleanup()
		elseif orderid == "loop" then
			menu.infoTablePersistentData[instance].planneddefaultorderloop = { curobject = menu.infoSubmenuObject }
			menu.closeContextMenu()
			menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			menu.refreshInfoFrame()
		elseif menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
			C.CreateOrder(menu.infoSubmenuObject, orderid, default)
			local buf = ffi.new("Order")
			if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
				menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
				menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
				menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
				menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
				menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
				menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
				menu.infoTablePersistentData[instance].planneddefaultorderloop = nil

				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
						menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
				end
			end

			menu.closeContextMenu()
			if default then
				menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
			else
				menu.infoTablePersistentData[instance].selectedorder = { #menu.infoTableData[instance].orders + 1 }
				menu.extendOrder(menu.infoSubmenuObject, #menu.infoTableData[instance].orders + 1, instance)
			end
			menu.refreshInfoFrame()
		else
			DebugError("menu.buttonNewOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
		end
	else
		menu.contextMenuMode = "neworder"
		menu.contextMenuData = { default = default, instance = instance }
		local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
		if instance == "right" then
			offsetx = Helper.viewWidth - offsetx - Helper.scaleX(config.orderqueueContextWidth)
		end
		menu.createContextFrame(Helper.scaleX(config.orderqueueContextWidth), Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
	end
end

function menu.buttonOrderUp(order, instance, modified)
	local oldidx, newidx, enable
	oldidx = order
	if modified == "ctrl" then
		newidx = 1
		enable = true
	else
		if menu.infoTableData[instance].disabledmarker == order then
			newidx = order
			enable = true
		else
			newidx = order - 1
			enable = menu.infoTableData[instance].orders[order].enabled
		end
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderUp: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonOrderDown(order, instance, modified)
	local oldidx, newidx, enable
	oldidx = order
	if modified == "ctrl" then
		if menu.infoTableData[instance].disabledmarker == order + 1 then
			newidx = order
			enable = false
		elseif order < menu.infoTableData[instance].disabledmarker then
			newidx = menu.infoTableData[instance].disabledmarker - 1
			enable = true
		else
			newidx = #menu.infoTableData[instance].orders
			enable = false
		end
	else
		if menu.infoTableData[instance].disabledmarker == order + 1 then
			newidx = order
			enable = false
		else
			newidx = order + 1
			enable = menu.infoTableData[instance].orders[order].enabled
		end
	end

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.AdjustOrder(menu.infoSubmenuObject, oldidx, newidx, enable, false, false) then
			menu.swapExtendedOrder(menu.infoSubmenuObject, oldidx, newidx, instance)
			menu.resetOrderParamMode()
		end
	else
		DebugError("menu.buttonOrderDown: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonRemoveOrder(order, instance)
	if menu.removeOrder(order, instance) then
		menu.resetOrderParamMode()
	end
end

function menu.removeOrder(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if C.RemoveOrder(menu.infoSubmenuObject, orderidx, false, false) then
			menu.removeExtendedOrder(menu.infoSubmenuObject, orderidx, instance)
			if orderidx == #menu.infoTableData[instance].orders then
				menu.infoTablePersistentData[instance].selectedorder = (orderidx > 1) and { (orderidx - 1), object = menu.infoSubmenuObject } or nil
			end
			if menu.infoTablePersistentData[instance].selectedorder and (type(menu.infoTablePersistentData[instance].selectedorder[1]) == "number") then
				menu.infoTablePersistentData[instance].selectedorder = { math.min(menu.infoTablePersistentData[instance].selectedorder[1], #menu.infoTableData[instance].orders - 1), object = menu.infoSubmenuObject }
			end

			return true
		end
	else
		DebugError("menu.removeOrder: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	return false
end

function menu.buttonStartOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i, order in ipairs(menu.infoTableData[instance].orders) do
			if order.state == "disabled" then
				C.EnableOrder(menu.infoSubmenuObject, i)
			end
			if order.state == "setup" then
				break
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonStartOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDeleteAllOrders(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		for i = #menu.infoTableData[instance].orders, 1, -1 do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, false) then
				menu.removeExtendedOrder(menu.infoSubmenuObject, i, instance)
			end
		end
		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonDeleteAllOrders: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonDefaultOrderDiscard(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.RemovePlannedDefaultOrder(menu.infoSubmenuObject)
	else
		DebugError("menu.buttonDefaultOrderDiscard: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonDefaultOrderConfirm(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if menu.infoTablePersistentData[instance].planneddefaultorderloop then
			C.RemoveAllOrders(menu.infoSubmenuObject)
			C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
			C.SetOrderLoop(menu.infoSubmenuObject, 0, false)
		else
			C.ResetOrderLoop(menu.infoSubmenuObject)
			C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
		end
	else
		DebugError("menu.buttonDefaultOrderConfirm: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
	menu.infoTablePersistentData[instance].orderqueuemode = nil
	menu.refreshInfoFrame(0, 0)
end

function menu.buttonSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local paramtype, oldvalue
		if paramdata.type == "list" then
			paramtype = paramdata.inputparams.type
			if not paramtype then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			paramtype = paramdata.type
			oldvalue = paramdata.value
		end

		if paramtype == "bool" then
			SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, not (oldvalue ~= 0))
			menu.refreshInfoFrame()
		elseif paramtype == "object" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.infoTableMode = "objectlist"
			menu.mode = "orderparam_object"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable, order, param }

			if type(menu.modeparam[5]) == "string" then
				C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
			else
				C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
			end

			local orderdefid
			if order == "default" then
				orderdefid = menu.infoTableData[instance].defaultorder.orderdefref.id
			elseif order == "planneddefault" then
				orderdefid = menu.infoTableData[instance].planneddefaultorder.orderdefref.id
			else
				orderdefid = menu.infoTableData[instance].orders[order].orderdefref.id
			end
			if (orderdefid == "Attack") then
				menu.setMouseCursorOverride("targetred", 3)
			else
				menu.setMouseCursorOverride("target", 3)
			end

			menu.settoprow = 0

			menu.closeContextMenu()
			menu.refreshInfoFrame()
			menu.refreshMainFrame = true
		elseif paramtype == "sector" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for sector in pairs(value) do
						table.insert(sorted, ConvertStringTo64Bit(sector))
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, sector in ipairs(paramdata.value) do
								if not value[tostring(sector)] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortComponentName)
						for _, sector in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ConvertStringToLuaID(tostring(sector)))
						end
					end
				else
					SetOrderParam(object64, order, param, index, ConvertStringToLuaID(tostring(value)))
					AddUITriggeredEvent(menu.name, menu.contextMenuMode, ConvertStringToLuaID(tostring(value)))
				end
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_sector"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "ware" then
			if value then
				local object64 = ConvertStringTo64Bit(tostring(menu.infoSubmenuObject))
				if (paramdata.type == "list") and (type(value) == "table") then
					local skip = true

					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					-- we want to re-add the complete list to keep it alphabetical
					if not paramdata.value then
						-- no values yet, we need to set
						skip = false
					else
						if #paramdata.value ~= #sorted then
							-- number is not the same, we need to set
							skip = false
						else
							for _, ware in ipairs(paramdata.value) do
								if not value[ware] then
									-- exisiting value not in new list, we need to set
									skip = false
									break
								end
							end
							-- if skip is still true here, all existing values are in the new list and previous check excludes the case of only new entries added, nothing to do
						end
						if not skip then
							-- remove all old
							for listidx = #paramdata.value, 1, -1 do
								RemoveOrderListParam(object64, order, param, listidx)
							end
						end
					end
					if not skip then
						-- add all new
						table.sort(sorted, Helper.sortWareName)
						for _, ware in ipairs(sorted) do
							SetOrderParam(object64, order, param, nil, ware)
						end
					end
				else
					SetOrderParam(object64, order, param, index, value)
					AddUITriggeredEvent(menu.name, "orderparam_" .. paramdata.name, value)
				end
				menu.closeContextMenu()
				Helper.clearTableConnectionColumn(menu, 3)
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_ware"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		elseif paramtype == "macro" then
			-- TODO
		elseif paramtype == "position" then
			menu.currentInfoMode = { menu.infoTableMode, menu.infoMode.left }
			menu.mode = "orderparam_position"
			local controllable = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))
			local toprow = 1
			if instance == "left" then
				toprow = GetTopRow(menu.infoTable)
			elseif instance == "right" then
				toprow = GetTopRow(menu.infoTableRight)
			end
			menu.modeparam = { function (value) return menu.setOrderParamFromMode(controllable, order, param, index, value, instance) end, paramdata, toprow, controllable }

			menu.setMouseCursorOverride("target", 3)

			menu.settoprow = 0
			menu.closeContextMenu()
			menu.refreshInfoFrame()
		elseif paramtype == "formationshape" then
			if value then
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
				menu.closeContextMenu()
				menu.refreshInfoFrame()
			else
				menu.contextMenuMode = "set_orderparam_formationshape"
				menu.contextMenuData = { order = order, param = param, index = index, instance = instance }
				local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
				if instance == "right" then
					offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
				end
				menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
			end
		else
			DebugError("Unsupported order parameter type '" .. tostring(paramtype) .. "' [Florian]")
		end
	else
		DebugError("menu.buttonSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.checkboxOrderPlayerOverride(order, param, paramdata, overrideparam, overrideparamdata, checked)
	local object = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))

	if checked then
		-- remove all overrides
		for listidx = #overrideparamdata.value, 1, -1 do
			RemoveOrderListParam(object, order, overrideparam, listidx)
		end
	else
		-- init override list with current list
		for _, value in ipairs(paramdata.value) do
			SetOrderParam(object, order, overrideparam, nil, value)
		end
	end
	menu.refreshInfoFrame()
end

function menu.checkboxOrderPlayerOverrideValue(order, overrideparam, listidx, value)
	local object = ConvertStringToLuaID(tostring(menu.infoSubmenuObject))

	if listidx then
		RemoveOrderListParam(object, order, overrideparam, listidx)
	else
		SetOrderParam(object, order, overrideparam, nil, value)
	end
	menu.refreshInfoFrame()
end

function menu.slidercellSetOrderParam(order, param, index, value, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local paramdata
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		elseif order == "planneddefault" then
			paramdata = menu.infoTableData[instance].planneddefaultorder.params[param]
		else
			paramdata = menu.infoTableData[instance].orders[order].params[param]
		end

		local type, oldvalue
		if paramdata.type == "list" then
			type = paramdata.inputparams.type
			if not type then
				DebugError("Order parameter of type 'list' does not specify a input parameter 'type' [Florian]")
			end
			if index then
				oldvalue = paramdata.value[index]
			end
		else
			type = paramdata.type
			oldvalue = paramdata.value
		end

		if type == "number" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "length" then
			if value then
				menu.noupdate = true
				if paramdata.inputparams.step >= 1000 then
					value = value * 1000
				end
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value)
			end
		elseif type == "time" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 60)
			end
		elseif type == "money" then
			if value then
				menu.noupdate = true
				SetOrderParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index, value * 100)
			end
		end
	else
		DebugError("menu.slidercellSetOrderParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.buttonRemoveListParam(order, param, index, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		if order == "default" then
			menu.copyDefaultOrderForPlanning(instance)

			order = "planneddefault"
		end

		RemoveOrderListParam(ConvertStringToLuaID(tostring(menu.infoSubmenuObject)), order, param, index)

		menu.refreshInfoFrame()
	else
		DebugError("menu.buttonRemoveListParam: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonNewPlot()
	--print("x: " .. tostring(menu.plotData.size.x) .. ", y: " .. tostring(menu.plotData.size.y) .. ", z: " .. tostring(menu.plotData.size.z))
	menu.plotData.active = true
	C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
end

function menu.buttonRemovePlot(station, confirmed, removebuildstorage)
	if not station then
		DebugError("menu.buttonRemovePlot called with no station set. station: " .. tostring(station))
		return
	end

	if confirmed then
		local newselection = nil
		if menu.plotData.component == station then
			newselection = "plots_new"
		end
		local breaknext = nil
		for i, plot in ipairs(menu.plots) do
			if station == plot.station then
				if C.RemoveBuildPlot2(station, removebuildstorage) then
					plot.removed = true
					breaknext = true
				end
			elseif breaknext then
				if newselection then
					newselection = plot.station
				end
				break
			end
		end

		if newselection then
			menu.updatePlotData(newselection, true)
		end
		menu.refreshInfoFrame()

		menu.closeContextMenu()
	else
		menu.contextMenuMode = "userquestion"
		menu.contextMenuData = { mode = "removeplot", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, station = station, destroyBuildStorage = false }

		menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	end
end

function menu.buttonRemoveBuildStorage(buildstorage)
	C.RemoveBuildStorage(buildstorage)
	menu.refreshInfoFrame()
	menu.closeContextMenu()
end

function menu.buttonToggleMultiverseMap()
	if (not C.AreVenturesCompatible()) or ((not C.IsVentureSeasonSupported()) and (not C.WasSessionOnline())) then
		return
	end

	menu.closeContextMenu()
	if menu.showMultiverse then
		menu.showMultiverse = false
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
		end

		menu.mode = nil
		menu.removeMouseCursorOverride(3)

		local startpos = ffi.new("UIPosRot")
		C.ShowUniverseMap2(menu.holomap, false, false, false, 0, startpos)

		if menu.normalmapstate then
			C.SetMapState(menu.holomap, menu.normalmapstate)
			menu.normalmapstate = nil
		end
	else
		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end

		menu.mode = nil
		menu.plots_initialized = nil
		menu.plotData = {}
		menu.seasonMode.left = "currentseason"
		menu.removeMouseCursorOverride(3)

		Helper.callExtensionFunction("multiverse", "getVentures")
		Helper.updateVenturePlatforms()

		menu.normalmapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, menu.normalmapstate)

		C.ShowMultiverseMap(menu.holomap)

		local isonline = Helper.isOnlineGame()
		local operationRewardPending = Helper.hasVentureRewards()
		if C.IsVentureSeasonSupported() and (not isonline) then
			menu.contextMenuMode = "onlinemode"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		elseif operationRewardPending then
			menu.contextMenuMode = "onlinereward"
			menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
			menu.createContextFrame(nil, nil, nil, nil, 0)
		end
	end
	AddUITriggeredEvent(menu.name, "venture_map", menu.showMultiverse)
	menu.refreshMainFrame = true
	menu.selectedRows.propertytabs = 1
	menu.selectedCols.propertytabs = 1
	menu.refreshInfoFrame(0, 0)
	menu.setTextFilter()
	menu.applyFilterSettings()
end

function menu.buttonConvertVentureSave()
	SaveOnlineGame()

	menu.closeContextMenu()
end

function menu.buttonConfirmConvertVentureSave()
	menu.contextMenuMode = "onlinemode"
	menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, confirmoverwrite = true }
	menu.createContextFrame(nil, nil, nil, nil, 0)
end

function menu.editboxInfoLogbookPageActivated(widget, instance)
	menu.noupdate = true
	if menu.logbookPageEditBox and (widget == menu.logbookPageEditBox.id) then
		C.SetEditBoxText(menu.logbookPageEditBox.id, tostring(menu.infoTablePersistentData[instance].logbookData.curPage))
	end
end

function menu.editboxInfoLogbookPage(instance, text, textchanged)
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	local newpage = tonumber(text)
	if newpage and (newpage ~= logbookdata.curPage) then
		logbookdata.curPage = math.max(1, math.min(newpage, logbookdata.numPages))
		menu.refreshInfoFrame()
	else
		C.SetEditBoxText(menu.logbookPageEditBox.id, logbookdata.curPage .. " / " .. logbookdata.numPages)
	end
	menu.noupdate = false
end

function menu.orderMoveWait(component, sector, offset, playerprecise, clear)
	if not C.IsOrderSelectableFor("MoveWait", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "MoveWait", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
		if playerprecise then
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 5, nil, true)
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.selectCV(component)
	local convertedComponent = ConvertStringTo64Bit(tostring(component))
	local isplayerowned, isenemy = GetComponentData(convertedComponent, "isplayerowned", "isenemy")
	if (not C.IsBuilderBusy(component)) and (not isenemy) then
		if not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney >= fee then
				TransferPlayerMoneyTo(fee, convertedComponent)
			else
				return
			end
		end

		menu.orderDeployToStation(component, ConvertIDTo64Bit(menu.modeparam[1]), true)

		Helper.closeMenu(menu, "back")
		menu.cleanup()
	end
end

function menu.orderDeployToStation(component, station, clear)
	if not C.IsOrderSelectableFor("DeployToStation", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateDeployToStationOrder(component)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(station)))
		C.EnableOrder(component, orderidx)
	end
end

function menu.orderAttack(component, target, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderAttackMultiple(component, maintarget, secondarytargets, clear)
	if not C.IsOrderSelectableFor("Attack", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(maintarget)))
		for _, secondarytarget in ipairs(secondarytargets) do
			SetOrderParam(ConvertStringToLuaID(tostring(component)), orderidx, 2, nil, ConvertStringToLuaID(tostring(secondarytarget)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectDeployables(component, deployables, clear)
	if not C.IsOrderSelectableFor("CollectDeployables", component) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDeployables", false)
	if orderidx > 0 then
		for _, deployable in ipairs(deployables) do
			SetOrderParam(ConvertStringTo64Bit(tostring(component)), orderidx, 1, nil, ConvertStringToLuaID(tostring(deployable)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.buttonContextTrade(wareexchange)
	menu.contextMenuMode = "trade"
	menu.contextMenuData = { component = menu.contextMenuData.component, currentShip = menu.contextMenuData.currentShip, shadyOnly = menu.contextMenuData.shadyOnly, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, wareexchange = wareexchange }

	local numwarerows, numinforows = menu.initTradeContextData()
	menu.updateTradeContextDimensions(numwarerows, numinforows)

	if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
		menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
	end
	local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
	if menu.contextMenuData.yoffset + height > Helper.viewHeight - Helper.frameBorder then
		menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
	end

	menu.createContextFrame(menu.tradeContext.width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextTradeLoop()
	menu.contextMenuMode = "tradeloop"
	menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), currentShip = menu.contextMenuData.currentShip, orders = {}, xoffset = menu.contextMenuData.xoffset, yoffset = menu.contextMenuData.yoffset, loop = menu.contextMenuData.loop, reservecargo = true }

	menu.createContextFrame(Helper.scaleX(config.tradeLoopWidth), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonContextResearch()
	Helper.closeMenuAndOpenNewMenu(menu, "ResearchMenu", {0, 0}, true)
	menu.cleanup()
end

function menu.buttonConfirmTrade()
	if menu.contextMenuData.immediate then
		-- Station sells / ship buys (if we're doing immediate orders the order that is added last will be at the front of the queue, so we queue the order to buy first as the order to sell (which needs to be _processed_ first!) will be pushed in front
		for id, amount in pairs(menu.contextMenuData.orders) do
			if amount < 0 then
				AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), -amount, menu.contextMenuData.immediate)
			end
		end
	end
	-- Station buys / ship sells
	for id, amount in pairs(menu.contextMenuData.orders) do
		if amount > 0 then
			AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), amount, menu.contextMenuData.immediate)
		end
	end
	if not menu.contextMenuData.immediate then
		-- Station sells / ship buys (not immediate so the order will be appended to the queue, meaning transferring to the ship must happen after space has been freed up by processing the transfers to the station first)
		for id, amount in pairs(menu.contextMenuData.orders) do
			if amount < 0 then
				AddTradeToShipQueue(ConvertStringToLuaID(tostring(id)), ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), -amount, menu.contextMenuData.immediate)
			end
		end
	end
	if menu.contextMenuData.immediate then
		SignalObject(ConvertStringTo64Bit(tostring(C.GetPlayerID())), "docked_player_trade_added", ConvertStringToLuaID(tostring(menu.contextMenuData.immediateObject)))
	end
	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonConfirmTradeLoop()
	local volume = GetWareData(menu.contextMenuData.ware, "volume")

	local orderidx = C.CreateOrder(menu.contextMenuData.currentShip, menu.contextMenuData.loop, false)
	if orderidx > 0 then
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 1, nil, menu.contextMenuData.ware)
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 4, nil, ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 5, nil, (menu.contextMenuData.amount or ((menu.contextMenuData.loop == "SingleBuy") and menu.contextMenuData.max or 0)))
		SetOrderParam(menu.contextMenuData.currentShip, orderidx, 7, nil, (menu.contextMenuData.price or GetWareData(menu.contextMenuData.ware, "avgprice")) * 100)
		C.EnableOrder(menu.contextMenuData.currentShip, orderidx)
	end

	menu.closeContextMenu("back")
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.buttonCancelTrade()
	menu.closeContextMenu("back")
end

function menu.buttonDockToTrade()
	local ship = menu.contextMenuData.currentShip
	local container = menu.contextMenuData.component
	if not C.IsOrderSelectableFor("Player_DockToTrade", ship) then
		return
	end
	local orderidx = C.CreateOrder(ship, "Player_DockToTrade", false)
	if orderidx > 0 then
		SetOrderParam(ship, orderidx, 1, nil, ConvertStringToLuaID(tostring(container)))
		C.EnableOrder(ship, orderidx)
	end

	menu.closeContextMenu("back")
end

function menu.buttonMissionAbort(confirmed)
	if not confirmed then
		local oldcontextmenudata = menu.contextMenuData
		menu.closeContextMenu()

		menu.contextMenuMode = "userquestion"
		local mode = "abortmission"
		if oldcontextmenudata.groupID ~= "" then
			mode = "abortguildmission"
		end
		menu.contextMenuData = { mode = mode, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, missionid = oldcontextmenudata.missionid, saveOption = false }
		
		if __CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] then
			-- continue immediately
			menu.buttonConfirmUserQuestion()
		else
			menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
		end
	else
		menu.staleMissionID = menu.contextMenuData.missionid
		C.AbortMission(menu.contextMenuData.missionid)
		menu.closeContextMenu()
		menu.refreshIF = getElapsedTime()
	end
end

function menu.buttonMissionBriefing()
	local missionid
	if menu.contextMenuData.threadMissionID ~= 0 then
		missionid = menu.contextMenuData.threadMissionID
	else
		missionid = menu.contextMenuData.missionid
	end
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), false })
	menu.cleanup()
end

function menu.buttonMissionActivate()
	local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
	for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
		if submissionEntry.active then
			active = true
		end
	end
	if active then
		C.SetActiveMission(0)
	else
		C.SetActiveMission(menu.contextMenuData.missionid)
		PlaySound("ui_mission_set_active")

		-- kuertee start: callback
		if menu.uix_callbacks ["buttonMissionActivate_on_activate"] then
			-- get active mission first, because the clicked item may have been a group
			local activeMissionId
			local numMissions = GetNumMissions ()
			for i = 1, numMissions do
				local entry = mapMenu.getMissionInfoHelper (i)
				if entry.active then
					activeMissionId = entry.ID
				end
			end
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonMissionActivate_on_activate"]) do
				-- callback (menu.contextMenuData.missionid)
				uix_callback (activeMissionId)
			end
		end
		-- kuertee end: callback

	end
	menu.closeContextMenu()
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionDeliverWares()
	SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "ware_mission_delivery", ConvertStringToLuaID(tostring(menu.contextMenuData.missionid)))
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionInteractionButton()
	C.MissionBriefingInteractButtonClicked(menu.contextMenuData.missionid)
	menu.refreshIF = getElapsedTime()
end

function menu.buttonMissionOfferBriefing()
	local offerid = menu.contextMenuData.missionid
	menu.closeContextMenu()
	Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, offerid, true })
	menu.cleanup()
end

function menu.buttonMissionOfferAccept()
	local offerid = menu.contextMenuData.missionid
	local offeractor = menu.contextMenuData.offeractor
	local onlinechapter = menu.contextMenuData.onlinechapter
	menu.closeContextMenu()

	if onlinechapter ~= "" then
		if C.HasAcceptedOnlineMission() then
			if #menu.missionList["coalition"] > 0 then
				C.AbortMission(ConvertStringTo64Bit(menu.missionList["coalition"][1].ID))
			else
				DebugError("menu.buttonMissionOfferAccept(): Could not find accepted online mission. Aborting.")
				return
			end
		end
	end
	SignalObject(offeractor, "accept", ConvertStringToLuaID(tostring(offerid)))

	if menu.missionOfferList then
		local found = false
		for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
			if ConvertStringTo64Bit(entry.ID) == offerid then
				found = true
				entry.accepted = true
				menu.highlightLeftBar["mission"] = true
				menu.refreshMainFrame = true
				break
			end
		end
		if not found then
			for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
				for _, entry in ipairs(data.missions) do
					if ConvertStringTo64Bit(entry.ID) == offerid then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
				if found then
					break
				end
			end
		end
		if not found then
			for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == offerid then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
		end
	end
	menu.refreshIF = getElapsedTime()
	if onlinechapter ~= "" then
		menu.refreshMissionContext = { id = offerid, time = menu.refreshIF + 0.1 }
	end
end

function menu.buttonSellShips()
	TransferMoneyToPlayer(menu.contextMenuData.totalprice, menu.contextMenuData.shipyard, "sellship") -- add eventtype
	for i, data in ipairs(menu.contextMenuData.ships) do
		if #data[2] == 0 then
			C.SellPlayerShip(data[1], menu.contextMenuData.shipyard)
		end
	end
	menu.closeContextMenu()
end

function menu.buttonInfoSubMode(mode, col, instance, confirmed)
	if mode ~= menu.infoMode[instance] then
		if (menu.infoMode[instance] == "orderqueue") or (menu.infoMode[instance] == "orderqueue_advanced") then
			if (mode ~= "orderqueue") and (mode ~= "orderqueue_advanced") then
				if not menu.handlePlannedDefaultOrder(instance, confirmed, function () menu.buttonInfoSubMode(mode, col, instance, true) end) then
					return
				end
			end
		end

		menu.infoMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.infoMode[instance])

		menu.selectedRows["orderHeaderTable" .. instance] = 1
		menu.selectedCols["orderHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0)
		end
	end
end

function menu.buttonObjectSubMode(mode, col)
	if mode ~= menu.objectMode then
		menu.objectMode = mode

		AddUITriggeredEvent(menu.name, menu.objectMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonPropertySubMode(mode, col)
	if mode ~= menu.propertyMode then
		menu.propertyMode = mode

		AddUITriggeredEvent(menu.name, menu.propertyMode)

		menu.selectedRows.propertytabs = 1
		menu.selectedCols.propertytabs = col
		menu.refreshInfoFrame(1, col)
	end
end

function menu.buttonMissionSubMode(mode, col)
	if mode ~= menu.missionMode then
		menu.closeContextMenu()
		menu.missionMode = mode
		menu.updateMissions()

		AddUITriggeredEvent(menu.name, menu.missionMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonMissionOfferSubMode(mode, col)
	if mode ~= menu.missionOfferMode then
		menu.closeContextMenu()
		menu.missionOfferMode = mode
		if menu.missionOfferMode ~= "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
			end
		end
		menu.updateMissionOfferList(true)

		AddUITriggeredEvent(menu.name, menu.missionOfferMode)

		menu.missionModeCurrent = "tabs"
		menu.refreshInfoFrame(0, 0)
	end
end

function menu.buttonVentureSeasonSubMode(mode, col, instance)
	if mode ~= menu.seasonMode[instance] then
		menu.seasonMode[instance] = mode

		AddUITriggeredEvent(menu.name, menu.seasonMode[instance])

		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = 1
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = col
		menu.settoprow = 1
		if instance == "left" then
			menu.refreshInfoFrame(1, 0, 1, 0)
		elseif instance == "right" then
			menu.refreshInfoFrame2(1, 0, 1, 0)
		end
	end
end

function menu.buttonExpandMissionGroup(id, row, contextCallback)
	menu.missionModeCurrent = id
	if menu.expandedMissionGroups[id] then
		menu.expandedMissionGroups[id] = false
	else
		menu.expandedMissionGroups[id] = true
	end
	menu.setrow = row
	menu.closeContextMenu()
	if contextCallback then
		contextCallback()
	end
	menu.refreshInfoFrame()
end

function menu.onMissionOfferRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		local desc = Helper.createButton(Helper.createTextInfo(ReadText(1001, 6402), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 1, nil, "button")
		local desc = Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 2, nil, "button")
	end
end

function menu.onMissionRemoved(event, id)
	if id == menu.contextMenuData.missionid then
		menu.contextMenuData.expired = true

		local desc = Helper.createButton(Helper.createTextInfo(ReadText(1001, 6403), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines - 1, 1, nil, "button")
		local desc = Helper.createButton(Helper.createTextInfo("-", "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, false, 0, 0, 0, Helper.standardButtonHeight)
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines - 1, 2, true, "button")
		Helper.setCellContent(menu, menu.contextbottomtable, desc, menu.contextMenuData.bottomLines, 1, nil, "button")
	end
end

function menu.buttonSelectSector()
	if menu.checkForOrderParamObject(menu.currentsector) then
		menu.modeparam[1](ConvertStringToLuaID(tostring(menu.currentsector)))
		AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(menu.currentsector)))
	end
end

function menu.buttonRemoveOrderSyncPoint(orderidx, instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local order = menu.infoTableData[instance].orders[orderidx]

		C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		if instance == "left" then
			menu.refreshInfoFrame()
		elseif instance == "right" then
			menu.refreshInfoFrame2()
		end
	else
		DebugError("menu.buttonRemoveOrderSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.buttonSetFilterLayer(mode, row, col)
	__CORE_DETAILMONITOR_MAPFILTER[mode] = not __CORE_DETAILMONITOR_MAPFILTER[mode]
	AddUITriggeredEvent(menu.name, mode .. "_toggle", __CORE_DETAILMONITOR_MAPFILTER[mode] and "true" or "false")
	menu.applyFilterSettings()
	menu.refreshMainFrame = true
end

function menu.filterUpdate(_, params)
	local settingid, value = string.match(params, "(.+);(.+)")

	local found = false
	local usesavegame = false
	for mode, settings in pairs(config.layersettings) do
		for _, setting in ipairs(settings) do
			if setting.id == settingid then
				found = true
				usesavegame = setting.savegame
				break
			end
			for _, option in ipairs(setting) do
				if option.id == settingid then
					found = true
					usesavegame = setting.savegame
					break
				end
			end
		end
		if found then
			break
		end
	end

	if value == "true" then
		value = true
	elseif value == "false" then
		value = false
	else
		value = tonumber(value) or 0
	end

	local settings = usesavegame and __CORE_DETAILMONITOR_MAPFILTER_SAVE or __CORE_DETAILMONITOR_MAPFILTER
	settings[settingid] = value
	menu.refreshFilterSettings = true
end

function menu.buttonFilterSwitch(mode, row, col)
	if menu.displayedFilterLayer ~= mode then
		menu.displayedFilterLayer = mode

		AddUITriggeredEvent(menu.name, menu.displayedFilterLayer)

		menu.refreshMainFrame = true
	end
end

function menu.buttonWeaponConfig(component, orderidx, usedefault, instance)
	menu.contextMenuMode = "weaponconfig"
	menu.contextMenuData = { component = component, orderidx = orderidx, usedefault = usedefault, weaponsystems = {}, instance = instance }

	local n = C.GetNumAllowedWeaponSystems()
	local buf = ffi.new("WeaponSystemInfo[?]", n)
	n = C.GetAllowedWeaponSystems(buf, n, ConvertIDTo64Bit(component), menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
	end
	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				menu.contextMenuData.default = entry.active
			end
		end
	end

	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.orderqueueContextWidth
	end
	menu.createContextFrame(config.orderqueueContextWidth, Helper.viewHeight - menu.infoTableOffsetY, offsetx, menu.infoTableOffsetY)
end

function menu.buttonClearWeaponConfig()
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		menu.contextMenuData.weaponsystems[i].active = false
	end
	menu.createContextFrame()
end

function menu.buttonCancelWeaponConfig()
	menu.closeContextMenu()
end

function menu.buttonConfirmWeaponConfig()
	local weaponsystems = ffi.new("WeaponSystemInfo[?]", #menu.contextMenuData.weaponsystems)
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		weaponsystems[i - 1].id = Helper.ffiNewString(entry.id)
		weaponsystems[i - 1].active = entry.active
	end
	C.SetAllowedWeaponSystems(menu.contextMenuData.component, menu.contextMenuData.orderidx or 0, menu.contextMenuData.usedefault, weaponsystems, #menu.contextMenuData.weaponsystems)
	menu.closeContextMenu()
end

function menu.buttonHire()
	local playerMoney = GetPlayerMoney()
	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	else
		fee = 0
	end
	if fee then
		fee = RoundTotalTradePrice(fee) * menu.hiringdiscounts.totalfactor
	else
		DebugError("menu.buttonHire(): Could not find hiring fee. [Florian]")
		fee = 0
	end

	if (not ishiring) or (playerMoney >= fee) then
		C.ClearMapObjectFilter(menu.holomap)
		if ishiring then
			TransferPlayerMoneyTo(fee, GetContextByClass(npc or object, "container", true))
		end
		if menu.contextMenuData.hireIsMission then
			if npc then
				SignalObject(ConvertStringTo64Bit(tostring(menu.contextMenuData.hireObject)), "npc_mission_delivery", ConvertStringToLuaID(menu.contextMenuData.hireRole), ConvertStringToLuaID(tostring(npc)))
				menu.closeContextMenu()
				menu.onCloseElement("close")
			else
				C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.hireObject, "npctemplate_mission_delivery", ConvertStringTo64Bit(menu.contextMenuData.hireRole), npcseed, object)
				menu.closeContextMenu()
				menu.onCloseElement("back")
			end
		elseif menu.modeparam[1] == "signal" then
			-- actor must be either entity or person (controllable and seed)
			local actor = { entity = npc, personcontrollable = object, personseed = npcseed }
			C.AssignHiredActor(actor, menu.contextMenuData.hireObject, menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, not menu.contextMenuData.hireIsPost and menu.contextMenuData.hireRole or nil, false)
			menu.closeContextMenu()
			menu.onCloseElement("back")
		else
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.hireObject)), menu.contextMenuData.hireRole, menu.contextMenuData.hireIsPost })
			menu.cleanup()
		end
	else
		menu.closeContextMenu()
		menu.refreshMainFrame = true
	end
end

function menu.buttonSelectHandler()
	if menu.mode == "selectCV" then
		menu.selectCV(menu.contextMenuData.component)
	elseif menu.mode == "orderparam_object" then
		if menu.checkForOrderParamObject(menu.contextMenuData.component) then
			AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
			menu.modeparam[1](ConvertStringToLuaID(tostring(menu.contextMenuData.component)))
		end
	elseif menu.mode == "selectComponent" then

		-- kuertee start: callback
		if menu.modeparam[6] ~= nil then
			-- if selectComponent returnsection is nil, then do a AddUITriggeredEvent instead
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (menu.contextMenuData.component))
			-- DebugError ("kuertee_menu_map.ui.buttonSelectHandler menu.contextMenuData.component " .. tostring (ConvertStringToLuaID (tostring (menu.contextMenuData.component))))
			AddUITriggeredEvent (menu.modeparam[6], "select_component", ConvertStringToLuaID (tostring (menu.contextMenuData.component)))
			menu.mode = menu.old_mode
			menu.modeparam = menu.old_modeparam
			menu.infoTableMode = menu.old_infoTableMode
			menu.closeContextMenu()
			menu.refreshMainFrame = true
			menu.refreshInfoFrame()
			return

			-- DebugError ("kuertee_menu_map buttonSelectHandler menu.modeparam [1]: " .. tostring (menu.modeparam [1]))
			-- if menu.checkForSelectComponent(menu.contextMenuData.component) then
		elseif menu.checkForSelectComponent(menu.contextMenuData.component) then
			-- kuertee end: callback

			C.ClearMapObjectFilter(menu.holomap)
			Helper.closeMenuForSection(menu, menu.modeparam[1], { ConvertStringToLuaID(tostring(menu.contextMenuData.component)) })
			menu.cleanup()
		end
	end
	menu.closeContextMenu()
end

function menu.buttonRemoveAssignment()
	if C.RemoveCommander2(menu.infoSubmenuObject) then
		C.CreateOrder(menu.infoSubmenuObject, "Wait", true)
		C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, false)
	end

	menu.refreshInfoFrame()
end

function menu.plotModeUpdateValue(dimension, valchange)
	local axis = "x"
	local bigaxis = "X"
	if dimension == "posY" or dimension == "negY" then
		axis = "y"
		bigaxis = "Y"
	elseif dimension == "posZ" or dimension == "negZ" then
		axis = "z"
		bigaxis = "Z"
	end
	menu.plotData.size[axis] = menu.plotData.dimensions["pos" .. bigaxis] + menu.plotData.dimensions["neg" .. bigaxis]
	menu.plotModeUpdatePrice()
	menu.updatePlotSize(dimension, axis, valchange)
end

function menu.plotModeUpdatePrice()
	if not menu.plotData.price then
		return
	end
	--print("size.x: " .. tostring(menu.plotData.size.x * 1000) .. ", boughtrawsize.x: " .. tostring(menu.plotData.boughtrawsize.x) .. ". size.y: " .. tostring(menu.plotData.size.y * 1000) .. ", boughtrawsize.y: " .. tostring(menu.plotData.boughtrawsize.y) .. ". size.z: " .. tostring(menu.plotData.size.z * 1000) .. ", boughtrawsize.z: " .. tostring(menu.plotData.boughtrawsize.z))
	local numchanged = 3
	local x = menu.plotData.size.x * 1000
	if x == menu.plotData.boughtrawsize.x then
		numchanged = numchanged - 1
	end
	local y = menu.plotData.size.y * 1000
	if y == menu.plotData.boughtrawsize.y then
		numchanged = numchanged - 1
	end
	local z = menu.plotData.size.z * 1000
	if z == menu.plotData.boughtrawsize.z then
		numchanged = numchanged - 1
	end

	local owner = GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.component)), "owner")
	local buf = ffi.new("bool[1]", 0)
	local plotpayment = tonumber(C.GetBuildPlotPayment(menu.plotData.component, buf))
	local haspositionchanged = buf[0]
	menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, x, y, z, owner)) - plotpayment
	menu.plotData.affordable = GetPlayerMoney() >= menu.plotData.price

	menu.plotData.fullypaid = menu.plotData.price <= 0
end

function menu.buttonBuyPlot()
	local station = menu.plotData.component
	local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
	if not menu.plotData.price or GetPlayerMoney() < menu.plotData.price then
		DebugError("menu.buttonBuyPlot() called but there is no price or the player cannot afford the plot. price: " .. tostring(menu.plotData.price) .. ", player cash: " .. tostring(GetPlayerMoney()))
		return
	end
	local offset = C.GetBuildPlotCenterOffset(station)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.boughtrawcenteroffset = offset
			break
		end
	end
	local controlstation = C.GetSectorControlStation(menu.plotData.sector)
	TransferPlayerMoneyTo(menu.plotData.price, ConvertStringTo64Bit(tostring(controlstation)))
	C.PayBuildPlotSize(station, size, offset)
	menu.updatePlotData(nil, true)
	menu.refreshInfoFrame()
end

function menu.buttonDropPilotInventory(pilot, wares)
	menu.contextMenuMode = "dropwares"
	menu.contextMenuData = { mode = "inventory", entity = pilot, wares = wares }

	local height = (#wares + 4) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder
	if instance == "right" then
		offsetx = Helper.viewWidth - offsetx - config.dropInventoryWidth
	end
	local offsety = (Helper.viewHeight + menu.infoTableOffsetY - height) / 2
	if offsety + height > Helper.viewHeight then
		offsety = menu.infoTableOffsetY
	end

	menu.createContextFrame(config.dropInventoryWidth, nil, offsetx, offsety)
end

function menu.buttonFireCrew(instance, object)
	for _, entry in ipairs(menu.infoTablePersistentData[instance].crew.unassigned.persons) do
		C.RemovePerson(object, entry.person)
	end

	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.buttonConfirmUserQuestion()
	if menu.contextMenuData.saveOption then
		__CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] = true
	end

	if menu.contextMenuData.mode == "markashostile" then
		C.SetRelationBoostToFaction(menu.contextMenuData.controllable, "player", "markedashostile", -1, 1, 600)
		menu.closeContextMenu()
	elseif (menu.contextMenuData.mode == "abortmission") or (menu.contextMenuData.mode == "abortguildmission") then
		menu.buttonMissionAbort(true)
	end
end

function menu.buttonObjectSorter(sorttype)
	if menu.objectSorterType == sorttype then
		menu.objectSorterType = sorttype .. "inverse"
	else
		menu.objectSorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonPropertySorter(sorttype)
	if menu.propertySorterType == sorttype then
		menu.propertySorterType = sorttype .. "inverse"
	else
		menu.propertySorterType = sorttype
	end
	menu.refreshInfoFrame()
end

function menu.buttonDeploy(instance)
	local infomacrostolaunch = menu.infoTablePersistentData[instance].macrostolaunch
	if next(infomacrostolaunch) then
		if infomacrostolaunch.mine then
			C.LaunchMine(menu.infoSubmenuObject, infomacrostolaunch.mine)
		elseif infomacrostolaunch.navbeacon then
			C.LaunchNavBeacon(menu.infoSubmenuObject, infomacrostolaunch.navbeacon)
		elseif infomacrostolaunch.satellite then
			C.LaunchSatellite(menu.infoSubmenuObject, infomacrostolaunch.satellite)
		elseif infomacrostolaunch.lasertower then
			C.LaunchLaserTower(menu.infoSubmenuObject, infomacrostolaunch.lasertower)
		elseif infomacrostolaunch.resourceprobe then
			C.LaunchResourceProbe(menu.infoSubmenuObject, infomacrostolaunch.resourceprobe)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonLogbookInteraction(entry)
	if IsValidComponent(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(entry.interactioncomponent), true)
		elseif entry.interaction == "guidance" then
			local convertedInteractionComponent = ConvertIDTo64Bit(entry.interactioncomponent)
			if convertedInteractionComponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(convertedInteractionComponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.buttonInfoLogbookClearQuestion(instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "clearlogbook", xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.buttonInfoLogbookClear(instance)
	menu.closeContextMenu()
	local logbookdata = menu.infoTablePersistentData[instance].logbookData
	if #logbookdata.logbook > 0 then
		for i = #logbookdata.logbook, 1, -1 do
			local entry = logbookdata.logbook[i]
			RemoveLogbookEntry(entry.index)
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonEditTradeRule(traderuleid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "traderule", (traderuleid ~= 0) and traderuleid or nil } })
	menu.cleanup()
end

function menu.buttonEditBlacklist(blacklistid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "blacklist", (blacklistid ~= 0) and blacklistid or nil } })
	menu.cleanup()
end

function menu.buttonEditFightRule(fightruleid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "fightrule", (fightruleid ~= 0) and fightruleid or nil } })
	menu.cleanup()
end

function menu.slidercellPlotValue(_, value, dimension, fullsize)
	if not dimension then
		DebugError("menu.slidercellPlotValue(): no dimension passed in.")
		return
	end

	local shiftpressed = C.IsShiftPressed()
	local dimensions = { dimension }
	if shiftpressed then
		dimensions = {
			[1] = "posX",
			[2] = "negX",
			[3] = "posY",
			[4] = "negY",
			[5] = "posZ",
			[6] = "negZ",
		}

		value = math.min(value, config.maxPlotSize / 2)
	end

	if fullsize then
		for i, dimension2 in ipairs(dimensions) do
			menu.plotData.size[dimension2] = value
		end
		menu.updatePlotSize()
	else
		for i, dimension2 in ipairs(dimensions) do
			local minimumdimension = menu.plotData.minimumdimensions[dimension2] or 0
			local locvalue = math.max(value, minimumdimension)

			local valchange = locvalue - menu.plotData.dimensions[dimension2]
			menu.plotData.dimensions[dimension2] = locvalue
			menu.plotModeUpdateValue(dimension2, valchange)
		end
		if shiftpressed then
			menu.updatePlotSliders()
		end
	end
end

function menu.tradeContextCostAndStorageUpdateHelper(storagetype, ware)
	menu.updateTradeCost()
	if not menu.contextMenuData.wareexchange then
		-- profit
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Color["text_normal"]
		if profit < 0 then
			profitcolor = Color["text_negative"]
		elseif profit > 0 then
			profitcolor = Color["text_positive"]
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 1, 3 + menu.tradeContext.coloffset, ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), profitcolor)
		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Color["text_normal"]
		if total < 0 then
			transactioncolor = Color["text_negative"]
		elseif total > 0 then
			transactioncolor = Color["text_positive"]
		end
		Helper.updateCellText(menu.contextbuttontable, menu.tradeContext.numinforows + 2, 3 + menu.tradeContext.coloffset, ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), transactioncolor)
	end
	-- ship
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		if waredata.ware == ware then
			local content = menu.getTradeContextRowContent(waredata)
			if content[2].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 2, content[2].text, content[2].color)
			end
			if content[3].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, 3, content[3].text, content[3].color)
			end
			if content[6].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.sellcol, content[6].text, content[6].color)
			end
			if content[7].text then
				Helper.updateCellText(menu.contextshiptable, 4 + i, waredata.buycol, content[7].text, content[7].color)
			end
			break
		end
	end

	-- storage
	local storagecontent = menu.getTradeContextShipStorageContent()
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 1, content.scale.start)
		end
	end
	if menu.contextMenuData.wareexchange then
		storagecontent = menu.getTradeContextShipStorageContent(true)
		for i, content in ipairs(storagecontent) do
			if i <= menu.tradeContext.numinforows then
				Helper.setSliderCellValue(menu.contextbuttontable, 2 + i, 2, content.scale.start)
			end
		end
	end
end

function menu.orderAmountHelper(sellid, buyid, newvalue)
	if newvalue > 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = newvalue
		end
	elseif newvalue < 0 then
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = newvalue
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	else
		if sellid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] = 0
		end
		if buyid then
			menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] = 0
		end
	end
end

function menu.slidercellBoardingAssignedMarines(ship, marinelevel, newvalue)
	local change = newvalue - menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel]
	--print("assigned group marines: " .. menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] .. ", newvalue: " .. tostring(newvalue) .. ", change: " .. tostring(change))

	menu.boardingData.shipdata[ship].assignedgroupmarines[marinelevel] = newvalue
	--print("recording " .. tostring(newvalue) .. " assigned group marines from " .. ffi.string(C.GetComponentName(ship)))

	if (change > 0) then
		--print("adding")
		if (newvalue > menu.boardingData.shipdata[ship].marines[marinelevel]) then
			local numtoadd = menu.boardingData.shipdata[ship].marines[marinelevel]
			local remaining = newvalue - numtoadd
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = numtoadd
			--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)) .. ". remaining: " .. tostring(remaining))

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].marines[marinelevel]) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if menu.boardingData.shipdata[subordinate].marines[marinelevel] and (menu.boardingData.shipdata[subordinate].marines[marinelevel] > 0) then
						numtoadd = math.min(remaining, menu.boardingData.shipdata[subordinate].marines[marinelevel])
						remaining = remaining - numtoadd
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = numtoadd
						--print("recording " .. tostring(numtoadd) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done adding")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = newvalue
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	else
		--print("removing. change: " .. tostring(change) .. ", numassignedmarines: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]))
		if (-change > menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) then
			local numtosubtract = menu.boardingData.shipdata[ship].assignedmarines[marinelevel]
			local remaining = -change - numtosubtract
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] - numtosubtract

			if remaining > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. " " .. tostring(subordinate) .. " level: " .. tostring(marinelevel) .. ", assigned subordinate marines: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel]))
					if (menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] > 0) then
						numtosubtract = math.min(remaining, menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel])
						remaining = remaining - numtosubtract
						menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] = menu.boardingData.shipdata[subordinate].assignedmarines[marinelevel] - numtosubtract
						--print("recording removal of " .. tostring(numtosubtract) .. " assigned marines from " .. ffi.string(C.GetComponentName(subordinate)) .. ". remaining: " .. tostring(remaining))
						if remaining < 1 then
							--print("done removing")
							break
						end
					end
				end
			end
		else
			menu.boardingData.shipdata[ship].assignedmarines[marinelevel] = menu.boardingData.shipdata[ship].assignedmarines[marinelevel] + change
			--print("recording " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[marinelevel]) .. " assigned marines from " .. ffi.string(C.GetComponentName(ship)))
		end
	end
	menu.boardingData.changed = true
end

function menu.slidercellShipCargo(sellid, buyid, ware, cargoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, change, true)
		if menu.contextMenuData.wareexchange then
			RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, change, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), ware, -change, true)
		end
		RemoveCargo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), ware, -change, true)
	end

	-- fix order amounts in case adding cargo failed
	value = cargoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, cargoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("cargo", ware)
end

function menu.slidercellShipAmmo(sellid, buyid, ware, ammoamount, value)
	menu.tradeAmountChanged = ware

	local oldsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local oldbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)
	local newsellvalue = sellid and (menu.contextMenuData.orders[ConvertIDTo64Bit(sellid)] or 0) or 0
	local newbuyvalue = buyid and (menu.contextMenuData.orders[ConvertIDTo64Bit(buyid)] or 0) or 0

	local waremacro = GetWareData(ware, "component")
	local change = oldsellvalue - newsellvalue + oldbuyvalue - newbuyvalue
	if change > 0 then
		change = AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, change, false, true)
		if menu.contextMenuData.wareexchange then
			RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, change, false, true)
		end
	elseif change < 0 then
		if menu.contextMenuData.wareexchange then
			change = -AddAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), waremacro, -change, false, true)
		end
		RemoveAmmo(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), waremacro, -change, false, true)
	end

	-- fix order amounts in case adding cargo failed
	value = ammoamount - oldsellvalue - oldbuyvalue + change
	menu.orderAmountHelper(sellid, buyid, ammoamount - value)

	menu.tradeContextCostAndStorageUpdateHelper("ammo", ware)
end

function menu.onSliderCellDown()
	if menu.contextMenuMode == "trade" then
		menu.tradeSliderLock = true
	end
end

function menu.onSliderCellActivated()
	if menu.contextMenuMode == "trade" then
		menu.tradeSliderLock = true
	end
end

function menu.slidercellTradeConfirmed(ware)
	if menu.tradeAmountChanged then
		menu.tradeAmountChanged = nil
		menu.showOptionalWarningWare = nil
	else
		menu.showOptionalWarningWare = ware
	end

	--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
	--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
	menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
	menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
	menu.tradeSliderLock = nil
	menu.createContextFrame()
end

function menu.slidercellStorageWarePriceOverride(container, ware, buysellswitch, value)
	if value then
		SetContainerWarePriceOverride(container, ware, buysellswitch, value)
	end
end

function menu.dropdownBoardingSetAction(ship, newaction)
	menu.boardingData.shipdata[ship].action = newaction
	menu.boardingData.changed = true
end

function menu.dropdownBoardingSetRisk(newrisklevel, phaseindex)
	--print("newrisklevel: " .. tostring(newrisklevel))
	local stage = ("risk" .. phaseindex)
	menu.boardingData[stage] = newrisklevel
	menu.boardingData.changed = true
end

function menu.dropdownShip(_, shipid)
	local shipid64 = ConvertStringTo64Bit(shipid)
	if shipid64 ~= menu.contextMenuData.currentShip then
		if C.IsComponentOperational(menu.contextMenuData.currentShip) then
			SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
		end

		menu.contextMenuData.currentShip = shipid64
		SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)

		menu.contextMenuData.orders = {}

		menu.initTradeContextData()

		--menu.topRows.contextoffertable = GetTopRow(menu.contextoffertable)
		--menu.selectedRows.contextoffertable = Helper.currentTableRow[menu.contextoffertable]
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
	end
end

function menu.dropdownNewSyncPoint(orderidx, idstring)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		local id = tonumber(idstring)

		if id == 0 then
			C.RemoveOrderSyncPointID(menu.infoSubmenuObject, orderidx)
		else
			C.SetOrderSyncPointID(menu.infoSubmenuObject, orderidx, id, false)
		end

		menu.refreshInfoFrame()
	else
		DebugError("menu.dropdownNewSyncPoint: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end
end

function menu.dropdownChangeOverrideOrder(idstring, attacker, instance)
	-- remove all override orders
	for i = #menu.infoTableData[instance].orders, 1, -1 do
		local entry = menu.infoTableData[instance].orders[i]
		if entry.isoverride then
			menu.removeOrder(i, instance)
		end
	end

	local orderidx
	if idstring == "Flee" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Flee", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, 'boost')
			SetOrderParam(menu.infoSubmenuObject, orderidx, 3, nil, true)
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Attack" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Attack", false, true, true)
		if orderidx > 0 then
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 1, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Wait" then
		orderidx = C.CreateOrder3(menu.infoSubmenuObject, "Wait", false, true, true)
		if orderidx > 0 then
			SetOrderParam(menu.infoSubmenuObject, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(menu.infoSubmenuObject, orderidx, 5, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	end

	if orderidx > 0 then
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.infoSubmenuObject, hasloop)

		C.EnableOrder(menu.infoSubmenuObject, orderidx)
		local newidx = tonumber(C.GetOrderQueueCurrentIdx(menu.infoSubmenuObject))
		if not C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, true) then
			newidx = newidx + 1
		end
		C.AdjustOrder(menu.infoSubmenuObject, orderidx, newidx, true, false, false)
		if hasloop[0] then
			C.SetCurrentLoopOrder(menu.infoSubmenuObject, newidx, true, false, false)
		end
	end

	menu.noupdate = false
end

function menu.buttonReleaseSyncPoint(syncpointinfo)
	if syncpointinfo.id > 0 then
		C.ReleaseOrderSyncPoint(syncpointinfo.id)
	else
		C.ReleaseOrderSyncPointFromOrder(syncpointinfo.owningcontrollable, syncpointinfo.owningorderidx)
	end
	menu.refreshInfoFrame()
end

function menu.buttonContextSetLogo(logo)
	menu.contextMenuData.currentlogo = logo
	C.SetFleetLogo(menu.contextMenuData.component, logo)
end

function menu.buttonChangeLogoCancel()
	C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
	menu.closeContextMenu("back")
end

function menu.dropdownModuleSet(_, idstring)
	menu.plotData.set = idstring
	menu.noupdate = false
end

-- mode: "factionresponses", "controllableresponses"
function menu.dropdownOrdersSetResponse(_, newresponseid, factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.dropdownOrdersSetResponse called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.dropdownOrdersSetResponse called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.dropdownOrdersSetResponse called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if newresponseid == "reset" then
		if mode == "controllableresponses" then
			if not C.ResetResponseToSignalForControllable(signalid, factionorcontrollable) then
				DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(factionorcontrollable)) .. " " .. tostring(factionorcontrollable))
			end
		else
			local factionobjects = GetContainedObjectsByOwner(factionorcontrollable)
			for _, object in ipairs(factionobjects) do
				local object64 = ConvertIDTo64Bit(object)
				if C.IsComponentClass(object64, "controllable") then
					if not C.ResetResponseToSignalForControllable(signalid, object64) then
						DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(object64)) .. " " .. tostring(object64))
					end
				end
			end
		end
	else
		local ask
		if mode == "controllableresponses" then
			ask = C.GetAskToSignalForControllable(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForControllable(newresponseid, ask, signalid, factionorcontrollable)
		else
			ask = C.GetAskToSignalForFaction(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForFaction2(newresponseid, ask, signalid, factionorcontrollable, "")
		end
	end
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersResupply(controllable, id)
	C.SetDefensibleLoadoutLevel(controllable, tonumber(id))
	menu.refreshInfoFrame()
end

function menu.dropdownOrdersCargoReservations(ship, id)
	C.SetShipTradeLoopCargoReservationOverride(ship, id == "on")
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersBlacklist(controllable, type, id)
	C.SetControllableBlacklist(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function  menu.dropdownOrdersFightRule(controllable, type, id)
	C.SetControllableFightRule(controllable, tonumber(id), type, true)
	menu.refreshInfoFrame()
end

function menu.dropdownHireRole(_, idstring)
	menu.noupdate = false
	if idstring ~= nil then
		local type, id = string.match(idstring, "(.+):(.+)")
		if type == "mission" then
			menu.contextMenuData.hireIsMission = true
			menu.contextMenuData.hireIsPost = nil
		else
			menu.contextMenuData.hireIsMission = nil
			menu.contextMenuData.hireIsPost = type == "post"
		end
		menu.contextMenuData.hireRole = id

		menu.refreshContextFrame()
	end
end

function menu.dropdownBehaviourFormation(_, shape)
	if shape ~= nil then
		local info = C.SetFormationShape(menu.infoSubmenuObject, shape)
		shape = ffi.string(info.shape)

		if (shape ~= "") then
			local subordinates = GetSubordinates(menu.infoSubmenuObject)
			for i = #subordinates, 1, -1 do
				local subordinate = ConvertIDTo64Bit(subordinates[i])

				local numorders = C.GetNumOrders(subordinate)
				local currentorders = ffi.new("Order[?]", numorders)
				numorders = C.GetOrders(currentorders, numorders, subordinate)
				local paramoffset = 0
				for j = 1, numorders do
					if (ffi.string(currentorders[0].orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentorders[0].orderdef) == "Escort") or (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, j, paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, j, paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, j, paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, j, paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, j, paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end

				local currentdefaultorder = ffi.new("Order")
				if C.GetDefaultOrder(currentdefaultorder, subordinate) then
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") then
						paramoffset = 0
					elseif (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						paramoffset = 1
					end
					if (ffi.string(currentdefaultorder.orderdef) == "Escort") or (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
						SetOrderParam(subordinate, "default", paramoffset + 2, nil, shape) -- shape
						SetOrderParam(subordinate, "default", paramoffset + 3, nil, info.radius) -- radius
						SetOrderParam(subordinate, "default", paramoffset + 4, nil, info.rollMembers) -- rollmembers
						SetOrderParam(subordinate, "default", paramoffset + 5, nil, info.rollFormation) -- rollformation
						SetOrderParam(subordinate, "default", paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
					end
				end
			end
		end
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownTradeRule(container, type, id, ware, refresh)
	if type == "trade" then
		C.SetContainerTradeRule(container, tonumber(id), "buy",  ware or "", true)
		C.SetContainerTradeRule(container, tonumber(id), "sell", ware or "", true)
	else
		C.SetContainerTradeRule(container, tonumber(id), type, ware or "", true)
	end

	if refresh then
		menu.refreshInfoFrame()
	end
end

function  menu.dropdownBuildRule(container, id)
	C.SetContainerBuildMethod(container, id)
end

function menu.checkboxSetWeaponConfig(system, value)
	if system == "default" then
		menu.contextMenuData.default = value
	end
	for i, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id == system then
			menu.contextMenuData.weaponsystems[i].active = value
		end
	end
	menu.createContextFrame()
end

-- mode: "factionresponses", "controllableresponses"
function menu.checkboxOrdersSetAsk(factionorcontrollable, signalid, mode)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetAsk called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.checkboxOrdersSetAsk called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetAsk called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	local ask
	local response
	if mode == "controllableresponses" then
		ask = not C.GetAskToSignalForControllable(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForControllable(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForControllable(response, ask, signalid, factionorcontrollable)
	else
		ask = not C.GetAskToSignalForFaction(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForFaction2(signalid, factionorcontrollable, "")
		C.SetDefaultResponseToSignalForFaction2(response, ask, signalid, factionorcontrollable, "")
	end
	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked)
	if mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetOverride called with invalid mode set. only 'controllableresponses' is supported at this time. mode: " .. tostring(mode))
		return
	elseif not controllable then
		DebugError("menu.checkboxOrdersSetOverride called with invalid faction or controllable set. controllable: " .. tostring(controllable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetOverride called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if checked then
		if not C.ResetResponseToSignalForControllable(signalid, controllable) then
			DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(controllable)) .. " " .. tostring(controllable))
		end
	else
		local faction, primarypurpose = GetComponentData(controllable, "owner", "primarypurpose")
		local deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, primarypurpose))
		local ask = C.GetAskToSignalForControllable(signalid, controllable)
		C.SetDefaultResponseToSignalForControllable(deffactresponse, ask, signalid, controllable)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetResupplyOverride(controllable, checked)
	if checked then
		C.SetDefensibleLoadoutLevel(controllable, -1)
	else
		C.SetDefensibleLoadoutLevel(controllable, 0)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetCargoReservations(ship, checked)
	if checked then
		C.RemoveShipTradeLoopCargoReservationOverride(ship)
	else
		C.SetShipTradeLoopCargoReservationOverride(ship, C.GetPlayerGlobalTradeLoopCargoReservationSetting())
	end

	menu.refreshInfoFrame()
end

function menu.checkboxStorageWarePriceOverride(container, ware, buysellswitch, price, checked)
	if checked then
		ClearContainerWarePriceOverride(container, ware, buysellswitch)
	else
		SetContainerWarePriceOverride(container, ware, buysellswitch, price)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetBlacklistOverride(controllable, type, checked)
	if checked then
		C.SetControllableBlacklist(controllable, -1, type, false)
	else
		C.SetControllableBlacklist(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxOrdersSetFightRuleOverride(controllable, type, checked)
	if checked then
		C.SetControllableFightRule(controllable, -1, type, false)
	else
		C.SetControllableFightRule(controllable, -1, type, true)
	end

	menu.refreshInfoFrame()
end

function menu.checkboxSetWareList(ware, checked)
	menu.contextMenuData.selectedWares[ware] = checked or nil
end

function menu.checkboxSetSectorList(sector, checked)
	menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
end

function menu.checkboxToggleWareList(checked)
	for _, ware in ipairs(menu.contextMenuData.wares) do
		menu.contextMenuData.selectedWares[ware] = checked or nil
	end
end

function menu.checkboxToggleSectorList(checked)
	for _, sector in ipairs(menu.contextMenuData.sectors) do
		menu.contextMenuData.selectedSectors[tostring(sector)] = checked or nil
	end
end

function menu.checkboxSetTradeRuleOverride(container, type, checked, ware)
	if type == "trade" then
		if checked then
			C.SetContainerTradeRule(container, -1, "buy",  ware or "", false)
			C.SetContainerTradeRule(container, -1, "sell", ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, "buy", ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "buy",  ware or "", true)
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "sell", ware or "", true)
		end
	else
		if checked then
			C.SetContainerTradeRule(container, -1, type, ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware or "", true)
		end
	end

	menu.refreshInfoFrame()
end

function menu.checkboxSetBuildRuleOverride(container, checked, curglobal)
	if checked then
		C.SetContainerBuildMethod(container, "")
	else
		C.SetContainerBuildMethod(container, curglobal or "default")
	end

	menu.refreshInfoFrame()
end

function menu.storeCurrentPlots()
	menu.currentPlots = {}
	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, station in ipairs(playerobjects) do
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station64)
		local plotcenter = C.GetBuildPlotCenterOffset(station64)
		menu.currentPlots[tostring(station64)] = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
	end
end

function menu.updatePlotData(station, donotrefresh)
	if not station then
		if not menu.plotData.component then
			DebugError("menu.updatePlotData(): no station passed in. station: " .. tostring(station) .. ", menu.plotData.component: " .. tostring(menu.plotData.component) .. ".")
			return
		end
		station = menu.plotData.component
	end

	if station ~= "plots_new" then
		local station64 = ConvertStringTo64Bit(tostring(station))
		local rawsize = C.GetBuildPlotSize(station)
		local plotcenter = C.GetBuildPlotCenterOffset(station)
		local sets = GetComponentData(station64, "modulesets")
		local sector = GetComponentData(station64, "sectorid")
		local owner = GetComponentData(station64, "owner")
		local boughtrawsize = C.GetPaidBuildPlotSize(station)
		local playermoney = GetPlayerMoney()
		local minimumrawsize = C.GetMinimumBuildPlotSize(station)
		local minimumcenter = C.GetMinimumBuildPlotCenterOffset(station)
		local pos = C.GetObjectPositionInSector(station)

		menu.plotData.name = ffi.string(C.GetComponentName(station))
		menu.plotData.component = station
		menu.plotData.position = pos
		menu.plotData.set = sets[1] or ""
		menu.plotData.placed = true
		menu.plotData.sector = ConvertIDTo64Bit(sector)
		menu.plotData.permanent = C.GetNumStationModules(station, true, true) > 0
		menu.plotData.isinownedspace = (GetComponentData(sector, "owner") ~= "ownerless") and (GetComponentData(sector, "owner") ~= "xenon")
		menu.plotData.paid = (not menu.plotData.isinownedspace) or (boughtrawsize.x > 0) or (boughtrawsize.y > 0) or (boughtrawsize.z > 0)
		local fullprice = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(station, buf))
		local haspositionchanged = buf[0]
		menu.plotData.fullypaid = ((not menu.plotData.isinownedspace) or ((boughtrawsize.x >= rawsize.x) and (boughtrawsize.y >= rawsize.y) and (boughtrawsize.z >= rawsize.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))
		menu.plotData.size = { x = rawsize.x / 1000, y = rawsize.y / 1000, z = rawsize.z / 1000 }
		menu.plotData.dimensions = {
			posX = math.ceil((rawsize.x / 2 + plotcenter.x) / 1000),
			negX = math.floor((rawsize.x / 2 - plotcenter.x) / 1000),
			posY = math.ceil((rawsize.y / 2 + plotcenter.y) / 1000),
			negY = math.floor((rawsize.y / 2 - plotcenter.y) / 1000),
			posZ = math.ceil((rawsize.z / 2 + plotcenter.z) / 1000),
			negZ = math.floor((rawsize.z / 2 - plotcenter.z) / 1000),
		}
		menu.plotData.minimumdimensions = {
			posX = math.ceil((minimumrawsize.x / 2 + minimumcenter.x) / 1000),
			negX = math.floor((minimumrawsize.x / 2 - minimumcenter.x) / 1000),
			posY = math.ceil((minimumrawsize.y / 2 + minimumcenter.y) / 1000),
			negY = math.floor((minimumrawsize.y / 2 - minimumcenter.y) / 1000),
			posZ = math.ceil((minimumrawsize.z / 2 + minimumcenter.z) / 1000),
			negZ = math.floor((minimumrawsize.z / 2 - minimumcenter.z) / 1000),
		}

		if ((not menu.plotData.isinownedspace) and (rawsize.x > boughtrawsize.x or rawsize.y > boughtrawsize.y or rawsize.z > boughtrawsize.z)) or GetComponentData(sector, "isplayerowned") then
			C.PayBuildPlotSize(station, rawsize, plotcenter)
			boughtrawsize = C.GetPaidBuildPlotSize(station)
			local found
			for _, plot in ipairs(menu.plots) do
				if plot.station == station then
					plot.boughtrawcenteroffset = plotcenter
					found = true
					break
				end
			end
			if not found then
				table.insert(menu.plots, { station = station, paid = true, fullypaid = true, permanent = C.GetNumStationModules(station, true, true) > 0, boughtrawcenteroffset = plotcenter, removed = nil })
			end
		end
		menu.plotData.boughtrawsize = { x = boughtrawsize.x, y = boughtrawsize.y, z = boughtrawsize.z }
		--print("fullypaid: " .. tostring(menu.plotData.fullypaid) .. ", boughtsize: " .. tostring(boughtrawsize.x) .. " x " .. tostring(boughtrawsize.y) .. " x " .. tostring(boughtrawsize.z) .. ", size: " .. tostring(rawsize.x) .. " x " .. tostring(rawsize.y) .. " x " .. tostring(rawsize.z))

		for _, plot in ipairs(menu.plots) do
			if station == plot.station then
				menu.plotData.boughtrawcenteroffset = plot.boughtrawcenteroffset
				break
			end
		end
		menu.plotData.price = tonumber(C.GetBuildPlotPrice(menu.plotData.sector, menu.plotData.position, rawsize.x, rawsize.y, rawsize.z, owner)) - plotpayment
		menu.plotData.affordable = playermoney >= menu.plotData.price

		if not menu.plotData.fullypaid and menu.plotData.price <= 0 then
			menu.plotData.fullypaid = true
		end
	else
		menu.plotData = {
			name = ReadText(1001, 9200),	-- New Plot
			set = "factory",
			active = false,
			placed = false,
			sector = menu.currentsector,
			permanent = false,
			isinownedspace = (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "ownerless") and (GetComponentData(ConvertStringTo64Bit(tostring(menu.currentsector)), "owner") ~= "xenon"),
			paid = false,
			fullypaid = false,
			boughtrawsize = { x = 0, y = 0, z = 0 },
			size = { x = 4, y = 4, z = 4 },
			dimensions = { posX = 2, negX = 2, posY = 2, negY = 2, posZ = 2, negZ = 2 },
			minimumdimensions = { posX = 0, negX = 0, posY = 0, negY = 0, posZ = 0, negZ = 0 },
			affordable = false,
			removed = nil
		}
	end

	if menu.currentsector ~= menu.plotData.sector then
		menu.currentsector = menu.plotData.sector
		C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
		menu.applyFilterSettings()
	end

	if not donotrefresh and menu.plotsliders then
		-- if slider setup (3-slider or 6-slider) and plotData don't match, refresh the menu at the next opportunity.
		if (menu.plotsliders[1].dimension == "x" and menu.plotData.placed) or (menu.plotsliders[1].dimension ~= "x" and not menu.plotData.placed) then
			menu.over = true
		else
			menu.updatePlotWidgets()
		end
	end
end

function menu.updatePlotSliders()
	for _, slider in ipairs(menu.plotsliders) do
		local locdimension = menu.plotData.dimensions[slider.dimension]
		local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[slider.dimension]]

		local maxselect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension)
		Helper.setSliderCellValue(slider.table.id, slider.row, slider.col, locdimension, maxselect)
	end
end

function menu.updatePlotWidgets()
	for _, slider in ipairs(menu.plotsliders) do
		local sliderproperties = { min = 0, minselect = 2, max = config.maxPlotSize, start = menu.plotData.size[slider.dimension], step = 2, suffix = ReadText(1001, 108) }
		if menu.plotData.placed then
			local locdimension = menu.plotData.dimensions[slider.dimension]
			local minimumdimension = menu.plotData.minimumdimensions[slider.dimension] or 0
			local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[slider.dimension]]

			local minselect = math.max(menu.plotData.permanent and minimumdimension or 0, (locpaireddimension == 0 and 1 or 0))
			sliderproperties = {
				min = 0,
				minselect = minselect,
				max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
				maxselect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
				start = locdimension,
				step = 1,
				suffix = ReadText(1001, 108)
			}
			if sliderproperties.minselect > sliderproperties.maxselect then
				print("menu.updatePlotWidgets(): minselect > maxselect [Florian]")
				sliderproperties.minselect = sliderproperties.maxselect
			end
			if sliderproperties.start < sliderproperties.minselect then
				print("menu.updatePlotWidgets(): start < minselect [Florian]")
				sliderproperties.start = sliderproperties.minselect
			end
		end
		--print("dimension: " .. tostring(slider.dimension) .. ", paired: " .. tostring(config.plotPairedDimension[slider.dimension]) .. ", row: " .. tostring(slider.row) .. ", value: " .. tostring(menu.plotData.dimensions[slider.dimension]) )
		--Helper.setSliderCellValue(slider.table.id, slider.row, slider.col, menu.plotData.dimensions[slider.dimension])

		-- NB: necessary at the moment to set max in addition to changing slider value.
		local color = Color["text_normal"]
		local desc = Helper.createSliderCell(
			Helper.createTextInfo(
				slider.cell.properties.text.text,
				"left",
				Helper.standardFont,
				slider.cell.properties.text.fontsize,
				color.r,
				color.g,
				color.b,
				color.a,
				0,
				0
			),
			nil,
			nil,
			nil,
			nil,
			config.mapRowHeight,
			slider.cell.properties.bgColor,
			nil,
			sliderproperties,
			ffi.string(C.GetDisplayedModifierKey("shift")) .. " - " .. ReadText(1026, 3279)
		)
		Helper.setCellContent(menu, slider.table.id, desc, slider.row, slider.col, nil, "slidercell", nil, function(_, val) return menu.slidercellPlotValue(_, val, slider.dimension, not menu.plotData.placed) end, function() menu.noupdate = true end, function() menu.noupdate = false end, nil, function() return menu.refreshInfoFrame() end)
	end

	-- NB: this is simply to reset the button's active attribute.
	for _, button in ipairs(menu.plotbuttons) do
		if button.rowdata == "createplot" then
			local activate
			if button.col == 2 then
				activate = (menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 ~= menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 ~= menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 ~= menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false
			elseif button.col == 3 then
				activate = not menu.plotData.placed
			end
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				activate
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		elseif button.rowdata == "buyplot" then
			local activate
			if button.col == 2 then
				activate = false
			elseif button.col == 3 then
				activate = (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable) and true or false
			end
			local mouseovertext = ""
			if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
				mouseovertext = ReadText(1026, 3222)
			end
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				activate,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				nil,
				mouseovertext
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		elseif button.rowdata == "initiateconstruction" then
			local color = Color["text_normal"]
			local desc = Helper.createButton(
				Helper.createTextInfo(
					button.cell.properties.text.text,
					"center",
					Helper.standardFont,
					button.cell.properties.text.fontsize,
					color.r,
					color.g,
					color.b,
					color.a,
					0,
					0
				),
				nil,
				false,
				menu.plotData.placed
			)
			Helper.setCellContent(menu, button.table.id, desc, button.row, button.col, nil, "button", nil, button.script)
		end
	end
end

function menu.resetPlotSize()
	if not menu.plotData.placed then
		DebugError("menu.resetPlotSize: tried to resize a plot that has not yet been placed.")
		return
	end
	if menu.plotData.paid then
		local wantedcenteroffset = menu.plotData.boughtrawcenteroffset
		--print("wantedcenteroffset.x: " .. tostring(wantedcenteroffset.x) .. ", wantedcenteroffset.y: " .. tostring(wantedcenteroffset.y) .. ", wantedcenteroffset.z: " .. tostring(wantedcenteroffset.z))
		local boughtdimensions = {
			posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + wantedcenteroffset.x) / 1000),
			negX = math.floor((menu.plotData.boughtrawsize.x / 2 - wantedcenteroffset.x) / 1000),
			posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + wantedcenteroffset.y) / 1000),
			negY = math.floor((menu.plotData.boughtrawsize.y / 2 - wantedcenteroffset.y) / 1000),
			posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + wantedcenteroffset.z) / 1000),
			negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - wantedcenteroffset.z) / 1000),
		}
		local posSizeChange = { x = (boughtdimensions.posX - menu.plotData.dimensions.posX) * 1000, y = (boughtdimensions.posY - menu.plotData.dimensions.posY) * 1000, z = (boughtdimensions.posZ - menu.plotData.dimensions.posZ) * 1000 }
		local negSizeChange = { x = (boughtdimensions.negX - menu.plotData.dimensions.negX) * 1000, y = (boughtdimensions.negY - menu.plotData.dimensions.negY) * 1000, z = (boughtdimensions.negZ - menu.plotData.dimensions.negZ) * 1000 }
		--print("poschangeX: " .. tostring(posSizeChange.x) .. ", possizechangeY: " .. tostring(posSizeChange.y) .. ", possizechangeZ: " .. tostring(posSizeChange.z) .. "\nnegchangeX: " .. tostring(negSizeChange.x) .. ", negsizechangeY: " .. tostring(negSizeChange.y) .. ", negsizechangeZ: " .. tostring(negSizeChange.z))
		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			local plotcenteroffset = C.GetBuildPlotCenterOffset(menu.plotData.component)
			menu.plotData.size = { x = menu.plotData.boughtrawsize.x / 1000, y = menu.plotData.boughtrawsize.y / 1000, z = menu.plotData.boughtrawsize.z / 1000 }
			menu.plotData.dimensions = {
				posX = math.ceil((menu.plotData.boughtrawsize.x / 2 + plotcenteroffset.x) / 1000),
				negX = math.floor((menu.plotData.boughtrawsize.x / 2 - plotcenteroffset.x) / 1000),
				posY = math.ceil((menu.plotData.boughtrawsize.y / 2 + plotcenteroffset.y) / 1000),
				negY = math.floor((menu.plotData.boughtrawsize.y / 2 - plotcenteroffset.y) / 1000),
				posZ = math.ceil((menu.plotData.boughtrawsize.z / 2 + plotcenteroffset.z) / 1000),
				negZ = math.floor((menu.plotData.boughtrawsize.z / 2 - plotcenteroffset.z) / 1000),
			}
			--print("menu.resetPlotSize: successfully reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			C.UpdateMapBuildPlot(menu.holomap)
		else
			DebugError("menu.resetPlotSize: failed to reset build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. "\nposSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. "\nnegSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z))
		end
		if not menu.plotData.fullypaid and menu.plotData.price <= 0 then
			menu.plotData.fullypaid = true
		end
		menu.updatePlotData(menu.plotData.component, true)
		menu.refreshInfoFrame()
	end
end

function menu.updatePlotSize(dimension, axis, valchange)
	if menu.plotData.active then
		C.ChangeMapBuildPlot(menu.holomap, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
	elseif menu.plotData.placed then
		local posSizeChange = { x = 0, y = 0, z = 0 }
		local negSizeChange = { x = 0, y = 0, z = 0 }
		if dimension == "posX" or dimension == "posY" or dimension == "posZ" then
			posSizeChange[axis] = valchange * 1000
		elseif dimension == "negX" or dimension == "negY" or dimension == "negZ" then
			negSizeChange[axis] = valchange * 1000
		else
			DebugError("menu.updatePlotSize: dimension passed in: " .. tostring(dimension) .. " indicates neither positive nor negative.")
			return
		end

		-- kuertee start: callback
		local canExtend = true
		if menu.uix_callbacks["updatePlotSize_on_before_extend"] then
			for uix_id, uix_callback in pairs(menu.uix_callbacks["updatePlotSize_on_before_extend"]) do
				local result = uix_callback(menu.plotData.component, posSizeChange, negSizeChange)
				if result == false then
					canExtend = false
					break
				end
			end
		end
		if not canExtend then return end
		-- kuertee end: callback

		if C.ExtendBuildPlot(menu.plotData.component, posSizeChange, negSizeChange, true) then
			--print("menu.updatePlotSize: successfully extended build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
			C.UpdateMapBuildPlot(menu.holomap)
			if (not menu.plotData.isinownedspace) or GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "isplayerowned") then
				local rawsize = C.GetBuildPlotSize(menu.plotData.component)
				local plotcenter = C.GetBuildPlotCenterOffset(menu.plotData.component)
				for _, plot in ipairs(menu.plots) do
					if plot.station == menu.plotData.component then
						plot.boughtrawcenteroffset = plotcenter
						break
					end
				end
				C.PayBuildPlotSize(menu.plotData.component, rawsize, plotcenter)
			end
		else
			DebugError("menu.updatePlotSize: failed to extend build plot of station: " .. ffi.string(C.GetComponentName(menu.plotData.component)) .. ". posSizeChange.x: " .. tostring(posSizeChange.x) .. ", posSizeChange.y: " .. tostring(posSizeChange.y) .. ", posSizeChange.z: " .. tostring(posSizeChange.z) .. ", negSizeChange.x: " .. tostring(negSizeChange.x) .. ", negSizeChange.y: " .. tostring(negSizeChange.y) .. ", negSizeChange.z: " .. tostring(negSizeChange.z) .. ".")
		end
	end
end

function menu.plotInitiateConstruction(station)
	if not station then
		DebugError("menu.plotInitiateConstruction(): no station passed in. station: " .. tostring(station))
		return
	end
	menu.setplotrow = Helper.currentTableRow[menu.infoTable]
	menu.setplottoprow = GetTopRow(menu.infoTable)
	for _, plot in ipairs(menu.plots) do
		if plot.station == station then
			plot.permanent = true
			break
		end
	end

	AddUITriggeredEvent(menu.name, "initiateconstruction_station", ConvertStringTo64Bit(tostring(station)))
	AddUITriggeredEvent(menu.name, "initiateconstruction_license", menu.plotData.fullypaid)

	Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, station })
	menu.cleanup()
end

-- shortcuts
function menu.hotkey(action)
	local rowdata = Helper.getCurrentRowData(menu, menu.infoTable)
	local selectedcomponent
	if next(menu.selectedcomponents) then
		for id, _ in pairs(menu.selectedcomponents) do
			selectedcomponent = ConvertStringTo64Bit(id)
			if IsValidComponent(selectedcomponent) then
				break
			end
			selectedcomponent = nil
		end
	end

	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_CLOSE_MAP" then
		if menu.showMultiverse then
			menu.buttonToggleMultiverseMap()
		else
			menu.onCloseElement("close")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MISSIONS" then
		if menu.infoTableMode ~= "mission" then
			if menu.mode ~= "hire" then
				menu.infoTableMode = "mission"
				menu.refreshMainFrame = true
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_ZONE_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 20000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SECTOR_VIEW" then
		if menu.holomap and (menu.holomap ~= 0) then
			C.SetMapTargetDistance(menu.holomap, 2000000)
			C.ResetMapPlayerRotation(menu.holomap)
			C.SetFocusMapComponent(menu.holomap, C.GetPlayerObjectID(), true)
			if menu.infoTableMode == "objectlist" then
				menu.refreshInfoFrame()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F1" then
		C.SetPlayerCameraCockpitView(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_T" then
		menu.target(nil, C.IsExternalTargetMode() or C.IsExternalViewActive(), selectedcomponent)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_A_SHIFT" then
		C.ToggleAutoPilot(false)

		menu.settoprow = GetTopRow(menu.infoTable)
		menu.setrow = Helper.currentTableRow[menu.infoTable]
		if not menu.createInfoFrameRunning then
			menu.createInfoFrame()
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE" then
		if GetPlayerActivity() == "travel" then
			C.StopPlayerActivity("travel")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE", "inactive", "")
		else
			C.StartPlayerActivity("travel")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_TRAVELMODE", "active", "")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_SETA" then
		if GetPlayerActivity() == "seta" then
			C.StopPlayerActivity("seta")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_SETA", "inactive", "")
		else
			C.StartPlayerActivity("seta")
			C.TriggerInputFeedback("action", "INPUT_ACTION_ADDON_DETAILMONITOR_SETA", "active", "")
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_MULTIVERSE" then
		if (menu.mode ~= "selectCV") and (menu.mode ~= "hire") and (menu.mode ~= "orderparam_object") and (menu.mode ~= "selectComponent") then
			if menu.showMultiverse then
				Helper.closeMenu(menu, dueToClose)
				menu.cleanup()
			else
				menu.buttonToggleMultiverseMap()
			end
		end
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_PROPERTY_OWNED" then
		menu.infoTableMode = "propertyowned"
		menu.closeContextMenu()
		menu.refreshMainFrame = true
		menu.refreshInfoFrame()
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_CURRENT_SHIP" then
		menu.openDetails(C.GetPlayerShipID())
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_CONTEXT_MENU" then
		if menu.picking then
			menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }
			menu.onRenderTargetRightMouseUp(nil)
		else
			local row = Helper.currentTableRow[menu.infoTable]
			if row ~= nil then
				menu.onTableRightMouseClick(menu.infoTable, Helper.currentTableRow[menu.infoTable], 0, 0)
			end
		end
	elseif selectedcomponent then
		if action == "INPUT_ACTION_ADDON_DETAILMONITOR_C" then
			if (not menu.mode) and IsComponentOperational(selectedcomponent) and GetComponentData(selectedcomponent, "caninitiatecomm") then
				menu.openComm(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_I" then
			if (not menu.mode) and IsInfoUnlockedForPlayer(selectedcomponent, "name") and CanViewLiveData(selectedcomponent) then
				menu.openDetails(selectedcomponent)
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_TELEPORT" then
			local isplayerowned, isally, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isally", "isdeployable")
			if (isplayerowned or (C.IsComponentClass(selectedcomponent, "station") and isally)) and (not isdeployable) and not C.IsUnit(selectedcomponent) then
				if selectedcomponent ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) then
					if ffi.string(C.CanTeleportPlayerTo(selectedcomponent, false, false)) == "granted" then
						C.TeleportPlayerTo(selectedcomponent, false, false, false)
						return
					end
				end
			end
			PlaySound("ui_target_set_fail")
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_P" then
			menu.plotCourse(selectedcomponent)
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_F3" then
			if not C.IsExternalViewDisabled() and C.IsPlayerCameraTargetViewPossible(selectedcomponent, true) then
				if menu.target(selectedcomponent, true) then
					C.SetPlayerCameraTargetView(selectedcomponent, true)
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REMOVE_ORDER" then
			local lastorderidx = C.GetNumOrders(selectedcomponent)
			if lastorderidx > 0 then
				if GetComponentData(selectedcomponent, "isplayerowned") and C.RemoveOrder(selectedcomponent, lastorderidx, false, true) then
					if C.RemoveOrder(selectedcomponent, lastorderidx, false, false) then
						if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "left")
							if lastorderidx == #menu.infoTableData.left.orders then
								menu.infoTablePersistentData.left.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.left.selectedorder and (type(menu.infoTablePersistentData.left.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.left.selectedorder = { math.min(menu.infoTablePersistentData.left.selectedorder[1], #menu.infoTableData.left.orders - 1) }
							end
						end
						if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
							menu.removeExtendedOrder(selectedcomponent, lastorderidx, "right")
							if lastorderidx == #menu.infoTableData.right.orders then
								menu.infoTablePersistentData.right.selectedorder = (lastorderidx > 1) and { (lastorderidx - 1) } or nil
							end
							if menu.infoTablePersistentData.right.selectedorder and (type(menu.infoTablePersistentData.right.selectedorder[1]) == "number") then
								menu.infoTablePersistentData.right.selectedorder = { math.min(menu.infoTablePersistentData.right.selectedorder[1], #menu.infoTableData.right.orders - 1) }
							end
						end
					else
						PlaySound("ui_target_set_fail")
					end
				else
					PlaySound("ui_target_set_fail")
				end
			else
				PlaySound("ui_target_set_fail")
			end
		end
	else
		PlaySound("ui_target_set_fail")
	end
end

function menu.target(component, allowfirstperson, fallbackcomponent)
	local refresh = false
	if component == nil then
		component = C.GetPickedMapComponent(menu.holomap)
		if not C.IsComponentClass(component, "sector") then
			if C.IsComponentClass(component, "object") or C.IsComponentClass(component, "highway") then
				menu.addSelectedComponent(component, true, true)
				refresh = true
			end
		else
			component = fallbackcomponent
		end
	end
	if component == nil then
		PlaySound("ui_target_set_fail")
		return
	end
	local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
	local targetsector = C.GetContextByClass(component, "sector", true)
	if C.IsComponentClass(component, "highway") then
		targetsector = C.ConvertStringTo64Bit(GetComponentData(ConvertStringToLuaID(tostring(component)), "sourcesector"))
	end
	if (not menu.mode) and (component ~= C.GetPlayerControlledShipID()) and (allowfirstperson or (not IsFirstPerson())) and ((targetsector == 0) or (playersector == targetsector)) then
		local success = C.SetSofttarget(component, "")
		if success then
			PlaySound("ui_target_set")
			if not menu.createInfoFrameRunning then
				menu.createInfoFrame()
			end
			return true
		else
			PlaySound("ui_target_set_fail")
		end
	else
		PlaySound("ui_target_set_fail")
	end
	if refresh then
		menu.refreshInfoFrame()
	end
	return false
end

function menu.openComm(component)
	menu.closeContextMenu()
	local entities = Helper.getSuitableControlEntities(component, true, true)
	if #entities == 1 then
		if menu.conversationMenu then
			Helper.closeMenuForSubConversation(menu, "default", entities[1], component)
		else
			Helper.closeMenuForNewConversation(menu, "default", entities[1], component)
		end
	else
		Helper.closeMenuForNewConversation(menu, "gMain_propertyResult", ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), component)
	end
	menu.cleanup()
end

function menu.openCommWithActor(actor)
	menu.closeContextMenu()
	if menu.conversationMenu then
		Helper.closeMenuForSubConversation(menu, "default", actor)
	else
		Helper.closeMenuForNewConversation(menu, "default", actor)
	end
	menu.cleanup()
end

function menu.openDetails(component)
	menu.infoTableMode = "info"
	menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(component))
	if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
		menu.infoMode.left = "objectinfo"
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradeStorage(setting)
	local count = 0
	for i, option in ipairs(setting) do
		local force = false
		if option.active and (not option.active()) then
			-- option is disabled we want to force all storage types to be active
			force = true
		end
		if force or menu.getFilterOption(option.id, setting.savegame) then
			count = count + 1
		end
	end
	local transport = ffi.new("const char*[?]", count)
	local i = 0
	for _, option in ipairs(setting) do
		local force = false
		if option.active and (not option.active()) then
			force = true
		end
		if force or menu.getFilterOption(option.id, setting.savegame) then
			transport[i] = Helper.ffiNewString(option.param)
			i = i + 1
		end
	end

	C.SetMapTradeFilterByWareTransport(menu.holomap, transport, count)
end

function menu.filterTradeRelation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "enemy" then
			if value or (option.active and (not option.active())) then
				C.ClearMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			else
				C.SetMapTradeFilterByWillingToTradeWithPlayer(menu.holomap)
			end
		end
	end
end

function menu.filterTradeWares(setting)
	local rawwarelist = menu.getFilterOption(setting.id, setting.savegame) or {}
	local warelist = ffi.new("const char*[?]", #rawwarelist)
	for i, ware in ipairs(rawwarelist) do
		warelist[i - 1] = Helper.ffiNewString(ware)
	end
	if (#rawwarelist > 0) and ((not setting.active) or setting.active()) then
		C.SetMapTradeFilterByWare(menu.holomap, warelist, #rawwarelist)
	else
		C.ClearMapTradeFilterByWare(menu.holomap)
	end
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.filterTradePrice(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id, setting.savegame) or false
		if option.param == "maxprice" then
			if (not option.active) or option.active() then
				C.SetMapTradeFilterByMaxPrice(menu.holomap, value)
			else
				C.SetMapTradeFilterByMaxPrice(menu.holomap, 0)
			end
		end
	end
end

function menu.filterTradeOffer(setting)
	for _, option in ipairs(setting) do
		local value = menu.getFilterOption(option.id, setting.savegame) or false
		if option.param == "number" then
			C.SetMapTopTradesCount(menu.holomap, value)
		end
	end
end

function menu.filterTradeVolume(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "volume" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or false
			end
			if (value ~= 0) and ((not option.active) or option.active()) then
				C.SetMapTradeFilterByMinTotalVolume(menu.holomap, value)
			else
				C.ClearMapTradeFilterByMinTotalVolume(menu.holomap)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterTradePlayerOffer(setting, override)
	for _, option in ipairs(setting) do
		if option.param == "playeroffer_buy" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or 0
			end
			if (value == 0) or (option.active and (not option.active())) then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, true)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, true, false)
			end
		elseif option.param == "playeroffer_sell" then
			local value = override
			if value == nil then
				value = menu.getFilterOption(option.id, setting.savegame) or 0
			end
			if (value == 0) or (option.active and (not option.active())) then
				C.ClearMapTradeFilterByPlayerOffer(menu.holomap, false)
			elseif value == 1 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, true)
			elseif value == 2 then
				C.SetMapTradeFilterByPlayerOffer(menu.holomap, false, false)
			end
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkAlert(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "alert" then
			C.SetMapAlertFilter(menu.holomap, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterThinkDiplomacy(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "factioncolor" then
			C.SetMapFactionRelationColorOption(menu.holomap, not value)
		elseif option.param == "highlightvisitors" then
			C.SetConfigSetting(option.param, value)
		end
	end
	menu.refreshIF = getElapsedTime()
end

function menu.filterMining(value)
	for _, setting in ipairs(config.layersettings["layer_mining"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterMiningResources(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "display" then
			C.SetMapRenderResourceInfo(menu.holomap, value)
		end
	end
end

function menu.filterOther(value)
	for _, setting in ipairs(config.layersettings["layer_other"]) do
		if value then
			setting.callback(setting)
		else
			setting.callback(setting, false)
		end
	end
end

function menu.filterOtherStation(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "missions" then
			C.SetMapRenderMissionOffers(menu.holomap, value)
		elseif option.param == "civilian" then
			C.SetMapRenderCivilianShips(menu.holomap, value)
		end
	end
end

function menu.filterOtherShip(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "orderqueue" then
			C.SetMapRenderAllOrderQueues(menu.holomap, value)
		elseif option.param == "allyorderqueue" then
			C.SetMapRenderAllAllyOrderQueues(menu.holomap, value)
		end
	end
end

function menu.filterOtherMisc(setting, override)
	for _, option in ipairs(setting) do
		local value = override
		if value == nil then
			value = menu.getFilterOption(option.id, setting.savegame) or false
		end
		if option.param == "ecliptic" then
			C.SetMapRenderEclipticLines(menu.holomap, value)
		elseif option.param == "wrecks" then
			C.SetMapRenderWrecks(menu.holomap, value)
		elseif option.param == "selectionlines" then
			C.SetMapRenderSelectionLines(menu.holomap, value)
		elseif option.param == "gateconnections" then
			C.SetMapRenderAllGateConnections(menu.holomap, value)
		elseif option.param == "opacity" then
			menu.refreshMainFrame = true
		elseif option.param == "coveroverride" then
			C.SetUICoverOverride(value)
			menu.refreshIF = getElapsedTime()
		elseif option.param == "rendersatelliteradarrange" then
			C.SetMapRenderSatelliteRadarRange(menu.holomap, value)
		end
	end
end

-- menu display
function menu.onShowMenu(state)
	-- Restore settings
	C.SetUICoverOverride(false)
	__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false

	-- Init variables
	menu.selectedcomponents = {}
	menu.borderOffset = Helper.frameBorder
	menu.sellShipsWidth = Helper.scaleX(300)
	menu.selectWidth = Helper.scaleX(260)
	menu.searchtext = {}
	menu.syncMapFilterWithConfig()
	menu.createLegend()
	menu.orderloopskill = C.GetOrderLoopSkillLimit() * 3
	menu.showMultiverse = false
	menu.onlineModeHintWidth = Helper.scaleX(600)

	-- Handle menu parameters
	menu.importMenuParameters()
	if menu.mode == nil then
		if state or menu.state then
			menu.onRestoreState(state or menu.state, state ~= nil)
			menu.state = nil
		end
	end
	if menu.initMultiverse then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "getVentures")
		end
		Helper.updateVenturePlatforms()

		menu.showMultiverse = true
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
		end
	else
		menu.showMultiverse = false
	end
	menu.initMultiverse = nil

	if (menu.infoTableMode ~= "plots") and (menu.mode ~= "selectCV") then
		menu.plotData = {}
	end

	-- main frame
	menu.editboxHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))

	menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	menu.sideBarOffsetX = menu.borderOffset
	menu.sideBarOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2 + menu.sideBarWidth + 2 * Helper.borderSize

	-- infoTable
	menu.infoTableWidth = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize
	menu.infoTableWidth = math.max(menu.infoTableWidth, 400)
	menu.infoTableOffsetX = menu.sideBarOffsetX + menu.sideBarWidth + 2 * Helper.borderSize
	menu.infoTableOffsetY = Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + menu.borderOffset / 2

	-- searchfield
	menu.searchFieldData = {
		width = Helper.playerInfoConfig.width - menu.sideBarWidth - 2 * Helper.borderSize,
		offsetX = Helper.viewWidth - Helper.playerInfoConfig.width - menu.borderOffset,
		offsetY = menu.borderOffset,
	}

	-- map
	menu.rendertargetWidth = Helper.viewWidth
	menu.rendertargetHeight = Helper.viewHeight

	-- selected ships
	menu.selectedShipsTableData = {
		height = Helper.scaleY(20),
		width = Helper.scaleX(50),
		singleObjectWidth = Helper.scaleX(600),
		maxCols = 6,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		textHeight = Helper.scaleY(Helper.standardTextHeight),
	}

	-- trade rules
	Helper.updateTradeRules()

	-- Possible orders
	menu.orderdefs = {}
	menu.orderdefbyid = {}
	local orderdefs_skillsorted = {}
	local orderdefcategories_skillsorted = { mining = true }
	local orderdefs_forcedorderatfront = { "TradeRoutine_Basic", "TradeRoutine_Advanced" }

	local n = C.GetNumOrderDefinitions()
	local buf = ffi.new("OrderDefinition[?]", n)
	n = C.GetOrderDefinitions(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)
		entry.description = ffi.string(buf[i].description)
		entry.category = ffi.string(buf[i].category)
		entry.categoryname = ffi.string(buf[i].categoryname)
		entry.infinite = buf[i].infinite
		entry.requiredSkill = buf[i].requiredSkill
		entry.loopable = C.IsOrderLoopable(entry.id)
		table.insert(menu.orderdefs, entry)
		menu.orderdefbyid[entry.id] = entry
		if (orderdefcategories_skillsorted[entry.category]) then
			table.insert(orderdefs_skillsorted, entry)
			--orderdefcategories_skillsorted[entry.category] = entry.categoryname
		end
	end
	table.sort(menu.orderdefs, Helper.sortName)
	table.sort(orderdefs_skillsorted, function (a, b) return a.requiredSkill < b.requiredSkill end)
	for i, orderid in ipairs(orderdefs_forcedorderatfront) do
		for j, entry in ipairs(menu.orderdefs) do
			if entry.id == orderid then
				table.insert(menu.orderdefs, i, entry)
				table.remove(menu.orderdefs, j + 1)
				break
			end
		end
	end

	menu.orderdefsbycategory = {}
	for _, orderdef in ipairs(menu.orderdefs) do
		if (not orderdefcategories_skillsorted[orderdef.category]) then
			if menu.orderdefsbycategory[orderdef.category] then
				table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
			else
				menu.orderdefsbycategory[orderdef.category] = { orderdef }
			end
		end
	end
	for _, orderdef in ipairs(orderdefs_skillsorted) do
		if menu.orderdefsbycategory[orderdef.category] then
			table.insert(menu.orderdefsbycategory[orderdef.category], orderdef)
		else
			menu.orderdefsbycategory[orderdef.category] = { orderdef }
		end
	end

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	menu.displayMenu(true)

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onMinimizeMenu()
	UnregisterAddonBindings("ego_detailmonitor")
	UnregisterEvent("updateHolomap", menu.updateHolomap)
	UnregisterEvent("info_updatePeople", menu.infoUpdatePeople)
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.state = menu.onSaveState()
end

function menu.onRestoreMenu()
	if not menu.sound_ambient then
		menu.sound_ambient = StartPlayingSound("ui_map_ambient")
	end
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	menu.selectedcomponents = {}
	menu.displayMenu()

	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		if not menu.showMultiverse then
			local mapstate = ffi.new("HoloMapState")
			C.GetMapState(menu.holomap, mapstate)
			state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
		else
			state.map = menu.normalMapCameraState
		end
	end

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
		if (key[1] == "focuscomponent") then
			if menu.holomap ~= 0 then
				local currentfocus = C.GetMapFocusComponent(menu.holomap)
				state[key[1]] = (currentfocus ~= 0) and currentfocus or nil
			end
		end
	end
	return state
end

function menu.onRestoreState(state, restorefromsubmenu)
	if (not menu.showMultiverse) and (not menu.initMultiverse) then
		if state.map then
			local offset = ffi.new("UIPosRot", {
				x = state.map.offset.x,
				y = state.map.offset.y,
				z = state.map.offset.z,
				yaw = state.map.offset.yaw,
				pitch = state.map.offset.pitch,
				roll = state.map.offset.roll
			})
			menu.mapstate = ffi.new("HoloMapState", {
				offset = offset,
				cameradistance = state.map.cameradistance
			})
		end
	else
		menu.normalMapCameraState = state.map
	end

	local focuscomponent = menu.focuscomponent
	local focusoffset = menu.focusoffset
	menu.focusoffset = nil

	for _, key in ipairs(config.stateKeys) do
		if key[2] == "UniverseID" then
			menu[key[1]] = ConvertStringTo64Bit(tostring(state[key[1]]))
			if menu[key[1]] == 0 then
				menu[key[1]] = nil
			end
		elseif key[2] == "bool" then
			if type(state[key[1]]) == "number" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		else
			menu[key[1]] = state[key[1]]
		end
	end

	-- check if stored focuscomponent still makes sense
	if menu.focuscomponent then
		if not IsValidComponent(menu.focuscomponent) then
			-- component is not valid anymore, keep default value
			menu.focuscomponent = focuscomponent
		elseif not CanViewLiveData(menu.focuscomponent) then
			-- component is not in view anymore, keep default value
			menu.focuscomponent = focuscomponent
		end
	end
	if (not restorefromsubmenu) and menu.param[4] then
		-- we are not restoring from a submenu but opened the map with this explizit parameter, keep the parameter
		menu.focuscomponent = focuscomponent
		menu.focusoffset = focusoffset
		menu.mapstate = nil
	end
	-- check if stored infoSubmenuObject still makes sense
	if menu.infoSubmenuObject then
		if not IsValidComponent(menu.infoSubmenuObject) then
			-- component is not valid anymore, keep default value
			menu.infoSubmenuObject = nil
		end
	end
	-- check selectedcomponents
	local remove = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if not (IsValidComponent(selectedcomponent) and CanViewLiveData(selectedcomponent)) then
			table.insert(remove, id)
		end
	end
	for _, id in ipairs(remove) do
		menu.selectedcomponents[id] = nil
	end
	-- update venture platforms
	Helper.updateVenturePlatforms()
	-- set plot mode if necessary (only if we are restoring from a submenu now, see mail "#Observations# March 18th 2023 X4KE")
	if menu.infoTableMode == "plots" then
		if not restorefromsubmenu then
			menu.infoTableMode = "objectlist"
		else
			menu.updatePlotData("plots_new", true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
			menu.clearSelectedComponents()
		end
	end
	if menu.mode == "selectbuildlocation" then
		if not restorefromsubmenu then
			menu.mode = nil
		end
	end
end

function menu.displayMenu(firsttime)
	-- register lua events
	RegisterEvent("updateHolomap", menu.updateHolomap)
	RegisterEvent("info_updatePeople", menu.infoUpdatePeople)

	-- Register bindings
	RegisterAddonBindings("ego_detailmonitor", "map")
	RegisterAddonBindings("ego_detailmonitor", "context")
	RegisterAddonBindings("ego_detailmonitor", "comm")
	RegisterAddonBindings("ego_detailmonitor", "autopilot")
	RegisterAddonBindings("ego_detailmonitor", "undo")
	RegisterAddonBindings("ego_detailmonitor", "modes")

	menu.renderedComponents = {}

	menu.holomapcolor = Helper.getHoloMapColors()
	menu.prepareEconomyWares()
	if firsttime then
		menu.prepareKnownSectors()
	end

	-- create frames
	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.activatemap = nil
	local curtime = getElapsedTime()
	menu.lastrefresh = curtime
	menu.lastHighlightCheck = curtime

	if menu.mode == "infomode" then
		menu.infoTableMode = menu.modeparam[1]

		if menu.infoTableMode == "info" then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(menu.modeparam[2]))
			menu.focuscomponent = menu.infoSubmenuObject
			if not menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode.left) then
				menu.infoMode.left = "objectinfo"
			end
			if menu.modeparam[3] then
				menu.extendedinfo = {}
				for _, loccategory in ipairs(menu.modeparam[3]) do
					menu.extendedinfo[loccategory .. "left"] = true
				end
			end
		elseif menu.infoTableMode == "objectlist" then
			if menu.modeparam[2] then
				menu.objectMode = menu.modeparam[2]
			end
		elseif menu.infoTableMode == "propertyowned" then
			if menu.modeparam[2] then
				menu.propertyMode = menu.modeparam[2]
			end
		elseif menu.infoTableMode == "mission" then
			if menu.modeparam[2] then
				menu.missionMode = menu.modeparam[2]
			end
			if menu.modeparam[3] then
				menu.missionModeCurrent = menu.modeparam[3]
			end
			if menu.modeparam[4] and (menu.modeparam[4] ~= 0) then
				menu.expandedMissionGroups[menu.modeparam[3]] = true
			end
		end

		menu.mode = nil
		menu.modeparam = {}

		if menu.infoTableMode == "plots" then
			menu.initPlotList()
			local station = "plots_new"
			if C.IsRealComponentClass(menu.focuscomponent, "station") then
				station = menu.focuscomponent
			end
			menu.updatePlotData(station, true)
			menu.storeCurrentPlots()
			menu.mode = "selectbuildlocation"
			menu.clearSelectedComponents()
		end
	elseif menu.mode == "hire" then
		menu.infoTableMode = "propertyowned"
		menu.searchTableMode = "hire"
	elseif menu.mode == "sellships" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local ships = {}
		for _, ship in ipairs(menu.modeparam[2]) do
			table.insert(ships, ConvertIDTo64Bit(ship))
		end
		menu.contextMenuData = { shipyard = ConvertIDTo64Bit(menu.modeparam[1]), ships = ships, xoffset = menu.modeparam[3], yoffset = menu.modeparam[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif menu.mode == "selectCV" then
		menu.infoTableMode = "objectlist"
		menu.objectMode = "objectall"
		menu.propertyMode = "propertyall"
		table.insert(menu.searchtext, { text = ReadText(1014, 803), blockRemove = true })
		menu.focuscomponent = ConvertIDTo64Bit(menu.modeparam[1])
		menu.focusoffset = nil
		menu.layerBackup = {}
		for _, entry in ipairs(config.layers) do
			local oldvalue = __CORE_DETAILMONITOR_MAPFILTER[entry.mode]
			__CORE_DETAILMONITOR_MAPFILTER[entry.mode] = false
			menu.layerBackup[entry.mode] = oldvalue
		end
		menu.layerBackup["think_diplomacy_highlightvisitor"] = __CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"]
	elseif menu.mode == "selectComponent" then
		menu.infoTableMode = "objectlist"

		if menu.modeparam[3] == "deployables" then
			menu.objectMode = "deployables"
			menu.propertyMode = "deployables"
		end
	elseif menu.mode == "ventureconsole" then
		if C.AreVenturesCompatible() and (C.IsVentureSeasonSupported() or C.WasSessionOnline()) then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "getVentures")
			end
			Helper.updateVenturePlatforms()

			menu.showMultiverse = true
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
			end

			menu.mode = nil
			menu.modeparam = {}

			local isonline = Helper.isOnlineGame()
			if isonline then
				local operation = OnlineGetCurrentOperation()
				local currentteam = OnlineGetCurrentTeam()
				if operation.isvalid and currentteam.isvalid then
					menu.ventureMode = "ventureoperation"
				else
					menu.ventureMode = "ventureseason"
					menu.seasonMode.left = "currentseason"
				end
			end
		else
			menu.mode = nil
			menu.modeparam = {}
		end
	elseif menu.mode == "behaviourinspection" then
		menu.behaviourInspectionComponent = menu.modeparam[1]
	end

	if menu.mode == "tradecontext" then
		local shadyOnly = false
		if menu.modeparam[4] then
			shadyOnly = menu.modeparam[4] ~= 0
		end

		local loop = false
		if menu.modeparam[5] then
			loop = menu.modeparam[5]
		end

		local width, height
		if loop then
			menu.contextMenuMode = "tradeloop"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[6]), orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeLoopWidth / 2, yoffset = Helper.frameBorder, tradeModeHeight = config.tradeLoopWidth, loop = loop, reservecargo = true }

			width = Helper.scaleX(config.tradeLoopWidth)
		else
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertIDTo64Bit(menu.modeparam[1]), currentShip = ConvertIDTo64Bit(menu.modeparam[2]), shadyOnly = shadyOnly, orders = {}, xoffset = Helper.viewWidth / 2 - config.tradeContextMenuWidth / 2, yoffset = Helper.frameBorder, wareexchange = menu.modeparam[3] ~= 0 }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			if menu.contextMenuData.xoffset + menu.tradeContext.width > Helper.viewWidth - Helper.frameBorder then
				menu.contextMenuData.xoffset = Helper.viewWidth - menu.tradeContext.width - Helper.frameBorder
			end
			menu.contextMenuData.tradeModeHeight = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize
			if menu.contextMenuData.yoffset + menu.contextMenuData.tradeModeHeight > Helper.viewHeight - Helper.frameBorder then
				menu.contextMenuData.yoffset = Helper.viewHeight - menu.contextMenuData.tradeModeHeight - Helper.frameBorder
			end
			width = menu.tradeContext.width
			height = menu.contextMenuData.tradeModeHeight
		end

		menu.createMainFrame(nil, menu.contextMenuData.tradeModeHeight)

		menu.contextMenuData.yoffset = menu.contextMenuData.yoffset + menu.topLevelHeight
		menu.createContextFrame(width, height, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "boardingcontext" then
		-- accessing boarding menu from outside the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.closemapwithmenu = true
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = menu.modeparam[1], boarders = menu.modeparam[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif menu.mode == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = menu.modeparam[1], rightShip = menu.modeparam[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "dropwarescontext" then
		C.SetTrackedMenuFullscreen(menu.name, false)
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = menu.modeparam[1], entity = ConvertStringTo64Bit(tostring(menu.modeparam[2])), xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			-- kuertee start:
			if not onlineitems then
				onlineitems = {}
			end
			-- kuertee end

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "renamecontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "rename"

		-- kuertee start: multi-rename
		-- menu.contextMenuData = { component = menu.modeparam[1], fleetrename = menu.modeparam[2] ~= 0, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }
		menu.contextMenuData = {
			component = menu.modeparam[1],
			fleetrename = menu.modeparam[2] ~= 0,
			uix_multiRename_objects = menu.modeparam[3],
			xoffset = x + Helper.viewWidth / 2,
			yoffset = Helper.viewHeight / 2 - y
		}
		-- kuertee end: multi-rename

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "changelogocontext" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = menu.modeparam[1], origlogo = {}, currentlogo = {}, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturepatroninfo" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = menu.modeparam[1], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif menu.mode == "venturereport" then
		local x, y = GetLocalMousePosition()

		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = menu.modeparam[1], reason = menu.modeparam[2], timestamp = menu.modeparam[3], author = menu.modeparam[4], transactionid = menu.modeparam[5], userid = menu.modeparam[6], xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset, nil, false)
	else
		menu.createMainFrame(firsttime)

		if firsttime then
			if menu.infoTableMode then
				AddUITriggeredEvent(menu.name, menu.infoTableMode)
				local tab
				if menu.infoTableMode == "objectlist" then
					tab = menu.objectMode
				elseif menu.infoTableMode == "propertyowned" then
					tab = menu.propertyMode
				elseif menu.infoTableMode == "info" then
					tab = menu.infoMode
				elseif menu.infoTableMode == "missionoffer" then
					tab = menu.missionOfferMode
				elseif menu.infoTableMode == "mission" then
					tab = menu.missionMode
				end
				if tab then
					AddUITriggeredEvent(menu.name, "infoTableTab", tab)
				end
			end
		end
		menu.createInfoFrame()

		if menu.showMultiverse then
			local isonline = Helper.isOnlineGame()
			local operationRewardPending = Helper.hasVentureRewards()
			if C.IsVentureSeasonSupported() and (not isonline) then
				menu.contextMenuMode = "onlinemode"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			elseif operationRewardPending then
				menu.contextMenuMode = "onlinereward"
				menu.contextMenuData = { xoffset = 0, yoffset = menu.topLevelHeight, instance = instance, width = Helper.viewWidth, height = Helper.viewHeight - 2 * menu.topLevelHeight, rewardentries = OnlineGetLogbookRewards() }
				menu.createContextFrame(nil, nil, nil, nil, 0)
			end
		end
	end
end

-- create main frame (sideBar, navBar, map)
function menu.createMainFrame(firsttime, height, refresh)
	menu.createMainFrameRunning = true
	-- remove old data
	Helper.removeAllWidgetScripts(menu, config.mainFrameLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainFrameLayer,
		standardButtons = { back = true, close = true, help = true },
		standardButtonHelpOverlays = { help = "map_standardbutton_help" },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- player info
	menu.createPlayerInfo(menu.mainFrame, Helper.playerInfoConfig.width, Helper.playerInfoConfig.height, Helper.playerInfoConfig.offsetX, Helper.playerInfoConfig.offsetY)
	if menu.mode ~= "tradecontext" then
		if not menu.showMultiverse then
			-- search field
			menu.createSearchField(menu.mainFrame, menu.searchFieldData.width, 0, menu.searchFieldData.offsetX, menu.searchFieldData.offsetY, refresh)
		else
			Helper.clearTableConnectionColumn(menu, 3)
		end
		-- sideBar
		menu.createSideBar(firsttime, menu.mainFrame, menu.sideBarWidth, 0, menu.sideBarOffsetX, menu.sideBarOffsetY)
		if not menu.showMultiverse then
			-- rightBar
			menu.createRightBar(menu.mainFrame, menu.sideBarWidth, 0, Helper.viewWidth - menu.sideBarWidth - menu.borderOffset, menu.searchFieldData.offsetY)
			-- selected ships
			menu.createSelectedShips(menu.mainFrame)
		else
			Helper.clearTableConnectionColumn(menu, 4)
		end
	end
	-- top level
	menu.createTopLevel(menu.mainFrame)
	if menu.mode ~= "tradecontext" then
		-- map
		local alpha = 98
		if __CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] then
			alpha = 100
		end
		menu.mainFrame:addRenderTarget({width = menu.rendertargetWidth, height = menu.rendertargetHeight, x = 0, y = 0, scaling = false, alpha = alpha, clear = false })
	end

	if menu.mode == "tradecontext" then
		menu.mainFrame.properties.background.icon = "solid"
		menu.mainFrame.properties.background.color = Color["frame_background_semitransparent"]
		if height then
			menu.mainFrame.properties.height = height + menu.topLevelHeight + 2 * Helper.frameBorder
		end
	end

	menu.mainFrame:display()
end

-- (re)create info frame (infoTable)
function menu.createInfoFrame()
	menu.createInfoFrameRunning = true
	menu.refreshed = true
	menu.noupdate = false

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame = Helper.createFrameHandle(menu, {
		x = menu.infoTableOffsetX,
		y = menu.infoTableOffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer,
		standardButtons = {},
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe",
	})
	menu.infoFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.autopilottarget = GetAutoPilotTarget()
	menu.softtarget = C.GetSofttarget2().softtargetID
	menu.populateUpkeepMissionData()

	if (menu.infoTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.left.cashtransferdetails = {}
		menu.infoTablePersistentData.left.drops = {}
		menu.infoTablePersistentData.left.crew.object = nil
		menu.infoTablePersistentData.left.macrostolaunch = {}
	end

	if menu.holomap ~= 0 then
		if menu.infoTableMode then
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		else
			C.SetMapStationInfoBoxMargin(menu.holomap, "left", 0)
		end
	end

	Helper.clearTableConnectionColumn(menu, 2)

	local helpOverlayText = ""

	local infotabledesc, infotabledesc2
	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.left = {}
	if menu.showMultiverse then
		if menu.ventureMode == "ventureseason" then
			if menu.seasonMode.left == "currentseason" then
				menu.createVentureSeason(menu.infoFrame, "left")
			elseif menu.seasonMode.left == "coalition" then
				Helper.callExtensionFunction("multiverse", "createVentureCoalition", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "ventureteam" then
				Helper.callExtensionFunction("multiverse", "createVentureTeam", menu, menu.infoFrame, "left")
			elseif menu.seasonMode.left == "pastseasons" then
				Helper.callExtensionFunction("multiverse", "createVenturePastSeasons", menu, menu.infoFrame, "left")
			end
		elseif menu.ventureMode == "ventureoperation" then
			Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturelogbook" then
			Helper.callExtensionFunction("multiverse", "createVentureLogbook", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "ventureinventory" then
			Helper.callExtensionFunction("multiverse", "createVentureInventory", menu, menu.infoFrame, "left")
		elseif menu.ventureMode == "venturecontacts" then
			Helper.createVentureContacts(menu, menu.infoFrame, "left", menu.infoTableWidth, nil, nil, menu.infoTableOffsetX, menu.infoTableOffsetY)
		else
			-- empty
			menu.infoFrame.properties.background.icon = ""
			menu.infoFrame.properties.autoFrameHeight = false
			menu.infoFrame:addTable(0)
		end
	else
		if menu.infoTableMode == "objectlist" then
			infotabledesc, infotabledesc2 = menu.createObjectList(menu.infoFrame, "left")
		elseif menu.infoTableMode == "propertyowned" then
			infotabledesc = menu.createPropertyOwned(menu.infoFrame, "left")
		elseif menu.infoTableMode == "plots" then
			menu.createPlotMode(menu.infoFrame)
		elseif menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectinfo" then
				menu.infoFrame.properties.autoFrameHeight = false
				menu.createInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectcrew" then
				menu.createCrewInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectloadout" then
				menu.createLoadoutInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "objectlogbook" then
				menu.createLogbookInfoSubmenu(menu.infoFrame, "left")
			elseif menu.infoMode.left == "orderqueue" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "orderqueue_advanced" then
				menu.createOrderQueue(menu.infoFrame, menu.infoMode.left, "left")
			elseif menu.infoMode.left == "standingorders" then
				menu.createStandingOrdersMenu(menu.infoFrame, "left")
			end
		elseif menu.infoTableMode == "missionoffer" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "mission" then
			menu.createMissionMode(menu.infoFrame)
		elseif menu.infoTableMode == "cheats" then
			menu.createCheats(menu.infoFrame)
		elseif menu.uix_callbacks then
			-- kuertee start: callback
			if menu.uix_callbacks ["createInfoFrame_on_menu_infoTableMode"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_on_menu_infoTableMode"]) do
					uix_callback (menu.infoFrame)
				end
			end
			-- kuertee end: callback
		else
			-- empty
			menu.infoFrame.properties.background.icon = ""
			menu.infoFrame.properties.autoFrameHeight = false
			menu.infoFrame:addTable(0)
		end

	end
	menu.infoFrame.properties.helpOverlayText = helpOverlayText
	menu.infoFrame:display()

	if menu.holomap and (menu.holomap ~= 0) then
		menu.setSelectedMapComponents()
	end
end

-- create context frame
function menu.createContextFrame(width, height, xoffset, yoffset, noborder, startanimation)
	PlaySound("ui_positive_click")
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	menu.contextMenuData = menu.contextMenuData or {}
	if width then
		menu.contextMenuData.width = width
	end
	if height then
		menu.contextMenuData.height = height
	end
	if xoffset then
		menu.contextMenuData.xoffset = xoffset
	end
	if yoffset then
		menu.contextMenuData.yoffset = yoffset
	end

	if menu.contextMenuData.xoffset + menu.contextMenuData.width + Helper.borderSize > Helper.viewWidth then
		menu.contextMenuData.width = Helper.viewWidth - menu.contextMenuData.xoffset - Helper.borderSize
	end

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
		startAnimation = startanimation,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local adjustFrameHeight = true
	if menu.contextMenuMode == "neworder" then
		menu.createNewOrderContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_ware" then
		menu.createOrderparamWareContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "set_orderparam_sector" then
		menu.createOrderparamSectorContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "filter_multiselectlist" then
		menu.createFilterparamWareContext(menu.contextFrame)
	elseif menu.contextMenuMode == "set_orderparam_formationshape" then
		menu.createOrderparamFormationShapeContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "trade" then
		menu.createTradeContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "mission" then
		menu.createMissionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "boardingcontext" then
		menu.oldmode = menu.mode
		menu.mode = "boardingcontext"
		menu.oldInfoTableMode = menu.infoTableMode
		menu.infoTableMode = nil
		menu.refreshInfoFrame()
		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "weaponconfig" then
		menu.createWeaponConfigContext(menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "sellships" then
		menu.createSellShipsContext(menu.contextFrame)
	elseif menu.contextMenuMode == "select" then
		menu.createSelectContext(menu.contextFrame)
	elseif menu.contextMenuMode == "info_context" then
		menu.createInfoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.initCrewTransferData()
		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "rename" then
		menu.createRenameContext(menu.contextFrame)
	elseif menu.contextMenuMode == "changelogo" then
		menu.createChangeLogoContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion" then
		menu.createUserQuestionContext(menu.contextFrame)
	elseif menu.contextMenuMode == "userquestion_multiverse" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "onlinemode" then
		local contexttable = menu.createOnlineModeContext(menu.contextFrame)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
		menu.contextFrame.properties.standardButtons = {}
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "ventureconfig" then
		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturepatron" then
		Helper.callExtensionFunction("multiverse", "createVenturePatronContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturereport" then
		Helper.callExtensionFunction("multiverse", "createUserQuestionContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "ventureteammembercontext" then
		Helper.callExtensionFunction("multiverse", "createVentureTeamMemberContext", menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturecontactcontext" then
		Helper.createVentureContactContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturefriendlist" then
		Helper.showVentureFriendListContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["frame_background2_notification"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "searchfield" then
		menu.createSearchFieldContext(menu.contextFrame)
		menu.contextFrame.properties.standardButtons = {}
	end

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

-- handle created frames
function menu.viewCreated(layer, ...)
	if layer == config.mainFrameLayer then
		if menu.mode ~= "tradecontext" then
			if menu.showMultiverse then
				menu.playerInfoTable, menu.sideBar, menu.topLevel, menu.map = ...
			else
				menu.playerInfoTable, menu.searchField, menu.sideBar, menu.rightBar, menu.selectedShipsTable, menu.topLevel, menu.map = ...
			end

			if menu.activatemap == nil then
				menu.activatemap = true
			end
		else
			menu.playerInfoTable, menu.topLevel = ...
		end
		menu.createMainFrameRunning = false
	elseif layer == config.infoFrameLayer then
		menu.infoTable, menu.infoTable2, menu.infoTable3 = ...

		menu.createInfoFrameRunning = false
	elseif layer == config.infoFrameLayer2 then
		menu.infoTableRight, menu.infoTableRight2, menu.infoTableRight3 = ...

		menu.createInfoFrame2Running = false
	elseif layer == config.contextFrameLayer then
		if menu.contextMenuMode == "neworder" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_ware" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_sector" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "set_orderparam_formationshape" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "trade" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "tradeloop" then
			menu.contextshiptable, menu.contextbuttontable = ...
		elseif menu.contextMenuMode == "mission" then
			menu.contextdesctable, menu.contextobjectivetable, menu.contextbottomtable = ...

			if menu.contextMenuData.isoffer then
				RegisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				RegisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "weaponconfig" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "sellships" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "select" then
			menu.contexttable = ...
		elseif menu.contextMenuMode == "crewtransfer" then
			menu.contextbuttontable, menu.contexttable = ...
		elseif menu.contextMenuMode == "ventureconfig" then
			menu.contexttitletable, menu.contextmissiontable, menu.contextinfotable, menu.contextbuttontable, menu.contextrewardtable, menu.contextdescriptiontable = ...
		elseif menu.contextMenuMode == "hire" then
			menu.contexttable = ...
		end
	end
end

function menu.refreshContextFrame(setrow, setcol, noborder)
	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)

	local closeOnUnhandledClick = true
	if menu.contextMenuMode == "boardingcontext" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinemode" then
		closeOnUnhandledClick = false
	elseif menu.contextMenuMode == "onlinereward" then
		closeOnUnhandledClick = false
	end
	if menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		closeOnUnhandledClick = false
	end
	if menu.mode == "tradecontext" then
		closeOnUnhandledClick = false
	end

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - (noborder and 0 or 2 * Helper.borderSize),
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + (noborder and 0 or 2 * Helper.borderSize),
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
		closeOnUnhandledClick = closeOnUnhandledClick,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local adjustFrameHeight = true
	if menu.contextMenuMode == "boardingcontext" then
		menu.contexttoprow = GetTopRow(menu.boardingtable_shipselection.id)
		menu.contextselectedrow = Helper.currentTableRow[menu.boardingtable_shipselection.id]

		menu.createBoardingContext(menu.contextFrame, menu.contextMenuData.target, menu.contextMenuData.boarders)
	elseif menu.contextMenuMode == "crewtransfer" then
		menu.contexttoprow = GetTopRow(menu.contexttable)
		menu.contextselectedrow = Helper.currentTableRow[menu.contexttable]

		menu.createCrewTransferContext(menu.contextFrame)
	elseif menu.contextMenuMode == "tradeloop" then
		menu.contextselectedrow = Helper.currentTableRow[menu.contextbuttontable]

		menu.createTradeLoopContext(menu.contextFrame)
	elseif menu.contextMenuMode == "ventureconfig" then
		menu.topRows.contextdescriptiontable = GetTopRow(menu.contextdescriptiontable)
		menu.selectedRows.contextdescriptiontable = setrow or Helper.currentTableRow[menu.contextdescriptiontable]
		menu.selectedCols.contextdescriptiontable = setcol or Helper.currentTableCol[menu.contextdescriptiontable]

		menu.topRows.contextinfotable = GetTopRow(menu.contextinfotable)
		menu.selectedRows.contextinfotable = setrow or Helper.currentTableRow[menu.contextinfotable]
		menu.selectedCols.contextinfotable = setcol or Helper.currentTableCol[menu.contextinfotable]

		menu.topRows.contextbuttontable = GetTopRow(menu.contextbuttontable)
		menu.selectedRows.contextbuttontable = Helper.currentTableRow[menu.contextbuttontable]
		menu.selectedCols.contextbuttontable = Helper.currentTableCol[menu.contextbuttontable]

		Helper.callExtensionFunction("multiverse", "showVentureConfigurationContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "venturecreateparty" then
		Helper.callExtensionFunction("multiverse", "createVentureCreatePartyContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "hire" then
		menu.createHireContext(menu.contextFrame)
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "ventureoutcome" then
		Helper.callExtensionFunction("multiverse", "createVentureOutcomeContext", menu, menu.contextFrame, menu.contextMenuData.instance)
	elseif menu.contextMenuMode == "onlinereward" then
		local contexttable
		contexttable, menu.contextMenuData.allowClose = Helper.callExtensionFunction("multiverse", "createVentureRewardContext", menu, menu.contextFrame, menu.contextMenuData.instance)
		menu.contextFrame:setBackground("gradient_alpha_02", {  })
		if not menu.contextMenuData.allowClose then
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["hint_background_orange"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationRate = 360, rotationStart = 135, rotationDuration = 4, rotationInterval = 10 })
			menu.contextFrame.properties.standardButtons = {}
		else
			menu.contextFrame:setBackground2("tut_gradient_hint_01", { color = Color["hint_background_azure"], width = menu.onlineModeHintWidth + 3 * Helper.borderSize, height = contexttable:getFullHeight() + 4 * Helper.borderSize, rotationStart = 135 })
			menu.contextFrame.properties.standardButtonX = Helper.viewWidth - contexttable.properties.x - menu.onlineModeHintWidth - Helper.borderSize
			menu.contextFrame.properties.standardButtonY = contexttable.properties.y
		end
		menu.contextFrame.properties.height = menu.contextMenuData.height
		adjustFrameHeight = false
	elseif menu.contextMenuMode == "searchfield" then
		menu.createSearchFieldContext(menu.contextFrame)
		menu.contextFrame.properties.standardButtons = {}
	end

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	if adjustFrameHeight then
		menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	end
	menu.contextFrame:display()
end

function menu.refreshInfoFrame(setrow, setcol, setrow2, setcol2)
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrameRunning then
		menu.settoprow = menu.settoprow or GetTopRow(menu.infoTable)
		menu.topRows.infotableleft = menu.settoprow
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
		local storerowinfo = true
		if not menu.showMultiverse then
			if (menu.infoTableMode ~= "objectlist") and (menu.infoTableMode ~= "propertyowned") and ((menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation")) then
				storerowinfo = false
			end
		end
		if storerowinfo then
			menu.setrow = setrow or Helper.currentTableRow[menu.infoTable]
			menu.selectedRows.infotableleft = menu.setrow
			if menu.setplotrow then
				menu.setrow = menu.setplotrow
				menu.setplotrow = nil
			end
			menu.setcol = setcol or Helper.currentTableCol[menu.infoTable]
			menu.selectedCols.infotableleft = menu.setcol
		end

		menu.selectedRows.infotable2 = nil
		menu.selectedCols.infotable2 = nil
		if menu.infoTable2 then
			menu.selectedRows.infotable2 = setrow2 or Helper.currentTableRow[menu.infoTable2]
			menu.selectedCols.infotable2 = setcol2 or Helper.currentTableCol[menu.infoTable2]
		end
		if menu.infoTable3 then
			menu.topRows.infotable3left = GetTopRow(menu.infoTable3)
			menu.selectedRows.infotable3left = Helper.currentTableRow[menu.infoTable3]
		end
		if menu.orderHeaderTable and menu.lastactivetable == menu.orderHeaderTable.id then
			menu.selectedRows.orderHeaderTableleft = menu.selectedRows.orderHeaderTableleft or Helper.currentTableRow[menu.orderHeaderTable.id] or 1
			menu.selectedCols.orderHeaderTableleft = menu.selectedCols.orderHeaderTableleft or Helper.currentTableCol[menu.orderHeaderTable.id]
		end
		if menu.ventureSeasonHeaderTableLeft and menu.lastactivetable == menu.ventureSeasonHeaderTableLeft.id then
			menu.selectedRows.ventureSeasonHeaderTableleft = menu.selectedRows.ventureSeasonHeaderTableleft or Helper.currentTableRow[menu.ventureSeasonHeaderTableLeft.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableleft = menu.selectedCols.ventureSeasonHeaderTableleft or Helper.currentTableCol[menu.ventureSeasonHeaderTableLeft.id]
		end
		if menu.ventureInventoryHeaderTableLeft and menu.lastactivetable == menu.ventureInventoryHeaderTableLeft.id then
			menu.selectedRows.ventureInventoryHeaderTableleft = menu.selectedRows.ventureInventoryHeaderTableleft or Helper.currentTableRow[menu.ventureInventoryHeaderTableLeft.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableleft = menu.selectedCols.ventureInventoryHeaderTableleft or Helper.currentTableCol[menu.ventureInventoryHeaderTableLeft.id]
		end
		if menu.ventureContactsHeaderTableLeft and menu.lastactivetable == menu.ventureContactsHeaderTableLeft.id then
			menu.selectedRows.ventureContactsHeaderTableleft = menu.selectedRows.ventureContactsHeaderTableleft or Helper.currentTableRow[menu.ventureContactsHeaderTableLeft.id] or 1
			menu.selectedCols.ventureContactsHeaderTableleft = menu.selectedCols.ventureContactsHeaderTableleft or Helper.currentTableCol[menu.ventureContactsHeaderTableLeft.id]
		end
		if menu.missionModeHeaderTableLeft and menu.lastactivetable == menu.missionModeHeaderTableLeft.id then
			menu.selectedRows.missionModeHeaderTableleft = menu.selectedRows.missionModeHeaderTableleft or Helper.currentTableRow[menu.missionModeHeaderTableLeft.id] or 1
			menu.selectedCols.missionModeHeaderTableleft = menu.selectedCols.missionModeHeaderTableleft or Helper.currentTableCol[menu.missionModeHeaderTableLeft.id]
		end
		menu.createInfoFrame()
	end
	menu.refreshInfoFrame2()
end

function menu.refreshInfoFrame2(setrow, setcol)
	-- kuertee start: callback
	local isCreated = false
	if menu.uix_callbacks ["refreshInfoFrame2_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["refreshInfoFrame2_on_start"]) do
			if uix_callback () then
				isCreated = true
			end
		end
	end
	-- kuertee end: callback

	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	end
	if not menu.createInfoFrame2Running then
		menu.topRows.infotableright = menu.topRows.infotableright or GetTopRow(menu.infoTableRight)
		menu.selectedRows.infotableright = setrow or Helper.currentTableRow[menu.infoTableRight]
		menu.selectedCols.infotableright = setcol or Helper.currentTableCol[menu.infoTableRight]

		if menu.infoTableRight3 then
			menu.topRows.infotable3right = GetTopRow(menu.infoTableRight3)
			menu.selectedRows.infotable3right = Helper.currentTableRow[menu.infoTableRight3]
		end
		if menu.orderHeaderTableRight and menu.lastactivetable == menu.orderHeaderTableRight.id then
			menu.selectedRows.orderHeaderTableright = menu.selectedRows.orderHeaderTableright or Helper.currentTableRow[menu.orderHeaderTableRight.id] or 1
			menu.selectedCols.orderHeaderTableright = menu.selectedCols.orderHeaderTableright or Helper.currentTableCol[menu.orderHeaderTableRight.id]
		end
		if menu.ventureSeasonHeaderTableRight and menu.lastactivetable == menu.ventureSeasonHeaderTableRight.id then
			menu.selectedRows.ventureSeasonHeaderTableright = menu.selectedRows.ventureSeasonHeaderTableright or Helper.currentTableRow[menu.ventureSeasonHeaderTableRight.id] or 1
			menu.selectedCols.ventureSeasonHeaderTableright = menu.selectedCols.ventureSeasonHeaderTableright or Helper.currentTableCol[menu.ventureSeasonHeaderTableRight.id]
		end
		if menu.ventureInventoryHeaderTableRight and menu.lastactivetable == menu.ventureInventoryHeaderTableRight.id then
			menu.selectedRows.ventureInventoryHeaderTableright = menu.selectedRows.ventureInventoryHeaderTableright or Helper.currentTableRow[menu.ventureInventoryHeaderTableRight.id] or 1
			menu.selectedCols.ventureInventoryHeaderTableright = menu.selectedCols.ventureInventoryHeaderTableright or Helper.currentTableCol[menu.ventureInventoryHeaderTableRight.id]
		end
		if menu.ventureContactsHeaderTableRight and menu.lastactivetable == menu.ventureContactsHeaderTableRight.id then
			menu.selectedRows.ventureContactsHeaderTableright = menu.selectedRows.ventureContactsHeaderTableright or Helper.currentTableRow[menu.ventureContactsHeaderTableRight.id] or 1
			menu.selectedCols.ventureContactsHeaderTableright = menu.selectedCols.ventureContactsHeaderTableright or Helper.currentTableCol[menu.ventureContactsHeaderTableRight.id]
		end
		if menu.missionModeHeaderTableRight and menu.lastactivetable == menu.missionModeHeaderTableRight.id then
			menu.selectedRows.missionModeHeaderTableright = menu.selectedRows.missionModeHeaderTableright or Helper.currentTableRow[menu.missionModeHeaderTableRight.id] or 1
			menu.selectedCols.missionModeHeaderTableright = menu.selectedCols.missionModeHeaderTableright or Helper.currentTableCol[menu.missionModeHeaderTableRight.id]
		end
		menu.createInfoFrame2()
	end
end

function menu.extendSectionAndRefresh(rowdata)
	menu.extendModuleType(rowdata[2], rowdata[3])
	menu.settoprow = GetTopRow(menu.infoTable)
	menu.updateMapAndInfoFrame()
end

function menu.getContainerNameAndColors(container, iteration, issquadleader, showScanLevel, showbehaviourinspection)
	local convertedContainer = ConvertIDTo64Bit(container)
	local isplayer, revealpercent, name, faction, icon, ismissiontarget, isonlineobject, isenemy, ishostile = GetComponentData(container, "isplayerowned", "revealpercent", "name", "owner", "icon", "ismissiontarget", "isonlineobject", "isenemy", "ishostile")
	local unlocked = IsInfoUnlockedForPlayer(container, "name")
	local usefactioncolor = false
	local highlightvisitors = false
	if menu.getFilterOption("layer_other", false) then
		usefactioncolor = menu.getFilterOption("think_diplomacy_factioncolor", false)
		highlightvisitors = menu.getFilterOption("think_diplomacy_highlightvisitor", false)
	end

	local name = Helper.unlockInfo(unlocked, name .. " (" .. ffi.string(C.GetObjectIDCode(convertedContainer)) .. ")") .. (((not showScanLevel) or isplayer) and "" or " (" .. revealpercent .. " %)")
	local font = Helper.standardFont
	local color = Color["text_normal"]

	if faction == nil then
		if C.IsComponentClass(convertedContainer, "controllable") then
			DebugError("Found a controllable without a faction: " .. name)
		end
		usefactioncolor = false
	end

	local bgcolor = issquadleader and Color["row_background_blue"] or Color["row_background"]
	if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedContainer)) then
		bgcolor = Color["row_background_unselectable"]
	elseif (menu.mode == "selectCV") and C.IsBuilderBusy(convertedContainer) then
		name = ColorText["text_error"] .. ReadText(1001, 7943) .. "\27X - " .. name
		color = Color["text_inactive"]
	elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedContainer)) then
		bgcolor = Color["row_background_unselectable"]
	end

    -- mycu start: callback
    if menu.uix_callbacks ["getContainerNameAndColors_on_name_construct"] then
        for uix_id, uix_callback in pairs (menu.uix_callbacks ["getContainerNameAndColors_on_name_construct"]) do
            local result = uix_callback (container, name)
            if result then
                name = result.name
            end
        end
    end
    -- mycu end: callback

	if not menu.mode then
		if convertedContainer == menu.softtarget then
			name = config.softtargetmarker_l .. name
			font = Helper.standardFontBold
		end
		if IsSameComponent(menu.autopilottarget, container) then
			name = config.autopilotmarker .. name
		end
	end

	if ismissiontarget then
		color = menu.holomapcolor.missioncolor
	elseif isonlineobject and highlightvisitors then
		color = menu.holomapcolor.visitorcolor
	elseif not unlocked then
		color = Color["text_inactive"]
	elseif isplayer then
		if convertedContainer == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		else
			color = menu.holomapcolor.playercolor
		end
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	local factioncolor = ""
	if usefactioncolor then
		factioncolor = Helper.convertColorToText(GetFactionData(faction, "color"))
	end

	if IsComponentClass(container, "ship") or C.IsRealComponentClass(convertedContainer, "station") or IsComponentClass(container, "buildstorage") then
		local iconid = icon
		if iconid and iconid ~= "" then
			if usefactioncolor then
				name = string.format("%s\027[%s]%s %s", factioncolor, iconid, Helper.convertColorToText(color), name)
			else
				name = string.format("\027[%s] %s", iconid, name)
			end
		end
	end
	if showbehaviourinspection and (convertedContainer == menu.behaviourInspectionComponent) then
		name = ColorText["behaviour_inspection_text"] .. "\27[menu_behaviourinspection]\27X " .. name
	end
	local mouseover = "" --name
	for i = 1, iteration do
		name = "    " .. name
	end

	return name, color, bgcolor, font, mouseover, factioncolor
end

function menu.getFleetName(object64)
	if C.IsComponentClass(object64, "controllable") then
		local fleetname = ffi.string(C.GetFleetName(object64))
		if fleetname ~= "" then
			return fleetname
		end
	end
end

function menu.addInternallyStoredShips(id)
	if C.IsComponentClass(id, "container") then
		local dockedships = {}
		Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, id, nil)

		for i = 1, #dockedships do
			local dockedID = ConvertStringTo64Bit(tostring(dockedships[i]))
			local hull, purpose, ismodule, uirelation, isinternallystored = GetComponentData(dockedID, "hullpercent", "primarypurpose", "ismodule", "uirelation", "isinternallystored")
			if isinternallystored then
				table.insert(menu.renderedComponents, { id = dockedID, name = ffi.string(C.GetComponentName(dockedID)), fleetname = menu.getFleetName(dockedID), objectid = ismodule and "" or ffi.string(C.GetObjectIDCode(dockedID)), class = ffi.string(C.GetComponentClass(dockedID)), hull = hull, purpose = purpose, relation = uirelation })
				menu.renderedComponentsRef[dockedID] = true

				menu.addInternallyStoredShips(dockedID)
			end
		end
	end
end

function menu.updateRenderedComponents()
	menu.renderedComponents = {}
	menu.renderedComponentsRef = {}
	if menu.holomap and (menu.holomap ~= 0) then
		Helper.ffiVLA(menu.renderedComponents, "UniverseID", C.GetNumMapRenderedComponents, C.GetMapRenderedComponents, menu.holomap)
		for i = #menu.renderedComponents, 1, -1 do
			local id = ConvertStringTo64Bit(tostring(menu.renderedComponents[i]))
			if IsValidComponent(id) then
				local ismasstraffic, isenemy, hull, purpose, ismodule, uirelation = GetComponentData(id, "ismasstraffic", "isenemy", "hullpercent", "primarypurpose", "ismodule", "uirelation")
				if ismasstraffic and (not isenemy) then
					table.remove(menu.renderedComponents, i)
				else
					menu.renderedComponents[i] = { id = id, name = ffi.string(C.GetComponentName(id)), fleetname = menu.getFleetName(id), objectid = ismodule and "" or ffi.string(C.GetObjectIDCode(id)), class = ffi.string(C.GetComponentClass(id)), hull = hull, purpose = purpose, relation = uirelation }
					menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(id))] = true

					menu.addInternallyStoredShips(id)
				end
			else
				table.remove(menu.renderedComponents, i)
			end
		end

		-- make sure the holomap is up before using the focuscomponent to init selectedcomponents
		if #menu.renderedComponents > 0 then
			if menu.focuscomponent then
				menu.infoTable = nil
				menu.highlightedbordercomponent = nil
				menu.highlightedbordermoduletype = nil
				menu.highlightedplannedmodule = nil
				menu.highlightedbordersection = nil
				menu.highlightedborderstationcategory = nil
				menu.selectedstationcategory = nil
				menu.highlightedconstruction = nil
				menu.selectedconstruction = nil
				menu.selectedfleetcommander = nil
				menu.highlightedfleetunit = nil
				menu.selectedfleetunit = nil
				if menu.selectfocuscomponent then
					menu.addSelectedComponent(menu.focuscomponent)
					menu.selectfocuscomponent = nil
				end
				menu.focuscomponent = nil
			end
		end
	end

	-- Always show target component
	local softtarget = ConvertStringTo64Bit(tostring(C.GetSofttarget2().softtargetID))
	if softtarget ~= 0 then
		if not menu.renderedComponentsRef[softtarget] then
			local hull, purpose, uirelation, sector = GetComponentData(softtarget, "hullpercent", "primarypurpose", "uirelation", "sector")
			table.insert(menu.renderedComponents, { id = softtarget, name = ffi.string(C.GetComponentName(softtarget)), fleetname = menu.getFleetName(softtarget), objectid = C.IsComponentClass(softtarget, "object") and ffi.string(C.GetObjectIDCode(softtarget)) or "", class = ffi.string(C.GetComponentClass(softtarget)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
			menu.renderedComponentsRef[softtarget] = true
		end
	end

	-- Always show selected components
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if not menu.renderedComponentsRef[selectedcomponent] then
				local hull, purpose, uirelation, sector = GetComponentData(selectedcomponent, "hullpercent", "primarypurpose", "uirelation", "sector")
				table.insert(menu.renderedComponents, { id = selectedcomponent, name = ffi.string(C.GetComponentName(selectedcomponent)), fleetname = menu.getFleetName(selectedcomponent), objectid = C.IsComponentClass(selectedcomponent, "object") and ffi.string(C.GetObjectIDCode(selectedcomponent)) or "", class = ffi.string(C.GetComponentClass(selectedcomponent)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
				menu.renderedComponentsRef[selectedcomponent] = true
			end
		end
	end

	table.sort(menu.renderedComponents, menu.componentSorter(menu.objectSorterType))
end

function menu.componentSorter(sorttype)
	local sorter = Helper.sortNameAndObjectID
	if sorttype == "nameinverse" then
		sorter = function (a, b) return Helper.sortNameAndObjectID(a, b, true) end
	elseif sorttype == "class" then
		sorter = Helper.sortShipsByClassAndPurpose
	elseif sorttype == "classinverse" then
		sorter = function (a, b) return Helper.sortShipsByClassAndPurpose(a, b, true) end
	elseif sorttype == "hull" then
		sorter = Helper.sortHullAndName
	elseif sorttype == "hullinverse" then
		sorter = function (a, b) return Helper.sortHullAndName(a, b, true) end
	elseif sorttype == "relation" then
		sorter = Helper.sortRelationAndName
	elseif sorttype == "relationinverse" then
		sorter = function (a, b) return Helper.sortRelationAndName(a, b, true) end
	elseif sorttype == "sector" then
		sorter = Helper.sortNameSectorAndObjectID
	elseif sorttype == "sectorinverse" then
		sorter = function (a, b) return Helper.sortNameSectorAndObjectID(a, b, true) end

	-- kuertee start: add sort by distance
	elseif sorttype == "distance_from_player" then
		sorter = menu.sortDistanceFromPlayer
	elseif sorttype == "distance_from_playerinverse" then
		sorter = function (a, b) return menu.sortDistanceFromPlayer (a, b, true) end
	elseif sorttype == "distance_from_object" then
		sorter = menu.sortDistanceFromObject
	elseif sorttype == "distance_from_objectinverse" then
		sorter = function (a, b) return menu.sortDistanceFromObject (a, b, true) end
	-- kuertee end: add sort by distance

	end
	return sorter
end

function menu.sortComponentListHelper(components, sorter)
	local sortedComponents = {}
	for _, component in ipairs(components) do
		if component.component then
			local component64 = ConvertStringTo64Bit(tostring(component.component))
			local hull, purpose, uirelation, sector = GetComponentData(component64, "hullpercent", "primarypurpose", "uirelation", "sector")
			table.insert(sortedComponents, { id = component64, name = ffi.string(C.GetComponentName(component64)), fleetname = menu.getFleetName(component64), objectid = C.IsComponentClass(component64, "object") and ffi.string(C.GetObjectIDCode(component64)) or "", class = ffi.string(C.GetComponentClass(component64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector })
		elseif component.fleetunit then
			local info = C.GetFleetUnitInfo(component.fleetunit)
			local macro = ffi.string(info.macro)
			local primarypurpose = GetMacroData(macro, "primarypurpose")
			local name = ffi.string(info.name)
			local fleetname = ffi.string(C.GetFleetUnitFleetName(component.fleetunit))
			local objectid = ffi.string(info.idcode)
			local hull = 0
			local sector = ""
			if info.replacementid ~= 0 then
				local name, hull, sector = GetComponentData(ConvertStringToLuaID(tostring(info.replacementid)), "name", "hullpercent", "sector")
				name = name
				objectid = ffi.string(C.GetObjectIDCode(info.replacementid))
				hull = hull
				sector = sector
			end
			local class = ffi.string(C.GetMacroClass(macro))

			table.insert(sortedComponents, { fleetunit = component.fleetunit, name = name, fleetname = fleetname, objectid = objectid, class = class, hull = hull, purpose = primarypurpose, relation = 30, sector = sector })
		end
	end
	table.sort(sortedComponents, menu.componentSorter(sorter))
	local returnvalue = {}
	for _, entry in ipairs(sortedComponents) do
		if entry.id then
			table.insert(returnvalue, { component = ConvertStringToLuaID(tostring(entry.id)) })
		elseif entry.fleetunit then
			table.insert(returnvalue, { fleetunit = entry.fleetunit })
		end
	end
	return returnvalue
end

function menu.isObjectValid(object)
	local isdeployable, isradarvisible, isorphaned, isattachedaslimpet = GetComponentData(object, "isdeployable", "isradarvisible", "isorphaned", "isattachedaslimpet")
	local isship = C.IsComponentClass(object, "ship")
	if not isship and not (C.IsRealComponentClass(object, "station") and (not C.IsComponentWrecked(object))) and not isdeployable and not C.IsComponentClass(object, "lockbox") and not C.IsComponentClass(object, "collectablewares") and not (C.IsComponentClass(object, "buildstorage") and isorphaned) then
		return false
	elseif C.IsComponentClass(object, "controllable") and C.IsUnit(object) then
		return false
	elseif (not C.IsObjectKnown(object)) or (not isradarvisible) then
		return false
	elseif isship and isattachedaslimpet then
		return false
	end
	return true
end

function menu.getShipIconWidth()
	local numbertext = "99"
	local minWidthPercent = 0.028

	local textheight = math.ceil(C.GetTextHeight("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), Helper.viewWidth))
	local textwidth = math.ceil(C.GetTextWidth("99", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize)))

	return math.max(minWidthPercent * menu.infoTableWidth, math.max(textheight, textwidth))
end

-- Object List

function menu.getSubordinates(controllable, checkrendered)
	local controllable64 = C.ConvertStringTo64Bit(tostring(controllable))

	local subordinates = {}
	if C.IsComponentClass(controllable64, "controllable") then
		local locsubordinates = GetSubordinates(controllable)
		for _, subordinate in ipairs(locsubordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			if menu.isObjectValid(subordinate64) then
				table.insert(subordinates, { component = subordinate })
			end
			if checkrendered and menu.renderedComponentsRef[subordinate64] then
				subordinates.hasRendered = true
			end
		end

		local n = C.GetNumControllableSubordinateFleetUnits(controllable64, -1)
		if n > 0 then
			local buf = ffi.new("FleetUnitID[?]", n)
			n = C.GetControllableSubordinateFleetUnits(buf, n, controllable64, -1)
			for i = 0, n - 1 do
				local fleetunit = buf[i]
				table.insert(subordinates, { fleetunit = fleetunit })
			end
			if checkrendered ~= nil then
				subordinates.hasRendered = true
			end
		end
		if checkrendered == false then
			subordinates.hasRendered = #subordinates > 0
		end
	end
	return subordinates
end

function menu.getMinFleetUnitSubordinateCommanderDistance(instance, replacementcandidate, fleetunit, firstcommandercomponent)
	local subordinates = menu.infoTableData[instance].subordinates["fleetunit:" .. tostring(fleetunit)]
	for _, subordinate in ipairs(subordinates) do
		if subordinate.component then
			-- get the list of all commanders and find distance to firstcommandercomponent
			local commanderlist = GetAllCommanders(subordinate.component)
			for i, commander in ipairs(commanderlist) do
				if IsSameComponent(commander, firstcommandercomponent) then
					if i == 1 then
						-- found the replacement component, as this is the direct commander
						replacementcandidate = { component = subordinate.component, distance = i }
						break
					else
						-- not the direct commander, keep looking but keep this result, if it's the best
						if (not replacementcandidate) or (i < replacementcandidate.distance) then
							replacementcandidate = { component = subordinate.component, distance = i }
						end
					end
				end
			end
			if replacementcandidate and (replacementcandidate.distance == 1) then
				-- we found the replacement -> abort this loop
				break
			end
		end
	end
	if replacementcandidate and (replacementcandidate.distance == 1) then
		-- we found the replacement -> return
		return replacementcandidate
	end
	-- we also need to check the still-existing subordinates of destroyed subordinates. These could be promoted above the siblings of their destroyed commander under certain conditions,
	-- e.g. the replacement for A1 in this example
	-- Fleet: FC -> A1 |-> B1 |-> C1   (destroy B1)   FC -> A1 |-> C1 |-> C2   (destroy A1)   FC -> C1 |-> C2
	--                 |      |-> C2   ----------->            |      |-> C3   ----------->            |-> C3
	--                 |      \-> C3                           \-> B2                                  \-> B2
	--                 \-> B2
	for _, subordinate in ipairs(subordinates) do
		if subordinate.fleetunit then
			replacementcandidate = menu.getMinFleetUnitSubordinateCommanderDistance(instance, replacementcandidate, subordinate.fleetunit, firstcommandercomponent)
		end
	end

	return replacementcandidate
end

function menu.getFleetUnitSubordinates(instance, controllable, checkrendered)
	local infoTableData = menu.infoTableData[instance]

	local controllableid = tostring(ConvertStringToLuaID(tostring(controllable)))
	infoTableData.fleetUnitData[controllableid] = { count = 0, haserrors = false }

	local n = C.GetNumAllFleetUnits(controllable)
	if n > 0 then
		local fleetunits = {}

		local buf = ffi.new("FleetUnitID[?]", n)
		n = C.GetAllFleetUnits(buf, n, controllable)

		infoTableData.fleetUnitData[controllableid].count = n

		for i = 0, n - 1 do
			local fleetunit = buf[i]
			table.insert(fleetunits, fleetunit)

			if not infoTableData.fleetUnitData[controllableid].haserrors then
				local issues = ffi.string(C.GetFleetUnitBuildIssues(fleetunit))
				for issue in string.gmatch(issues, "[^;]+") do
					if (issue == "nocontainer") or (issue == "objectmacro") or (issue == "equipment") or (issue == "paused") then
						infoTableData.fleetUnitData[controllableid].haserrors = true
						break
					end
				end
			end

			local fleetunitsubordinates = {}
			local num_subordinates = C.GetNumFleetUnitSubordinates(fleetunit, -1)
			if num_subordinates > 0 then
				local buf_subordinates = ffi.new("UniverseID[?]", num_subordinates)
				num_subordinates = C.GetFleetUnitSubordinates(buf_subordinates, num_subordinates, fleetunit, -1)
				for j = 0, num_subordinates - 1 do
					local fleetunitsubordinate = ConvertStringToLuaID(tostring(buf_subordinates[j]))
					table.insert(fleetunitsubordinates, { component = fleetunitsubordinate })
					infoTableData.fleetUnitSubordinates[tostring(fleetunitsubordinate)] = true
					if checkrendered and menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(fleetunitsubordinate))] then
						fleetunitsubordinates.hasRendered = true
					end
				end
			end

			local num_fleetunits = C.GetNumFleetUnitSubordinateFleetUnits(fleetunit, -1)
			if num_fleetunits > 0 then
				local buf_fleetunits = ffi.new("FleetUnitID[?]", num_fleetunits)
				num_fleetunits = C.GetFleetUnitSubordinateFleetUnits(buf_fleetunits, num_fleetunits, fleetunit, -1)
				for j = 0, num_fleetunits - 1 do
					local fleetunitsubordinate = buf_fleetunits[j]
					table.insert(fleetunitsubordinates, { fleetunit = fleetunitsubordinate })
					if checkrendered ~= nil then
						fleetunitsubordinates.hasRendered = true
					end
				end
			end
			if checkrendered == false then
				fleetunitsubordinates.hasRendered = #fleetunitsubordinates > 0
			end

			infoTableData.subordinates["fleetunit:" .. tostring(fleetunit)] = fleetunitsubordinates
		end

		-- get replacement component's for each fleetunit (do this after getting all fleetunit data, so we have their subordinate data already)
		for _, fleetunit in ipairs(fleetunits) do
			local replacementcandidate
			-- get first existing commander
			local firstcommandercomponent = ConvertStringToLuaID(tostring(C.GetFleetUnitFirstCommanderComponent(fleetunit)))
			if firstcommandercomponent ~= 0 then
				firstcommandercomponent = ConvertStringToLuaID(tostring(firstcommandercomponent))
				-- go through ALL existing subordinates of fleetunit, recursive, breadth-first
				replacementcandidate = menu.getMinFleetUnitSubordinateCommanderDistance(instance, replacementcandidate, fleetunit, firstcommandercomponent)
				if replacementcandidate then
					infoTableData.fleetUnitReplacements["fleetunit:" .. tostring(fleetunit)]      = replacementcandidate.component
					-- one existing component can replace multiple fleetunits
					if infoTableData.fleetUnitReplacements[tostring(replacementcandidate.component)] then
						table.insert(infoTableData.fleetUnitReplacements[tostring(replacementcandidate.component)], fleetunit)
					else
						infoTableData.fleetUnitReplacements[tostring(replacementcandidate.component)] = { fleetunit }
					end
				end
			end
		end
	end
end

function menu.createObjectList(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local objecttable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	objecttable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	objecttable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	objecttable:setDefaultCellProperties("icon",   { height = config.mapRowHeight })
	objecttable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })
	--  [+/-] [Object Name] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	objecttable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	objecttable:setColWidthMinPercent(2, 20)
	objecttable:setColWidthMinPercent(4, 10)
	for i = 1, maxicons do
		objecttable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	objecttable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)
	objecttable:setDefaultBackgroundColSpan(2, 4 + maxicons)

	-- title section
	local onlysectorallowed
	if menu.currentsector and (menu.currentsector ~= 0) then
		-- title
		menu.title = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(menu.currentsector))
		infoTableData.ownerDetails = C.GetOwnerDetails(menu.currentsector)

		if menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = menu.checkForOrderParamObject(menu.currentsector)
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end

			local row = objecttable:addRow(sectorallowed, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(4):createText(menu.title, Helper.headerRowCenteredProperties)
			row[5]:setColSpan(1 + maxicons):createButton({ active = sectorallowed, height = Helper.headerRow1Height, mouseOverText = ReadText(1001, 3228) }):setText(ReadText(1001, 3102), { halign = "center" })
			row[5].handlers.onClick = menu.buttonSelectSector
		else
			local row = objecttable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5 + maxicons):createText(menu.title, Helper.headerRowCenteredProperties)
		end

		-- owner
		if ffi.string(infoTableData.ownerDetails.factionIcon) ~= "" then
			local locsectorname = ffi.string(infoTableData.ownerDetails.factionName)
			if C.IsContestedSector(menu.currentsector) then
				locsectorname = locsectorname .. " " .. ReadText(1001, 3247)
			end

			local row = objecttable:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
			local sector64 = ConvertStringTo64Bit(tostring(menu.currentsector))
			row[1]:createIcon(function () return GetComponentData(sector64, "ownericon") end)
			row[2]:setColSpan(4 + maxicons):createText(locsectorname)
		end
	end

	-- object section
	infoTableData.playerStations = { }
	infoTableData.npcStations = { }
	infoTableData.moduledata = { }
	infoTableData.playerShips = { }
	infoTableData.npcShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }
	infoTableData.fleetUnitData = { }
	infoTableData.fleetUnitSubordinates = { }
	infoTableData.fleetUnitReplacements = { }

	menu.updateRenderedComponents()
	local numdisplayed = 0
	local maxvisibleheight

	if not onlysectorallowed then
		for _, entry in ipairs(menu.renderedComponents) do
			local id = entry.id
			local convertedID = ConvertStringToLuaID(tostring(id))
			if menu.isObjectValid(id) then
				local primarypurpose, isplayerowned, isdeployable, isfleetlead, isdocked = GetComponentData(convertedID, "primarypurpose", "isplayerowned", "isdeployable", "isfleetlead", "isdocked")
				if menu.mode == "selectCV" then
					if C.IsComponentClass(id, "ship") and (primarypurpose == "build") then
						if isplayerowned then
							table.insert(infoTableData.playerShips, convertedID)
						else
							table.insert(infoTableData.npcShips, convertedID)
						end
					end
				else

					if isdeployable or C.IsComponentClass(id, "lockbox") or (C.IsComponentClass(id, "collectablewares") and ((id == menu.softtarget) or menu.isSelectedComponent(id))) then
						table.insert(infoTableData.deployables, convertedID)
					elseif C.IsComponentClass(id, "ship") or C.IsRealComponentClass(id, "station") then
						if isfleetlead then
							-- get all fleet unit subordinate data here once instead of doing recursion
							menu.getFleetUnitSubordinates(instance, id, true)
						end

						-- Determine subordinates that may appear in the menu
						infoTableData.subordinates[tostring(convertedID)] = menu.getSubordinates(convertedID, true)

						local dockedships = {}
						if C.IsComponentClass(id, "container") then
							Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, id, nil)
						end
						for i = #dockedships, 1, -1 do
							local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
							local commander = GetCommander(convertedID)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								dockedships[i] = { component = convertedID }
							else
								table.remove(dockedships, i)
							end
						end
						infoTableData.dockedships[tostring(convertedID)] = dockedships

						if C.IsComponentClass(id, "ship") then
							local commander = GetCommander(convertedID)
							local dockcontainer = C.GetContextByClass(id, "container", false)
							if (not commander) or (not menu.renderedComponentsRef[ConvertIDTo64Bit(commander)]) then
								if (not isdocked) or (not menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(dockcontainer))]) then
									if isplayerowned then
										table.insert(infoTableData.playerShips, convertedID)
									else
										table.insert(infoTableData.npcShips, convertedID)
									end
								end
							end
						elseif C.IsRealComponentClass(id, "station") then
							local isplayerowned = isplayerowned
							if isplayerowned then
								table.insert(infoTableData.playerStations, convertedID)
							else
								table.insert(infoTableData.npcStations, convertedID)
							end

							local constructions = {}
							local constructionshipsbymacro = {}
							-- builds in progress
							local n = C.GetNumBuildTasks(id, 0, true, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, true, false)
							for i = 0, n - 1 do
								table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
							end
							if #constructions > 0 then
								table.insert(constructions, { empty = true })
							end
							-- other builds
							local n = C.GetNumBuildTasks(id, 0, false, false)
							local buf = ffi.new("BuildTaskInfo[?]", n)
							n = C.GetBuildTasks(buf, n, id, 0, false, false)
							for i = 0, n - 1 do
								local component = buf[i].component
								local macro = ffi.string(buf[i].macro)
								if (component == 0) and (macro ~= "") then
									if constructionshipsbymacro[macro] then
										constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
										table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
									else
										table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
										constructionshipsbymacro[macro] = #constructions
									end
								else
									table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
								end
							end
							infoTableData.constructions[tostring(convertedID)] = constructions
						end
					elseif C.IsComponentClass(id, "buildstorage") then
						local isplayerowned = isplayerowned
						if isplayerowned then
							table.insert(infoTableData.playerStations, convertedID)
						else
							table.insert(infoTableData.npcStations, convertedID)
						end
					end
				end
			end
		end

		maxvisibleheight = objecttable:getFullHeight()
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "ownedstations", objecttable, ReadText(1001, 3276), infoTableData.playerStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "ownedships", objecttable, ReadText(1001, 8301), infoTableData.playerShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if (menu.objectMode == "stations") or (menu.objectMode == "objectall") then
				numdisplayed = menu.createPropertySection(instance, "npcstations", objecttable, ReadText(1001,8302), infoTableData.npcStations, "-- " .. ReadText(1001, 33) .. " --", true, numdisplayed, nil, menu.objectSorterType)
			end
		end
		if (menu.objectMode == "ships") or (menu.objectMode == "objectall") then
			numdisplayed = menu.createPropertySection(instance, "npcships", objecttable, ReadText(1001,8303), infoTableData.npcShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
		end
		if menu.mode ~= "selectCV" then
			if menu.objectMode == "deployables" then
				numdisplayed = menu.createPropertySection(instance, "deployables", objecttable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.objectSorterType)
			end
		end
	end

	if numdisplayed > 50 then
		objecttable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = objecttable.numfixedrows

	if menu.selectedRows["objectlist"] then
		objecttable:setSelectedRow(menu.selectedRows["objectlist"])
		menu.selectedRows["objectlist"] = nil
		if menu.topRows["objectlist"] then
			objecttable:setTopRow(menu.topRows["objectlist"])
			menu.topRows["objectlist"] = nil
		end
		if menu.selectedCols["objectlist"] then
			objecttable:setSelectedCol(menu.selectedCols["objectlist"])
			menu.selectedCols["objectlist"] = nil
		end
	else
		menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 21) and (menu.setrow - 17) or 3) or menu.settoprow
		objecttable:setTopRow(menu.settoprow)
		local highlightborderrow = menu.sethighlightborderrow or menu.setrow
		if menu.infoTable then
			local result = GetShiftStartEndRow(menu.infoTable)
			if result then
				if highlightborderrow then
					local shiftstart, shiftend = table.unpack(result)
					local ismultiselected = objecttable.rows[highlightborderrow] and objecttable.rows[highlightborderrow].properties.multiSelected
					if (not ismultiselected) or (((not shiftstart) or (shiftstart <= highlightborderrow)) and ((not shiftend) or (shiftend >= highlightborderrow))) then
						objecttable:setShiftStartEnd(table.unpack(result))
					end
				end
			end
		end
		objecttable:setSelectedRow(highlightborderrow)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- object list categories row
		local row = tabtable:addRow("property_tabs", { fixed = true })
		local rowCount = 1
		if #config.objectCategories > 0 then
			for i, entry in ipairs(config.objectCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true })
					rowCount = rowCount + 1
				end
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if entry.category == menu.objectMode then
					bgcolor = Color["row_background_selected"]
				end
				local active = true
				if menu.mode == "selectCV" then
					active = entry.category == "objectall"
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonObjectSubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.objectSorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.objectSorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.objectSorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("hull") end
		-- "relation"
		local row = tabtable:addRow(true, { fixed = true })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 7749), { halign = "center", scaling = true })
		if menu.objectSorterType == "relation" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.objectSorterType == "relationinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonObjectSorter("relation") end
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	objecttable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	menu.playerinfotable:addConnection(1, 2, true)
	tabtable:addConnection(2, 2)
	objecttable:addConnection(3, 2)
end

-- Property Owned

function menu.createPropertyOwned(frame, instance)
	-- kuertee start: callback
	if menu.uix_callbacks ["createPropertyOwned_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyOwned_on_start"]) do
			uix_callback (config)
		end
	end
	-- kuertee end: callback

	local infoTableData = menu.infoTableData[instance]

	-- TODO: Move to config table?
	infoTableData.maxIcons = 5
	infoTableData.shipIconWidth = menu.getShipIconWidth()
	local maxicons = infoTableData.maxIcons

	local ftable = frame:addTable(5 + maxicons, { tabOrder = 1, multiSelect = true })
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	--  [+/-] [Object Name][Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N] [Shield/Hull Bar]
	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setDefaultBackgroundColSpan(2, 4 + maxicons)
	ftable:setColWidthMinPercent(2, 14)
	ftable:setColWidthMinPercent(4, 5)
	for i = 1, maxicons do
		ftable:setColWidth(5 + i - 1, infoTableData.shipIconWidth, false)
	end
	ftable:setColWidth(5 + maxicons, infoTableData.shipIconWidth, false)

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(5 + maxicons):createText(ReadText(1001, 1000), Helper.headerRowCenteredProperties)

	infoTableData.stations = { }
	infoTableData.fleetLeaderShips = { }
	infoTableData.unassignedShips = { }
	infoTableData.constructionShips = { }
	infoTableData.inventoryShips = { }
	infoTableData.deployables = { }
	infoTableData.subordinates = { }
	infoTableData.dockedships = { }
	infoTableData.constructions = { }
	infoTableData.fleetUnitData = { }
	infoTableData.fleetUnitSubordinates = { }
	infoTableData.fleetUnitReplacements = { }
	infoTableData.moduledata = { }

	-- kuertee start: callback
	if menu.uix_callbacks ["createPropertyOwned_on_init_infoTableData"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyOwned_on_init_infoTableData"]) do
			uix_callback (infoTableData)
		end
	end
	-- kuertee end: callback

	local onlineitems = {}
	if menu.propertyMode == "inventoryships" then
		onlineitems = OnlineGetUserItems()

		-- kuertee start:
		if not onlineitems then
			onlineitems = {}
		end
		-- kuertee end

	end

	local playerobjects = {}
	if Helper.isPlayerCovered() and (not C.IsUICoverOverridden()) then
		playerobjects[1] = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	else
		playerobjects = GetContainedObjectsByOwner("player")
	end
	for i = #playerobjects, 1, -1 do
		local object = playerobjects[i]
		local object64 = ConvertIDTo64Bit(object)
		if menu.isObjectValid(object64) then
			local hull, purpose, uirelation, sector = GetComponentData(object, "hullpercent", "primarypurpose", "uirelation", "sector")
			playerobjects[i] = { id = object, name = ffi.string(C.GetComponentName(object64)), fleetname = menu.getFleetName(object64), objectid = ffi.string(C.GetObjectIDCode(object64)), class = ffi.string(C.GetComponentClass(object64)), hull = hull, purpose = purpose, relation = uirelation, sector = sector }
		else
			table.remove(playerobjects, i)
		end
	end

	table.sort(playerobjects, menu.componentSorter(menu.propertySorterType))

	for _, entry in ipairs(playerobjects) do
		local object = entry.id
		local object64 = ConvertIDTo64Bit(object)

		local basestation, isdeployable, assignedpilot, isfleetlead = GetComponentData(object, "basestation", "isdeployable", "assignedpilot", "isfleetlead")
		if isfleetlead then
			-- get all fleet unit subordinate data here once instead of doing recursion
			menu.getFleetUnitSubordinates(instance, object64, false)
		end
		-- Determine subordinates that may appear in the menu
		local subordinates = menu.getSubordinates(object, false)
		infoTableData.subordinates[tostring(object)] = subordinates
		-- Find docked ships
		local dockedships = {}
		if C.IsComponentClass(object64, "container") then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, object64, nil)
		end
		for i = #dockedships, 1, -1 do
			local convertedID = ConvertStringToLuaID(tostring(dockedships[i]))
			local loccommander = GetCommander(convertedID)
			if not loccommander then
				dockedships[i] = { component = convertedID }
			else
				table.remove(dockedships, i)
			end
		end
		infoTableData.dockedships[tostring(object)] = dockedships
		-- Check if object is station, fleet leader or unassigned
		local commander
		if C.IsComponentClass(object64, "controllable") then
			commander = GetCommander(object)
		end
		if not commander then
			if C.IsRealComponentClass(object64, "station") then
				table.insert(infoTableData.stations, object)
			elseif C.IsComponentClass(object64, "buildstorage") then
				if not basestation then
					table.insert(infoTableData.stations, object)
				end
			elseif isdeployable or C.IsComponentClass(object64, "lockbox") or C.IsComponentClass(object64, "collectablewares") then
				table.insert(infoTableData.deployables, object)
			elseif #subordinates > 0 then
				table.insert(infoTableData.fleetLeaderShips, object)
			else
				table.insert(infoTableData.unassignedShips, object)
			end
		end

		if C.IsRealComponentClass(object64, "station") then
			local constructions = {}
			local constructionshipsbymacro = {}
			-- builds in progress
			local n = C.GetNumBuildTasks(object64, 0, true, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, true, false)
			for i = 0, n - 1 do
				table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
			end
			if #constructions > 0 then
				table.insert(constructions, { empty = true })
			end
			-- other builds
			local n = C.GetNumBuildTasks(object64, 0, false, false)
			local buf = ffi.new("BuildTaskInfo[?]", n)
			n = C.GetBuildTasks(buf, n, object64, 0, false, false)
			for i = 0, n - 1 do
				local component = buf[i].component
				local macro = ffi.string(buf[i].macro)
				if (component == 0) and (macro ~= "") then
					if constructionshipsbymacro[macro] then
						constructions[constructionshipsbymacro[macro]].amount = constructions[constructionshipsbymacro[macro]].amount + 1
						table.insert(constructions[constructionshipsbymacro[macro]].ids, buf[i].id)
					else
						table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
						constructionshipsbymacro[macro] = #constructions
					end
				else
					table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
				end
			end
			infoTableData.constructions[tostring(object)] = constructions
		elseif C.IsComponentClass(object64, "ship") then
			if menu.propertyMode == "inventoryships" then
				local pilot = ConvertIDTo64Bit(assignedpilot)
				if pilot and (pilot ~= C.GetPlayerID()) then
					local inventory = GetInventory(pilot)
					if next(inventory) then
						local sortedWares = {}
						for ware, entry in pairs(inventory) do
							local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
							if (not ispersonalupgrade) and (not onlineitems[ware]) then
								table.insert(infoTableData.inventoryShips, object)
								break
							end
						end
					end
				end
			end

			-- kuertee start: callback
			if menu.uix_callbacks ["createPropertyOwned_on_add_ship_infoTableData"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyOwned_on_add_ship_infoTableData"]) do
					uix_callback (infoTableData, object)
				end
			end
			-- kuertee end: callback

		end
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyOwned_on_add_other_objects_infoTableData"]) do
			result = uix_callback (infoTableData)
			if result then
				infoTableData = result.infoTableData
			end
		end
	end
	-- kuertee end: callback

	local constructionshipsbymacro = {}
	local n = C.GetNumPlayerShipBuildTasks(true, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, true, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
		end
	end
	if #infoTableData.constructionShips > 0 then
		table.insert(infoTableData.constructionShips, { empty = true })
	end
	local n = C.GetNumPlayerShipBuildTasks(false, false)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetPlayerShipBuildTasks(buf, n, false, false)
	for i = 0, n - 1 do
		local factionid = ffi.string(buf[i].factionid)
		if factionid == "player" then
			local component = buf[i].component
			local macro = ffi.string(buf[i].macro)
			if (component == 0) and (macro ~= "") then
				if constructionshipsbymacro[macro] then
					infoTableData.constructionShips[constructionshipsbymacro[macro]].amount = infoTableData.constructionShips[constructionshipsbymacro[macro]].amount + 1
					table.insert(infoTableData.constructionShips[constructionshipsbymacro[macro]].ids, buf[i].id)
				else
					table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false, amount = 1, ids = { buf[i].id } })
					constructionshipsbymacro[macro] = #infoTableData.constructionShips
				end
			else
				table.insert(infoTableData.constructionShips, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = component, macro = macro, factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = false })
			end
		end
	end

	local numdisplayed = 0
	local maxvisibleheight = ftable:getFullHeight()
	if menu.mode ~= "selectCV" then
		if (menu.propertyMode == "stations") or (menu.propertyMode == "propertyall") then
			numdisplayed = menu.createPropertySection(instance, "ownedstations", ftable, ReadText(1001, 8379), infoTableData.stations, "-- " .. ReadText(1001, 33) .. " --", menu.mode ~= "hire", numdisplayed, nil, menu.propertySorterType)
		end
	end
	if (menu.propertyMode == "fleets") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedfleets", ftable, ReadText(1001, 8326), infoTableData.fleetLeaderShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)			-- {1001,8326} = Fleets
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		numdisplayed = menu.createPropertySection(instance, "ownedships", ftable, ReadText(1001, 8327), infoTableData.unassignedShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)	-- {1001,8327} = Unassigned Ships
	end
	if menu.propertyMode == "inventoryships" then
		numdisplayed = menu.createPropertySection(instance, "inventoryships", ftable, ReadText(1001, 8381), infoTableData.inventoryShips, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, true, menu.propertySorterType)	-- {1001,8327} = Ships with Inventory
	end
	if (menu.propertyMode == "unassignedships") or (menu.propertyMode == "propertyall") then
		-- construction rows do not use the shield/hull bar widget
		menu.createConstructionSection(instance, "constructionships", ftable, ReadText(1001, 8328), infoTableData.constructionShips)
	end
	if menu.mode ~= "selectCV" then
		if menu.propertyMode == "deployables" then
			numdisplayed = menu.createPropertySection(instance, "owneddeployables", ftable, ReadText(1001, 1332), infoTableData.deployables, "-- " .. ReadText(1001, 34) .. " --", nil, numdisplayed, nil, menu.propertySorterType)
		end
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"] then
		local result
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyOwned_on_createPropertySection_unassignedships"]) do
			result = uix_callback (numdisplayed, instance, ftable, infoTableData)
			if result and result.numdisplayed > numdisplayed then
				numdisplayed = result.numdisplayed
			end
		end
	end
	-- kuertee end: callback

	if numdisplayed > 50 then
		ftable.properties.maxVisibleHeight = maxvisibleheight + 50 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
	end

	menu.numFixedRows = ftable.numfixedrows

	if menu.selectedRows["propertyowned"] then
		ftable:setSelectedRow(menu.selectedRows["propertyowned"])
		menu.selectedRows["propertyowned"] = nil
		if menu.topRows["propertyowned"] then
			ftable:setTopRow(menu.topRows["propertyowned"])
			menu.topRows["propertyowned"] = nil
		end
		if menu.selectedCols["propertyowned"] then
			ftable:setSelectedCol(menu.selectedCols["propertyowned"])
			menu.selectedCols["propertyowned"] = nil
		end
	else
		menu.settoprow = ((not menu.settoprow) or (menu.settoprow == 0)) and ((menu.setrow and menu.setrow > 21) and (menu.setrow - 17) or 3) or menu.settoprow
		ftable:setTopRow(menu.settoprow)
		local highlightborderrow = menu.sethighlightborderrow or menu.setrow
		if menu.infoTable then
			local result = GetShiftStartEndRow(menu.infoTable)
			if result then
				if highlightborderrow then
					local shiftstart, shiftend = table.unpack(result)
					local ismultiselected = ftable.rows[highlightborderrow] and ftable.rows[highlightborderrow].properties.multiSelected
					if (not ismultiselected) or (((not shiftstart) or (shiftstart <= highlightborderrow)) and ((not shiftend) or (shiftend >= highlightborderrow))) then
						ftable:setShiftStartEnd(shiftstart, shiftend)
					end
				end
			end
		end
		ftable:setSelectedRow(highlightborderrow)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil
	menu.sethighlightborderrow = nil

	local tabtable
	local maxNumCategoryColumns =  math.floor(menu.infoTableWidth / (menu.sideBarWidth + Helper.borderSize))
	if maxNumCategoryColumns > Helper.maxTableCols then
		maxNumCategoryColumns = Helper.maxTableCols
	end
	local numOfSorterColumns = 4 -- "sort by", "size", "name", "hull"
	local colSpanPerSorterColumn = math.floor(maxNumCategoryColumns / numOfSorterColumns)
	tabtable = frame:addTable(maxNumCategoryColumns, { tabOrder = 2, reserveScrollBar = false })
	if maxNumCategoryColumns > 0 then
		for i = 1, maxNumCategoryColumns do
			tabtable:setColWidth(i, menu.sideBarWidth, false)
		end
		local diff = menu.infoTableWidth - maxNumCategoryColumns * (menu.sideBarWidth + Helper.borderSize)
		tabtable:setColWidth(maxNumCategoryColumns, menu.sideBarWidth + diff, false)
		-- product categories row
		local row = tabtable:addRow("property_tabs", { fixed = true })
		local rowCount = 1
		if #config.propertyCategories > 0 then
			for i, entry in ipairs(config.propertyCategories) do
				if i / maxNumCategoryColumns > rowCount then
					row = tabtable:addRow("property_tabs", { fixed = true })
					rowCount = rowCount + 1
				end
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if entry.category == menu.propertyMode then
					bgcolor = Color["row_background_selected"]
				end
				local active = true
				if menu.mode == "hire" then
					active = entry.category ~= "deployables"
				elseif menu.mode == "selectCV" then
					active = entry.category == "propertyall"
                    -- start: mycu callback
                    if menu.uix_callbacks ["onSetActiveStateForCVMode_on_createPropertyOwned"] then
                        for uix_id, uix_callback in pairs (menu.uix_callbacks ["onSetActiveStateForCVMode_on_createPropertyOwned"]) do
                            active = uix_callback (entry)
                        end
                    end
                    -- end: mycu callback
				elseif (menu.mode == "selectComponent") and (menu.modeparam[3] == "deployables") then
					active = entry.category == "deployables"
					if active and (menu.selectedCols.propertytabs == nil) then
						menu.selectedCols.propertytabs = i
					end
				end
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns]:createButton({ height = menu.sideBarWidth, width = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText, active = active }):setIcon(entry.icon, { color = color})
				row[i - math.floor((i - 1) / maxNumCategoryColumns) * maxNumCategoryColumns].handlers.onClick = function () return menu.buttonPropertySubMode(entry.category, i) end
			end
		end
		local row = tabtable:addRow(true, { fixed = true })
		-- sorter row
		-- "sort by"
		row[1]:setColSpan(colSpanPerSorterColumn):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		local buttonheight = Helper.scaleY(config.mapRowHeight)
		-- "size"
		local sorterColumn = 2
		local tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 8026), { halign = "center", scaling = true })
		if menu.propertySorterType == "class" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "classinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("class") end
		-- "name"
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 2809), { halign = "center", scaling = true })
		if menu.propertySorterType == "name" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "nameinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("name") end
		-- "hull"
		sorterColumn = 4
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 1), { halign = "center", scaling = true })
		if menu.propertySorterType == "hull" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "hullinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("hull") end
		-- "sector"
		local row = tabtable:addRow(true, { fixed = true })
		sorterColumn = 2
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(ReadText(1001, 11284), { halign = "center", scaling = true })
		if menu.propertySorterType == "sector" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "sectorinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("sector") end

		--kuertee start: add distance sorters
		-- "distance from player"
		local buttonLabel = ffi.string (C.GetPlayerName ())
		sorterColumn = 3
		tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
		local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
		if menu.propertySorterType == "distance_from_player" then
			button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		elseif menu.propertySorterType == "distance_from_playerinverse" then
			button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
		end
		row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_player") end
		-- "distance from object"
		if menu.infoSubmenuObject then
			buttonLabel = ffi.string (C.GetObjectIDCode (menu.infoSubmenuObject))
			if buttonLabel == "" then
				buttonLabel = ffi.string (C.GetComponentName (menu.infoSubmenuObject))
			end
			sorterColumn = 4
			tableColumn = (sorterColumn - 1) * colSpanPerSorterColumn + 1
			local button = row[tableColumn]:setColSpan(colSpanPerSorterColumn):createButton({ scaling = false, height = buttonheight }):setText(buttonLabel, { halign = "center", scaling = true })
			if menu.propertySorterType == "distance_from_object" then
				button:setIcon("table_arrow_inv_down", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			elseif menu.propertySorterType == "distance_from_objectinverse" then
				button:setIcon("table_arrow_inv_up", { width = buttonheight, height = buttonheight, x = button:getColSpanWidth() - buttonheight })
			end
			row[tableColumn].handlers.onClick = function () return menu.buttonPropertySorter("distance_from_object") end
		end
		--kuertee end: add distance sorters
	end

	tabtable:setSelectedRow(menu.selectedRows.propertytabs or menu.selectedRows.infotable2 or 0)
	tabtable:setSelectedCol(menu.selectedCols.propertytabs or Helper.currentTableCol[menu.infoTable2] or 0)
	menu.selectedRows.propertytabs = nil
	menu.selectedCols.propertytabs = nil

	ftable.properties.y = tabtable.properties.y + tabtable:getFullHeight() + Helper.borderSize

	menu.playerinfotable:addConnection(1, 2, true)
	tabtable:addConnection(2, 2)
	ftable:addConnection(3, 2)
end

function menu.createPropertySection(instance, id, ftable, name, array, nonetext, showmodules, numdisplayed, hidesubordinates, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

	if id == menu.highlightedbordersection then
		menu.sethighlightborderrow = row.index + 1
	end

	local prevnumdisplayed = numdisplayed
	if #array > 0 then
		for _, component in ipairs(array) do
			numdisplayed = menu.createPropertyRow(instance, ftable, component, 0, nil, showmodules, hidesubordinates, numdisplayed, sorter)
		end
	end
	if numdisplayed == prevnumdisplayed then
		row = ftable:addRow(id, { interactive = false })
		row[2]:setColSpan(4 + maxicons):createText(nonetext)
	end

	return numdisplayed
end

function menu.getOrderInfo(ship, gettargetname)
	local isplayerowned, assignment, assignedpilot = GetComponentData(ship, "isplayerowned", "assignment", "assignedpilot")
	if not isplayerowned then
		return "", "", nil, "", false, nil, "", "", ""
	end

	local waiticon = ""
	local orderdefinition = ffi.new("OrderDefinition")
	if C.GetOrderDefinition(orderdefinition, "Wait") then
		waiticon = ffi.string(orderdefinition.icon)
	end

	local orders, defaultorder = {}, {}
	local n = C.GetNumOrders(ship)
	local buf = ffi.new("Order2[?]", n)
	n = C.GetOrders2(buf, n, ship)
	for i = 0, n - 1 do
		local order = {}
		order.state = ffi.string(buf[i].state)
		order.statename = ffi.string(buf[i].statename)
		order.orderdef = ffi.string(buf[i].orderdef)
		order.actualparams = tonumber(buf[i].actualparams)
		order.enabled = buf[i].enabled
		order.isinfinite = buf[i].isinfinite
		order.issyncpointreached = buf[i].issyncpointreached
		order.istemporder = buf[i].istemporder
		order.isoverride = buf[i].isoverride

		local orderdefinition = ffi.new("OrderDefinition")
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			order.orderdef = {}
			order.orderdef.id = ffi.string(orderdefinition.id)
			order.orderdef.icon = ffi.string(orderdefinition.icon)
			order.orderdef.name = ffi.string(orderdefinition.name)
			order.orderdef.description = ffi.string(orderdefinition.description)
		else
			order.orderdef = { id = "", icon = "", name = "", description = "" }
		end

		table.insert(orders, order)
	end

	local hasrealorders = false
	for _, order in ipairs(orders) do
		if order.enabled and (not order.istemporder) then
			hasrealorders = true
			break
		end
	end

	local buf = ffi.new("Order")
	if C.GetDefaultOrder(buf, ship) then
		defaultorder.state = ffi.string(buf.state)
		defaultorder.statename = ffi.string(buf.statename)
		defaultorder.orderdef = ffi.string(buf.orderdef)
		defaultorder.actualparams = tonumber(buf.actualparams)
		defaultorder.enabled = buf.enabled
		defaultorder.issyncpointreached = buf.issyncpointreached
		defaultorder.istemporder = buf.istemporder

		local orderdefinition = ffi.new("OrderDefinition")
		if defaultorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, defaultorder.orderdef) then
			defaultorder.orderdef = {}
			defaultorder.orderdef.id = ffi.string(orderdefinition.id)
			defaultorder.orderdef.icon = ffi.string(orderdefinition.icon)
			defaultorder.orderdef.name = ffi.string(orderdefinition.name)
			defaultorder.orderdef.description = ffi.string(orderdefinition.description)
		else
			defaultorder.orderdef = { id = "", icon = "", name = "", description = "" }
		end
	end

	local icon, name, description, color, isoverride, mouseovertext, targetname, behaviouricon, behaviourname, behaviourdescription = "", "", "", nil, false, nil, "", "", "", ""
	if #orders > 0 then
		-- there is an order
		local curindex = tonumber(C.GetOrderQueueCurrentIdx(ship))
		local order = orders[curindex]
		name = order.orderdef.name
		description = order.orderdef.description
		icon = order.orderdef.icon
		isoverride = order.isoverride
		-- change icon to wait if the order is in the wait part
		if (order.orderdef.id == "MoveWait") or (order.orderdef.id == "MoveToObject") or (order.orderdef.id == "DockAndWait") then
			if order.issyncpointreached then
				icon = waiticon
			end
		end
		-- if all orders are temp they were spawned by a defaultorder
		if not hasrealorders then
			color = Color["order_temp"]
		end
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, curindex, false)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
		-- if there are normal orders also return information about the default order
		if next(defaultorder) then
			-- there is a defaultorder
			behaviourname = defaultorder.orderdef.name
			behaviourdescription = defaultorder.orderdef.description
			behaviouricon = defaultorder.orderdef.icon
			if (defaultorder.orderdef.id == "Wait") then
				-- do not show Wait default order
				behaviouricon = ""
			elseif (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
				if defaultorder.issyncpointreached then
					-- do not show these default orders if they reached the wait part
					behaviouricon = ""
				end
			elseif defaultorder.orderdef.id == "TradeRoutine" then
				local params = GetOrderParams(ship, "default")
				local overridewares = ""
				for i, entry in ipairs(params) do
					if entry.name == "warebasket_override" then
						local sortedwares = {}
						for _, ware in ipairs(entry.value) do
							table.insert(sortedwares, ware)
						end
						table.sort(sortedwares, Helper.sortWareName)

						for j, ware in ipairs(sortedwares) do
							if j == 1 then
								overridewares = overridewares .. "\n\n" .. ReadText(1001, 11651) .. ReadText(1001, 120)
							elseif j > 5 then
								overridewares = overridewares .. "\n· " .. ((#entry.value == 6) and GetWareData(ware, "name") or string.format(ReadText(1001, 11633), #entry.value - 5))
								break
							end
							overridewares = overridewares .. "\n· " .. GetWareData(ware, "name")
						end
						break
					end
				end

				behaviourdescription = behaviourdescription .. overridewares
			end
		end
	elseif next(defaultorder) then
		-- there is a defaultorder
		name = defaultorder.orderdef.name
		description = defaultorder.orderdef.description
		icon = defaultorder.orderdef.icon
		-- change icon to wait if the order is in the wait part
		if (defaultorder.orderdef.id == "MoveWait") or (defaultorder.orderdef.id == "MoveToObject") or (defaultorder.orderdef.id == "DockAndWait") then
			if defaultorder.issyncpointreached then
				icon = waiticon
			end
		elseif defaultorder.orderdef.id == "TradeRoutine" then
			local params = GetOrderParams(ship, "default")
			local overridewares = ""
			for i, entry in ipairs(params) do
				if entry.name == "warebasket_override" then
					local sortedwares = {}
					for _, ware in ipairs(entry.value) do
						table.insert(sortedwares, ware)
					end
					table.sort(sortedwares, Helper.sortWareName)

					for j, ware in ipairs(sortedwares) do
						if j == 1 then
							overridewares = overridewares .. "\n\n" .. ReadText(1001, 11651) .. ReadText(1001, 120)
						elseif j > 5 then
							overridewares = overridewares .. "\n· " .. ((#entry.value == 6) and GetWareData(ware, "name") or string.format(ReadText(1001, 11633), #entry.value - 5))
							break
						end
						overridewares = overridewares .. "\n· " .. GetWareData(ware, "name")
					end
					break
				end
			end

			description = description .. overridewares
		end
		color = Color["order_temp"]
		if gettargetname then
			local targets = {}
			Helper.ffiVLA(targets, "UniverseID", C.GetNumOrderLocationData, C.GetOrderLocationData, ship, 0, true)
			if #targets == 1 then
				local target = targets[1]
				targetname = ffi.string(C.GetComponentName(target))
				if C.IsComponentClass(target, "ship") then
					targetname = targetname .. " (" .. ffi.string(C.GetObjectIDCode(target)) .. ")"
				end
			elseif #targets > 0 then
				targetname = ReadText(1001, 3424)
			end
		end
	end

	if assignedpilot and (assignment == "assist") then
		-- if the ship is trying to mimic, but failed, mark the icon red
		local aicommandactionraw = GetComponentData(assignedpilot, "aicommandactionraw")
		if aicommandactionraw == "orderfailed" then
			color = Color["text_failure"]
			mouseovertext = ReadText(1026, 3268)
		end
	elseif C.HasControllableAnyOrderFailures(ship) then
		-- if the ship had any order failure, mark the icon orange
		color = Color["text_warning"]
	end

	local texticon = ""
	if icon ~= "" then
		texticon = (color and Helper.convertColorToText(color) or "") .. "\27[" .. icon .. "]\27X"
	end
	local behaviourtexticon = ""
	if behaviouricon ~= "" then
		behaviourtexticon = ColorText["order_temp"] .. "\27[" .. behaviouricon .. "]\27X"
	end
	return texticon, icon, color, name, description, isoverride, mouseovertext, targetname, behaviourtexticon, behaviouricon, behaviourname, behaviourdescription
end

function menu.overrideOrderIcon(normalcolor, usetext, icon, prefix, postfix)
	-- number between 0 and 1, duration 1s
	local x = getElapsedTime() % 1

	normalcolor = normalcolor or Color["icon_normal"]
	overridecolor = Color["order_override"]
	local color = {
		r = (1 - x) * overridecolor.r + x * normalcolor.r,
		g = (1 - x) * overridecolor.g + x * normalcolor.g,
		b = (1 - x) * overridecolor.b + x * normalcolor.b,
		a = (1 - x) * overridecolor.a + x * normalcolor.a,
	}
	if usetext then
		local colortext = Helper.convertColorToText(color) .. "\27[" .. icon .. "]\27X"
		return prefix .. colortext .. postfix
	else
		return color
	end
end

function menu.moduleSorter(a, b)
	if a.rawname == b.rawname then
		return a.index < b.index
	end
	return a.rawname < b.rawname
end

function menu.getModuleData(object64)
	local delimiter = ReadText(20005, 8003)
	local matchstring = "(.*) " .. delimiter .. "(%d+)"

	local modules = {}
	local modulesByID = {}
	local n = C.GetNumStationModules(object64, false, false)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, object64, false, false)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		local type = GetModuleType(module)
		local name = ffi.string(C.GetComponentName(module))
		local rawname, index = utf8.match(name, matchstring)

		modulesByID[tostring(module)] = true
		if modules[type] then
			table.insert(modules[type], { module = module, name = name, rawname = rawname or name, index = index and tonumber(index) or 0 })
		else
			modules[type] = { { module = module, name = name, rawname = rawname or name, index = index and tonumber(index) or 0 } }
		end
	end
	local n = C.GetNumPlannedStationModules(object64, false)
	local buf = ffi.new("UIConstructionPlanEntry[?]", n)
	n = C.GetPlannedStationModules(buf, n, object64, false)
	for i = 0, tonumber(n) - 1 do
		local module, type, name, rawname, index
		if buf[i].componentid ~= 0 then
			module = ConvertStringTo64Bit(tostring(buf[i].componentid))
			type = GetModuleType(module)
			name = ffi.string(C.GetComponentName(module))
			rawname, index = utf8.match(name, matchstring)

			if modulesByID[tostring(module)] then
				module = nil
				type = nil
			end
		else
			module = ffi.string(buf[i].macroid)
			type = GetModuleType(nil, module)
			name = GetMacroData(module, "name")
		end
		if module then
			if modules[type] then
				table.insert(modules[type], { module = module, name = name, rawname = rawname or name, index = index and tonumber(index) or 0 })
			else
				modules[type] = { { module = module, name = name, rawname = rawname or name, index = index and tonumber(index) or 0 } }
			end
		end
	end

	for _, modules in pairs(modules) do
		table.sort(modules, menu.moduleSorter)
	end

	return modules
end

function menu.createPropertyRow(instance, ftable, component, iteration, commanderlocation, showmodules, hidesubordinates, numdisplayed, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)] or {}
	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local constructions = menu.infoTableData[instance].constructions[tostring(component)] or {}
	local replacedfleetunits = menu.infoTableData[instance].fleetUnitReplacements[tostring(component)]
	local convertedComponent = ConvertStringTo64Bit(tostring(component))

	-- kuertee start: callback
	if menu.uix_callbacks ["createPropertyRow_on_init_vars"] then
		local result
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyRow_on_init_vars"]) do
			result = uix_callback (maxicons, subordinates, dockedships, constructions, convertedComponent, iteration)
			if result then
				maxicons = result.maxicons
				subordinates = result.subordinates
				dockedships = result.dockedships
				constructions = result.constructions
				convertedComponent = result.convertedComponent
				iteration = result.iteration
			end
		end
	end
	-- kuertee end: callback

	if (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(convertedComponent, numtexts, texts, true) end, "text") then
		if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(convertedComponent)) then
			return numdisplayed
		elseif (menu.mode == "selectComponent") and (not menu.checkForSelectComponent(convertedComponent)) then
			return numdisplayed
		end

		numdisplayed = numdisplayed + 1

		if (not menu.isPropertyExtended(tostring(component))) and (menu.isCommander(convertedComponent, 0) or menu.isConstructionContext(convertedComponent)) then
			menu.extendedproperty[tostring(component)] = true
		end
		if (not menu.isPropertyExtended(tostring(component))) and menu.isDockContext(convertedComponent) then

			-- if menu.infoTableMode ~= "propertyowned" then
			-- kuertee start: callback
			if not string.find (menu.infoTableMode, "propertyowned") then
				-- kuertee end: callback

				menu.extendedproperty[tostring(component)] = true
			end
		end

		-- check whether all subordinates are actually fleetunit subordinates
		local subordinatefound = false
		for _, subordinate in ipairs(subordinates) do
			if (subordinate.component and (menu.infoTableData[instance].fleetUnitSubordinates[tostring(subordinate.component)] ~= true)) or subordinate.fleetunit then
				subordinatefound = true
				break
			end
		end

		local isstation = C.IsRealComponentClass(convertedComponent, "station")
		local isdoublerow = (iteration == 0 and (isstation or #subordinates > 0))
		local name, color, bgcolor, font, mouseover, factioncolor = menu.getContainerNameAndColors(component, iteration, isdoublerow, false, true)
		local alertString = ""
		local alertMouseOver = ""
		if menu.getFilterOption("layer_other", false) then
			local alertStatus, missionlist = menu.getContainerAlertLevel(component)
			local minAlertLevel = menu.getFilterOption("think_alert", false)
			if (minAlertLevel ~= 0) and alertStatus >= minAlertLevel then
				local color = Color["text_normal"]
				if alertStatus == 1 then
					color = menu.holomapcolor.lowalertcolor
				elseif alertStatus == 2 then
					color = menu.holomapcolor.mediumalertcolor
				else
					color = menu.holomapcolor.highalertcolor
				end
				alertString = Helper.convertColorToText(color) .. "\027[workshop_error]\027X"
				alertMouseOver = ReadText(1001, 3305) .. ReadText(1001, 120) .. "\n" .. missionlist
			end
		end
		local location, locationtext, isdocked, aipilot, isplayerowned, isonlineobject, iscovered, isenemy, macro, isally = GetComponentData(component, "sectorid", "sector", "isdocked", "assignedaipilot", "isplayerowned", "isonlineobject", "iscovered", "isenemy", "macro", "isally")
		if isplayerowned and iscovered then
			alertString = alertString .. factioncolor .. "\27[menu_hidden]\27X"
		end

		if menu.mode == "selectCV" then
			if isenemy then
				mouseover = ColorText["text_error"] .. ReadText(1026, 8014) .. "\027X"
			elseif C.IsBuilderBusy(convertedComponent) then
				mouseover = ColorText["text_error"] .. ReadText(1001, 7939) .. "\027X"
			elseif not isplayerowned then
				local fee = tonumber(C.GetBuilderHiringFee())
				mouseover = ((fee > GetPlayerMoney()) and ColorText["text_error"] or ColorText["text_success"]) .. ReadText(1001, 7940) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101) .. "\027X"
			end
		end

		local row = ftable:addRow({"property", component, nil, iteration}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(component) })
		if (menu.getNumSelectedComponents() == 1) and menu.isSelectedComponent(component) then
			menu.setrow = row.index
		end
		if IsSameComponent(component, menu.highlightedbordercomponent) then
			menu.sethighlightborderrow = row.index
		end

		-- Set up columns
		--  [+/-] [Object Name] [Top Level Shield/Hull Bar] [Location] [Sub_1] [Sub_2] [Sub_3] ... [Sub_N or Shield/Hull Bar]
		local isconstruction = IsComponentConstruction(component)
		local isstationexpandable = showmodules and isstation and (not isconstruction)
		if showmodules and isstation and isconstruction then
			isstationexpandable = C.GetNumStationModules(convertedComponent, true, false) > 0
		end
		if isstationexpandable or (subordinates.hasRendered and (not hidesubordinates) and subordinatefound) or (#dockedships > 0) or (isstation and (#constructions > 0)) then
			row[1]:createButton({ scaling = false }):setText(menu.isPropertyExtended(tostring(component)) and "-" or "+", { scaling = true, halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendProperty(tostring(component)) end
		end

		local displaylocation = location and not (commanderlocation and IsSameComponent(location, commanderlocation))
		local currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = "", "", nil, "", "", false, nil, "", "", "", ""
		if IsComponentClass(component, "ship") then
			currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext, _, behaviouricon, behaviourrawicon, behaviourname, behaviourdescription = menu.getOrderInfo(convertedComponent)
		end
		local fleettypes = IsComponentClass(component, "controllable") and menu.getPropertyOwnedFleetData(instance, component, maxicons) or {}

		if isplayerowned and isonlineobject then
			locationtext = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. ReadText(1001, 11231) .. "\27X"
			currentordericon = Helper.convertColorToText(menu.holomapcolor.visitorcolor) .. "\27[order_venture]\27X"
			currentorderrawicon = "order_waitforventure"
			currentordercolor = menu.holomapcolor.visitorcolor
			currentordername = ReadText(1001, 7868)
			currentordermouseovertext = nil
			isdocked = false
		end

		-- kuertee start: callback
		if menu.uix_callbacks ["createPropertyRow_on_set_locationtext"] then
			local result
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyRow_on_set_locationtext"]) do
				result = uix_callback (locationtext, component)
				if result.locationtext then
					locationtext = result.locationtext
				end
			end
		end
		-- kuertee end: callback

		local namecolspan = 1
		if menu.infoTableMode == "objectlist" then
			displaylocation = false
		end
		if not displaylocation then
			if (currentordericon ~= "") or isdocked then
				namecolspan = namecolspan + maxicons - 3
			else
				namecolspan = namecolspan + maxicons
			end
		end

		if isdoublerow then
			if isstation then
				-- station case
				local secondline = ""
				if displaylocation then
					secondline = locationtext
				end
				row[2]:setColSpan(4 + maxicons - #fleettypes - 1)
				local stationname = alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				if isconstruction then
					stationname = stationname .. ColorText["text_inactive"] .. " (" .. ReadText(1001, 3217) .. ")\27X"
				end
				if alertMouseOver ~= "" then
					if mouseover ~= "" then
						mouseover = mouseover .. "\n\n"
					end
					mouseover = mouseover .. alertMouseOver
				end
				row[2]:createText(stationname .. "\n" .. secondline, { font = font, mouseOverText = mouseover })
			else
				-- fleet case
				local textheight = C.GetTextHeight(" \n ", font, Helper.scaleFont(font, config.mapFontSize), Helper.viewWidth)
				local icon = row[2]:setColSpan(4 + maxicons - #fleettypes - 1):createIcon("solid", { scaling = false, color = Color["icon_transparent"], height = textheight })

				local secondtext1 = ""
				local secondtext2 = ""
				if displaylocation or (currentordericon ~= "") or isdocked then
					if displaylocation then
						secondtext1 = locationtext
					end
					secondtext2 = (currentordericon ~= "") and currentordericon or ""
					if isdocked then
						secondtext2 = secondtext2 .. " \27[order_dockat]"
					end
					if behaviouricon ~= "" then
						secondtext2 = ColorText["order_temp"] .. behaviouricon .. "\27X" .. secondtext2
					end
				end
				local secondtext1truncated = TruncateText(secondtext1, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx))
				local secondtext1width = C.GetTextWidth(secondtext1truncated, font, Helper.scaleFont(font, config.mapFontSize))
				local secondtext2width = C.GetTextWidth(secondtext2, font, Helper.scaleFont(font, config.mapFontSize))

				local fleetname = ffi.string(C.GetFleetName(convertedComponent))
				local shipname = alertString .. name
				local fleetnametruncated = TruncateText(fleetname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext1width - Helper.scaleX(10))
				local shipnametruncated = TruncateText(shipname, font, Helper.scaleFont(font, config.mapFontSize), icon:getColSpanWidth() - Helper.scaleX(Helper.standardTextOffsetx) - secondtext2width - Helper.scaleX(10))

				local mouseovertext = ""
				if fleetnametruncated ~= fleetname then
					mouseovertext = mouseovertext .. fleetname
				end
				if shipnametruncated ~= shipname then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. alertString .. Helper.convertColorToText(color) .. name .. "\27X"
				end
				if secondtext1truncated ~= secondtext1 then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. secondtext1
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourname and behaviourname ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. behaviourname
				end
				-- skip adding when behaviouricon was ignored (case: behaviour == HoldPosition AND order ~= null)
				if behaviouricon ~= "" and behaviourdescription and behaviourdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(behaviourdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if currentordername ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. currentordername .. (currentordermouseovertext and ("\n" .. ColorText["text_error"] .. currentordermouseovertext .. "\27X") or "")
				end
				if currentorderdescription and currentorderdescription ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. Helper.indentText(currentorderdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont())
				end
				if isdocked then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ReadText(1001, 3249)
				end
				if alertMouseOver ~= "" then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n\n"
					end
					mouseovertext = mouseovertext .. alertMouseOver
				end
				icon.properties.mouseOverText = mouseovertext

				icon:setText(string.format("%s\n%s%s", fleetnametruncated, Helper.convertColorToText(color), shipnametruncated), { scaling = true, font = font, x = Helper.standardTextOffsetx })
				icon:setText2(currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, true, currentorderrawicon, secondtext1truncated .. "\n", isdocked and "\27[order_dockat]" or "") end or (secondtext1truncated .. "\n" .. secondtext2), { scaling = true, font = font, halign = "right", x = Helper.standardTextOffsetx })
			end
			-- fleet info
			for i, fleetdata in ipairs(fleettypes) do
				local colidx = 5 + maxicons - #fleettypes + i - 1
				if fleetdata.icon then
					if fleetdata.count then
						row[colidx]:createText(string.format("\027[%s]\n%d", fleetdata.icon, fleetdata.count), { halign = "center", x = 0, color = fleetdata.color })
					else
						row[colidx]:createText(string.format("\027[%s]\n ", fleetdata.icon), { halign = "center", x = 0, color = fleetdata.color })
					end
				else
					row[colidx]:createText(string.format("...\n%d", fleetdata.count), { halign = "center", x = 0 })
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component, { y = isstation and Helper.standardTextHeight / 2 or 1.5 * Helper.standardTextHeight })
		else
			-- unassigned ship case
			row[2]:setColSpan(namecolspan + 1)
			if alertMouseOver ~= "" then
				if mouseover ~= "" then
					mouseover = mouseover .. "\n\n"
				end
				mouseover = mouseover .. alertMouseOver
			end
			local fleetunitreplacementstring = ""
			if replacedfleetunits then
				fleetunitreplacementstring = ColorText["text_player"] .. " \27[menu_fleet_replacing]\27X"
				if mouseover ~= "" then
					mouseover = mouseover .. "\n\n"
				end
				mouseover = mouseover .. ReadText(1026, 3287) .. ReadText(1001, 120)
				for _, fleetunit in ipairs(replacedfleetunits) do
					local info = C.GetFleetUnitInfo(fleetunit)
					local macro = ffi.string(info.macro)
					local icon = GetMacroData(macro, "icon")
					mouseover = mouseover .. "\n" .. ColorText["text_player_lowlight"] .. "\27[" .. icon .. "] " .. ffi.string(info.name) .. " (" .. ffi.string(info.idcode) .. ")\27X"
				end
			end
			local indentation, actualname = string.match(name, "([ ]*)(.*)")
			local shipname = indentation .. alertString .. actualname .. fleetunitreplacementstring

			-- kuertee start: callback
			-- row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			if not menu.uix_callbacks ["createPropertyRow_override_row_shipname_createText"] then
				row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
			else
				local result
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyRow_override_row_shipname_createText"]) do
					result = uix_callback (shipname, { font = font, color = color, mouseOverText = mouseover }, component)
					if result then
						row[2]:createText(result.shipname, result.properties)
					end
				end
				if not result then
					row[2]:createText(shipname, { font = font, color = color, mouseOverText = mouseover })
				end
			end
			-- kuertee end: callback

			-- location / order
			if displaylocation then
				local colspan = 5 + maxicons - 3 - namecolspan
				if currentordericon ~= "" then
					colspan = colspan - 1
				end
				if isdocked then
					colspan = colspan - 1
				end
				if behaviouricon ~= "" then
					colspan = colspan - 1
				end
				-- kuertee start: callback
				-- row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				if not menu.uix_callbacks ["createPropertyRow_override_row_location_createText"] then
					row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
				else
					local result
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPropertyRow_override_row_location_createText"]) do
						result = uix_callback (locationtext, {halign = "right", font = font, mouseOverText = mouseovertext, x = 0}, component)
						if result then
							row[3 + namecolspan]:createText(result.locationtext, result.properties)
						end
					end
					if not result then
						row[3 + namecolspan]:setColSpan(colspan):createText(locationtext, { halign = "right", font = font, x = 0 })
					end
				end
				-- kuertee end: callback

			end
			if (currentordericon ~= "") or isdocked then
				local col = 4 + maxicons
				if isdocked then
					row[col]:createIcon("order_dockat", { width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = ReadText(1001, 3249) })
					col = col - 1
				end
				if currentordericon ~= "" then
					row[col]:createIcon(currentorderrawicon, { color = currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, false) end or currentordercolor, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = currentordername .. "\n" .. Helper.indentText(currentorderdescription .. (currentordermouseovertext and ("\n" .. ColorText["text_error"] .. currentordermouseovertext .. "\27X") or ""), "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont()) })
					col = col - 1
				end
				if behaviouricon ~= "" then
					row[col]:createIcon(behaviourrawicon, { color = Color["order_temp"], width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = behaviourname .. "\n" .. Helper.indentText(behaviourdescription, "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont()) })
					col = col - 1
				end
			end
			-- shieldhullbar
			row[5 + maxicons]:createObjectShieldHullBar(component)
		end

		if row[1].type == "button" then
			if isdoublerow and (not isstation) then
				row[1].properties.height = row[2]:getHeight()
			else
				row[1].properties.height = row[2]:getMinTextHeight(true)
			end
		end

		if isstation then
			AddKnownItem("stationtypes", macro)
		elseif IsComponentClass(component, "ship_xl") then
			AddKnownItem("shiptypes_xl", macro)
		elseif IsComponentClass(component, "ship_l") then
			AddKnownItem("shiptypes_l", macro)
		elseif IsComponentClass(component, "ship_m") then
			AddKnownItem("shiptypes_m", macro)
		elseif GetMacroData(macro, "islasertower") then
			AddKnownItem("lasertowers", macro)
		elseif IsComponentClass(component, "ship_s") then
			AddKnownItem("shiptypes_s", macro)
		elseif IsComponentClass(component, "ship_xs") then
			AddKnownItem("shiptypes_xs", macro)
		end

		if menu.isPropertyExtended(tostring(component)) then
			-- modules
			if showmodules and isstation then
				menu.createModuleSection(instance, ftable, component, iteration)
			end
			-- subordinates
			if subordinates.hasRendered and (not hidesubordinates) and subordinatefound then
				numdisplayed = menu.createSubordinateSection(instance, ftable, component, false, isstation, iteration, location or commanderlocation, numdisplayed, sorter, isplayerowned, isally)
			end
			-- dockedships
			if #dockedships > 0 then
				local isdockedshipsextended = menu.isDockedShipsExtended(tostring(component), isstation)
				if (not isdockedshipsextended) and menu.isDockContext(convertedComponent) then

					-- kuertee start: callback
					-- if menu.infoTableMode ~= "propertyowned" then
					if not string.find (menu.infoTableMode, "propertyowned") then
						-- kuertee end: callback

						menu.extendeddockedships[tostring(component)] = true
						isdockedshipsextended = true
					end
				end

				local row = ftable:addRow({"dockedships", component}, {  })
				row[1]:createButton():setText(isdockedshipsextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendDockedShips(tostring(component), isstation) end
				local text = ReadText(1001, 3265)
				for i = 1, iteration + 1 do
					text = "    " .. text
				end
				row[2]:setColSpan(3):createText(text)
				local numdockedplayerships = 0
				for _, dockedship in ipairs(dockedships) do
					local isplayerowned = GetComponentData(dockedship.component, "isplayerowned")
					if isplayerowned then
						numdockedplayerships = numdockedplayerships + 1
					end
				end
				if numdockedplayerships > 0 then
					row[5]:setColSpan(1 + maxicons):createText("\27[order_dockat] " .. numdockedplayerships, { halign = "right", color = menu.holomapcolor.playercolor })
				end
				if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "dockedships") then
					menu.sethighlightborderrow = row.index
				end
				if isdockedshipsextended then
					dockedships = menu.sortComponentListHelper(dockedships, sorter)
					for _, dockedship in ipairs(dockedships) do
						numdisplayed = menu.createPropertyRow(instance, ftable, dockedship.component, iteration + 2, location or commanderlocation, nil, true, numdisplayed, sorter)
					end
				end
			end
			if isstation then
				-- construction
				if #constructions > 0 then
					menu.createConstructionSubSection(ftable, component, constructions)
				end
			end
		end
	end

	return numdisplayed
end

function menu.fleetUnitBuildProgress(replacement, buildercomponent, commanderlocation)
	local location, locationname = GetComponentData(replacement, "sectorid", "sector")
	local displaylocation = location and not (commanderlocation and IsSameComponent(location, commanderlocation))
	return (displaylocation and ((locationname .. " ") or "") or "") .. "\27[menu_hammer] " .. Helper.formatTimeLeft(C.GetBuildProcessorEstimatedTimeLeft(buildercomponent))
end

function menu.createFleetUnitRow(instance, ftable, fleetunit, iteration, commanderlocation, numdisplayed, sorter)
	local maxicons = menu.infoTableData[instance].maxIcons

	local id = "fleetunit:" .. tostring(fleetunit)
	local subordinates = menu.infoTableData[instance].subordinates[id] or {}

	numdisplayed = numdisplayed + 1

	if (not menu.isPropertyExtended(id)) and menu.isCommander(0, fleetunit) then
		menu.extendedproperty[id] = true
	end

	local info = C.GetFleetUnitInfo(fleetunit)
	local macro = ffi.string(info.macro)
	local macroname, icon = GetMacroData(macro, "name", "icon")
	local mouseovertext = ""
	local mouseovertext2 = ""
	local color = Color["text_inactive"]
	local duration, ordericon, shieldhullbar
	local currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext
	local location, locationname

	local name = "\27[" .. icon .. "] " .. ffi.string(info.name) .. " (" .. ffi.string(info.idcode) .. ")"
	for i = 1, iteration do
		name = "    " .. name
	end

	local searchresult = true
	if #menu.searchtext > 0 then
		if info.replacementid ~= 0 then
			searchresult = Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(info.replacementid, numtexts, texts, true) end, "text")
		else
			searchresult = Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterFleetUnitByText(fleetunit, numtexts, texts) end, "text")
		end
	end
	if searchresult then
		numdisplayed = numdisplayed + 1

		local row = ftable:addRow({ "fleetunit", ConvertStringToLuaID(tostring(info.replacementid)), { fleetunit = fleetunit }, iteration }, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(component) })
		if menu.highlightedfleetunit and (fleetunit == menu.highlightedfleetunit) then
			menu.sethighlightborderrow = row.index
		end
		if (info.replacementid ~= 0) and IsSameComponent(ConvertStringTo64Bit(tostring(info.replacementid)), menu.highlightedbordercomponent) then
			menu.sethighlightborderrow = row.index
		end

		local namecols = 3
		if menu.infoTableMode == "propertyowned" then
			namecols = 2
		end

		local issues = ffi.string(C.GetFleetUnitBuildIssues(fleetunit))
		local first = true
		for issue in string.gmatch(issues, "[^;]+") do
			if (issue == "nocontainer") or (issue == "objectmacro") or (issue == "equipment") or (issue == "hacked") or (issue == "paused") then
				if first then
					if issue == "hacked" then
						duration = ColorText["text_warning"] .. "\27[menu_hammer] --:--"
					else
						duration = ColorText["text_error"] .. "\27[menu_hammer] --:--"
					end
					first = false
				else
					mouseovertext2 = mouseovertext2 .. "\n\n"
				end
			end

			if issue == "nocontainer" then
				local iscapship = IsMacroClass(macro, "ship_l") or IsMacroClass(macro, "ship_xl")
				mouseovertext2 = mouseovertext2 .. (iscapship and ReadText(1026, 3289) or ReadText(1026, 3290))
			elseif issue == "objectmacro" then
				mouseovertext2 = mouseovertext2 .. ReadText(1026, 3291) .. ReadText(1001, 120) .. " " .. macroname
			elseif issue == "equipment" then
				mouseovertext2 = mouseovertext2 .. ReadText(1026, 3292) .. ReadText(1001, 120)
				local n = C.GetNumFleetUnitProblematicEquipmentWares(fleetunit)
				if n > 0 then
					local buf = ffi.new("const char*[?]", n)
					n = C.GetFleetUnitProblematicEquipmentWares(buf, n, fleetunit)
					for i = 0, n - 1 do
						mouseovertext2 = mouseovertext2 .. "\n· " .. GetWareData(ffi.string(buf[i]), "name")
					end
				end
			elseif issue == "hacked" then
				mouseovertext2 = mouseovertext2 .. ReadText(1026, 3293)
			elseif issue == "paused" then
				mouseovertext2 = mouseovertext2 .. ReadText(1026, 3294)
			end
		end

		if mouseovertext2 == "" then
			if info.replacementid ~= 0 then
				local replacement64 = ConvertStringTo64Bit(tostring(info.replacementid))
				color = Color["text_player_inactive"]
				name = menu.getContainerNameAndColors(replacement64, 0, false, false)
				for i = 1, iteration do
					name = "    " .. name
				end
				if C.IsComponentOperational(info.replacementid) then
					name = name .. " " .. ColorText["text_player"] .. "(" .. ReadText(1001, 11662) .. ")\27X"

					currentordericon, currentorderrawicon, currentordercolor, currentordername, currentorderdescription, currentorderisoverride, currentordermouseovertext = menu.getOrderInfo(replacement64)
					location, locationname = GetComponentData(replacement64, "sectorid", "sector")
					local displaylocation = location and not (commanderlocation and IsSameComponent(location, commanderlocation))
					duration = (displaylocation and ((locationname .. " ") or "") or "")
					shieldhullbar = true
				else
					name = name .. " " .. ColorText["text_player"] .. "(" .. math.floor(C.GetCurrentBuildProgress(info.replacementid)) .. " %)\27X"

					if info.buildtaskid ~= 0 then
						local buildtaskinfo = C.GetBuildTaskInfo(info.buildtaskid)
						if buildtaskinfo.buildercomponent ~= 0 then
							if menu.infoTableMode == "objectlist" then
								duration = function () return "\27[menu_hammer] " .. Helper.formatTimeLeft(C.GetBuildProcessorEstimatedTimeLeft(buildtaskinfo.buildercomponent)) end
							else
								duration = function () return menu.fleetUnitBuildProgress(replacement64, buildtaskinfo.buildercomponent, commanderlocation) end
							end
						end
					end
				end
			elseif info.buildtaskid ~= 0 then
				color = Color["text_player_inactive"]
				local buildtaskinfo = C.GetBuildTaskInfo(info.buildtaskid)

				mouseovertext2 = ReadText(1026, 3288) .. ReadText(1001, 120) .. " " .. ColorText["text_player"] .. ffi.string(C.GetComponentName(buildtaskinfo.buildingcontainer)) .. " (" .. ffi.string(C.GetObjectIDCode(buildtaskinfo.buildingcontainer)) .. ")\27X"

				local missingresources = {}
				local n = C.GetNumMissingBuildResources2(buildtaskinfo.buildingcontainer, nil, 0, true)
				if n > 0 then
					local buf = ffi.new("UIWareInfo[?]", n)
					n = C.GetMissingBuildResources(buf, n)
					for i = 0, n - 1 do
						table.insert(missingresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
					end
				end
				if #missingresources > 0 then
					duration = ColorText["text_warning"]
					mouseovertext2 = mouseovertext2 .. "\n\n" .. ColorText["text_warning"] .. ReadText(1001, 8018) .. "\n\n" .. ReadText(1001, 8046) .. ReadText(1001, 120)
					for i, entry in ipairs(missingresources) do
						mouseovertext2 = mouseovertext2 .. "\n· " .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
					end
				end

				duration = (duration or "") .. "\27[menu_hammer] " .. ColorText["text_inactive"] .. Helper.formatTimeLeft(C.GetBuildTaskDuration(buildtaskinfo.buildingcontainer, buildtaskinfo.id))
			end
		end

		local hascomponentsubordinate = false
		for _, subordinate in ipairs(subordinates) do
			if subordinate.component then
				hascomponentsubordinate = true
				break
			end
		end

		local replacementcomponent = menu.infoTableData[instance].fleetUnitReplacements[id]
		if replacementcomponent then
			name = name .. ColorText["text_player"] .. " \27[menu_fleet_replaced]\27X"
			local replacementname, replacementcolor = menu.getContainerNameAndColors(replacementcomponent, 0, false, false)
			mouseovertext = ReadText(1026, 3286) .. ReadText(1001, 120) .. "\n" .. Helper.convertColorToText(replacementcolor) .. replacementname
		end

		row[2]:setColSpan(namecols):createText(name, { font = font, color = color, mouseOverText = mouseovertext })

		if subordinates.hasRendered then
			row[1]:createButton({ scaling = false, height = row[2]:getMinTextHeight(true) }):setText(menu.isPropertyExtended(id) and "-" or "+", { scaling = true, halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendProperty(id) end
		end

		if duration then
			row[2 + namecols]:setColSpan(maxicons + 4 - namecols - (shieldhullbar and 1 or 0) - (currentordericon and 1 or 0)):createText(duration, { halign = "right", mouseOverText = mouseovertext2 })
		end

		if currentordericon then
			if currentordericon ~= "" then
				row[4 + maxicons]:createIcon(currentorderrawicon, { color = currentorderisoverride and function () return menu.overrideOrderIcon(currentordercolor, false) end or currentordercolor, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = currentordername .. "\n" .. Helper.indentText(currentorderdescription .. (currentordermouseovertext and ("\n" .. ColorText["text_error"] .. currentordermouseovertext .. "\27X") or ""), "  ", GetCurrentMouseOverWidth(), GetCurrentMouseOverFont()) })
			end
		end

		if shieldhullbar then
			row[5 + maxicons]:createObjectShieldHullBar(info.replacementid)
		end

		if menu.isPropertyExtended(id) then
			-- subordinates
			if subordinates.hasRendered then
				numdisplayed = menu.createSubordinateSection(instance, ftable, fleetunit, true, false, iteration, location or commanderlocation, numdisplayed, sorter, true, false)
			end
		end
	end

	return numdisplayed
end

function menu.createSubordinateSection(instance, ftable, component, isfleetunit, isstation, iteration, location, numdisplayed, sorter, isplayerowned, isally)
	local maxicons = menu.infoTableData[instance].maxIcons
	local id = (isfleetunit and "fleetunit:" or "") .. tostring(component)
	local subordinates = menu.infoTableData[instance].subordinates[id] or {}
	subordinates = menu.sortComponentListHelper(subordinates, sorter)
	-- setup groups
	local groups = {}
	for _, subordinate in ipairs(subordinates) do
		-- only show fleetunit subordinates for fleetunits
		local isfleetunitsub = false
		if subordinate.component then
			isfleetunitsub = menu.infoTableData[instance].fleetUnitSubordinates[tostring(subordinate.component)] == true
		end
		if (subordinate.component and (isfleetunitsub == isfleetunit)) or subordinate.fleetunit then
			local group
			if subordinate.component then
				if isfleetunitsub then
					-- need to get the group it's assigned to at the fleet unit, not the current actual group
					group = C.GetGroupOfFleetUnitSubordinate(C.ConvertStringTo64Bit(tostring(subordinate.component)), component)
				else
					group = GetComponentData(subordinate.component, "subordinategroup")
				end
			elseif subordinate.fleetunit then
				group = C.GetFleetUnitSubordinateGroup(subordinate.fleetunit)
			end
			if group and group > 0 then
				if groups[group] then
					if (not groups[group].hasrendered) and (menu.infoTableMode == "objectlist") and subordinate.component then
						groups[group].hasrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate.component)]
					end
					table.insert(groups[group].subordinates, subordinate)
				else
					local isrendered = true
					if (menu.infoTableMode == "objectlist") and subordinate.component then
						isrendered = menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate.component)]
					end

					local assignment = ""
					if isfleetunit then
						assignment = ffi.string(C.GetFleetUnitSubordinateGroupAssignment(component, group))
					else
						assignment = ffi.string(C.GetSubordinateGroupAssignment(ConvertIDTo64Bit(component), group))
					end
					groups[group] = { assignment = assignment, subordinates = { subordinate }, hasrendered = isrendered }
				end
			end
		end
	end

	for group = 1, 10 do
		if groups[group] and groups[group].hasrendered then
			local issubordinateextended = menu.isSubordinateExtended(id, group)
			if (not issubordinateextended) and menu.isCommander(isfleetunit and 0 or C.ConvertStringTo64Bit(tostring(component)), isfleetunit and fleetunit or 0, group) then
				menu.extendedsubordinates[id .. group] = true
				issubordinateextended = true
			end

			local row = ftable:addRow({ "subordinates" .. id .. group, isfleetunit and 0 or component, group, isfleetunit and component or nil }, {  })
			row[1]:createButton():setText(issubordinateextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendSubordinate(id, group) end
			local text = string.format(ReadText(1001, 8398), ReadText(20401, group))
			for i = 1, iteration + 1 do
				text = "    " .. text
			end
			row[2]:setColSpan(2):createText(text)

			local assignmenttext = config.assignments[groups[group].assignment] and config.assignments[groups[group].assignment].name or ""
			local groupiconstext = ""
			local groupmouseovertext = ""

			if isplayerowned or isally then
				groupmouseovertext = ReadText(1001, 5903) .. ReadText(1001, 120) .. " " .. assignmenttext -- Assignment: X
				local idlingshipstext = ReadText(1026, 3271) -- "%d ships waiting for orders."
				local idlingshipstext_singular = ReadText(1026, 3272) -- "1 ship waiting for orders."
				local awayshipstext = ReadText(1026, 3273) -- "%d ships in a different sector."
				local awayshipstext_singular = ReadText(1026, 3274) -- "1 ship in a different sector."

				-- group icons
				if not isfleetunit then
					local shipstates = menu.getPropertyOwnedGroupIcons(instance, component, groups[group].subordinates)
					for i, shipstatedata in ipairs(shipstates) do
						if shipstatedata.icon and shipstatedata.count > 0 then
							groupiconstext = groupiconstext .. string.format("\027[%s]%d  ", shipstatedata.icon, shipstatedata.count)
							if (shipstatedata.name == "shipstate_idling") then
								if shipstatedata.count == 1 then
									groupmouseovertext = groupmouseovertext .. "\n" .. idlingshipstext_singular
								elseif shipstatedata.count > 1 then
									groupmouseovertext = groupmouseovertext .. "\n" .. string.format(idlingshipstext, shipstatedata.count)
								end
							elseif (shipstatedata.name == "shipstate_away") then
								if shipstatedata.count == 1 then
									groupmouseovertext = groupmouseovertext .. "\n" .. awayshipstext_singular
								elseif shipstatedata.count > 1 then
									groupmouseovertext = groupmouseovertext .. "\n" .. string.format(awayshipstext, shipstatedata.count)
								end
							end
						end
					end
				end
				groupiconstext = groupiconstext .. assignmenttext
			else
				groupiconstext = assignmenttext
			end

			row[4]:setColSpan(maxicons + 2):createText(groupiconstext, { halign = "right", mouseOverText = groupmouseovertext })
			if menu.highlightedborderstationcategory == "subordinates" .. id .. group then
				menu.sethighlightborderrow = row.index
			end
			if issubordinateextended then
				for _, subordinate in ipairs(groups[group].subordinates) do
					local isdocked, subordinategroup
					if subordinate.component then
						isdocked, subordindategroup = GetComponentData(subordinate.component, "isdocked", "subordinategroup")
					elseif subordinate.fleetunit then
						isdocked = false
						subordindategroup = C.GetFleetUnitSubordinateGroup(subordinate.fleetunit)
					end
					local isexternaldock, parent
					if isdocked then
						isexternaldock = C.IsShipAtExternalDock(ConvertIDTo64Bit(subordinate.component))
						parent = C.GetContextByClass(ConvertIDTo64Bit(subordinate.component), "container", false)
					end

					if (menu.infoTableMode ~= "objectlist") or subordinate.fleetunit or menu.renderedComponentsRef[ConvertIDTo64Bit(subordinate.component)] or (isdocked and (not isexternaldock) and menu.renderedComponentsRef[ConvertStringTo64Bit(tostring(parent))]) then
						if subordinate.component then
							numdisplayed = menu.createPropertyRow(instance, ftable, subordinate.component, iteration + 2, location, nil, nil, numdisplayed, sorter)
						elseif subordinate.fleetunit then
							numdisplayed = menu.createFleetUnitRow(instance, ftable, subordinate.fleetunit, iteration + 2, location, numdisplayed, sorter)
						end
					end
				end
			end
		end
	end

	return numdisplayed
end

function menu.createModuleSection(instance, ftable, component, iteration)
	local moduledata = menu.getModuleData(ConvertStringTo64Bit(tostring(component)))
	local maxicons = menu.infoTableData[instance].maxIcons

	for _, moduletype in ipairs(config.moduletypes) do
		local modules = Helper.tableCopy(moduledata[moduletype.type]) or {}
		if moduletype.additionaltypes then
			for _, additionaltype in ipairs(moduletype.additionaltypes) do
				for _, v in ipairs(moduledata[additionaltype] or {}) do
					table.insert(modules, v)
				end
			end
		end

		if next(modules) then
			if (not menu.isModuleTypeExtended(component, moduletype.type)) then
				for _, moduleentry in ipairs(modules) do
					if menu.isSelectedComponent(moduleentry.module) then
						menu.extendModuleType(component, moduletype.type, true)
						break
					end
				end
			end

			local istypeextended = menu.isModuleTypeExtended(component, moduletype.type)

			local bgcolor
			if (menu.mode == "orderparam_object") then
				bgcolor = Color["row_background_unselectable"]
			end

			local row = ftable:addRow({"moduletype", component, moduletype.type, iteration}, { bgColor = bgcolor })
			if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) then
				menu.sethighlightborderrow = row.index
			end

			row[1]:createButton():setText(istypeextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendModuleType(component, moduletype.type) end
			local moduleUnderConstruction
			for _, moduleentry in ipairs(modules) do
				if type(moduleentry.module) ~= "string" then
					if IsComponentConstruction(moduleentry.module) then
						moduleUnderConstruction = moduleentry.module
						break
					end
				end
			end

			if moduleUnderConstruction then
				row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "    " .. moduletype.name, moduleUnderConstruction) end)
				local buildingprocessor = GetComponentData(component, "buildingprocessor")
				local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
				row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), moduleUnderConstruction, ismissingresources) end, { halign = "right", mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
			else
				row[2]:setColSpan(3):createText("    " .. moduletype.name)
			end

			if istypeextended then
				for _, moduleentry in ipairs(modules) do
					local module = moduleentry.module
					if type(module) == "string" then
						local bgcolor
						if menu.mode == "orderparam_object" then
							bgcolor = Color["row_background_unselectable"]
						end
						local row = ftable:addRow({"module", nil, moduletype.type, iteration, component, module}, { bgColor = bgcolor })

						if IsSameComponent(component, menu.highlightedbordercomponent) and (moduletype.type == menu.highlightedbordermoduletype) and (module == menu.highlightedplannedmodule) then
							menu.sethighlightborderrow = row.index
						end

						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. moduleentry.name, 0) end, { color = color })
					else
						local moduleunlocked = isplayer or IsInfoUnlockedForPlayer(module, "name")

						local color = (not moduleunlocked) and Color["text_inactive"] or nil
						local bgcolor
						if (menu.mode == "orderparam_object") and (not menu.checkForOrderParamObject(module)) then
							bgcolor = Color["row_background_unselectable"]
						end

						local row = ftable:addRow({"module", ConvertStringToLuaID(tostring(module)), moduletype.type, iteration, component}, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(module) })
						if IsSameComponent(module, menu.highlightedbordercomponent) then
							menu.sethighlightborderrow = row.index
						end
						local name = moduleunlocked and moduleentry.name or ReadText(1001, 3210)
						row[2]:setColSpan(3):createText(function () return menu.getBuildProgress(component, "        " .. name, module) end, { color = color })

						local isfunctional, ishacked = GetComponentData(module, "isfunctional", "ishacked")
						if IsComponentConstruction(module) then
							local buildingprocessor = GetComponentData(component, "buildingprocessor")
							local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
							row[5]:setColSpan(1 + maxicons):createText(function () return menu.getBuildTime(ConvertIDTo64Bit(buildingprocessor), module, ismissingresources) end, { halign = "right", color = color, mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
						else
							if not isfunctional then
								row[5]:setColSpan(maxicons):createText(ishacked and ("[" .. ReadText(1001, 4770) .. "]") or ("[" .. ReadText(1001, 11606) .. "]"), { halign = "right", color = Color["text_warning"] })
							end
							row[5 + maxicons]:createObjectShieldHullBar(module)
						end
					end
				end
			end
		end
	end
end

function menu.createConstructionSubSection(ftable, component, constructions)
	for i, construction in ipairs(constructions) do
		if menu.isSelectedComponent(construction.component) then
			menu.extendedconstruction[tostring(component)] = true
		end
	end
	local isconstructionextended = menu.isConstructionExtended(tostring(component))
	local row = ftable:addRow({"constructions", component}, {  })
	row[1]:createButton():setText(isconstructionextended and "-" or "+", { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonExtendConstruction(tostring(component)) end
	row[2]:setColSpan(3):createText("    " .. ReadText(1001, 3266))
	if IsSameComponent(component, menu.highlightedbordercomponent) and (menu.highlightedborderstationcategory == "constructions") then
		menu.sethighlightborderrow = row.index
	end
	if isconstructionextended then
		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				menu.createConstructionRow(ftable, component, construction, 2)
			end
		end
	end
end

function menu.createConstructionSection(instance, id, ftable, name, constructions)
	if #constructions > 0 then
		local maxicons = menu.infoTableData[instance].maxIcons

		local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(5 + maxicons):createText(name, Helper.headerRowCenteredProperties)

		if id == menu.highlightedbordersection then
			menu.sethighlightborderrow = row.index + 1
		end

		for i, construction in ipairs(constructions) do
			if construction.empty then
				ftable:addEmptyRow(config.mapRowHeight / 2)
			else
				local component = ConvertStringTo64Bit(tostring(construction.buildingcontainer))
				menu.createConstructionRow(ftable, component, construction, 1)
			end
		end
	end
end

function menu.createConstructionRow(ftable, component, construction, iteration)
	local name = ReadText(20109, 5101)
	if construction.component ~= 0 then
		name = ffi.string(C.GetComponentName(construction.component))
	elseif construction.macro ~= "" then
		name = GetMacroData(construction.macro, "name")
		if construction.amount then
			name = construction.amount .. ReadText(1001, 42) .. " " .. name
		end
	end
	for i = 1, iteration do
		name = "    " .. name
	end
	local color = (construction.factionid == "player") and menu.holomapcolor.playercolor or Color["text_normal"]
	local bgcolor
	if menu.mode == "orderparam_object" then
		bgcolor = Color["row_background_unselectable"]
	end

	local row = ftable:addRow({ "construction", component, construction }, { bgColor = bgcolor, multiSelected = menu.isSelectedComponent(construction.component) })
	if menu.highlightedconstruction and (construction.id == menu.highlightedconstruction.id) then
		menu.sethighlightborderrow = row.index
	end
	if (construction.component ~= 0) and IsSameComponent(ConvertStringTo64Bit(tostring(construction.component)), menu.highlightedbordercomponent) then
		menu.sethighlightborderrow = row.index
	end

	if construction.inprogress then
		local mouseovertext = ""
		if construction.ismissingresources then
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3223)

			local missingresources = {}
			local n = C.GetNumMissingBuildProcessorResources(component, construction.buildercomponent)
			if n > 0 then
				local buf = ffi.new("UIWareInfo[?]", n)
				n = C.GetMissingBuildProcessorResources(buf, n)
				for i = 0, n - 1 do
					table.insert(missingresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
				end
			end
			if #missingresources > 0 then
				mouseovertext = mouseovertext .. "\n\n" .. ReadText(1001, 8046) .. ReadText(1001, 120)
				for i, entry in ipairs(missingresources) do
					mouseovertext = mouseovertext .. "\n· " .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
				end
			end
		end

		row[2]:setColSpan(4):createText(function () return menu.getShipBuildProgress(construction.component, name .. " (" .. ffi.string(C.GetObjectIDCode(construction.component)) .. ")") end, { color = color, mouseOverText = mouseovertext })
		row[6]:setColSpan(5):createText(function () return (construction.ismissingresources and (ColorText["text_warning"] .. "\27[warning]") or "") .. Helper.formatTimeLeft(C.GetBuildProcessorEstimatedTimeLeft(construction.buildercomponent)) end, { halign = "right", color = color, mouseOverText = mouseovertext })
	else
		local duration = C.GetBuildTaskDuration(construction.buildingcontainer, construction.id)

		local mouseovertext = ""
		local missingresources = {}
		local n = C.GetNumMissingBuildResources2(ConvertStringTo64Bit(tostring(component)), nil, 0, true)
		if n > 0 then
			local buf = ffi.new("UIWareInfo[?]", n)
			n = C.GetMissingBuildResources(buf, n)
			for i = 0, n - 1 do
				table.insert(missingresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		if #missingresources > 0 then
			mouseovertext = ColorText["text_warning"] .. ReadText(1001, 8018) .. "\n\n" .. ReadText(1001, 8046) .. ReadText(1001, 120)
			for i, entry in ipairs(missingresources) do
				mouseovertext = mouseovertext .. "\n· " .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
			end
		end

		row[2]:setColSpan(2):createText(name, { color = color, mouseOverText = mouseovertext })
		if construction.amount then
			row[4]:setColSpan(7):createText(((#missingresources > 0) and (ColorText["text_warning"] .. "\27[warning]") or "") .. string.format(ReadText(1001, 11608), Helper.formatTimeLeft(duration)), { halign = "right", color = color, mouseOverText = mouseovertext })
		else
			row[4]:setColSpan(7):createText(((#missingresources > 0) and (ColorText["text_warning"] .. "\27[warning]") or "") .. "#" .. construction.queueposition .. " - " .. Helper.formatTimeLeft(duration), { halign = "right", color = color, mouseOverText = mouseovertext })
		end
	end
end

function menu.getPropertyOwnedFleetData(instance, component, maxentries)
	local shiptyperanks = { }
	local shiptypedata = { }
	menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	table.sort(shiptyperanks)
	local result = { }
	for _, shiptyperank in ipairs(shiptyperanks) do
		-- insert at front
		table.insert(result, 1, shiptypedata[shiptyperank])
	end

	local dockedships = menu.infoTableData[instance].dockedships[tostring(component)] or {}
	local numdockedplayerships = 0
	for _, dockedship in ipairs(dockedships) do
		local isplayerowned = GetComponentData(dockedship.component, "isplayerowned")
		if isplayerowned then
			local iscommander = false
			local commanderlist = GetAllCommanders(dockedship.component)
			for i, entry in ipairs(commanderlist) do
				if IsSameComponent(entry, component) then
					iscommander = true
					break
				end
			end
			if not iscommander then
				numdockedplayerships = numdockedplayerships + 1
			end
		end
	end
	if numdockedplayerships > 0 then
		table.insert(result, 1, { icon = "order_dockat", count = numdockedplayerships, color = menu.holomapcolor.playercolor })
	end

	local isfleetlead = GetComponentData(component, "isfleetlead")
	if isfleetlead then
		local count = menu.infoTableData[instance].fleetUnitData[tostring(component)].count

		table.insert(result, 1, { icon = "menu_hammer", count = (count > 0) and count or nil, color = menu.infoTableData[instance].fleetUnitData[tostring(component)].haserrors and Color["text_error"] or nil })
	end

	-- If there are too many entries, accumulate counts in last entry and invalidate icon
	while maxentries and #result > maxentries do
		local removed = table.remove(result)
		result[maxentries].count = result[maxentries].count + removed.count
		result[maxentries].icon = nil
	end
	return result
end

function menu.getPropertyOwnedFleetDataInternal(instance, component, shiptyperanks, shiptypedata)
	local shiptyperank
	local shipclass = "xs"
	if IsComponentClass(component, "ship_xl") then
		shiptyperank = 50
		shipclass = "xl"
	elseif IsComponentClass(component, "ship_l") then
		shiptyperank = 40
		shipclass = "l"
	elseif IsComponentClass(component, "ship_m") then
		shiptyperank = 30
		shipclass = "m"
	elseif IsComponentClass(component, "ship_s") then
		shiptyperank = 20
		shipclass = "s"
	elseif IsComponentClass(component, "ship_xs") then
		shiptyperank = 10
		shipclass = "xs"
	end
	if shiptyperank then
		local purpose, icon, primarypurposeicon = GetComponentData(component, "primarypurpose", "icon", "primarypurposeicon")
		if purpose == "fight" then
			shiptyperank = shiptyperank + 5
		elseif purpose == "auxiliary" then
			shiptyperank = shiptyperank + 4
		elseif purpose == "trade" then
			shiptyperank = shiptyperank + 3
		elseif purpose == "mine" then
			shiptyperank = shiptyperank + 2
		elseif purpose == "build" then
			shiptyperank = shiptyperank + 1
		else
			purpose = "neutral"
		end
		if primarypurposeicon ~= "" then
			icon = primarypurposeicon
		end
		if not shiptypedata[shiptyperank] then
			table.insert(shiptyperanks, shiptyperank)
			shiptypedata[shiptyperank] = { icon = icon, count = 0 }
		end
		shiptypedata[shiptyperank].count = shiptypedata[shiptyperank].count + 1
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["getPropertyOwnedFleetDataInternal_addToFleetIcons"]) do
			uix_callback (component, shiptyperanks, shiptypedata)
		end
	end
	-- kuertee end: callback

	local subordinates = menu.infoTableData[instance].subordinates[tostring(component)]
	if subordinates == nil then
		subordinates = menu.getSubordinates(component, nil)
		menu.infoTableData[instance].subordinates[tostring(component)] = subordinates
	end
	for _, subordinate in ipairs(subordinates) do
		if subordinate.component then
			menu.getPropertyOwnedFleetDataInternal(instance, subordinate.component, shiptyperanks, shiptypedata)
		end
	end
end

function menu.getPropertyOwnedGroupIcons(instance, component, subordinates)
	local shipstates = {}
	local shipstatesdata = {}
	local sectorbase = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	for _, subordinate in ipairs(subordinates) do
		if subordinate.component and menu.isObjectValid(ConvertIDTo64Bit(subordinate.component)) then
			menu.getPropertyOwnedGroupIcons_getData(instance, subordinate.component, shipstates, shipstatesdata, sectorbase)
		end
	end
	table.sort(shipstates)
	local result = {}
	for _, shipstate in ipairs(shipstates) do
		table.insert(result, 1, shipstatesdata[shipstate])
	end
	return result
end

function menu.getPropertyOwnedGroupIcons_getData(instance, component, shipstates, shipstatesdata, sectorbase)
	local shipstate_idling = 10
	local shipstate_name = "shipstate_idling"
	local shipstate_idling_icon = "ships_idling_01"
	local purpose = GetComponentData(component, "primarypurpose")
	if not shipstatesdata[shipstate_idling] then
		table.insert(shipstates, shipstate_idling)
		shipstatesdata[shipstate_idling] = {name = shipstate_name, icon = shipstate_idling_icon, count = 0 }
	end
	local numOrders = C.GetNumOrders(ConvertStringTo64Bit(tostring(component)))
	if numOrders == 0 then
		shipstatesdata[shipstate_idling].count = shipstatesdata[shipstate_idling].count + 1
	end
	local shipstate_away = 20
	local shipstate_name = "shipstate_away"
	local shipstate_away_icon = "ships_away_01"
	local sector = GetComponentData(ConvertStringTo64Bit(tostring(component)), "sector")
	if not shipstatesdata[shipstate_away] then
		table.insert(shipstates, shipstate_away)
		shipstatesdata[shipstate_away] = {name = shipstate_name, icon = shipstate_away_icon, count = 0}
	end
	if sector ~= sectorbase then
		shipstatesdata[shipstate_away].count = shipstatesdata[shipstate_away].count + 1
	end
end

function menu.populateUpkeepMissionData()
	menu.upkeepMissionData = {}

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, alertLevel = GetMissionDetails(i)

		if maintype == "upkeep" then
			if associatedcomponent then
				local rawcontainer = C.GetContextByRealClass(ConvertIDTo64Bit(associatedcomponent), "container", true)
				if rawcontainer ~= 0 then
					local container = ConvertStringTo64Bit(tostring(rawcontainer))

					if menu.upkeepMissionData[tostring(container)] then
						table.insert(menu.upkeepMissionData[tostring(container)], { missionID = missionID, alertLevel = alertLevel, name = name })
					else
						menu.upkeepMissionData[tostring(container)] = { { missionID = missionID, alertLevel = alertLevel, name = name } }
					end
				end
			end
		end
	end
end

function menu.getContainerAlertLevel(component)
	component = ConvertStringTo64Bit(tostring(component))
	local highestAlertLevel = 0
	local upkeepMissions = {}
	if menu.upkeepMissionData[tostring(component)] then
		for _, entry in ipairs(menu.upkeepMissionData[tostring(component)]) do
			highestAlertLevel = math.max(highestAlertLevel, entry.alertLevel)
			table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
		end
	end

	table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)
	local missionlist = ""
	for i, entry in ipairs(upkeepMissions) do
		if i ~= 1 then
			missionlist = missionlist .. "\n"
		end
		local color = Color["text_normal"]
		if entry.alertLevel == 1 then
			color = menu.holomapcolor.lowalertcolor
		elseif entry.alertLevel == 2 then
			color = menu.holomapcolor.mediumalertcolor
		else
			color = menu.holomapcolor.highalertcolor
		end
		missionlist = missionlist .. Helper.convertColorToText(color) .. entry.name
	end

	return highestAlertLevel, missionlist
end

function menu.getBuildProgress(station, name, component)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ConvertIDTo64Bit(station)))
	elseif component == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

function menu.getBuildTime(buildingprocessor, component, ismissingresources)
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		return (ismissingresources and (ColorText["text_warning"] .. "\27[warning] ") or "") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(buildingprocessor), "%h:%M:%S")
	else
		return ""
	end
end

function menu.getShipBuildProgress(ship, name)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(ship))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ship))
	elseif ship == 0 then
		buildprogress = "-"
	end

	if buildprogress == 100 then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

-- Order Queue

function menu.displayOrderParam(ftable, orderidx, order, paramidx, param, listidx, instance)
	local value = param.value
	local ismissing = value == nil
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64
	local paramactive = true
	if orderidx == "default" then
		paramactive = (menu.infoTableData[instance].commander == nil) and (not isplayeroccupiedship)
	end
	if paramactive and ((param.inputparams and param.inputparams.playerreadonly) or param.playerreadonly) then
		if param.inputparams and param.inputparams.playerreadonly then
			paramactive = (param.inputparams.playerreadonly ~= 1)
		elseif param.playerreadonly then
			paramactive = (param.playerreadonly ~= 1)
		end
	end
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local numValues = 0
	if not ismissing then
		if listidx then
			numValues = #order.params[paramidx].value
		end
		value = menu.getParamValue(param.type, value, param.inputparams)
	end

	local paramcolor = Color["text_normal"]
	if ismissing then
		paramcolor = Color["text_error"]
	elseif order.state == "setup" then
		paramcolor = Color["text_success"]
	end

	local paramtext = (param.text ~= "") and ("  " .. param.text .. ReadText(1001, 120)) or ""

	if listidx then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end

		if param.canplayeroverride then
			local checked = (#param.canplayeroverride.param.value == 0) or (param.canplayeroverride.values[param.value] ~= nil)
			local active = #param.canplayeroverride.param.value > 1
			local mouseovertext = ""

			if #param.canplayeroverride.param.value > 0 then
				if not checked then
					active = true
				elseif not active then
					mouseovertext = ReadText(1026, 3283)
				end
			end

			row[5]:setColSpan(1)
			row[6]:createCheckBox(checked, { active = active, width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = mouseovertext })
			row[6].handlers.onClick = function () menu.checkboxOrderPlayerOverrideValue(orderidx, param.canplayeroverride.paramidx, param.canplayeroverride.values[param.value], param.value) end

			local suffix = ""
			local mouseovertext = ""
			if param.canplayeroverride.criticalwares[param.value] then
				suffix = " " .. ColorText["text_warning"] .. "\27[menu_ware_critical]"
				mouseovertext = ReadText(1026, 3284)
			end
			row[7]:createText(value and (tostring(value) .. suffix) or "", { mouseOverText = mouseovertext })
		else
			row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
			local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
			row[5]:setColSpan(7):createButton({ active = active }):setText(value and tostring(value) or "", { halign = "center", color = paramcolor })
			row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
			row[12]:createButton({ active = active and ((not order.params[paramidx].required) or (numValues > 1)) }):setText("x", { halign = "center", color = paramcolor })
			row[12].handlers.onClick = function () return menu.buttonRemoveListParam(orderidx, paramidx, listidx, instance) end
		end
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		local playerreadonly = param.inputparams and param.inputparams.playerreadonly
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { name = subparam.id, text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable, playerreadonly = playerreadonly }
					menu.displayOrderParam(ftable, orderidx, order, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step >= 1000 then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = {
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			valueColor = paramactive and Color["slider_value"] or Color["slider_value_inactive"],
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			readOnly = (not paramactive) or isplayeroccupiedship or (((order.state ~= "setup") or (paramidx > (order.actualparams + 1))) and ((order.state == "setup") and (not param.editable))),
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText(paramtext)
		row[5]:setColSpan(8):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize, color = paramcolor })
		row[5].handlers.onSliderCellConfirm = function (_, value) return menu.slidercellSetOrderParam(orderidx, paramidx, listidx, value, instance) end
		row[5].handlers.onSliderCellActivated = function() menu.noupdate = true end
		row[5].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
	elseif param.type == "bool" then
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = active, width = config.mapRowHeight })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
	else
		local row = ftable:addRow({ orderidx, paramidx, listidx }, {  })
		if selectedorder and (selectedorder[1] == orderidx) and (selectedorder[2] == paramidx) and (selectedorder[3] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8)
		local active = paramactive and (not isplayeroccupiedship) and (((order.state == "setup") and (paramidx <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
		local text = value and tostring(value) or (active and (ColorText["text_inactive"] .. ReadText(1001, 3102) .. "..." .. ((paramidx < (order.actualparams + 1)) and (" (" .. ReadText(1001, 11669) .. ")") or "")) or "")
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = active, height = height, helpOverlayID = "orderparam_" .. param.name, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(text, { halign = "center", color = paramcolor, y = (height - config.mapRowHeight) / 2 })
		row[5].handlers.onClick = function () return menu.buttonSetOrderParam(orderidx, paramidx, listidx, nil, instance) end
		row[5].properties.uiTriggerID = "orderparam_" .. param.name
	end
end

function menu.displayFailureParam(ftable, failureidx, paramidx, param, listidx, instance)
	if instance == nil then
		print(TraceBack())
	end
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local value = menu.getParamValue(param.type, param.value, param.inputparams)

	local paramtext = (param.text ~= "") and ("  " .. param.text .. ReadText(1001, 120)) or ""

	if listidx then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8):createButton({ active = false }):setText(value and tostring(value) or "", { halign = "center" })
	elseif config.complexOrderParams[param.type] then
		local data = config.complexOrderParams[param.type].data(param.value)
		if next(data) then
			for _, subparam in ipairs(config.complexOrderParams[param.type]) do
				if subparam.value(data) then
					local subparam2 = { text = subparam.name, value = subparam.value(data), type = subparam.type, editable = param.editable }
					menu.displayFailureParam(ftable, failureidx, paramidx, subparam2, nil, instance)
				end
			end
		end
	elseif param.inputparams and (param.type == "number" or param.type == "length" or param.type == "time" or param.type == "money") then
		local defaultmax = 50000
		local minselect = math.max(0, param.inputparams.min or 0)
		local maxselect = math.max(0, param.inputparams.max or defaultmax)
		local curvalue = tonumber(param.value)
		local startvalue = param.inputparams.startvalue
		local step = (param.inputparams.step and (param.inputparams.step >= 1)) and param.inputparams.step or 1
		local usetimeformat = false

		local suffix = ""
		if param.type == "length" then
			if param.inputparams.step and (param.inputparams.step >= 1000) then
				suffix = ReadText(1001, 108)
				minselect = math.floor(minselect / 1000)
				maxselect = math.floor(maxselect / 1000)
				curvalue = curvalue and math.floor(curvalue / 1000)
				startvalue = startvalue and math.floor(startvalue / 1000)
				step = math.ceil(step / 1000)
			else
				suffix = ReadText(1001, 107)
			end
		elseif param.type == "time" then
			suffix = ReadText(1001, 103)
			usetimeformat = true
			minselect = math.floor(minselect / 60)
			maxselect = math.floor(maxselect / 60)
			curvalue = curvalue and math.floor(curvalue / 60)
			startvalue = startvalue and math.floor(startvalue / 60)
			step = math.ceil(step / 60)
		elseif param.type == "money" then
			suffix = ReadText(1001, 101)
		end

		local useinfinite = false
		if param.hasinfinitevalue then
			useinfinite = true
			infinitevalue = param.infinitevalue
		end

		local slidercellProperties = {
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			readOnly = true,
			min       = minselect,
			max       = maxselect,
			start     = math.max(minselect, math.min(maxselect, curvalue or startvalue or minselect)),
			step      = step,
			suffix    = suffix,
			exceedMaxValue = false,
			hideMaxValue = param.hasinfinitevalue,
			useInfiniteValue = useinfinite,
			infiniteValue = infinitevalue,
			useTimeFormat = usetimeformat,
		}

		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3)
		row[menu.infoTableData[instance].hasloop and 4 or 2]:createText(paramtext)
		row[5]:setColSpan(8):createSliderCell(slidercellProperties):setText("", { fontsize = config.mapFontSize })
	elseif param.type == "bool" then
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		local rawvalue = param.value ~= 0
		if ismissing then
			rawvalue = false
		end
		row[5]:createCheckBox(rawvalue, { active = false, width = config.mapRowHeight })
	else
		local row = ftable:addRow({ "failure", failureidx, paramidx, listidx }, { interactive = false })
		if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == failureidx) and (selectedorder[3] == paramidx) and (selectedorder[4] == listidx) then
			menu.selectedRows["infotable" .. instance] = row.index
			menu.selectedCols["infotable" .. instance] = nil
		end
		row[menu.infoTableData[instance].hasloop and 4 or 2]:setColSpan(menu.infoTableData[instance].hasloop and 1 or 3):createText(paramtext)
		row[5]:setColSpan(8)
		local text = value and tostring(value) or ""
		local height = math.max(config.mapRowHeight, math.ceil(C.GetTextHeight(text, Helper.standardFont, Helper.standardFontSize, row[5]:getWidth())) + Helper.borderSize)
		row[5]:createButton({ active = false, height = height }):setText(text, { halign = "center", y = (height - config.mapRowHeight) / 2 })
	end
end

function menu.copyDefaultOrderForPlanning(instance)
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
		C.CreateOrder(menu.infoSubmenuObject, menu.infoTableData[instance].defaultorder.orderdef, true)
		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			menu.infoTableData[instance].planneddefaultorder.state = ffi.string(buf.state)
			menu.infoTableData[instance].planneddefaultorder.statename = ffi.string(buf.statename)
			menu.infoTableData[instance].planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			menu.infoTableData[instance].planneddefaultorder.actualparams = tonumber(buf.actualparams)
			menu.infoTableData[instance].planneddefaultorder.enabled = buf.enabled
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = true

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == menu.infoTableData[instance].planneddefaultorder.orderdef) then
					menu.infoTableData[instance].planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end

		menu.closeContextMenu()
		menu.infoTablePersistentData[instance].orderqueuemode = { mode = "plandefaultorder", curobject = menu.infoSubmenuObject }
	else
		DebugError("menu.copyDefaultOrderForPlanning: function called with invalid object: " .. ffi.string(C.GetComponentName(menu.infoSubmenuObject)) .. " " .. tostring(menu.infoSubmenuObject))
	end

	CopyDefaultOrderParamsForPlanning(menu.infoSubmenuObject)
	menu.refreshInfoFrame()
end

function menu.createOrdersMenuHeader(frame, instance)
	-- sync with tab table in menu.createOrderQueue()
	local orderHeaderTable
	if instance == "left" then
		menu.orderHeaderTable = frame:addTable(#config.infoCategories + 1, { tabOrder = 1, reserveScrollBar = false })
		orderHeaderTable = menu.orderHeaderTable
	elseif instance == "right" then
		menu.orderHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1, reserveScrollBar = false })
		orderHeaderTable = menu.orderHeaderTableRight
	end

	local count = 0
	for i, entry in ipairs(config.infoCategories) do
		if entry.empty then
			count = count + 0.5
		else
			count = count + 1
		end
	end

	local extraColWidth = Helper.borderSize + 1
	local sideBarWidth = menu.sideBarWidth
	if (count * menu.sideBarWidth + (#config.infoCategories - 1) * Helper.borderSize + extraColWidth) > frame.properties.width then
		sideBarWidth = math.floor((frame.properties.width - (#config.infoCategories - 1) * Helper.borderSize - extraColWidth) / count)
	end

	for i, entry in ipairs(config.infoCategories) do
		if entry.empty then
			orderHeaderTable:setColWidth(i, sideBarWidth / 2, false)
		else
			orderHeaderTable:setColWidth(i, sideBarWidth, false)
		end
	end

	local row = orderHeaderTable:addRow("orders_tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(config.infoCategories) do
		if not entry.empty then
			local bgcolor = Color["row_title_background"]
			local color = Color["icon_normal"]
			if entry.category == menu.infoMode[instance] then
				bgcolor = Color["row_background_selected"]
			end

			local shown = true
			if entry.category == "orderqueue_advanced" then
				if C.IsMasterVersion() and (C.GetConfigSetting("advancedorderqueue") <= 0) then
					shown = false
				end
			end

			if shown then
				local loccount = count
				row[loccount]:createButton({ active = menu.isInfoModeValidFor(menu.infoSubmenuObject, entry.category), height = sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				row[loccount].handlers.onClick = function () return menu.buttonInfoSubMode(entry.category, loccount, instance) end
				count = count + 1
			end
		else
			count = count + 1
		end
	end

	if menu.selectedRows["orderHeaderTable" .. instance] then
		orderHeaderTable.properties.defaultInteractiveObject = true
		orderHeaderTable:setSelectedRow(menu.selectedRows["orderHeaderTable" .. instance])
		if menu.isInfoModeValidFor(menu.infoSubmenuObject, menu.infoMode[instance]) then
			orderHeaderTable:setSelectedCol(menu.selectedCols["orderHeaderTable" .. instance] or 0)
		end
		menu.selectedRows["orderHeaderTable" .. instance] = nil
		menu.selectedCols["orderHeaderTable" .. instance] = nil
	end

	return orderHeaderTable
end

function menu.createResponsesForControllable(ftable, controllable, textproperties, mode, yoffset, instance)
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(controllable, "standingorders")
	local faction, primarypurpose = GetComponentData(controllable, "owner", "primarypurpose")
	if C.IsComponentClass(controllable, "ship") then
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 8362), Helper.headerRowCenteredProperties)

		for _, signalentry in ipairs(menu.signals) do
			local signalid = signalentry.id
			local defask = false
			local defresponse = ""
			local deffactresponse = ""
			local hasownresponse = false
			if isvalid then
				defask = C.GetAskToSignalForControllable(signalid, controllable)
				defresponse = ffi.string(C.GetDefaultResponseToSignalForControllable(signalid, controllable))
				deffactresponse = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, primarypurpose))
				hasownresponse = C.HasControllableOwnResponse(controllable, signalid)
			end
			local deffactresponsename = ""

			local locresponses = {}
			for _, responseentry in ipairs(signalentry.responses) do
				if responseentry.id == deffactresponse then
					deffactresponsename = responseentry.name
					break
				end
			end
			for _, responseentry in ipairs(signalentry.responses) do
				table.insert(locresponses, { id = responseentry.id, text = responseentry.name, text2 = (deffactresponse ~= responseentry.id) and ("[" .. ReadText(1001, 8366) .. ReadText(1001, 120) .. " " .. deffactresponsename .. "]") or "", icon = "", displayremoveoption = false })
			end
			--table.insert(locresponses, { id = "reset", text = ReadText(1001, 9311), icon = "", displayremoveoption = false })	-- Reset standing orders of this ship for this scenario

			row = ftable:addRow(false, {  })
			row[1]:setColSpan(8):createText(ReadText(1001, 9321) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default response to, :

			local rowdata = "orders_" .. tostring(signalid) .. "_global"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetOverride(controllable, signalid, mode, checked) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

			local rowdata = "orders_" .. tostring(signalid) .. "_response"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:setColSpan(8):createDropDown(locresponses, { height = config.mapRowHeight, startOption = defresponse, active = isvalid and hasownresponse }):setTextProperties({fontsize = config.mapFontSize}):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
			row[1].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(_, newresponseid, controllable, signalid, mode) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			local rowdata = "orders_" .. tostring(signalid) .. "_ask"
			row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(defask, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid and hasownresponse })
			row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(controllable, signalid, mode) end
			row[2]:setColSpan(7):createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs
			row[2].properties.color = hasownresponse and Color["text_normal"] or Color["text_inactive"]

			ftable:addEmptyRow()
		end
	end

	if C.IsComponentClass(controllable, "ship") or C.IsComponentClass(controllable, "station") then
		-- resupply
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 7722) or ReadText(1001, 7724), Helper.headerRowCenteredProperties)

		local curOption = Helper.round(C.GetDefensibleLoadoutLevel(controllable), 1)
		local hasownresponse = isvalid and (curOption ~= -1)
		local component = controllable
		while curOption == -1 do
			component = GetCommander(component)
			if component then
				curOption = Helper.round(C.GetDefensibleLoadoutLevel(ConvertIDTo64Bit(component)), 1)
			else
				curOption = Helper.round(C.GetPlayerGlobalLoadoutLevel(), 1)
				break
			end
		end

		local rowdata = "orders_resupply_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetResupplyOverride(controllable, checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = 0,   text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			{ id = 0.1, text = ReadText(1001, 7736), icon = "", displayremoveoption = false },
			{ id = 0.5, text = ReadText(1001, 7737), icon = "", displayremoveoption = false },
			{ id = 1.0, text = ReadText(1001, 7738), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_resupply", {})
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersResupply(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		ftable:addEmptyRow()

		-- blacklists
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(C.IsComponentClass(controllable, "ship") and ReadText(1001, 9143) or ReadText(1001, 9178), Helper.headerRowCenteredProperties)

		local blacklists = Helper.getBlackLists()

		local purpose = GetComponentData(controllable, "primarypurpose")
		local group = ((purpose == "fight") or (purpose == "auxiliary")) and "military" or "civilian"
		local types = {
			{ type = "sectortravel",	name = ReadText(1001, 9165) },
			{ type = "sectoractivity",	name = ReadText(1001, 9166) },
			{ type = "objectactivity",	name = ReadText(1001, 9167) },
		}
		for i, entry in ipairs(types) do
			row = ftable:addRow(false, {  })
			row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120), textproperties)

			local hasownlist = isvalid and C.HasControllableOwnBlacklist(controllable, entry.type)
			local blacklistid = C.GetControllableBlacklistID(controllable, entry.type, group)

			local rowdata = "orders_blacklist_" .. entry.type .. "_global"
			local row = ftable:addRow({ rowdata }, {  })
			if selectedorder and (selectedorder[1] == rowdata) then
				menu.setrow = row.index
				menu.setcol = nil
			end
			row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetBlacklistOverride(controllable, entry.type, checked) end
			row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

			local locresponses = {
				{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
			}
			for _, blacklist in ipairs(blacklists) do
				if blacklist.type == entry.type then
					table.insert(locresponses, { id = blacklist.id, text = blacklist.name, icon = "", displayremoveoption = false })
				end
			end
			local row = ftable:addRow("orders_resupply", {})
			row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (blacklistid ~= 0) and blacklistid or -1, active = isvalid and hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersBlacklist(controllable, entry.type, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8413) }):setIcon("menu_edit")
			row[8].handlers.onClick = function () return menu.buttonEditBlacklist(C.GetControllableBlacklistID(controllable, entry.type, group)) end

			ftable:addEmptyRow()
		end

		-- fight rules
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 7753), Helper.headerRowCenteredProperties)

		local fightrules = Helper.getFightRules()

		local hasownrule = isvalid and C.HasControllableOwnFightRule(controllable, "attack")
		local fightruleid = C.GetControllableFightRuleID(controllable, "attack")

		local rowdata = "orders_fightrule_attack_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:createCheckBox(not hasownrule, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetFightRuleOverride(controllable, "attack", checked) end
		row[2]:setColSpan(7):createText(GetCommander(controllable) and ReadText(1001, 7723) or ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
		}
		for _, fightrule in ipairs(fightrules) do
			table.insert(locresponses, { id = fightrule.id, text = fightrule.name, icon = "", displayremoveoption = false })
		end
		local row = ftable:addRow("orders_resupply", {})
		row[1]:setColSpan(7):createDropDown(locresponses, { startOption = (fightruleid ~= 0) and fightruleid or -1, active = isvalid and hasownrule }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersFightRule(controllable, "attack", id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
		row[8]:createButton({ mouseOverText = ReadText(1026, 8414) }):setIcon("menu_edit")
		row[8].handlers.onClick = function () return menu.buttonEditFightRule(C.GetControllableFightRuleID(controllable, "attack")) end
	end

	-- ship trade prices & restrictions
	if C.IsComponentClass(controllable, "ship") then
		ftable:addEmptyRow()

		-- trade loop cargo reservations
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 11642), Helper.headerRowCenteredProperties)

		local rowdata = "orders_cargoreservations_global"
		local row = ftable:addRow({ rowdata }, {  })
		if selectedorder and (selectedorder[1] == rowdata) then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local hasownresponse = C.HasShipTradeLoopCargoReservationOverride(controllable)
		local curOption = C.GetShipTradeLoopCargoReservationSetting(controllable) and "on" or "off"
		row[1]:createCheckBox(not hasownresponse, { width = config.mapRowHeight, height = config.mapRowHeight, active = isvalid })
		row[1].handlers.onClick = function(_, checked) return menu.checkboxOrdersSetCargoReservations(controllable, checked) end
		row[2]:setColSpan(7):createText(ReadText(1001, 8367), textproperties)

		local locresponses = {
			{ id = "off",   text = ReadText(1001, 7726),  icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3276) },
			{ id = "on",    text = ReadText(1001, 11643), icon = "", displayremoveoption = false },
		}
		local row = ftable:addRow("orders_cargoreservations", {  })
		row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = curOption, active = isvalid and hasownresponse }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownOrdersCargoReservations(controllable, id) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

		if GetComponentData(controllable, "issupplyship") then
			ftable:addEmptyRow()

			-- preferred build method
			local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(controllable))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = ftable:addRow({ rowdata }, {  })
			row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(controllable, checked, curglobalsetting) end
			row[2]:setColSpan(7):createText(ReadText(1001, 8367))

			local row = ftable:addRow("info_buildrule", {  })
			row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(controllable, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			ftable:addEmptyRow()

			local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 7725), Helper.headerRowCenteredProperties)

			-- trade rule
			local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", "") or C.HasContainerOwnTradeRule(controllable, "sell", "")
			local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", "")
			if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", "") then
				DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", "")))
			end
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(8):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
			-- global
			local row = ftable:addRow("order_wares_global", {  })
			row[1]:setColSpan(7):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
			row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
			row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked) end
			-- current
			local row = ftable:addRow("order_wares_current", {  })
			row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, "", true) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
			row[8].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(controllable, "buy", "")) end

			local row = ftable:addRow(false, {})
			row[1]:setColSpan(8):createText("")

			local wares = {}
			local n = C.GetNumMaxProductionStorage(controllable)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, controllable)
			for i = 0, n - 1 do
				table.insert(wares, ffi.string(buf[i].wareid))
			end
			table.sort(wares, Helper.sortWareName)

			local reservations = {}
			local n = C.GetNumContainerWareReservations2(controllable, false, false, true)
			local buf = ffi.new("WareReservationInfo2[?]", n)
			n = C.GetContainerWareReservations2(buf, n, controllable, false, false, true)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				if reservations[ware] then
					table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta })
				else
					reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta } }, [invbuyflag] = {} }
				end
			end
			for _, data in pairs(reservations) do
				table.sort(data.buyoffer, menu.etaSorter)
				table.sort(data.selloffer, menu.etaSorter)
			end

			for _, ware in ipairs(wares) do
				local name, minprice, maxprice = GetWareData(ware, "name", "minprice", "maxprice")
				local isextended = menu.isOrderExtended(controllable, ware, instance)

				-- ware
				local rowdata = "orders_wares_" .. ware .. "_header"
				local row = ftable:addRow({ rowdata }, {  })
				if selectedorder and (selectedorder[1] == rowdata) then
					menu.setrow = row.index
					menu.setcol = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(controllable, ware, instance, row.index, 1) end
				row[2]:setColSpan(5):createText(name)
				if (C.GetContainerTradeRuleID(controllable, "buy", ware) > 0) or (C.GetContainerTradeRuleID(controllable, "sell", ware) > 0) then
					row[7]:setColSpan(2):createText("\27[lso_error]", { halign = "right", color = Color["text_warning"] })
				end

				if isextended then
					-- trade rule
					local hasownlist = C.HasContainerOwnTradeRule(controllable, "buy", ware) or C.HasContainerOwnTradeRule(controllable, "sell", ware)
					local traderuleid = C.GetContainerTradeRuleID(controllable, "buy", ware)
					if traderuleid ~= C.GetContainerTradeRuleID(controllable, "sell", ware) then
						DebugError("menu.createResponsesForControllable(): Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(controllable, "sell", ware)))
					end
					local row = ftable:addRow(nil, {  })
					row[2]:setColSpan(7):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
					-- global
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradeglobal", {  })
					row[2]:setColSpan(6):createText(ReadText(1001, 11031) .. ReadText(1001, 120), textproperties)
					row[8]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
					row[8].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(controllable, "trade", checked, ware) end
					-- current
					local row = ftable:addRow("orders_wares_" .. ware .. "_tradecurrent", {  })
					row[2]:setColSpan(6):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
					row[2].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(controllable, "trade", id, ware, true) end
					row[2].handlers.onDropDownActivated = function () menu.noupdate = true end
					row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
					row[8].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(controllable, "buy", ware)) end

					ftable:addEmptyRow(config.mapRowHeight / 2)

					local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(controllable, ware, true))))
					local haspriceoverride = HasContainerWarePriceOverride(controllable, ware, true)
					-- automatic pricing
					local rowdata = "orders_wares_" .. ware .. "_autoprice"
					local row = ftable:addRow({ rowdata }, {  })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(6):createText(ReadText(1001, 8402) .. ReadText(1001, 120))
					row[8]:createCheckBox(not haspriceoverride, { height = config.mapRowHeight })
					row[8].handlers.onClick = function (_, checked) return menu.checkboxStorageWarePriceOverride(controllable, ware, true, currentprice, checked) end
					-- price
					local rowdata = "orders_wares_" .. ware .. "_price"
					local row = ftable:addRow({ rowdata }, {  })
					if selectedorder and (selectedorder[1] == rowdata) then
						menu.setrow = row.index
						menu.setcol = nil
					end
					row[2]:setColSpan(7):createSliderCell({
						height = Helper.standardTextHeight,
						valueColor = haspriceoverride and Color["slider_value"] or Color["slider_value_inactive"],
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
					})
					row[2].handlers.onSliderCellChanged = function(_, value) return menu.slidercellStorageWarePriceOverride(controllable, ware, true, value) end
					-- reservations
					if reservations[ware] and (#reservations[ware].buyoffer > 0) then
						-- title
						local row = ftable:addRow(nil, {  })
						row[2]:setColSpan(7):createText(ReadText(1001, 7946) .. ReadText(1001, 120))
						for _, reservation in ipairs(reservations[ware].buyoffer) do
							local row = ftable:addRow(false, {  })
							local name = ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")"
							row[2]:setColSpan(5):createText(function () return "   " .. Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
							row[7]:setColSpan(2):createText(ConvertIntegerString(reservation.amount, true, 0, false), { halign = "right" })
						end
					end
				end
			end
		end
	end
end

function menu.createOrderQueue(frame, mode, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if menu.infoTablePersistentData[instance].planneddefaultorderloop and (menu.infoTablePersistentData[instance].planneddefaultorderloop.curobject ~= menu.infoSubmenuObject) then
		menu.infoTablePersistentData[instance].planneddefaultorderloop = nil
	end
	if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.curobject ~= menu.infoSubmenuObject) then
		C.RemovePlannedDefaultOrder(menu.infoTablePersistentData[instance].orderqueuemode.curobject)
		menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
		menu.infoTablePersistentData[instance].orderqueuemode = nil
	end

	-- Current orders
	infoTableData.orders = {}
	infoTableData.defaultorder = {}
	infoTableData.planneddefaultorder = {}

	if menu.isInfoModeValidFor(menu.infoSubmenuObject, mode) then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			entry.istemporder = buf[i].istemporder
			table.insert(infoTableData.orders, entry)
		end

		local buf = ffi.new("Order")
		if C.GetDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.defaultorder.state = ffi.string(buf.state)
			infoTableData.defaultorder.statename = ffi.string(buf.statename)
			infoTableData.defaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.defaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.defaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.defaultorder.orderdef) then
					infoTableData.defaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		end

		local buf = ffi.new("Order")
		if C.GetPlannedDefaultOrder(buf, menu.infoSubmenuObject) then
			infoTableData.planneddefaultorder.state = ffi.string(buf.state)
			infoTableData.planneddefaultorder.statename = ffi.string(buf.statename)
			infoTableData.planneddefaultorder.orderdef = ffi.string(buf.orderdef)
			infoTableData.planneddefaultorder.actualparams = tonumber(buf.actualparams)
			infoTableData.planneddefaultorder.enabled = buf.enabled

			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == infoTableData.planneddefaultorder.orderdef) then
					infoTableData.planneddefaultorder.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Planned default order of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. ffi.string(buf.orderdef) .. "' [Florian]")
			end
		elseif (not menu.infoTablePersistentData[instance].planneddefaultorderloop) and menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.infoTablePersistentData[instance].planneddefaultorderiscopy = nil
			menu.infoTablePersistentData[instance].orderqueuemode = nil
		end

		infoTableData.commander = GetCommander(menu.infoSubmenuObject)

		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.infoSubmenuObject, hasloop)
		infoTableData.hasloop = hasloop[0]
		infoTableData.currentIdx = tonumber(C.GetOrderQueueCurrentIdx(menu.infoSubmenuObject))
	end

	if not selectedorder then
		menu.setcol = nil
	else
		if selectedorder.object ~= menu.infoSubmenuObject then
			selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
			menu.topRows["infotable" .. instance] = nil
			menu.selectedRows["infotable" .. instance] = nil
			menu.selectedCols["infotable" .. instance] = nil
		end
	end

	local numcols = 12
	local ftable = frame:addTable(numcols, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, Helper.standardTextHeight)
	ftable:setColWidth(3, 2 * Helper.standardTextHeight)
	ftable:setColWidth(4, frame.properties.width / 3 - 4 * Helper.scaleY(Helper.standardTextHeight) - 3 * Helper.borderSize, false)
	ftable:setColWidth(5, Helper.standardTextHeight)
	ftable:setColWidth(6, Helper.standardTextHeight)
	ftable:setColWidth(7, frame.properties.width / 3 - 2 * Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidth(9, Helper.standardTextHeight)
	ftable:setColWidth(10, Helper.standardTextHeight)
	ftable:setColWidth(11, Helper.standardTextHeight)
	ftable:setColWidth(12, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 10)
	ftable:setDefaultColSpan(5, 3)

	-- isvalid == controllable.isclass.ship and controllable.isplayerowned
	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local color = Color["text_normal"]
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numcols):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numcols):createText((mode == "orderqueue") and ReadText(1001, 8360) or ReadText(1001, 8361), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Color["row_title_background"] })
	row[numcols]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[numcols].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(numcols - 1):setColSpan(7):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[8]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[8].properties.color = color
		row[8].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(numcols - 1):setColSpan(numcols - 1):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	local maxvisibleheight

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") then
		---- pilot info ----
		local pilot, formation, isplayerowned = GetComponentData(menu.infoSubmenuObject, "assignedpilot", "formation", "isplayerowned")
		local pilot64 = ConvertIDTo64Bit(pilot)
		local isplayer = pilot64 == C.GetPlayerID()
		local commandername, commandercolor = "-", Color["text_normal"]
		if infoTableData.commander then
			commandername, commandercolor = menu.getContainerNameAndColors(infoTableData.commander, 0, false, false)
		end
		if isvalid and isplayerowned then
			local name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", ReadText(1001, 4847), {}
			if pilot and IsValidComponent(pilot) then
				name, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
			end
			--- name ---
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(postname .. ReadText(1001, 120))
			row[5]:setColSpan(8):createText(name)
			--- skills ---
			local adjustedskill = pilot and math.floor(C.GetEntityCombinedSkill(pilot64, nil, isplayer and "playerpilot" or "aipilot") * 15 / 100) or 0
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(ReadText(1001, 9124) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
			row[5]:setColSpan(8):createText(pilot and Helper.displaySkill(adjustedskill) or "-", { color = pilot and Color["text_skills"] or nil, mouseOverText = ReadText(1026, 2) })
			--- commander ---
			local row = ftable:addRow({ infoTableData.commander }, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			if infoTableData.commander then
				row[5]:setColSpan(7):createText(commandername, { color = commandercolor })
				row[12]:createButton():setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[12].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end
			else
				row[5]:setColSpan(8):createText(commandername, { color = commandercolor })
			end
			--- current ai command ---
			if pilot and IsValidComponent(pilot) then
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[1]:setColSpan(4):createText(ReadText(1001, 78) .. ReadText(1001, 120))
				local unlocked_operator_commands = IsInfoUnlockedForPlayer(menu.infoSubmenuObject, "operator_commands")
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[5]:setColSpan(8):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)))
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[3]:setColSpan(8):createText(Helper.unlockInfo(unlocked_operator_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)))
			end
			--- subordinates ---
			local subordinates = GetSubordinates(menu.infoSubmenuObject, nil, true)
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createText(#subordinates)
			--- formation ---
			local n = C.GetNumFormationShapes()
			local buf = ffi.new("UIFormationInfo[?]", n)
			n = C.GetFormationShapes(buf, n)
			local formationshapes = {}
			for i = 0, n - 1 do
				-- skill range from 0-5 -> 0-15
				table.insert(formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape), requiredSkill = buf[i].requiredSkill * 3 })
			end
			table.sort(formationshapes, Helper.sortName)
			local formationOptions = {}
			for _, data in ipairs(formationshapes) do
				table.insert(formationOptions, { id = data.shape, text = data.name, text2 = Helper.displaySkill(data.requiredSkill), icon = "", displayremoveoption = false, active = data.requiredSkill <= adjustedskill })
			end
			local row = ftable:addRow({ "formation" }, {  })
			if selectedorder and (selectedorder[1] == "formation") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8307) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createDropDown(formationOptions, { height = config.mapRowHeight, startOption = formation, active = isvalid and (#subordinates > 0), textOverride = (#subordinates == 0) and ReadText(20223, 11) or nil }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, color = Color["text_skills"], halign = "right" })
			row[5].handlers.onDropDownConfirmed = menu.dropdownBehaviourFormation
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
		end

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(numcols):createText(" ")

		---- actual order queue ----
		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numcols):createText((infoTableData.hasloop and (utf8.char(8734) .. " ") or "") .. ((mode == "orderqueue") and ReadText(1001, 3225) or ReadText(1001, 8318)) .. (infoTableData.hasloop and (" [" .. ReadText(1001, 11270) .. "]") or ""), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_orderqueue"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		menu.displayOrderFailureSection(ftable, instance)

		if infoTableData.hasloop then
			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			if #infoTableData.orders > 0 then
				local nontempcounter = 0
				for _, order in ipairs(infoTableData.orders) do
					if not order.istemporder then
						nontempcounter = nontempcounter + 1
					end
				end
				row[1]:setColSpan(numcols):createText(string.format(ReadText(1001, 11271), nontempcounter) .. ReadText(1001, 120), { font = Helper.standardFontBold })
			else
				row[1]:setColSpan(numcols):createText(ReadText(1001, 11272), { font = Helper.standardFontBold })
			end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end

		local row = ftable:addEmptyRow(1)
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		if #infoTableData.orders > 15 then
			maxvisibleheight = ftable:getFullHeight() + 15 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		end

		--- orders ---
		infoTableData.disabledmarker = nil
		local firstoverride = true
		local nontempcounter = 0
		for i, order in ipairs(infoTableData.orders) do
			local nextorder = infoTableData.orders[i + 1]
			if i == 1 and ((order.state == "setup") or (order.state == "disabled")) then
				infoTableData.disabledmarker = 1
			elseif (not infoTableData.disabledmarker) and ((nextorder and ((nextorder.state == "setup") or (nextorder.state == "disabled"))) or (i == #infoTableData.orders)) then
				infoTableData.disabledmarker = i + 1
			end
			-- red line
			if infoTableData.disabledmarker == i then
				if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
					local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[2]:setColSpan(numcols - 1):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
				end

				local row = ftable:addRow(false, {  })
				row[1]:setColSpan(numcols):createText(ReadText(1001, 8319), { halign = "center", titleColor = Color["text_negative"] })
			end

			-- orderdef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if (orderdef.id == order.orderdef) then
					order.orderdefref = orderdef
					found = true
					break
				end
			end
			if not found then
				break
			end

			-- params
			order.params = GetOrderParams(menu.infoSubmenuObject, i)

			-- hasrequiredparams
			order.hasrequiredparams = false
			for _, param in ipairs(order.params) do
				if param.type ~= "internal" then
					order.hasrequiredparams = true
					break
				end
			end

			-- sync point
			order.syncPointInfo = ffi.new("SyncPointInfo2")
			order.hasSyncPoint = C.GetSyncPointInfo2(menu.infoSubmenuObject, i, order.syncPointInfo)

			local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i, instance)

			-- sort out parameters for AdjustOrder()
			local oldidx, newupidx, newdownidx, enableup, enabledown
			oldidx = i
			if infoTableData.disabledmarker == i + 1 then
				newupidx = i - 1
				newdownidx = i
				enableup = true
				enabledown = false
			elseif infoTableData.disabledmarker == i then
				newupidx = i
				newdownidx = i + 1
				enableup = true
				enabledown = false
			else
				newupidx = i - 1
				newdownidx = i + 1
				enableup = order.enabled
				enabledown = order.enabled
			end

			-- state color
			local statecolor = "\27X"
			if order.state == "setup" then
				statecolor = ColorText["text_negative"]
			elseif order.state == "disabled" then
				statecolor = ColorText["text_warning"]
			end

			local row = ftable:addRow({ i }, {  })
			if selectedorder and (selectedorder[1] == i) then
				menu.selectedRows["infotable" .. instance] = row.index
			end
			-- loop indicator
			if infoTableData.hasloop then
				if i == infoTableData.currentIdx then
					row[1]:createIcon("widget_arrow_right_01", { height = config.mapRowHeight, width = config.mapRowHeight })
				end
			end
			-- extend
			row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
			row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i, instance, row.index, infoTableData.hasloop and 2 or 1) end
			-- loop counter
			if infoTableData.hasloop then
				if not order.istemporder then
					nontempcounter = nontempcounter + 1
					row[3]:createText(nontempcounter, { halign = "right" })
				end
			end
			-- name
			local colspan = (firstoverride and order.isoverride) and 1 or 2
			if not infoTableData.hasloop then
				colspan = colspan + 2
			end
			local name = order.orderdefref.name
			local mouseovertext
			if order.isoverride then
				name = name .. " " .. ColorText["text_error"] .. "[" .. ReadText(1001, 11219) .. "]"
			elseif order.istemporder then
				name = name .. " " .. ColorText["text_inactive"] .. "[" .. ReadText(1001, 11283) .. "]"
				mouseovertext = ReadText(1026, 3261)
			end
			local id = C.GetOrderID(menu.infoSubmenuObject, i)
			local failure = infoTableData.looporderfailures[tostring(id)]
			if failure then
				menu.cachedOrderFailures[tostring(id)] = failure
			elseif (order.state ~= "started") and (order.state ~= "critical") then
				menu.cachedOrderFailures[tostring(id)] = nil
			end
			row[infoTableData.hasloop and 4 or 2]:setColSpan(colspan):createText((failure and (ColorText["text_warning"] .. "\27[warning]\27X ") or "") .. name, { x = infoTableData.hasloop and 0 or nil, mouseOverText = failure and (ColorText["text_warning"] .. failure.message) or mouseovertext })
			-- override
			if firstoverride and order.isoverride then
				local attacker
				if order.orderdefref.id == "Flee" then
					if order.params[6] and order.params[6].value then
						local value = ConvertIDTo64Bit(order.params[6].value)
						if value ~= 0 then
							attacker = value
						end
					end
				elseif order.orderdefref.id == "Attack" then
					if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
						attacker = order.params[1].value
					end
				elseif order.orderdefref.id == "Wait" then
					if order.params[5] and order.params[5].value then
						local value = ConvertIDTo64Bit(order.params[5].value)
						if value ~= 0 then
							attacker = value
						end
					end
				end

				local overrideOrderOptions = {}
				if order.orderdefref.id ~= "Attack" then
					table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Flee" then
					table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
				end
				if order.orderdefref.id ~= "Wait" then
					table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
				end

				row[5]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
				row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
				row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

				firstoverride = false
			end
			-- state
			row[8]:createText(statecolor .. " [" .. order.statename .. "]", { halign = "right" })
			-- weapon config
			row[9]:createButton({ active = isvalid and not isplayeroccupiedship, mouseOverText = ReadText(1001, 1105) }):setText("*", { halign = "center" })
			row[9].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, i, false, instance) end
			-- up
			row[10]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newupidx, enableup, false, true), mouseOverText = ReadText(1026, 3264) .. "\n".. ffi.string(C.GetDisplayedModifierKey("ctrl")) .. " - " .. ReadText(1026, 3277) }):setIcon("table_arrow_inv_up")
			row[10].handlers.onClick = function (_, _, modified) return menu.buttonOrderUp(i, instance, modified) end
			row[10].properties.uiTriggerID = "moveorderup"
			-- down
			row[11]:createButton({ active = isvalid and (not isplayeroccupiedship) and C.AdjustOrder(menu.infoSubmenuObject, oldidx, newdownidx, enabledown, false, true), mouseOverText = ReadText(1026, 3265) .. "\n" .. ffi.string(C.GetDisplayedModifierKey("ctrl")) .. " - " .. ReadText(1026, 3278) }):setIcon("table_arrow_inv_down")
			row[11].handlers.onClick = function (_, _, modified) return menu.buttonOrderDown(i, instance, modified) end
			row[11].properties.uiTriggerID = "moveorderdown"
			-- remove
			row[12]:createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, i, false, true), helpOverlayID = "map_ordercancel", helpOverlayText = " ", helpOverlayHighlightOnly = true, mouseOverText = ReadText(1026, 3263) }):setText("x", { halign = "center" })
			row[12].handlers.onClick = function () return menu.buttonRemoveOrder(i, instance) end
			row[12].properties.uiTriggerID = "deleteorder"
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			if isextended then
				if failure then
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 9 or 11):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. failure.message, { color = Color["text_warning"] })
				elseif menu.cachedOrderFailures[tostring(id)] then
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[infoTableData.hasloop and 4 or 2]:setColSpan(infoTableData.hasloop and 9 or 11):createText("  " .. Helper.getPassedTime(menu.cachedOrderFailures[tostring(id)].timestamp) .. " - " .. menu.cachedOrderFailures[tostring(id)].message, { color = Color["text_warning"] })
				end
				for j, param in ipairs(order.params) do
					if (not param.advanced) or (mode == "orderqueue_advanced") then
						if param.type == "list" then
							local playerreadonly = param.inputparams and param.inputparams.playerreadonly
							if param.value then
								for k, entry in ipairs(param.value) do
									local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
									menu.displayOrderParam(ftable, i, order, j, param2, k, instance)
								end
							end

							if playerreadonly ~= 1 then
								local row = ftable:addRow({ i, j, "new" }, {  })
								if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
									menu.selectedRows["infotable" .. instance] = row.index
									menu.selectedCols["infotable" .. instance] = nil
								end
								local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
								row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. string.format(ReadText(1001, 3235), param.text), { halign = "center" })
								row[2].handlers.onClick = function () return menu.buttonSetOrderParam(i, j, nil, nil, instance) end
							end
						elseif (param.type ~= "internal") then
							menu.displayOrderParam(ftable, i, order, j, param, nil, instance)
						end
					end
				end
				-- sync point option
				if (not order.hasSyncPoint) or (order.syncPointInfo.owningcontrollable == 0) then
					if (order.orderdefref.id == "MoveWait") or (order.orderdefref.id == "Wait") or (order.orderdefref.id == "DockAndWait") then
						local syncPointOptions = { [1] = { id = 0, text = ReadText(1001, 3236), icon = "", displayremoveoption = false } }
						for i = 1, 10 do
							table.insert(syncPointOptions, { id = i, text = Helper.getSyncPointName(i), icon = "", displayremoveoption = false })
						end

						local row = ftable:addRow({ i, nil, "syncoption" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncoption") then
							menu.selectedRows["infotable" .. instance] = row.index
							menu.selectedCols["infotable" .. instance] = nil
						end
						row[2]:setColSpan(3):createText("  " .. ReadText(1001, 3237))
						row[5]:setColSpan(8):createDropDown(syncPointOptions, { height = config.mapRowHeight, startOption = order.syncPointInfo.id, active = isvalid and (not isplayeroccupiedship) and order.isinfinite }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
						row[5].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownNewSyncPoint(i, id) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
					end
				end
			end

			-- sync point info
			if order.hasSyncPoint then
				local color = Color["text_failure"]
				if order.syncPointInfo.reached then
					color = Color["text_success"]
				end

				local row = ftable:addRow({ i, nil, "syncinfo" }, {  })
				if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncinfo") then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "syncpoint", instance)
				row[infoTableData.hasloop and 2 or 1]:createButton({ active = order.hasrequiredparams }):setText(isextended and "-" or "+", { halign = "center" })
				row[infoTableData.hasloop and 2 or 1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "syncpoint", instance, row.index, infoTableData.hasloop and 2 or 1) end

				if order.syncPointInfo.id > 0 then
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 9 or 10):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. Helper.getSyncPointName(order.syncPointInfo.id), { titleColor = color })
					row[numcols]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("x", { halign = "center" })
					row[numcols].handlers.onClick = function () return menu.buttonRemoveOrderSyncPoint(i, instance) end
				else
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 10 or 11):createText(ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(order.syncPointInfo.owningcontrollable)) .. " (" .. ffi.string(C.GetObjectIDCode(order.syncPointInfo.owningcontrollable)) .. ")", { titleColor = color })
				end

				if isextended then
					local row = ftable:addRow({ i, nil, "syncpointreleasesetting" }, {  })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointreleasesetting") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 9 or 10):createText("  " .. ReadText(1001, 11297) .. ReadText(1001, 120))
					if order.syncPointInfo.id > 0 then
						row[numcols]:createCheckBox(function () return C.GetSyncPointAutoRelease(order.syncPointInfo.id, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(order.syncPointInfo.id, checked, false) end
					else
						row[numcols]:createCheckBox(function () return C.GetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoReleaseFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, checked, false) end
					end

					local totalobjects, reachedobjects
					if order.syncPointInfo.id > 0 then
						totalobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, false)
						reachedobjects = C.GetNumObjectsWithSyncPoint(order.syncPointInfo.id, true)
					else
						totalobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, false)
						reachedobjects = C.GetNumObjectsWithSyncPointFromOrder(order.syncPointInfo.owningcontrollable, order.syncPointInfo.owningorderidx, true)
					end

					local row = ftable:addRow({ i, nil, "syncpointtrigger" }, {  })
					if selectedorder and (selectedorder[1] == i) and (selectedorder[3] == "syncpointtrigger") then
						menu.selectedRows["infotable" .. instance] = row.index
						menu.selectedCols["infotable" .. instance] = nil
					end
					row[infoTableData.hasloop and 3 or 2]:setColSpan(infoTableData.hasloop and 2 or 3):createText("  " .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects))
					row[5]:setColSpan(8):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(order.syncPointInfo) end
				end
			end
		end

		-- red line
		if (infoTableData.disabledmarker == nil) or (infoTableData.disabledmarker == (#infoTableData.orders + 1)) then
			if next(infoTableData.defaultorder) and (not infoTableData.hasloop) then
				local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(numcols - 1):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " " .. infoTableData.defaultorder.orderdefref.name, { font = Helper.standardFontBold })
			end

			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 8319), { halign = "center", titleColor = Color["text_negative"] })
		end

		local hasstartableorders = false
		local hasremoveableorders = false
		for i, order in ipairs(infoTableData.orders) do
			if C.RemoveOrder(menu.infoSubmenuObject, i, false, true) then
				hasremoveableorders = true
			end
			if order.state == "disabled" then
				hasstartableorders = true
				break;
			end
			if order.state == "setup" then
				break;
			end
		end

		if mode == "orderqueue_advanced" then
			local row = ftable:addRow({ "neworder" }, {  })
			if selectedorder and (selectedorder[1] == "neworder") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols):createButton({ active = isvalid and (not isplayeroccupiedship) and ((pilot64 ~= nil) and (pilot64 ~= 0)), mouseOverText = isplayeroccupiedship and ReadText(1026, 3224) or (((pilot64 == nil) or (pilot64 == 0)) and ReadText(1026, 3225) or "") }):setText(ReadText(1001, 3238), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonNewOrder(nil, false, instance) end
		end

		local row = ftable:addRow({ "buttons" }, {  })
		if selectedorder and (selectedorder[1] == "buttons") then
			menu.selectedRows["infotable" .. instance] = row.index
		end
		row[1]:setColSpan(4):createButton({ active = isvalid and hasremoveableorders }):setText(ReadText(1001, 3239), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonDeleteAllOrders(instance) end
		row[1].properties.uiTriggerID = "deleteallorders"
		row[8]:setColSpan(5):createButton({ active = isvalid and (not isplayeroccupiedship) and hasstartableorders }):setText(ReadText(1001, 3240), { halign = "center" })
		row[8].handlers.onClick = function () return menu.buttonStartOrders(instance) end
		row[8].properties.uiTriggerID = "startorderqueue"

		-- syncpoint overview
		local first = true
		for i = 1, 10 do
			local totalobjects = C.GetNumObjectsWithSyncPoint(i, false)
			local reachedobjects = C.GetNumObjectsWithSyncPoint(i, true)

			if totalobjects > 0 then
				if first then
					ftable:addEmptyRow(1)
					--- title ---
					local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(numcols):createText(ReadText(1001, 8323), Helper.headerRowCenteredProperties)
					first = false
				end
				local row = ftable:addRow({"sync", i}, {  })
				if selectedorder and (selectedorder[1] == "sync") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:setColSpan(4):createText(Helper.getSyncPointName(i) .. " (" .. string.format(ReadText(1001, 3229), reachedobjects, totalobjects) .. ")")
				row[5]:setColSpan(8):createButton({ active = (reachedobjects > 0) }):setText(ReadText(1001, 8324), { halign = "center" })
				local syncpointinfo = { id = i }
				row[5].handlers.onClick = function () return menu.buttonReleaseSyncPoint(syncpointinfo) end

				local row = ftable:addRow({"syncrelease", i}, {  })
				if selectedorder and (selectedorder[1] == "syncrelease") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[3]:setColSpan(9):createText(ReadText(1001, 11297) .. ReadText(1001, 120))
				row[numcols]:createCheckBox(function () return C.GetSyncPointAutoRelease(i, true) end, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[numcols].handlers.onClick = function(_, checked) return C.SetSyncPointAutoRelease(i, checked, false) end
			end
		end

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(numcols):createText(" ")

		---- assignment ----
		if infoTableData.commander and isvalid and (not isplayeroccupiedship) then
			--- title ---
			local row = ftable:addRow({ infoTableData.commander }, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols - 1):createText(string.format(ReadText(1001, 7803), Helper.convertColorToText(commandercolor) .. commandername), Helper.headerRowCenteredProperties)
			row[numcols]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
			row[numcols].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(infoTableData.commander), true) end

			local row = ftable:addRow({ "assignment" }, {  })
			if selectedorder and (selectedorder[1] == "assignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(4):createText(ReadText(1001, 8373) .. ReadText(1001, 120))

			local isstation = IsComponentClass(infoTableData.commander, "station")
			local isship = IsComponentClass(infoTableData.commander, "ship")
			local shiptype = GetComponentData(infoTableData.commander, "shiptype")
			local currentassignment, primarypurpose = GetComponentData(menu.infoSubmenuObject, "assignment", "primarypurpose")
			local asssignmentOptions = {}
			-- defence
			table.insert(asssignmentOptions, { id = "defence", text = ReadText(20208, 40301), icon = "", displayremoveoption = false })
			-- supplyfleet
			if isship and (primarypurpose == "auxiliary") and GetComponentData(menu.infoSubmenuObject, "cansupplyships") then
				table.insert(asssignmentOptions, { id = "supplyfleet", text = ReadText(20208, 40701), icon = "", displayremoveoption = false })
			end
			if isstation then
				-- trade
				table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, mouseovertext = (primarypurpose == "mine") and (ColorText["text_warning"] .. ReadText(1026, 8608)) or "" })
				if primarypurpose == "mine" then
					-- mining
					table.insert(asssignmentOptions, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false })
				else
					-- trade for build storage
					table.insert(asssignmentOptions, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false })
				end
				if primarypurpose == "salvage" then
					table.insert(asssignmentOptions, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false })
				end
			elseif isship then
				-- position defence
				local parentcommander = ConvertIDTo64Bit(GetCommander(infoTableData.commander))
				local subordinates = GetSubordinates(infoTableData.commander)
				local isfleetcommander = (not parentcommander) and (#subordinates > 0)
				if (shiptype == "carrier") and isfleetcommander then
					local hasintersectorgroup = C.HasSubordinateAssignment(ConvertIDTo64Bit(infoTableData.commander), "positiondefence")
					table.insert(asssignmentOptions, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false, active = hasintersectorgroup, mouseovertext = hasintersectorgroup and "" or ReadText(1026, 3270) })
				end
				-- attack and intercept
				table.insert(asssignmentOptions, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
				table.insert(asssignmentOptions, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
				local active = true
				local mouseovertext = ""
				local buf = ffi.new("Order")
				if not C.GetDefaultOrder(buf, ConvertIDTo64Bit(infoTableData.commander)) then
					active = false
					mouseovertext = ReadText(1026, 8606)
				end
				table.insert(asssignmentOptions, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
				
				-- start: aegs call-back
				if menu.uix_callbacks ["map_ship_assignments_insert"] then
					local data_o
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_ship_assignments_insert"]) do
						data_o = uix_callback (GetComponentData(infoTableData.commander, "macro"),primarypurpose)
						if data_o then
							table.insert(asssignmentOptions, data_o)
						end
					end
				end
				-- end: aegs call-back

				-- trade
				if shiptype == "resupplier" then
					table.insert(asssignmentOptions, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false })
				end
			end

			row[5]:setColSpan(8):createDropDown(asssignmentOptions, { height = config.mapRowHeight, startOption = currentassignment }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
			row[5].handlers.onDropDownConfirmed = function(_, newassignment) Helper.dropdownAssignment(_, menu.infoSubmenuObject, nil, nil, newassignment) end
			row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

			local row = ftable:addRow({ "removeassignment" }, {  })
			if selectedorder and (selectedorder[1] == "removeassignment") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols):createButton({ active = true }):setText(ReadText(1001, 7810), { halign = "center" })
			row[1].handlers.onClick = menu.buttonRemoveAssignment

			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(numcols):createText(" ")
		end

		---- default order ----
		local hasloop = infoTableData.hasloop or menu.infoTablePersistentData[instance].planneddefaultorderloop

		--- title ---
		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numcols):createText((hasloop and (utf8.char(8734) .. " ") or "") .. ReadText(1001, 8320), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "map_defaultorder"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false

		if menu.infoTablePersistentData[instance].orderqueuemode and (menu.infoTablePersistentData[instance].orderqueuemode.mode == "plandefaultorder") then
			menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
		else
			menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
		end
	else
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 11226), { wordwrap = true })
	end

	if maxvisibleheight then
		ftable.properties.maxVisibleHeight = maxvisibleheight
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	tabtable:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	ftable:addConnection(isleft and 3 or 2, isleft and 2 or 3)
end

function menu.displayOrderFailureSection(ftable, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	infoTableData.looporderfailures = {}

	local numcols = 12
	local found = false
	local n = C.GetNumOrderFailures(menu.infoSubmenuObject, infoTableData.hasloop == true)
	if n > 0 then
		local buf = ffi.new("OrderFailure[?]", n)
		n = C.GetOrderFailures(buf, n, menu.infoSubmenuObject, infoTableData.hasloop == true)
		for i = 0, n - 1 do
			local failure = buf[i]

			if failure.wasinloop then
				local entry = {}
				entry.message = ffi.string(failure.message)
				entry.timestamp = failure.timestamp
				infoTableData.looporderfailures[tostring(buf[i].orderid)] = entry
			else
				if not found then
					found = true
					-- failed behaviour
					local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(numcols):createText(ReadText(1001, 11621), Helper.subHeaderTextProperties)
				end

				local orderdefid = ffi.string(failure.orderdef)
				local orderfailuredef
				local found = false
				for _, orderdef in ipairs(menu.orderdefs) do
					if orderdef.id == orderdefid then
						orderfailuredef = orderdef
						found = true
						break
					end
				end
				if not found then
					DebugError("Order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
				end

				local isextended = menu.isOrderExtended(menu.infoSubmenuObject, i .. "failure", instance, true)
				local message = ffi.string(failure.message)
				-- name
				local row = ftable:addRow({ "failure", i }, {  })
				if selectedorder and (selectedorder[1] == "failure") and (selectedorder[2] == i) then
					menu.selectedRows["infotable" .. instance] = row.index
					menu.selectedCols["infotable" .. instance] = nil
				end
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendOrder(menu.infoSubmenuObject, i .. "failure", instance, row.index, 1) end
				row[2]:setColSpan(3):createText(orderfailuredef and orderfailuredef.name or "", { mouseOverText = ColorText["text_warning"] .. message })
				row[5]:setColSpan(7):createText("[" .. ReadText(1001, 8837) .. "]", { halign = "right", color = Color["text_warning"], mouseOverText = ColorText["text_warning"] .. message })
				row[12]:createButton({  }):setText("X", { halign = "center" })
				row[12].handlers.onClick = function () C.RemoveOrderFailure(menu.infoSubmenuObject, buf[i].id); menu.refreshInfoFrame(nil, 0) end
				if isextended then
					-- message
					local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
					row[2]:setColSpan(9):createText("  " .. Helper.getPassedTime(failure.timestamp) .. " - " .. message, { color = Color["text_warning"] })
					-- params
					local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
					for j, param in ipairs(params) do
						if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
							if param.type == "list" then
								if param.value then
									for k, entry in ipairs(param.value) do
										local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable }
										menu.displayFailureParam(ftable, i, j, param2, k, instance)
									end
								end
							elseif (param.type ~= "internal") then
								menu.displayFailureParam(ftable, i, j, param, nil, instance)
							end
						end
					end
				end
			end
		end
		if found then
			-- empty line
			local row = ftable:addEmptyRow()
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 11622), Helper.subHeaderTextProperties)
		end
	end
end

function menu.createStandingOrdersMenu(frame, instance)
	local infoTableData = menu.infoTableData[instance]

	infoTableData.ships = menu.getShipList(true, true)
	if not menu.infoSubmenuObject then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if GetComponentData(selectedcomponent, "isplayerowned") and C.IsComponentClass(selectedcomponent, "ship") then
				menu.infoSubmenuObject = selectedcomponent
				break
			end
		end
		if not menu.infoSubmenuObject then
			if #infoTableData.ships > 0 then
				menu.infoSubmenuObject = ConvertIDTo64Bit(infoTableData.ships[1].shipid)
			else
				menu.infoSubmenuObject = 0
			end
		end
	end

	if not menu.infoTablePersistentData[instance].selectedorder then
		menu.setcol = nil
	else
		if menu.infoTablePersistentData[instance].selectedorder.object ~= menu.infoSubmenuObject then
			menu.infoTablePersistentData[instance].selectedorder = nil
			menu.setrow = nil
			menu.setcol = nil
		end
	end

	local ftable = frame:addTable(8, { tabOrder = 1 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidth(2, frame.properties.width / 3 - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidthPercent(3, 33)
	ftable:setColWidth(5, Helper.standardTextHeight)
	ftable:setColWidth(6, Helper.standardTextHeight)
	ftable:setColWidth(7, Helper.standardTextHeight)
	ftable:setColWidth(8, Helper.standardTextHeight)

	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultBackgroundColSpan(1, 8)

	local color = Color["text_normal"]
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	if isplayerowned then
		color = menu.holomapcolor.playercolor
		if menu.infoSubmenuObject == C.GetPlayerObjectID() then
			color = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		color = menu.holomapcolor.visitorcolor
	elseif ishostile then
		color = menu.holomapcolor.hostilecolor
	elseif isenemy then
		color = menu.holomapcolor.enemycolor
	end

	--- title ---
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 8396), Helper.headerRowCenteredProperties)
	--- name ---
	local row = ftable:addRow({ "info_focus" }, { fixed = true, bgColor = Color["row_title_background"] })
	row[8]:createButton({ height = Helper.headerRow1Height, width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight, y = (Helper.headerRow1Height - Helper.standardTextHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if C.IsComponentClass(menu.infoSubmenuObject, "object") then
		row[1]:setBackgroundColSpan(7):setColSpan(3):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
		row[4]:setColSpan(4):createText(ffi.string(C.GetObjectIDCode(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[4].properties.color = color
		row[4].properties.halign = "right"
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(ffi.string(C.GetComponentName(menu.infoSubmenuObject)), Helper.headerRow1Properties)
		row[1].properties.color = color
	end

	---- current override order ----
	infoTableData.orders = {}
	if menu.isInfoModeValidFor(menu.infoSubmenuObject, "standingorders") then
		local n = C.GetNumOrders(menu.infoSubmenuObject)
		local buf = ffi.new("Order2[?]", n)
		n = C.GetOrders2(buf, n, menu.infoSubmenuObject)
		for i = 0, n - 1 do
			local entry = {}
			entry.state = ffi.string(buf[i].state)
			entry.statename = ffi.string(buf[i].statename)
			entry.orderdef = ffi.string(buf[i].orderdef)
			entry.actualparams = tonumber(buf[i].actualparams)
			entry.enabled = buf[i].enabled
			entry.isinfinite = buf[i].isinfinite
			entry.isoverride = buf[i].isoverride
			table.insert(infoTableData.orders, entry)
		end
	end

	if (#infoTableData.orders > 0) and infoTableData.orders[1].isoverride then
		local order = infoTableData.orders[1]
		local orderdefinition = ffi.new("OrderDefinition")
		local ordername = ""
		local orderrefid
		if order.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, order.orderdef) then
			ordername = ffi.string(orderdefinition.name)
			orderrefid = ffi.string(orderdefinition.id)
		end
		order.params = GetOrderParams(menu.infoSubmenuObject, 1)

		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 11221), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(8):createText(ordername .. " " .. ColorText["text_error"] .. "[" .. ReadText(1001, 11219) .. "]")

		local row = ftable:addRow({ "current_override_order" }, {  })

		local attacker
		if orderrefid == "Flee" then
			if order.params[6] and order.params[6].value then
				local value = ConvertIDTo64Bit(order.params[6].value)
				if value ~= 0 then
					attacker = value
				end
			end
		elseif orderrefid == "Attack" then
			if order.params[1] and order.params[1].value and (order.params[1].type == "object") and (order.params[1].value ~= 0) then
				attacker = order.params[1].value
			end
		elseif orderrefid == "Wait" then
			if order.params[5] and order.params[5].value then
				local value = ConvertIDTo64Bit(order.params[5].value)
				if value ~= 0 then
					attacker = value
				end
			end
		end

		local overrideOrderOptions = {}
		if orderrefid ~= "Attack" then
			table.insert(overrideOrderOptions, { id = "Attack", text = ReadText(1001, 11228), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3234), active = attacker ~= nil })
		end
		if orderrefid ~= "Flee" then
			table.insert(overrideOrderOptions, { id = "Flee", text = ReadText(1001, 11220), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3232), active = attacker ~= nil })
		end
		if orderrefid ~= "Wait" then
			table.insert(overrideOrderOptions, { id = "Wait", text = ReadText(1001, 11247), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3245), active = attacker ~= nil })
		end

		row[3]:createDropDown(overrideOrderOptions, { height = config.mapRowHeight, startOption = "", active = isvalid and (not isplayeroccupiedship), textOverride = ReadText(1001, 11248) }):setTextProperties({ fontsize = config.mapFontSize, halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownChangeOverrideOrder(id, attacker, instance) end
		row[3].handlers.onDropDownActivated = function () menu.noupdate = true end

		row[4]:setColSpan(5):createButton({ active = C.RemoveOrder(menu.infoSubmenuObject, 1, false, true), mouseOverText = ReadText(1026, 3233) }):setText(ReadText(1001, 11222), { halign = "center" })
		row[4].handlers.onClick = function () return menu.buttonRemoveOrder(1, instance) end

		local row = ftable:addRow(false, {  })
		row[1]:createText(" ")
	end

	---- standing orders ----
	menu.signals = {}
	local numsignals = C.GetNumAllSignals()
	local allsignals = ffi.new("SignalInfo[?]", numsignals)
	numsignals = C.GetAllSignals(allsignals, numsignals)
	for i = 0, numsignals - 1 do
		local signalid = ffi.string(allsignals[i].id)
		table.insert(menu.signals, {id = signalid, name = ffi.string(allsignals[i].name), description = ffi.string(allsignals[i].description), responses = {}})

		local numresponses = C.GetNumAllResponsesToSignal(signalid)
		local allresponses = ffi.new("ResponseInfo[?]", numresponses)
		numresponses = C.GetAllResponsesToSignal(allresponses, numresponses, signalid)
		for j = 0, numresponses - 1 do
			table.insert(menu.signals[#menu.signals].responses, {id = ffi.string(allresponses[j].id), name = ffi.string(allresponses[j].name), description = ffi.string(allresponses[j].description)})
		end
	end

	if C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station") then
		menu.createResponsesForControllable(ftable, menu.infoSubmenuObject, { height = config.mapRowHeight, fontsize = config.mapFontSize }, "controllableresponses", nil, instance)
	else
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(8):createText(ReadText(1001, 11227), { wordwrap = true })
	end

	if menu.selectedRows["infotable" .. instance] then
		ftable:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.selectedCols["infotable" .. instance] then
			ftable:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	if menu.topRows["infotable" .. instance] then
		ftable:setTopRow(menu.topRows["infotable" .. instance])
		menu.topRows["infotable" .. instance] = nil
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	--- tabs ---
	local tabtable = menu.createOrdersMenuHeader(frame, instance)

	ftable.properties.y = tabtable.properties.y + tabtable:getVisibleHeight() + Helper.borderSize
	
	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	tabtable:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	ftable:addConnection(isleft and 3 or 2, isleft and 2 or 3)
end

function menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, planned)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder
	local numcols = 12
	if not infoTableData.hasloop then
		local failure = ffi.new("OrderFailure")
		if C.GetDefaultOrderFailure(failure, menu.infoSubmenuObject) then
			-- failed behaviour
			local row = ftable:addRow({ "defaultorderfailure" }, { bgColor = Color["row_title_background"] })
			if selectedorder and (selectedorder[1] == "defaultorderfailure") then
				menu.selectedRows["infotable" .. instance] = row.index
				menu.selectedCols["infotable" .. instance] = nil
			end
			row[1]:setColSpan(numcols - 1):setBackgroundColSpan(9):createText(ReadText(1001, 11618), Helper.subHeaderTextProperties)
			row[numcols]:createButton({ height = Helper.subHeaderHeight }):setText("X", { halign = "center" })
			row[numcols].handlers.onClick = function () C.RemoveDefaultOrderFailure(menu.infoSubmenuObject); menu.refreshInfoFrame() end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

			local orderdefid = ffi.string(failure.orderdef)
			local orderfailuredef
			local found = false
			for _, orderdef in ipairs(menu.orderdefs) do
				if orderdef.id == orderdefid then
					orderfailuredef = orderdef
					found = true
					break
				end
			end
			if not found then
				DebugError("Default order failure of '" .. tostring(menu.infoSubmenuObject) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
			end

			-- name
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
			row[5]:setColSpan(8):createButton({ active = false }):setText(orderfailuredef and orderfailuredef.name or ""):setText2(orderfailuredef and Helper.displaySkill(math.floor(orderfailuredef.requiredSkill * 15 / 100)) or "", { halign = "right", color = Color["text_skills"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- params
			local params = GetOrderFailureParams(menu.infoSubmenuObject, tonumber(failure.id))
			for j, param in ipairs(params) do
				if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
					if param.type == "list" then
						if param.value then
							for k, entry in ipairs(param.value) do
								local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable }
								menu.displayFailureParam(ftable, "defaultorderfailure", j, param2, k, instance)
							end
						end
					elseif (param.type ~= "internal") then
						menu.displayFailureParam(ftable, "defaultorderfailure", j, param, nil, instance)
					end
				end
			end
			-- message
			local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(numcols):createText(Helper.getPassedTime(failure.timestamp) .. " - " .. ffi.string(failure.message), { color = Color["text_warning"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			if orderdefid ~= infoTableData.defaultorder.orderdefref.id then
				-- changed default
				local row = ftable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1]:setColSpan(numcols):createText(ReadText(1001, 11619), { color = Color["text_warning"] })
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			end
			-- empty line
			local row = ftable:addEmptyRow()
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			-- current behaviour
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(numcols):createText(planned and ReadText(1001, 11620) or ReadText(1001, 11617), Helper.subHeaderTextProperties)
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	end
end

function menu.displayDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local selectedorder = menu.infoTablePersistentData[instance].selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance)

	local numcols = 12
	local order = infoTableData.defaultorder
	if infoTableData.hasloop then
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "default")
		-- commander
		if infoTableData.commander then
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(numcols):createText(ReadText(1001, 11230), { wordwrap = true })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 8363) .. ReadText(1001, 120))
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8364) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({helpOverlayID = "map_behaviourassignement", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		row[5].properties.uiTriggerID = "DefaultBehaviour"
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- weapon config - TODO
		--row[7]:createButton({ active = isvalid and not isplayeroccupiedship }):setText("*", { halign = "center" })
		--row[7].handlers.onClick = function () return menu.buttonWeaponConfig(menu.infoSubmenuObject, nil, true) end

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					local canplayeroverride = (param.inputparams.canplayeroverride == 1) and infoTableData.commander

					if param.value then
						local overridedata
						if canplayeroverride then
							overridedata = {}

							local overrideparamname = param.name .. "_override"
							for i, entry in ipairs(order.params) do
								if entry.name == overrideparamname then
									overridedata.paramidx = i
									overridedata.param = entry
									break
								end
							end
							if not overridedata.paramidx then
								DebugError("Missing override order parameter '" .. overrideparamname .."' although canplayeroverride is set.")
								return
							end

							local row = ftable:addRow({ j, "manual" })
							if selectedorder and (selectedorder[1] == j) and (selectedorder[2] == "manual") then
								menu.setrow = row.index
								menu.setcol = nil
							end
							row[2]:setColSpan(3):createText("  " .. param.text .. ReadText(1001, 120))
							row[5]:setColSpan(1):createCheckBox(#overridedata.param.value == 0, { width = config.mapRowHeight, height = config.mapRowHeight, mouseOverText = ReadText(1026, 3282) })
							row[5].handlers.onClick = function (_, checked) return menu.checkboxOrderPlayerOverride("default", j, param, overridedata.paramidx, overridedata.param, checked) end
							row[6]:setColSpan(7):createText(ReadText(1001, 11650), { mouseOverText = ReadText(1026, 3282) })

							ftable:addEmptyRow()

							overridedata.values = {}
							for k, entry in ipairs(overridedata.param.value) do
								overridedata.values[entry] = k
							end

							overridedata.criticalwares = {}
							local commander = infoTableData.commander
							if GetComponentData(menu.infoSubmenuObject, "assignment") == "tradeforbuildstorage" then
								commander = GetComponentData(commander, "buildstorage")
							end
							local commander64 = C.ConvertStringTo64Bit(tostring(commander))
							local n = C.GetNumContainerCriticalWares(commander64)
							if n > 0 then
								local buf = ffi.new("const char*[?]", n)
								n = C.GetContainerCriticalWares(buf, n, commander64)
								for i = 0, n - 1 do
									overridedata.criticalwares[ffi.string(buf[i])] = true
								end
							end
						end

						if overridedata and (#overridedata.param.value > 0) and overridedata.param.inputparams.optionsource then
							if overridedata.param.inputparams.optionsource == "commanderwarebasket" then
								if overridedata.param.inputparams.type == "ware" then
									local warebasket = {}
									local found = {}
									local commander = infoTableData.commander
									if GetComponentData(menu.infoSubmenuObject, "assignment") == "tradeforbuildstorage" then
										commander = GetComponentData(commander, "buildstorage")
									end
									local allresources, allproducts, rawtradewares = GetComponentData(commander, "allresources", "products", "tradewares")
									for _, ware in ipairs(allresources) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end
									for _, ware in ipairs(allproducts) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end
									for _, ware in ipairs(rawtradewares) do
										if not found[ware] then
											found[ware] = true
											table.insert(warebasket, ware)
										end
									end

									for i = #warebasket, 1, -1 do
										if GetWareCapacity(overridedata.param.inputparams.cancarry, warebasket[i], true) == 0 then
											table.remove(warebasket, i)
										end
									end
									table.sort(warebasket, Helper.sortWareName)

									for k, ware in ipairs(warebasket) do
										local param2 = { text = ((k == 1) and (not canplayeroverride)) and param.text or "", value = ware, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly, canplayeroverride = overridedata }
										menu.displayOrderParam(ftable, "default", order, j, param2, k, instance)
									end
								end
							end
						else
							for k, entry in ipairs(param.value) do
								local param2 = { text = ((k == 1) and (not canplayeroverride)) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly, canplayeroverride = overridedata }
								menu.displayOrderParam(ftable, "default", order, j, param2, k, instance)
							end
						end
					end

					if (playerreadonly ~= 1) and (not canplayeroverride) then
						local row = ftable:addRow({ i, j, "new" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.setrow = row.index
							menu.setcol = nil
						end

						-- kuertee start: callback
						if menu.uix_callbacks ["displayDefaultBehaviour_change_param_behaviouractive"] then
							for uix_id, uix_callback in pairs (menu.uix_callbacks ["displayDefaultBehaviour_change_param_behaviouractive"]) do
								result = uix_callback (behaviouractive)
								if result then
									behaviouractive = result.behaviouractive
								end
							end
						end
						-- kuertee end: callback

						local active = behaviouractive and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. string.format((param.inputparams.type == "ware") and ReadText(1001, 8378) or ReadText(1001, 3235), param.text), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("default", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "default", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "default" }, {  })
		if selectedorder and (selectedorder[1] == "default") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[2]:setColSpan(numcols - 2):createText(ReadText(1001, 8320) .. ReadText(1001, 120) .. " ---")
		row[numcols]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[numcols].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local row = ftable:addRow({ "defaultbuttons" }, {  })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = false }):setText(ReadText(1001, 2821), { halign = "center" })
	row[8]:setColSpan(5):createButton({ active = false }):setText(ReadText(1001, 64), { halign = "center" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.displayPlannedDefaultBehaviour(ftable, mode, titlerow, instance)
	local infoTableData = menu.infoTableData[instance]
	local persistentData = menu.infoTablePersistentData[instance]
	local selectedorder = persistentData.selectedorder

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, mode)
	local playeroccupiedship64 = C.GetPlayerOccupiedShipID()
	local isplayeroccupiedship = menu.infoSubmenuObject == playeroccupiedship64

	local haspilot = GetComponentData(menu.infoSubmenuObject, "assignedpilot") ~= nil
	local behaviouractive = (infoTableData.commander == nil) and isvalid and (not isplayeroccupiedship) and haspilot
	local mouseovertext = isplayeroccupiedship and ReadText(1026, 3226) or ((not haspilot) and ReadText(1026, 3227) or "")

	menu.displayDefaultBehaviourFailure(ftable, mode, titlerow, instance, true)

	menu.setcol = nil

	local order = infoTableData.planneddefaultorder

	local numcols = 12
	local row = ftable:addEmptyRow(1)
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

	if persistentData.planneddefaultorderloop then
		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 8365) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and ReadText(1026, 3269) or mouseovertext }):setText(ReadText(1001, 11267)):setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		-- delete existing orders note
		if #infoTableData.orders > 0 then
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(numcols):createText(function () return persistentData.planneddefaultorderloop.hasunremoveableorders and ReadText(1001, 11269) or ReadText(1001, 11268) end, { color = Color["text_error"] })
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		end
	elseif next(order) then
		order.params = GetOrderParams(menu.infoSubmenuObject, "planneddefault")

		-- note
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(numcols):createText((persistentData.planneddefaultorderiscopy and ReadText(1001, 11610) or ReadText(1001, 8365)) .. ReadText(1001, 120), { font = Helper.standardFontBold })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		-- name
		local row = ftable:addRow({ "default2" }, {  })
		if selectedorder and (selectedorder[1] == "default2") then
			menu.setrow = row.index
			menu.setcol = nil
		end
		local printedSkillReq = math.floor(order.orderdefref.requiredSkill * 15 / 100)
		row[1]:setColSpan(4):createText(ReadText(1001, 8320) .. ReadText(1001, 120))
		row[5]:setColSpan(8):createButton({ active = behaviouractive, mouseOverText = (mouseovertext == "") and order.orderdefref.description or mouseovertext }):setText(order.orderdefref.name):setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
		row[5].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		for j, param in ipairs(order.params) do
			if (not param.hasinfinitevalue) and ((not param.advanced) or (mode == "orderqueue_advanced")) then
				if param.type == "list" then
					local playerreadonly = param.inputparams and param.inputparams.playerreadonly
					if param.value then
						for k, entry in ipairs(param.value) do
							local param2 = { text = (k == 1) and param.text or "", value = entry, type = param.inputparams.type, editable = param.editable, playerreadonly = playerreadonly }
							menu.displayOrderParam(ftable, "planneddefault", order, j, param2, k, instance)
						end
					end

					if playerreadonly ~= 1 then
						local row = ftable:addRow({ i, j, "new" }, {  })
						if selectedorder and (selectedorder[1] == i) and (selectedorder[2] == j) and (selectedorder[3] == "new") then
							menu.selectedRows["infotable" .. instance] = row.index
							menu.selectedCols["infotable" .. instance] = nil
						end
						local active = isvalid and (not isplayeroccupiedship) and (((order.state == "setup") and (j <= (order.actualparams + 1))) or ((order.state ~= "setup") and param.editable))
						row[2]:setColSpan(numcols - 1):createButton({ active = active }):setText("  " .. (param.inputparams and string.format((param.inputparams.type == "ware") and ReadText(1001, 8378) or ReadText(1001, 3235), param.text) or "---"), { halign = "center" })
						row[2].handlers.onClick = function () return menu.buttonSetOrderParam("planneddefault", j, nil, nil, instance) end
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				elseif (param.type ~= "internal") then
					menu.displayOrderParam(ftable, "planneddefault", order, j, param, nil, instance)
				end
			end
		end
	else
		local row = ftable:addRow({ "planneddefault" }, {  })
		if selectedorder and (selectedorder[1] == "planneddefault") then
			menu.setrow = row.index
		end
		row[2]:setColSpan(numcols - 2):createText(ReadText(1001, 8322) .. ReadText(1001, 120) .. " ---")
		row[numcols]:createButton({ active = behaviouractive, mouseOverText = mouseovertext }):setIcon("menu_edit")
		row[numcols].handlers.onClick = function () return menu.buttonNewOrder(nil, true, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	local fleetunit = C.GetFleetUnit(menu.infoSubmenuObject)
	if fleetunit ~= 0 then
		local info = C.GetFleetUnitInfo(fleetunit)
		local name = ffi.string(info.name)
		local objectid = ffi.string(info.idcode)

		local row = ftable:addRow({ "warning" }, {  })
		row[1]:setColSpan(numcols):createText(string.format(ReadText(1001, 11663), name .. " (" .. objectid .. ")"), { color = Color["text_warning"], wordwrap = true })
	end

	local row = ftable:addRow({ "defaultbuttons" }, {  })
	if selectedorder and (selectedorder[1] == "defaultbuttons") then
		menu.setrow = row.index
	end
	row[1]:setColSpan(4):createButton({ active = function () return menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid) end, helpOverlayID = "map_confirmdefaultorder", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonDefaultOrderConfirm(instance) end
	row[1].properties.uiTriggerID = "map_confirmdefaultorder"
	row[8]:setColSpan(5):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[8].handlers.onClick = function () return menu.buttonDefaultOrderDiscard(instance) end
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
end

function menu.buttonConfirmPlannedDefaultOrderActive(instance, isvalid)
	if not isvalid then
		return false
	end
	if next(menu.infoTableData[instance].planneddefaultorder) then
		return C.EnablePlannedDefaultOrder(menu.infoSubmenuObject, true)
	else
		menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = nil
		local numorders = C.GetNumOrders(menu.infoSubmenuObject)
		local currentorders = ffi.new("Order[?]", numorders)
		numorders = C.GetOrders(currentorders, numorders, menu.infoSubmenuObject)
		for i = 0, numorders - 1 do
			if ffi.string(currentorders[i].state) == "critical" then
				menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders = true
				break
			end
		end
		return not menu.infoTablePersistentData[instance].planneddefaultorderloop.hasunremoveableorders
	end
end

function menu.createPlotMode(inputframe)
	local textproperties = { height = config.mapRowHeight, fontsize = config.mapFontSize }

	menu.initPlotList()

	menu.table_plotlist = inputframe:addTable(4, {tabOrder = 1})
	menu.table_plotlist:setColWidth(4, Helper.scaleY(textproperties.height), false)
	menu.table_plotlist:setColWidthPercent(2, 30)
	menu.table_plotlist:setColWidthPercent(3, 5)

	local row = menu.table_plotlist:addRow(false, {fixed = true, bgColor = Color["row_title_background"]})
	row[1]:setColSpan(4):createText(ReadText(1001, 9201), Helper.headerRowCenteredProperties)	-- Your Plots

	local numrows = config.plots.maxPlotRows
	local maxVisibleHeight
	local numplotentries = #menu.plots + 1
	for i, plot in ipairs(menu.plots) do
		local station64 = ConvertStringTo64Bit(tostring(plot.station))
		local stationname = menu.getContainerNameAndColors(station64, 0, false, false)
		row = menu.table_plotlist:addRow(station64, { bgColor = Color["row_background_blue"] })
		row[1]:setBackgroundColSpan(3):createText((stationname), textproperties)
		row[1].properties.color = function() return plot.fullypaid and Color["text_normal"] or Color["text_error"] end

		row[2]:createText((ReadText(1001, 9210) .. " " .. i), textproperties)	-- Plot
		row[2].properties.halign = "right"
		row[2].properties.x = 0
		row[2].properties.color = function() return plot.fullypaid and Color["text_normal"] or Color["text_error"] end

		row[3]:createText(function() return (plot.fullypaid and "" or "!") end, textproperties)
		row[3].properties.halign = "left"
		row[3].properties.font = Helper.standardFontBold
		row[3].properties.color = Color["text_error"]
		local mouseovertext = ReadText(1026, 3280)
		if plot.permanent then
			mouseovertext = mouseovertext .. "\n- " .. ColorText["text_error"] .. ReadText(1026, 3281) .. "\27X"
		end
		row[4]:createButton({ active = not plot.permanent, helpOverlayID = "menu_cancel_plot", helpOverlayText = " ",  helpOverlayHighlightOnly = true, height = Helper.standardTextHeight, mouseOverText = mouseovertext }):setText("x", { halign = "center" })
		row[4].handlers.onClick = function() return menu.buttonRemovePlot(station64) end

		if i == numrows then
			maxVisibleHeight = menu.table_plotlist:getFullHeight()
		end
		if station64 == menu.plotData.component then
			menu.setrow = row.index
		end
	end
	row = menu.table_plotlist:addRow(false, { bgColor = Color["row_separator"] })
	row[1]:setColSpan(4):createText("", { height = 2 })
	row = menu.table_plotlist:addRow("plots_new", { bgColor = Color["row_background_blue"] })
	row[1]:setBackgroundColSpan(4):createText(ReadText(1001, 9200), textproperties)	-- New Plot
	row[2]:createText((ReadText(1001, 9210) .. " " .. tostring(numplotentries)), textproperties)	-- Plot
	row[2].properties.halign = "right"
	row[2].properties.x = 0

	if maxVisibleHeight then
		menu.table_plotlist.properties.maxVisibleHeight = maxVisibleHeight
	end

	if not menu.plotData.component and not menu.plots_initialized then
		for id, _ in pairs(menu.selectedcomponents) do
			local station = ConvertStringTo64Bit(id)
			if GetComponentData(station, "isplayerowned") and C.IsRealComponentClass(station, "station") then
				menu.updatePlotData(station, true)

				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1
						break
					end
				end

				break
			end
		end
	elseif menu.plotData.component then
		menu.updatePlotData(menu.plotData.component, true)
	end
	menu.plots_initialized = true

	if menu.setplotrow then
		menu.setrow = menu.setplotrow
		menu.setplotrow = nil
		if menu.setplottoprow then
			menu.settoprow = menu.setplottoprow
			menu.setplottoprow = nil
		end
	end

	if menu.setrow then
		menu.table_plotlist:setSelectedRow(menu.setrow)
		menu.plotDoNotUpdate = true
		menu.setrow = nil
	else
		menu.table_plotlist:setSelectedRow(row.index)
	end
	if menu.settoprow then
		menu.table_plotlist:setTopRow(menu.settoprow)
		menu.settoprow = nil
	else
		menu.table_plotlist:setTopRow((row.index - numrows + 1) > 1 and (row.index - numrows + 1) or 1)
	end

	local table_plotdetails = inputframe:addTable(3, { tabOrder = 2 })
	table_plotdetails:setColWidthPercent(1, 40)
	table_plotdetails:setDefaultBackgroundColSpan(1, 3)

	row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(3):createText(function () return menu.plotData.name or "" end, Helper.headerRowCenteredProperties)

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 11284) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return ffi.string(C.GetComponentName(menu.plotData.sector)) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 2412) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "sunlight") * 100 .. "%" end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 11296) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return string.format("%+.0f%%", GetComponentData(ConvertStringTo64Bit(tostring(menu.plotData.sector)), "populationworkforcefactor") * 100) end, { halign = "right" })

	local row = table_plotdetails:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 11285), Helper.headerRowCenteredProperties)

	if IsCheatVersion() then
		local setOptions = {}
		local n = C.GetNumAllModuleSets()
		local buf = ffi.new("UIModuleSet[?]", n)
		n = C.GetAllModuleSets(buf, n)
		for i = 0, n - 1 do
			table.insert(setOptions, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
		end
		table.sort(setOptions, function (a, b) return a.text < b.text end)

		row = table_plotdetails:addRow(true, { bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createDropDown(setOptions, { height = config.mapRowHeight, startOption = menu.plotData.set, active = not menu.plotData.placed and not menu.plotData.active }):setTextProperties({fontsize = config.mapFontSize})
		row[1].handlers.onDropDownConfirmed = function(_, idstring) return menu.dropdownModuleSet(_, idstring) end
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	end

	menu.plotsliders = {}
	menu.plotbuttons = {}
	local dimensions = { [1] = { dimension = "posX", text = ReadText(1001, 9220) },
						 [2] = { dimension = "negX", text = ReadText(1001, 9221) },
						 [3] = { dimension = "posY", text = ReadText(1001, 9222) },
						 [4] = { dimension = "negY", text = ReadText(1001, 9223) },
						 [5] = { dimension = "posZ", text = ReadText(1001, 9224) },
						 [6] = { dimension = "negZ", text = ReadText(1001, 9225) },
					}

	for i, dimension in ipairs(dimensions) do
		row = table_plotdetails:addRow(true, {})
		local locdimension = menu.plotData.dimensions[dimension.dimension]
		local minimumdimension = menu.plotData.minimumdimensions[dimension.dimension] or 0
		local locpaireddimension = menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]

		local minselect = math.max(menu.plotData.permanent and minimumdimension or 0, (locpaireddimension == 0 and 1 or 0))
		local maxselect = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or (config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]])
		local max = (menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] > config.maxPlotSize) and menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]] or config.maxPlotSize
		if maxselect > max then
			print("maxselect > max. axis: " .. tostring(dimension.dimension) .. " maxselect: " .. tostring(maxselect) .. ", max: " .. tostring(max) .. ", paired value: " .. tostring(menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]]))
		end
		if minselect > maxselect then
			print("menu.createPlotMode(): minselect > maxselect [Florian]")
			minselect = maxselect
		end
		if locdimension < minselect then
			print("menu.createPlotMode(): start < minselect [Florian]")
			locdimension = minselect
		end

		-- increased minSelect to 1 because it looks like slider text is rounding to the nearest integer (and shows 0.5 as 0). so smallest possible plot size is 2x2x2.
		local slider = row[1]:setColSpan(3):createSliderCell({
			height = config.mapRowHeight,
			bgColor = Color["slider_background_transparent"],
			min = 0,
			minSelect = minselect,
			max = (locpaireddimension > config.maxPlotSize) and locpaireddimension or config.maxPlotSize,
			maxSelect = (locpaireddimension > config.maxPlotSize) and locpaireddimension or (config.maxPlotSize - locpaireddimension),
			start = locdimension,
			step = 1,
			suffix = ReadText(1001, 108),
			mouseOverText = ffi.string(C.GetDisplayedModifierKey("shift")) .. " - " .. ReadText(1026, 3279),
		}):setText(dimension.text, {fontsize = config.mapFontSize})
		--row[1]:setColSpan(3):createSliderCell({ height = config.mapRowHeight, min = 0, minSelect = (menu.plotData.paid or menu.plotData.permanent) and menu.plotData.dimensions[dimension.dimension] or 1, max = 9, maxSelect = config.maxPlotSize - menu.plotData.dimensions[config.plotPairedDimension[dimension.dimension]], start = menu.plotData.dimensions[dimension.dimension], step = 1, suffix = ReadText(1001, 108) }):setText(dimension.text, {fontsize = config.mapFontSize})
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellPlotValue(_, val, dimension.dimension) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
		row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
		row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
		table.insert(menu.plotsliders, { table = table_plotdetails, cell = row[1], row = row.index, col = 1, dimension = dimension.dimension, slider = slider })
	end

	table_plotdetails:addEmptyRow(config.mapRowHeight / 2)

	row = table_plotdetails:addRow(nil, { bgColor = Color["row_background_unselectable"] })
	row[1]:createText(ReadText(1001, 8026) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(function () return (menu.plotData.dimensions.posX + menu.plotData.dimensions.negX) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posY + menu.plotData.dimensions.negY) .. " " .. ReadText(1001, 42) .. " " .. (menu.plotData.dimensions.posZ + menu.plotData.dimensions.negZ) .. " " .. ReadText(1001, 108) end, { halign = "right" })

	row = table_plotdetails:addRow("createplot", {})
	row[2]:createButton({ height = config.mapRowHeight, active = (menu.plotData.isinownedspace and menu.plotData.placed and menu.plotData.paid and (menu.plotData.size.x * 1000 ~= menu.plotData.boughtrawsize.x or menu.plotData.size.y * 1000 ~= menu.plotData.boughtrawsize.y or menu.plotData.size.z * 1000 ~= menu.plotData.boughtrawsize.z) and not menu.plotData.permanent) and true or false }):setText(ReadText(1001, 9230), { halign = "center", fontsize = config.mapFontSize })	-- Reset size
	row[2].handlers.onClick = function() return menu.resetPlotSize() end
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[2], row = row.index, col = 2, rowdata = "createplot", script = function() return menu.resetPlotSize() end })

	row[3]:createButton({ height = config.mapRowHeight, active = not menu.plotData.placed, helpOverlayID = "create_plot_new", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9231), { halign = "center", fontsize = config.mapFontSize })	-- Create new plot
	row[3].handlers.onClick = function() return menu.buttonNewPlot() end
	row[3].properties.uiTriggerID = "createnewplot"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row[3], row = row.index, col = 3, rowdata = "createplot", script = function() return menu.buttonNewPlot() end })

	table_plotdetails:setSelectedRow(menu.selectedRows.infotable2)
	menu.selectedRows.infotable2 = nil

	row = table_plotdetails:addRow(false, {bgColor = Color["row_title_background"]})
	row[1]:setColSpan(3):createText(ReadText(1001, 9202), Helper.headerRowCenteredProperties)	-- Real Estate Transfer Tax

	row = table_plotdetails:addRow(false, { bgColor = Color["row_background_unselectable"] })
	row2 = table_plotdetails:addRow("buyplot", {})

	row[1]:setColSpan(2):createText(function() return (not menu.plotData.placed and ReadText(1001, 9240)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9241)) or (ReadText(1001, 9242) .. ReadText(1001, 120)) end, textproperties)	-- Place or select plot to see required fees., You own this plot., Fee to acquire plot licence, :
	row[3]:createText(function() return (menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and (ConvertMoneyString(tostring(menu.plotData.price), false, true, 0, true) .. " " .. ReadText(1001, 101))) or "" end, textproperties)
	row[3].properties.halign = "right"

	-- TODO: activate after there is a distinction between a holomap-only plot and a real one.
	--row2[2]:createButton({active = false, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2]:createButton({active = not menu.plotData.fullypaid and menu.plotData.isinownedspace, height = config.mapRowHeight}):setText(ReadText(1001, 9232), {halign = "center", fontsize = config.mapFontSize})	-- Ignore licence
	--row2[2].handlers.onClick = function() return menu.buttonIgnorePlotLicence() end
	--table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[2], row = row2.index, col = 2, rowdata = "buyplot", script = function() return menu.buttonIgnorePlotLicence() end })
	local mouseovertext = ""
	if menu.plotData.placed and (not menu.plotData.fullypaid) and menu.plotData.isinownedspace and (not menu.plotData.affordable) then
		mouseovertext = ReadText(1026, 3222)
	end
	row2[3]:createButton({ active = menu.plotData.placed and not menu.plotData.fullypaid and menu.plotData.isinownedspace and menu.plotData.affordable, height = config.mapRowHeight, mouseOverText = mouseovertext, helpOverlayID = "create_plot_purchase", helpOverlayText = " ",  helpOverlayHighlightOnly = true, uiTriggerID = "buyplot" }):setText(ReadText(1001, 9233), { halign = "center", fontsize = config.mapFontSize })	-- Buy licence
	row2[3].handlers.onClick = function() return menu.buttonBuyPlot() end
	row2[3].properties.uiTriggerID = "buyplot"
	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "buyplot", script = function() return menu.buttonBuyPlot() end })

	row = table_plotdetails:addRow(false, {bgColor = Color["row_title_background"]})
	row[1]:setColSpan(3):createText(ReadText(1001, 9234), Helper.headerRowCenteredProperties)	-- Continue to Construction

	row = table_plotdetails:addRow(false, { bgColor = Color["row_background_unselectable"] })
	textproperties.height = config.mapRowHeight * 2
	textproperties.wordwrap = true
	row2 = table_plotdetails:addRow("initiateconstruction", {})

	row[1]:setColSpan(3):createText(function() return (not menu.plotData.placed and ReadText(1001, 9243)) or ((menu.plotData.fullypaid or not menu.plotData.isinownedspace) and ReadText(1001, 9244)) or ReadText(1001, 9245) end, textproperties)	-- Place or select plot to initiate construction., Click continue to initiate construction., Building without a licence will be seen as a hostile act by the local government.
	row[1].properties.color = function() return menu.plotData.placed and menu.plotData.isinownedspace and not menu.plotData.fullypaid and Color["text_error"] or Color["text_normal"] end
	row2[3]:createButton({active = menu.plotData.placed, height = config.mapRowHeight, helpOverlayID = "create_plot_continue", helpOverlayText = " ",  helpOverlayHighlightOnly = true}):setText(ReadText(1001, 9235), {halign = "center", fontsize = config.mapFontSize})	-- Continue
	row2[3].handlers.onClick = function() return menu.plotInitiateConstruction(menu.plotData.component) end
	row2[3].properties.uiTriggerID = "initiateconstruction"

	table.insert(menu.plotbuttons, { table = table_plotdetails, cell = row2[3], row = row2.index, col = 3, rowdata = "initiateconstruction", script = function() return menu.plotInitiateConstruction(menu.plotData.component) end })

	table_plotdetails.properties.y = menu.table_plotlist:getVisibleHeight() + Helper.borderSize

	menu.playerinfotable:addConnection(1, 2, true)
	menu.table_plotlist:addConnection(2, 2)
	table_plotdetails:addConnection(3, 2)
end

function menu.createFilterMode(ftable, numCols)
	local title = ""
	local row = ftable:addRow("tabs", { fixed = true })
	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local bgcolor = Color["row_title_background"]
		-- active filter groups get different colors
		if entry.mode == menu.displayedFilterLayer then
			title = entry.name
			bgcolor = Color["row_background_selected"]
		end
		if not menu.getFilterOption(entry.mode, false) then
			icon = icon .. "_disabled"
		end

		local colindex = i
		if i > 1 then
			colindex = colindex + 2
		end

		row[colindex]:setColSpan((i == 1) and 3 or 1):createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(icon, { })
		row[colindex].handlers.onClick = function () return menu.buttonFilterSwitch(entry.mode, row.index, colindex) end
	end

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	local color = Color["text_normal"]
	local onoffcolor = Color["text_normal"]
	local active = true
	if not __CORE_DETAILMONITOR_MAPFILTER[menu.displayedFilterLayer] then
		color = Color["text_inactive"]
		onoffcolor = Color["text_negative"]
		active = false
	end
	row[1]:setColSpan(2):createButton({ height = Helper.headerRow1Height, helpOverlayID = "toggle_current_filter", helpOverlayText = " ", helpOverlayHighlightOnly = true}):setIcon("menu_on_off", { color = onoffcolor })
	row[1].handlers.onClick = function () return menu.buttonSetFilterLayer(menu.displayedFilterLayer, row.index, 1) end
	row[3]:setColSpan(numCols - 2):createText(title, Helper.headerRowCenteredProperties)

	local settings = config.layersettings[menu.displayedFilterLayer]
	for i, setting in ipairs(settings) do
		if i > 1 then
			ftable:addEmptyRow(config.mapRowHeight / 2)
		end

		local titlerow = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(numCols):createText(setting.caption, Helper.subHeaderTextProperties)
		titlerow[1].properties.color = color
		if (not active) or (setting.active and (not setting.active())) then
			titlerow[1].properties.color = Color["text_inactive"]
			titlerow[1].properties.titleColor = Color["row_separator"]
		end
		titlerow[1].properties.helpOverlayID = setting.helpOverlayID
		titlerow[1].properties.helpOverlayText = setting.helpOverlayText
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = setting.helpOverlayHighlightOnly
		titlerow[1].properties.helpOverlayScaling = false

		if setting.type == "multiselectlist" then
			local settingactive = true
			if setting.active then
				settingactive = setting.active()
			end
			local list = menu.getFilterOption(setting.id, setting.savegame) or {}
			for i, curOption in ipairs(list) do
				local index = i

				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(numCols - 1):createText(setting.displayOption(curOption), { fontsize = config.mapFontSize })
				row[1].properties.color = color
				row[numCols]:createButton({ active = active and settingactive }):setText("x", { halign = "center" })
				row[numCols].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, index) end
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			end
			local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(numCols):createButton({ mouseOverText = setting.info, active = active and settingactive }):setText(setting.overrideText, { halign = "center", fontsize = config.mapFontSize })
			row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, setting.id) end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
		else
			for _, option in ipairs(setting) do
				local optionactive = true
				if option.active then
					optionactive = option.active()
				end
				if setting.type == "checkbox" then
					local row = ftable:addRow(true, {  })
					row[1]:createCheckBox(menu.getFilterOption(option.id, setting.savegame) or false, { scaling = false, width = Helper.scaleY(config.mapRowHeight), height = Helper.scaleY(config.mapRowHeight), active = active and optionactive })
					row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id) end
					row[2]:setColSpan(numCols - 1):createText(option.name, { color = ((not active) or (not optionactive)) and Color["text_inactive"] or color, mouseOverText = option.info })
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				elseif setting.type == "slidercell" then
					if option.scale.exceedmax then
						option.scale.start = math.max(option.scale.min, menu.getFilterOption(option.id, setting.savegame)) or option.scale.max
					else
						option.scale.start = math.max(option.scale.min, math.min(option.scale.max, menu.getFilterOption(option.id, setting.savegame))) or option.scale.max
					end
					local row = ftable:addRow(true, {  })
					row[1]:setColSpan(numCols):createSliderCell({ height = config.mapRowHeight, min = option.scale.min, minSelect = option.scale.minSelect, max = option.scale.max, maxSelect = option.scale.maxSelect, start = option.scale.start, step = option.scale.step, suffix = option.scale.suffix, exceedMaxValue = option.scale.exceedmax, mouseOverText = option.info, readOnly = (not active) or (not optionactive), bgColor = ((not active) or (not optionactive)) and Color["slider_background_transparent"] or nil, valueColor = ((not active) or (not optionactive)) and Color["slider_value_inactive_dark"] or nil }):setText(option.name, { color = ((not active) or (not optionactive)) and Color["text_inactive"] or nil, fontsize = config.mapFontSize })
					row[1].handlers.onSliderCellChanged = function (_, value) menu.noupdate = true; return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, value) end
					row[1].handlers.onSliderCellConfirm = function() menu.noupdate = false end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				elseif setting.type == "dropdown" then
					local listOptions = option.listOptions()
					local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
					row[1]:setColSpan(numCols):createDropDown(listOptions, { height = config.mapRowHeight, startOption = menu.getFilterOption(option.id, setting.savegame), mouseOverText = option.info, active = active and optionactive }):setTextProperties({ fontsize = config.mapFontSize }):setText2Properties({ fontsize = config.mapFontSize, halign = "right" })
					row[1].handlers.onDropDownConfirmed = function (_, id) return menu.setFilterOption(menu.displayedFilterLayer, setting, option.id, id) end
					row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
					titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				end
			end
		end
	end
end

function menu.createLegendMode(ftable, numCols)
	ftable.properties.highlightMode = "grey"

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 9801), Helper.headerRowCenteredProperties)

	for _, entry in ipairs(config.legend) do
		local row = ftable:addRow(true, {  })
		if entry.icon then
			local iconheight = entry.height or 1.5 * config.mapRowHeight
			local iconwidth  = entry.width  or 1.5 * config.mapRowHeight
			local iconx = 0
			if iconwidth < (1.5 * config.mapRowHeight) then
				iconx = (1.5 * config.mapRowHeight - iconwidth) / 2
			end
			local color
			if entry.color then
				if type(entry.color) == "string" then
					color = menu.holomapcolor[entry.color]
				else
					color = entry.color
				end
			end
			row[1]:setColSpan(3):createIcon(entry.icon, { width = iconwidth, height = iconheight, x = iconx, color = color })
			local texty = 0
			local textheight = math.max(math.max(entry.minRowHeight or 0, Helper.standardTextHeight), iconheight)
			if textheight > Helper.standardTextHeight then
				texty = (textheight - Helper.standardTextHeight) / 2
			end
			row[4]:setColSpan(numCols - 3):createText(entry.text, { minRowHeight = entry.minRowHeight, y = texty })
		else
			row[1]:setColSpan(numCols):createText(entry.text, Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end
	end
end

function menu.createHireMode(ftable, numCols)
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText(ishiring and ReadText(1001, 3500) or ReadText(1001, 3264), Helper.headerRowCenteredProperties)

	AddUITriggeredEvent(menu.name, "menu_hiremode")

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0
	local name
	if npc then
		name = GetComponentData(npc, "name")
	else
		name = ffi.string(C.GetPersonName(npcseed, object))
	end

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText(ReadText(1001, 2809))
	row[6]:setColSpan(numCols - 5):createText(name, { halign = "right" })
	-- Skills
	local possiblePostsAndRoles = {}
	local n = C.GetNumAllControlPosts()
	local buf = ffi.new("ControlPostInfo[?]", n)
	n = C.GetAllControlPosts(buf, n)
	for i = 0, n - 1 do
		table.insert(possiblePostsAndRoles, { name = ffi.string(buf[i].name), post = ffi.string(buf[i].id) })
	end
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20103), role = "service" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20203), role = "marine" })
	table.insert(possiblePostsAndRoles, { name = ReadText(20208, 20503), role = "trainee_group" })
	table.sort(possiblePostsAndRoles, Helper.sortName)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 3257))
	for _, entry in ipairs(possiblePostsAndRoles) do
		local adjustedskill
		if npc then
			adjustedskill = math.floor(C.GetEntityCombinedSkill(npc, entry.role, entry.post) * 15 / 100)
		else
			adjustedskill = math.floor(C.GetPersonCombinedSkill(object, npcseed, entry.role, entry.post) * 15 / 100)
		end
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText("   " .. entry.name)
		row[6]:setColSpan(numCols - 5):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Color["text_skills"] })
	end
end

function menu.hireReasonLookup(reason, isbulk)
	if reason == "" then
		return ""
	elseif reason == "invalid" then
		return ReadText(1026, 3236)
	elseif reason == "sameposition" then
		return ReadText(1026, 3237)
	elseif reason == "intransit" then
		return ReadText(1026, 3238)
	elseif reason == "nofreespace" then
		return isbulk and ReadText(1026, 3243) or ReadText(1026, 3239)
	elseif reason == "pilotbusy" then
		return ReadText(1026, 3240)
	elseif reason == "previouspilotbusy" then
		return ReadText(1026, 3241)
	elseif reason == "shiptraderbusy" then
		return ReadText(1026, 3244)
	elseif reason == "postoccupied" then
		return ReadText(1026, 3246)
	end
end

function menu.createInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if not menu.infoSubmenuObject or menu.infoSubmenuObject == 0 then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "infomenu_open", menu.infoSubmenuObject)

	local isdatavault, islandmark = GetComponentData(menu.infoSubmenuObject, "isdatavault", "islandmark")
	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "buildstorage") then
		mode = "buildstorage"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "sector"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "gate"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "deployable"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") then
		mode = "asteroid"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "object") and (isdatavault or islandmark) then
		mode = "none"
	else
		DebugError("menu.createInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(8, { tabOrder = 1 })
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidthMinPercent(2, 20)
	table_info:setColWidthMinPercent(3, 20)
	table_info:setColWidthPercent(4, 12)
	table_info:setColWidthPercent(6, 12)
	table_info:setColWidth(8, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 8)

	menu.setupInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local isplayerowned, isdeployable, description = GetComponentData(menu.infoSubmenuObject, "isplayerowned", "isdeployable", "description")

	local table_button_bottom = inputframe:addTable(2, { tabOrder = 2 })
	table_button_bottom:setColWidthPercent(2, 50)

	if ((mode == "ship") or (isplayerowned and ((mode == "station") or (mode == "buildstorage")))) and (not C.IsUnit(menu.infoSubmenuObject)) and (not isdeployable) then
		row = table_button_bottom:addRow("info_button_bottom", { fixed = true })
		if mode == "ship" then
			local library = "shiptypes_xs"
			if IsComponentClass(menu.infoSubmenuObject, "ship_xl") then
				library = "shiptypes_xl"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_l") then
				library = "shiptypes_l"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_m") then
				library = "shiptypes_m"
			elseif IsComponentClass(menu.infoSubmenuObject, "ship_s") then
				library = "shiptypes_s"
			end

			row[1]:createButton({ active = true }):setText(ReadText(1001, 2400), { halign = "center" })	-- Encyclopedia
			row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Ships", library, GetComponentData(menu.infoSubmenuObject, "macro") }); menu.cleanup() end
			if isplayerowned then
				row[2]:createButton({ active = true }):setText(ReadText(1001, 1137), { halign = "center" })	-- Ship Overview
				row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "upgrade", { tostring(menu.infoSubmenuObject) } }) menu.cleanup() end
			end
		elseif mode == "station" then
			row[1]:createButton({ active = true }):setText(ReadText(1001, 1136), { halign = "center" })	-- Configure Station
			row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
			row[2]:createButton({ active = true }):setText(ReadText(1001, 1138), { halign = "center" })	-- Station Overview
			row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, menu.infoSubmenuObject }) menu.cleanup() end
		elseif mode == "buildstorage" then
			local basestation = GetComponentData(menu.infoSubmenuObject, "basestation")
			if basestation then
				row[1]:createButton({ active = true }):setText(ReadText(1001, 1136), { halign = "center" })	-- Configure Station
				row[1].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, basestation }) menu.cleanup() end
				row[2]:createButton({ active = true }):setText(ReadText(1001, 1138), { halign = "center" })	-- Station Overview
				row[2].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, basestation }) menu.cleanup() end
			end
		end
	end
	table_button_bottom.properties.y = frameheight - table_button_bottom:getFullHeight() - Helper.borderSize

	local table_description = inputframe:addTable(1, { tabOrder = 3, highlightMode = "off" })
	row = table_description:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText(ReadText(1001, 2404), Helper.headerRowCenteredProperties)

	local numlines = math.max(6, math.min(12, math.floor(0.2 * frameheight / Helper.scaleY(Helper.standardTextHeight))))
	local descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #descriptiontext > numlines then
		-- scrollbar case
		descriptiontext = GetTextLines(description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), inputframe.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(descriptiontext) do
		local row = table_description:addRow(true, {  })
		row[1]:createText(descline)
		if linenum == numlines then
			visibleHeight = table_description:getFullHeight()
		end
	end

	if menu.selectedRows["infotable3" .. instance] then
		table_description:setSelectedRow(menu.selectedRows["infotable3" .. instance])
		menu.selectedRows["infotable3" .. instance] = nil
		if menu.topRows["infotable3" .. instance] then
			table_description:setTopRow(menu.topRows["infotable3" .. instance])
			menu.topRows["infotable3" .. instance] = nil
		end
	end

	if visibleHeight then
		table_description.properties.maxVisibleHeight = visibleHeight
	else
		table_description.properties.maxVisibleHeight = table_description:getFullHeight()
	end

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_description.properties.y = table_button_bottom.properties.y - table_description:getVisibleHeight() - Helper.borderSize
	table_info.properties.maxVisibleHeight = table_description.properties.y - table_info.properties.y - Helper.borderSize

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	table_header:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	table_info:addConnection(isleft and 3 or 2, isleft and 2 or 3)
	table_description:addConnection(isleft and 4 or 3, isleft and 2 or 3)
	table_button_bottom:addConnection(isleft and 5 or 4, isleft and 2 or 3)
end

function menu.createCrewInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "crewinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createCrewInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	if (C.IsComponentClass(menu.infoSubmenuObject, "ship") or C.IsComponentClass(menu.infoSubmenuObject, "station")) and (menu.infoTablePersistentData[instance].resetcrew or (menu.infoTablePersistentData[instance].crew.object ~= menu.infoSubmenuObject)) then
		menu.infoSubmenuPrepareCrewInfo(instance)
		menu.infoTablePersistentData[instance].resetcrew = nil
	end

	local table_info = inputframe:addTable(7, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(2, config.mapRowHeight)
	table_info:setColWidthPercent(4, 25)
	table_info:setColWidth(5, 0.25 * inputframe.properties.width - Helper.borderSize, false)
	table_info:setColWidth(6, 0.25 * inputframe.properties.width - (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(7, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 7)

	menu.setupCrewInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	table_header:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	table_info:addConnection(isleft and 3 or 2, isleft and 2 or 3)
end

function menu.createLoadoutInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	AddUITriggeredEvent(menu.name, "loadoutinfomenu_open", menu.infoSubmenuObject)

	if C.IsRealComponentClass(menu.infoSubmenuObject, "ship_xs") then
		mode = "none"
	elseif GetMacroData(GetComponentData(menu.infoSubmenuObject, "macro"), "islasertower") then
		mode = "none"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "ship") then
		mode = "ship"
	elseif C.IsRealComponentClass(menu.infoSubmenuObject, "station") then
		mode = "station"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "sector") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "gate") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "mine") or C.IsComponentClass(menu.infoSubmenuObject, "navbeacon") or C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") or C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "asteroid") or C.IsComponentClass(menu.infoSubmenuObject, "collectablewares") then
		mode = "none"
	elseif C.IsComponentClass(menu.infoSubmenuObject, "lockbox") then
		mode = "none"
	else
		DebugError("menu.createLoadoutInfoSubmenu(): Selected component " .. tostring(menu.infoSubmenuObject) .. " of class " .. ffi.string(C.GetComponentClass(menu.infoSubmenuObject)) .. " is unsupported. Support?")
	end

	local table_info = inputframe:addTable(13, { tabOrder = 1 } )
	table_info:setColWidth(1, config.mapRowHeight)
	table_info:setColWidth(3, config.mapRowHeight)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, 0.25 * inputframe.properties.width - 4 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize) , false)
	table_info:setColWidth(8, config.mapRowHeight)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)
	table_info:setColWidth(11, config.mapRowHeight)
	table_info:setColWidth(12, math.max(1, 0.25 * inputframe.properties.width - 5 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)) , false)
	table_info:setColWidth(13, config.mapRowHeight)

	table_info:setDefaultBackgroundColSpan(1, 13)

	menu.setupLoadoutInfoSubmenuRows(mode, table_info, menu.infoSubmenuObject, instance)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	table_header:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	table_info:addConnection(isleft and 3 or 2, isleft and 2 or 3)
end

function menu.createLogbookInfoSubmenu(inputframe, instance)
	local mode = ""
	local frameheight = inputframe.properties.height
	if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
		-- only get the first selected item. if multiple items selected, whose information do we show?
		for id, content in pairs(menu.selectedcomponents) do
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(id))
			break
		end
		if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
			menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (not menu.infoSubmenuObject) or (menu.infoSubmenuObject == 0) then
				menu.infoSubmenuObject = ConvertStringTo64Bit(tostring(C.GetPlayerContainerID()))
			end
		end
	end

	local isvalid = menu.isInfoModeValidFor(menu.infoSubmenuObject, "objectlogbook")

	AddUITriggeredEvent(menu.name, "logbookinfomenu_open", menu.infoSubmenuObject)

	local useSeparatePageRow = true
	local buttonsize = Helper.scaleY(config.mapRowHeight)
	local table_info = inputframe:addTable(10, { tabOrder = 1 } )
	table_info:setColWidth(1, inputframe.properties.width / 3, false)
	table_info:setColWidth(4, config.mapRowHeight)
	table_info:setColWidth(5, config.mapRowHeight)
	table_info:setColWidth(6, config.mapRowHeight)
	table_info:setColWidth(7, config.mapRowHeight)
	table_info:setColWidth(8, inputframe.properties.width / 3 - 4 * (buttonsize + Helper.borderSize), false)
	table_info:setColWidth(9, config.mapRowHeight)
	table_info:setColWidth(10, config.mapRowHeight)

	menu.setupLogbookInfoSubmenuRows(table_info, menu.infoSubmenuObject, instance, isvalid)

	if menu.selectedRows["infotable" .. instance] then
		table_info:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_info:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
		if menu.selectedCols["infotable" .. instance] then
			table_info:setSelectedCol(menu.selectedCols["infotable" .. instance])
			menu.selectedCols["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local table_header = menu.createOrdersMenuHeader(inputframe, instance)

	table_info.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize

	local table_button = inputframe:addTable(3, { tabOrder = 3 } )
	table_button:addEmptyRow()
	local row = table_button:addRow(true, {  })
	row[3]:createButton({ active = isvalid }):setText(ReadText(1001, 5722), { halign = "center" })
	row[3].handlers.onClick = function () return menu.buttonInfoLogbookClearQuestion(instance) end

	local infotableheight = table_info:getFullHeight()
	local buttontableheight = table_button:getFullHeight()
	if table_info.properties.y + infotableheight + buttontableheight + Helper.borderSize + Helper.frameBorder < frameheight then
		table_button.properties.y = table_info.properties.y + infotableheight + Helper.borderSize
	else
		table_button.properties.y = frameheight - Helper.frameBorder - buttontableheight
		table_info.properties.maxVisibleHeight = table_button.properties.y - Helper.borderSize - table_info.properties.y
	end

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	table_header:addConnection(isleft and 2 or 1, isleft and 2 or 3, true)
	table_info:addConnection(isleft and 3 or 2, isleft and 2 or 3)
	table_button:addConnection(isleft and 4 or 3, isleft and 2 or 3)
end

function menu.setupInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))

	if (not menu.infoTablePersistentData[instance].cashtransferdetails) or (menu.infoTablePersistentData[instance].cashtransferdetails.curobject ~= inputobject) then
		menu.infoTablePersistentData[instance].cashtransferdetails = { curobject = inputobject, transfers = {} }
		menu.infoTablePersistentData[instance].drops = {}
	end

	local infocashtransferdetails = menu.infoTablePersistentData[instance].cashtransferdetails
	local infodrops = menu.infoTablePersistentData[instance].drops

	local indentsize = 0

	local loadout = {}
	if (mode == "ship") or (mode == "station") then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end
	local unknowntext = ReadText(1001, 3210)
	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local ownerinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "owner")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")
	local productioninfo_products =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_products")
	local productioninfo_rate =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_rate")
	local productioninfo_resources =	cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_resources")
	local productioninfo_time =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "production_time")
	local storageinfo_capacity =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_capacity")
	local storageinfo_amounts =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_amounts")
	local storageinfo_warelist =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "storage_warelist")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")

	if not isplayerowned then
		menu.extendedinfo["info_weaponconfig" .. instance] = nil
	end

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)

	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(8):createText(ReadText(1001, 1111), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[8]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[8].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(7):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(7):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		locrowdata = { "info_name", ReadText(1001, 2809) .. ReadText(1001, 120), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + indentsize })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040) .. ReadText(1001, 120), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- "Owner"
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local loccontainer = nil
		if isdocked then
			loccontainer = ConvertStringTo64Bit(tostring(C.GetTopLevelContainer(inputobject)))
		end
		local objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "sectorid")))
		if objectlocid64 == 0 then
			objectlocid64 = ConvertStringTo64Bit(tostring(GetComponentData(object64, "clusterid")))		-- no sector; object is in superhighway
		end
		local objectloc = Helper.unlockInfo(C.IsInfoUnlockedForPlayer(objectlocid64, "name"), ffi.string(C.GetComponentName(objectlocid64)))
		if loccontainer then
			objectloc = ReadText(1001, 3248) .. " " .. ffi.string(C.GetComponentName(loccontainer)) .. ", " .. objectloc	-- Docked at
		end
		locrowdata = { false, ReadText(1001, 2943) .. ReadText(1001, 120), objectloc }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local macroname, ware, islasertower = GetMacroData(GetComponentData(object64, "macro"), "name", "ware", "islasertower")
		local objecttype = Helper.unlockInfo(nameinfo, macroname)
		locrowdata = { false, ReadText(1001, 94) .. ReadText(1001, 120), objecttype }	-- Model
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		if ware then
			local tradelicence, ishiddenwithoutlicence = GetWareData(ware, "tradelicence", "ishiddenwithoutlicence")

			local n = C.GetNumWareBlueprintOwners(ware)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWareBlueprintOwners(buf, n, ware)
			local first = true
			for i = 0, n - 1 do
				local faction = ffi.string(buf[i])
				local name = GetFactionData(faction, "name")
				local known = IsKnownItem("factions", faction)

				local hidden = false
				if ishiddenwithoutlicence then
					if not HasLicence("player", tradelicence, faction) then
						hidden = true
					end
				end

				if known and (not hidden) then
					locrowdata = { false, first and (ReadText(1001, 8391) .. ReadText(1001, 120)) or "", Helper.unlockInfo(nameinfo, name) }	-- Produced by
					row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
					first = false
				end
			end
		end

		locrowdata = { false, ReadText(1001, 9051) .. ReadText(1001, 120), Helper.unlockInfo(nameinfo, (function() return tostring(GetComponentData(object64, "shiptypename") or 0, true, 0, true) end)) }	-- Ship Type
		
		-- start: aegs call-back
		if menu.uix_callbacks ["map_shipInformation_shiptypename_override"] then
			local shiptypename_override
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_shipInformation_shiptypename_override"]) do
				shiptypename_override = uix_callback (GetComponentData(object64, "macro"))
				if shiptypename_override then
					locrowdata = { false, ReadText(1001, 9051) .. ReadText(1001, 120), Helper.unlockInfo(nameinfo, (function() return tostring(shiptypename_override or 0, true, 0, true) end)) }
				end
			end
		end
		-- end: aegs call-back

		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 1) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull") or 0), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. (GetComponentData(object64, "hullpercent") or 0) .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" ..  (GetComponentData(object64, "hullpercent") or 0) .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local shield_max = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString(Helper.round(GetComponentData(object64, "shieldmax")), true, 4, true, true, true))
		locrowdata = { false, ReadText(1001, 2) .. ReadText(1001, 120), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "shield") or 0), true, 4, true, true, true) .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" .. (GetComponentData(object64, "shieldpercent") or 0) .. "%)") end) or (unknowntext .. " / " .. shield_max .. " " .. ReadText(1001, 118) .. " (" ..  (GetComponentData(object64, "shieldpercent") or 0) .. "%)")) }	-- Shield, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { true, ReadText(1001, 9076) .. ReadText(1001, 120), defenceinfo_low and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "maxunboostedforwardspeed") or 0), true, 0, true) .. " " .. ReadText(1001, 113)) end) or (unknowntext .. " " .. ReadText(1001, 113)) }	-- Cruising Speed, m/s
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)

		local dpstable = ffi.new("DPSData[?]", 6)
		local hasturrets = (defenceinfo_low and #loadout.component.turret > 0)
		local numtotalquadrants = C.GetDefensibleDPS(dpstable, inputobject, true, true, true, true, hasturrets, false, false)
		if not hasturrets then
			locrowdata = { false, ReadText(1001, 9092) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		else
			for i = 0, numtotalquadrants - 1 do
				locrowdata = { false, (ReadText(1001, 9092) .. " (" .. ReadText(20220, dpstable[i].quadranttextid) .. ")" .. ReadText(1001, 120)), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(dpstable[i].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- Weapon Output, MW
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
			end
		end

		local sustainedfwddps = ffi.new("DPSData[?]", 1)
		C.GetDefensibleDPS(sustainedfwddps, inputobject, true, true, true, true, false, true, false)
		if sustainedfwddps[0].dps > 0 then
			locrowdata = { false, ReadText(1001, 9093) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(sustainedfwddps[0].dps), true, 0, true) .. " " .. ReadText(1001, 119)) end) or (unknowntext .. " " .. ReadText(1001, 119)) }	-- MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
		-- weapon range
		local range = C.GetDefensibleWeaponFireRange(inputobject, true, true, true, true, true, false)
		if range > 0 then
			locrowdata = { false, ReadText(1001, 11649) .. ReadText(1001, 120), defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(range), true, 0, true) .. " " .. ReadText(1001, 107)) end) or (unknowntext .. " " .. ReadText(1001, 107)) }	-- MW
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
		-- crew skill
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			local shipcombinedskill = math.floor(C.GetShipCombinedSkill(inputobject) * 15 / 100)
			local printedshipcombinedskill = unknowntext
			local locfont = inputfont
			local locfontcolor = Color["text_normal"]
			if operatorinfo_details then
				printedshipcombinedskill = Helper.displaySkill(shipcombinedskill)
				locfontcolor = Color["text_skills"]
			end
			locrowdata = { false, ReadText(1001, 9427) .. ReadText(1001, 120), printedshipcombinedskill }	-- Crew Skill
			row = inputtable:addRow(locrowdata[1], { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = Helper.standardTextOffsetx + indentsize, mouseOverText = ReadText(1026, 1) })
			row[4]:setColSpan(5):createText(locrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = locfont, color = locfontcolor, mouseOverText = ReadText(1026, 1) })
		end
		-- radar range
		local radarrange = Helper.unlockInfo(defenceinfo_low, ConvertIntegerString((Helper.round(GetComponentData(object64, "maxradarrange")) / 1000), true, 0, true))
		locrowdata = { false, ReadText(1001, 2426) .. ReadText(1001, 120), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- boarding strength
		locrowdata = { false, ReadText(1001, 1325) .. ReadText(1001, 120), Helper.unlockInfo(defenceinfo_high, (function() return ConvertIntegerString(GetComponentData(object64, "boardingstrength") or 0, true, 0, true) end)) }	-- Boarding Attack Strength
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, {  })
					row[2]:setColSpan(2):createText(shipname, { color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), {  })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- pilot
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end
		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		if (not C.IsRealComponentClass(inputobject, "ship_xs")) and (not islasertower) then
			-- title
			local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
			if pilot then
				local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
				-- name
				local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
				local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText(printedpilotname, { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				if operatorinfo_details then
					locfontcolor = Color["text_skills"]
				end
				row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			else
				-- name
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText("-", { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			end
			-- commander
			local commander = nil
			if C.IsComponentClass(inputobject, "controllable") then
				commander = GetCommander(menu.infoSubmenuObject)
			end
			local commandername, commandercolor = "-", Color["text_normal"]
			if commander then
				commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
			end
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(commandername, { halign = "right", color = commandercolor })
			-- subordinates
			local subordinates = {}
			if C.IsComponentClass(inputobject, "controllable") then
				subordinates = GetSubordinates(inputobject)
			end
			local row = inputtable:addRow("info_subordinates", { interactive = false })
			row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
			-- current order
			local numorders = C.GetNumOrders(inputobject)
			local currentorders = ffi.new("Order[?]", numorders)
			local activeorder = ffi.new("Order")
			if numorders > 0 then
				numorders = C.GetOrders(currentorders, numorders, inputobject)
				activeorder = currentorders[0]
			else
				C.GetDefaultOrder(activeorder, inputobject)
			end
			local ordername = ReadText(1001, 31)
			local orderdefinition = ffi.new("OrderDefinition")
			if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
				ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
			end
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(2):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
			row[4]:setColSpan(5):createText(ordername, { halign = "right" })
			-- command
			if pilot and IsValidComponent(pilot) then
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120), { x = Helper.standardIndentStep })
				if #aicommandstack > 0 then
					aicommand = aicommandstack[1].command
					aicommandparam = aicommandstack[1].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				local numaicommands = #aicommandstack
				if numaicommands > 1 then
					aicommandaction = aicommandstack[numaicommands].command
					aicommandactionparam = aicommandstack[numaicommands].param
				end
				row[4]:setColSpan(5):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
			end
			if isplayerowned then
				-- transaction log
				local row = inputtable:addRow(true, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
				row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
			end
		end
		-- storage
		local storagemodules = GetStorageData(object64)
		local cargotable = {}
		local sortedwarelist = {}
		local simplewarelist = {}
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				simplewarelist[ware.ware] = true
			end
		end

		local isresupplyship = GetComponentData(object64, "cansupplyships")
		if isresupplyship then
			local n = C.GetNumMaxProductionStorage(object64)
			local buf = ffi.new("UIWareAmount[?]", n)
			n = C.GetMaxProductionStorage(buf, n, object64)
			for i = 0, n - 1 do
				local locwareid = ffi.string(buf[i].wareid)
				if not simplewarelist[locwareid] then
					local locware = {}
					locware["ware"] = locwareid
					locware["name"], locware["volume"] = GetWareData(locwareid, "name", "volume")
					locware["amount"] = 0
					locware["consumption"] = buf[i].amount
					table.insert(sortedwarelist, locware)
					--print("inserting " .. tostring(locware.name) .. ". id: " .. tostring(locware.ware) .. ", name: " .. tostring(locware.name) .. ", amount: " .. tostring(locware.amount) .. ", volume: " .. tostring(locware.volume) .. ", consumption: " .. tostring(locware.consumption))
				end
			end
		end

		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties) -- Storage
		if storageinfo_warelist then
			-- slider showing total filled capacity
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				row = inputtable:addRow("info_storage_used_" .. ffi.string(transporttype[i].transport), { interactive = false })
				row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = transporttype[i].spaceused, max = transporttype[i].capacity, suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. " (" .. ffi.string(transporttype[i].name) .. ")" .. ReadText(1001, 120)), { fontsize = config.mapFontSize })
			end

			--local row = inputtable:addRow("info_storage_totalused", {  })
			--row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = storagemodules.stored, max = math.max(storagemodules.capacity, storagemodules.stored), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 1402) .. ReadText(1001, 120)), { fontsize = config.mapFontSize })

			if isplayerowned then
				local numtrips = GetComponentData(object64, "numtrips") or 0
				if numtrips > 0 then
					local cargoaftertrades = GetCargoAfterTradeOrders(object64, true)
					local totalvolume = 0
					for ware, amount in pairs(cargoaftertrades) do
						totalvolume = totalvolume + amount * GetWareData(ware, "volume")
					end
					local row = inputtable:addRow("info_storage_future", { interactive = false })
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = totalvolume, max = math.max(storagemodules.capacity, totalvolume), suffix = ReadText(1001, 110), readOnly = true }):setText((ReadText(1001, 8374) .. ReadText(1001, 120)), { fontsize = config.mapFontSize })
				end
			end

			inputtable:addEmptyRow(config.mapRowHeight / 2)

			local candrop = isplayerowned and (not C.IsUnit(menu.infoSubmenuObject))
			local locpolicefaction = GetComponentData(GetComponentData(object64, "zoneid"), "policefaction")
			for _, wareentry in ipairs(cargotable) do
				local ware = wareentry.ware
				local amount = wareentry.amount
				local targetamount = GetWareProductionLimit(object64, ware)
				if not infodrops[ware] then
					infodrops[ware] = 0
				end
				local row = inputtable:addRow(ware, { interactive = playerowned })
				if not isresupplyship then
					row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(math.floor(storagemodules.capacity / GetWareData(ware, "volume")), amount - infodrops[ware]), readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
				else
					-- applies even if targetamount == 0
					if targetamount then
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = math.max(targetamount, amount), readOnly = not candrop }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
					else
						row[2]:setColSpan(7):createSliderCell({ height = config.mapRowHeight, start = amount - infodrops[ware], maxSelect = amount, max = amount, readOnly = not candrop, hideMaxValue = true }):setText(GetWareData(ware, "name"), { fontsize = config.mapFontSize, color = (locpolicefaction and IsWareIllegalTo(ware, GetComponentData(object64, "owner"), locpolicefaction)) and Color["text_illegal"] or Color["text_normal"] })
					end
				end

				if candrop then
					--local oldamount = amount
					row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateDrops(ware, amount, newamount, instance) end
					row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
					row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

					local row = inputtable:addRow("Drops", {  })
					row[4]:setColSpan(5):createText(function() return (infodrops[ware] ~= 0) and (ReadText(1001, 9406) .. ReadText(1001, 120) .. " (" .. tostring(infodrops[ware]) .. ")") or "" end, { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont })	-- Dropping, :
				end
			end

			if candrop then
				local stufftodrop = false
				for ware, numdrops in pairs(infodrops) do
					if numdrops > 0 then
						stufftodrop = true
						break
					end
				end
				local row = inputtable:addRow("ConfirmDrops", {  })

				-- add a "Drop" button
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 9405), { halign = "center", fontsize = config.mapFontSize })	-- Drop
				row[4].handlers.onClick = function() return menu.infoSubmenuConfirmDrops(inputobject, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = stufftodrop }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end
	elseif (mode == "station") or (mode == "buildstorage") then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			local row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize, nil, nil, false)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(object64, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(object64, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		if mode == "station" then
			local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(object64, "hullmax")), true, 4, true, true, true) or unknowntext
			locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(object64, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(object64, "hullpercent") .. "%)")) }	-- Hull, MJ
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		local radarrange = defenceinfo_low and (Helper.round(GetComponentData(object64, "maxradarrange")) / 1000) or unknowntext
		locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		-- docked ships
		local shipstoragecapacity, numdockingbays = GetComponentData(inputobject, "shipstoragecapacity", "numdockingbays")
		local maxdockedships = (shipstoragecapacity or 0) + (numdockingbays or 0)
		if maxdockedships > 0 then
			local numdockedships = 0
			if C.IsComponentClass(inputobject, "container") then
				numdockedships = C.GetNumDockedShips(inputobject, nil)
			end
			local row = inputtable:addRow("info_dockedships", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = numdockedships > 0 }):setText(function() return (numdockedships > 0 and menu.isInfoExtended("info_dockedships", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_dockedships", instance) end
			row[1].properties.uiTriggerID = "info_dockedships_toggle"
			row[2]:setColSpan(2):createText(ReadText(1001, 3265) .. ReadText(1001, 120)) -- Docked Ships
			row[4]:setColSpan(5):createText(numdockedships .. " / " .. maxdockedships, { halign = "right" })
			if menu.isInfoExtended("info_dockedships", instance) then
				local dockedships = ffi.new("UniverseID[?]", numdockedships)
				numdockedships = C.GetDockedShips(dockedships, numdockedships, inputobject, nil)
				local playerowneddockedships = {}
				local npcowneddockedships = {}
				for i = 0, numdockedships-1 do
					local locship = ConvertStringTo64Bit(tostring(dockedships[i]))
					if GetComponentData(locship, "isplayerowned") then
						table.insert(playerowneddockedships, locship)
					else
						table.insert(npcowneddockedships, locship)
					end
				end
				table.sort(playerowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)
				table.sort(npcowneddockedships, function(a, b) return GetComponentData(a, "size") > GetComponentData(b, "size") end)

				for i, shipid in ipairs(playerowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. i, {  })
					row[2]:setColSpan(2):createText(shipname, { color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", color = Color["text_player"], x = Helper.standardTextOffsetx + indentsize })
				end
				for i, shipid in ipairs(npcowneddockedships) do
					local shipname = ffi.string(C.GetComponentName(shipid))
					local iconid = GetComponentData(shipid, "icon")
					if iconid and iconid ~= "" then
						shipname = string.format("\027[%s] %s", iconid, shipname)
					end
					row = inputtable:addRow("info_dockedship" .. (#playerowneddockedships + i), {  })
					row[2]:setColSpan(2):createText(shipname, { x = Helper.standardTextOffsetx + indentsize })
					row[4]:setColSpan(5):createText(("(" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")"), { halign = "right", x = Helper.standardTextOffsetx + indentsize })
				end
			end
		end
		-- trade subscription
		locrowdata = { false, ReadText(1001, 9414), (GetComponentData(object64, "tradesubscription") and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Updating Trade Offers
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local buildstorage = ConvertIDTo64Bit(GetComponentData(inputobject, "buildstorage"))
		if isplayerowned then
			-- acccounts
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(1001, 7708), Helper.headerRowCenteredProperties) -- Account Management
			local playercash = GetPlayerMoney()
			local cashcontainers = {}
			if C.IsComponentClass(inputobject, "container") then
				if mode == "buildstorage" then
					table.insert(cashcontainers, { container = inputobject, estimatetype = "wantedmoney", text = ReadText(1001, 9429), helpoverlayprefix = "info_buildstorage_account_" }) -- Funds for Station Construction
				else
					table.insert(cashcontainers, { container = inputobject, estimatetype = "productionmoney", supply = true, tradewares = true, text = ReadText(1001, 7710), helpoverlayprefix = "info_station_account_" }) -- Station Account
				end
			end
			if buildstorage then
				table.insert(cashcontainers, { container = buildstorage, estimatetype = "wantedmoney", text = ReadText(1001, 9429), helpoverlayprefix = "info_buildstorage_account_" }) -- Funds for Station Construction
			end
			for i, entry in ipairs(cashcontainers) do
				if i ~= 1 then
					inputtable:addEmptyRow(config.mapRowHeight)
				end

				if not infocashtransferdetails.transfers[i] then
					infocashtransferdetails.transfers[i] = { object = entry.container, amount = 0, estimatetype = entry.estimatetype, supply = entry.supply, tradewares = entry.tradewares }
				end

				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:createText("", { cellBGColor = Color["row_background"] })
				row[2]:setColSpan(7):createText(entry.text, Helper.subHeaderTextProperties)

				local container = entry.container
				local containercash = GetAccountData(container, "money") or 0
				local sliderstart = infocashtransferdetails.transfers[i].amount + containercash
				local slidermax = math.max((containercash + playercash), sliderstart)

				local othertransfers = 0
				for j, transferentry in ipairs(infocashtransferdetails.transfers) do
					if j ~= i then
						othertransfers = othertransfers + transferentry.amount
					end
				end
				local slidermaxselect = math.min(math.max((containercash + playercash - othertransfers), sliderstart), slidermax)

				local row = inputtable:addRow("info_stationaccount" .. i, {  })
				row[2]:setColSpan(7):createSliderCell({
					height = config.mapRowHeight,
					start = sliderstart,
					min = math.min(containercash, 0),
					max = slidermax,
					maxSelect = slidermaxselect,
					suffix = ReadText(1001, 101),
					helpOverlayID = entry.helpoverlayprefix .. "slider",
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
				})

				row[2].handlers.onSliderCellChanged = function(_, value)
					local idx = i
					local loccash = containercash
					return menu.infoSubmenuUpdateTransferAmount(instance, value, idx, loccash) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				row[2].handlers.onSliderCellConfirm = function() menu.over = true end

				local row = inputtable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1]:createText("", { cellBGColor = Color["row_background"] })

				local baseestimate = GetComponentData(container, entry.estimatetype)
				local supplymoney, tradewaremoney = 0, 0
				local estimate = baseestimate
				if entry.supply then
					supplymoney = tonumber(C.GetSupplyBudget(container)) / 100
					estimate = estimate + supplymoney
				end
				if entry.tradewares then
					tradewaremoney = tonumber(C.GetTradeWareBudget(container)) / 100
					estimate = estimate + tradewaremoney
				end

				local text = ReadText(1001, 9434)
				local mouseovertext = ""
				if container == buildstorage then
					text = ReadText(1001, 9436)
				else
					mouseovertext =	ReadText(1001, 8420) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(baseestimate, false, true, 0, true)	.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8423) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(supplymoney, false, true, 0, true)		.. " " .. ReadText(1001, 101) .. "\n" ..
									ReadText(1001, 8447) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tradewaremoney, false, true, 0, true)	.. " " .. ReadText(1001, 101)
				end
				row[2]:setColSpan(2):createText(text .. ReadText(1001, 120), { mouseOverText = mouseovertext })
				row[4]:setColSpan(5):createText(ConvertMoneyString(estimate, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })

				local row = inputtable:addRow("info_updateaccount", {  })
				row[3]:createButton({ height = config.mapRowHeight, active = function () local money, estimate, isplayerowned = GetComponentData(container, "money", entry.estimatetype, "isplayerowned"); if not isplayerowned then return false end; if entry.supply then estimate = estimate + tonumber(C.GetSupplyBudget(container)) / 100 end; if entry.tradewares then estimate = estimate + tonumber(C.GetTradeWareBudget(container)) / 100 end; return (money + GetPlayerMoney()) > estimate end, helpOverlayID = entry.helpoverlayprefix .. "accept_estimate", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })	-- Accept Estimate
				row[3].handlers.onClick = function () return menu.infoSubmenuSetManagerAccountToEstimate(i, instance) end
				row[4]:setColSpan(2):createButton({ height = config.mapRowHeight, active = function () local isplayerowned = GetComponentData(container, "isplayerowned"); if not isplayerowned then return false end; return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
				row[4].handlers.onClick = function () return menu.infoSubmenuUpdateManagerAccount(i, instance) end
				row[6]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function () return menu.checkTransferDetails(i, instance) end }):setText(ReadText(1001, 64), { halign = "center", fontsize = config.mapFontSize })	-- Cancel
				row[6].handlers.onClick = function() return menu.resetInfoSubmenu(i, instance) end
			end
			if mode == "station" then
				-- trade rules
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(8):createText(ReadText(1001, 11010), Helper.headerRowCenteredProperties)

				local types = {
					{ type = "trade",	name = ReadText(1001, 11017) },
					{ type = "supply",	name = ReadText(1001, 11018) },
					{ type = "build",	name = ReadText(1001, 11019), condition = GetComponentData(inputobject, "canequipships") },
				}
				if buildstorage then
					table.insert(types, { type = "trade",	name = ReadText(1001, 11032), object = buildstorage })
				end
				local displayed = false
				for i, entry in ipairs(types) do
					if (entry.condition == nil) or entry.condition then
						if displayed then
							row = inputtable:addRow(false, {  })
							row[1]:setColSpan(8):createText("")
						end
						displayed = true

						row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
						row[1]:setColSpan(8):createText(entry.name .. ReadText(1001, 120))

						local object = entry.object or inputobject
						local hasownlist, traderuleid
						if entry.type == "trade" then
							hasownlist = C.HasContainerOwnTradeRule(object, "buy", "") or C.HasContainerOwnTradeRule(object, "sell", "")
							traderuleid = C.GetContainerTradeRuleID(object, "buy", "")
							if traderuleid ~= C.GetContainerTradeRuleID(object, "sell", "") then
								DebugError("menu.setupInfoSubmenuRows(): Mismatch between buy and sell trade rule on station level: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(inputobject, "sell", "")))
							end
						else
							hasownlist = C.HasContainerOwnTradeRule(object, entry.type, "")
							traderuleid = C.GetContainerTradeRuleID(object, entry.type, "")
						end

						local rowdata = "info_traderule_" .. entry.type .. "_global"
						local row = inputtable:addRow({ rowdata }, {  })
						row[1]:createCheckBox(not hasownlist, { width = config.mapRowHeight, height = config.mapRowHeight })
						row[1].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(object, entry.type, checked) end
						row[2]:setColSpan(7):createText(ReadText(1001, 8367))

						local row = inputtable:addRow("info_traderule_" .. entry.type .. "_current", {  })
						row[1]:setColSpan(7):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
						row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(object, entry.type, id, nil, true) end
						row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
						row[8]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
						row[8].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(object, (entry.type == "trade") and "buy" or entry.type, "")) end
					end
				end
				-- preferred build method
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(8):createText(ReadText(1001, 11298), Helper.headerRowCenteredProperties)

				local cursetting = ffi.string(C.GetContainerBuildMethod(inputobject))
				local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
				local foundcursetting = false
				local locresponses = {}
				local n = C.GetNumPlayerBuildMethods()
				if n > 0 then
					local buf = ffi.new("ProductionMethodInfo[?]", n)
					n = C.GetPlayerBuildMethods(buf, n)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
						if id == curglobalsetting then
							foundcursetting = true
						end
						table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
					end
				end
				-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
				if not foundcursetting then
					curglobalsetting = "default"
				end
				local hasownsetting = cursetting ~= ""

				local rowdata = "info_buildrule_global"
				local row = inputtable:addRow({ rowdata }, {  })
				row[1]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[1].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(inputobject, checked, curglobalsetting) end
				row[2]:setColSpan(7):createText(ReadText(1001, 8367))

				local row = inputtable:addRow("info_buildrule", {  })
				row[1]:setColSpan(8):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(inputobject, id) end
				row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
			end
		end
		if mode == "station" then
			-- manager
			local manager = GetComponentData(inputobject, "tradenpc")
			manager = ConvertIDTo64Bit(manager)
			local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
			if manager then
				managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
			end
			-- title
			local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(printedtitle, Helper.headerRowCenteredProperties)
			if manager then
				local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
				-- name
				local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
				local row = inputtable:addRow({ "info_pilot", manager, inputobject }, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText(printedmanagername, { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				if operatorinfo_details then
					locfontcolor = Color["text_skills"]
				end
				row[4]:setColSpan(5):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			else
				-- name
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createText("-", { halign = "right" })
				-- combined skill
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(2):createText(ReadText(1001, 8395) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 2) })
				local locfontcolor = Color["text_normal"]
				row[4]:setColSpan(5):createText("-", { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			end
			-- subordinates
			local subordinates = C.IsComponentClass(inputobject, "controllable") and GetSubordinates(inputobject) or {}
			local row = inputtable:addRow("info_subordinates", { interactive = false })
			row[2]:setColSpan(2):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[4]:setColSpan(5):createText(#subordinates, { halign = "right" })
			if isplayerowned then
				-- transaction log
				local row = inputtable:addRow(true, {  })
				row[2]:setColSpan(2):createText(ReadText(1001, 11286) .. ReadText(1001, 120))
				row[4]:setColSpan(5):createButton({  }):setText(ReadText(1001, 11287), { halign = "center" })
				row[4].handlers.onClick = function() Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, inputobject }); menu.cleanup() end
			end
		end
		--storage
		local productiontable = {}
		local products = {}
		local intermediatewares = {}
		local resources = {}
		local productionmodules = GetProductionModules(object64)
		for i, prodmod in ipairs(productionmodules) do
			local macro = GetComponentData(prodmod, "macro")
			local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
			for _, productdata in ipairs(macrodata.products) do
				if not products[productdata.ware] then
					products[productdata.ware] = { name = GetWareData(productdata.ware, "name"), amount = 0, ware = productdata.ware }
					products[productdata.ware].listed = false
				end
			end
		end
		list_allresources = GetComponentData(inputobject, "allresources")
		for _, resource in ipairs(list_allresources) do
			if products[resource] then
				intermediatewares[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				intermediatewares[resource].listed = false
				products[resource] = nil
			elseif not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
			end
		end
		storagemodules = {capacity = 0, stored = 0}
		if C.IsComponentClass(inputobject, "container") then
			storagemodules = GetStorageData(inputobject)
		end
		cargotable = { products = {text = ReadText(1001, 1610), numcatwares = 0, wares = {}}, intermediatewares = {text = ReadText(1001, 6100), numcatwares = 0, wares = {}}, resources = {text = ReadText(1001, 41), numcatwares = 0, wares = {}}, storage = {text = ReadText(1001, 1400), numcatwares = 0, wares = {}} }	-- Products, Resources, Storage
		local cargocatindex = { "products", "intermediatewares", "resources", "storage" }
		numwares = 0
		local sortedwarelist = {}
		-- numbered: ware (see below); storagemodule.name, storagemodule.consumption, storagemodule.stored, storagemodule.capacity
		for _, storagemodule in ipairs(storagemodules) do
			--print("storage module: " .. tostring(storagemodule.name) .. ", consumption: " .. tostring(storagemodule.consumption) .. ", stored: " .. tostring(storagemodule.stored) .. ", capacity: " .. tostring(storagemodule.capacity))
			-- can query: ware.ware, ware.name, ware.amount, ware.consumption, ware.volume
			for _, ware in ipairs(storagemodule) do
				--print("sortedwarelist. inserting stored ware: " .. ware.name .. ", amount: " .. tostring(ware.amount))
				table.insert(sortedwarelist, ware)
				if resources[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					resources[ware.ware].listed = true
				end
				if intermediatewares[ware.ware] then
					--print("resource: " .. ware.name .. " is already listed.")
					intermediatewares[ware.ware].listed = true
				end
				if products[ware.ware] then
					--print("product: " .. ware.name .. " is already listed.")
					products[ware.ware].listed = true
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				--print("sortedwarelist. inserting resource: " .. resource.name)
				table.insert(sortedwarelist, resource)
			end
		end
		for _, intermediateware in pairs(intermediatewares) do
			if not intermediateware.listed then
				--print("sortedwarelist. inserting intermediate ware: " .. intermediateware.name)
				table.insert(sortedwarelist, intermediateware)
			end
		end
		for _, product in pairs(products) do
			if not product.listed then
				--print("sortedwarelist. inserting product: " .. product.name)
				table.insert(sortedwarelist, product)
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)

		for _, ware in ipairs(sortedwarelist) do
			local usage = "storage"
			if intermediatewares[ware.ware] then
				usage = "intermediatewares"
			elseif products[ware.ware] then
				usage = "products"
			elseif resources[ware.ware] then
				usage = "resources"
			end
			--print("usage: " .. tostring(usage) .. ", ware: " .. tostring(ware.ware) .. ", amount: " .. tostring(ware.amount) .. ", entry: " .. tostring(ware))
			table.insert(cargotable[usage].wares, { ware = ware.ware, amount = ware.amount })
			cargotable[usage].numcatwares = cargotable[usage].numcatwares + 1
			numwares = numwares + 1
		end
		--print("estimated: " .. tostring(storagemodules.estimated) .. ", productionestimated: " .. tostring(storagemodules.productionestimated))
		local loccapacity = (storagemodules.capacity > 0) and storagemodules.capacity or 0
		local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
		local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext

		-- ware reservations
		local reservationscapacity = menu.getReservationsVolumeByTransportType(inputobject)
		local reservationscargo = menu.getReservationsAmountByWareType(inputobject)

		-- title
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 1400), Helper.headerRowCenteredProperties)
		if storageinfo_warelist then
			local n = C.GetNumCargoTransportTypes(inputobject, true)
			local transporttype = ffi.new("StorageInfo[?]", n)
			n = C.GetCargoTransportTypes(transporttype, n, inputobject, true, false)
			for i = 0, n - 1 do
				-- slider showing total filled capacity
				local rowdata = {
					inputtable = inputtable,
					textcolumn = 2,
					textcolspan = 7,
					barcolumn = 1,
					currentamount = transporttype[i].spaceused,
					futureamount = transporttype[i].spaceused,
					maxcapacity = transporttype[i].capacity,
					transporttypename = ffi.string(transporttype[i].name)
				}

				if reservationscapacity[ffi.string(transporttype[i].transport)] then
					rowdata.futureamount = rowdata.futureamount + reservationscapacity[ffi.string(transporttype[i].transport)]
				end

				menu.addCapacityRow(rowdata)
			end

			locrowdata = { "info_station_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
			local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
			local setting, list = menu.getTradeWareFilter(true)
			if menu.isInfoExtended(locrowdata[1], instance) then
				for i, usagecat in ipairs(cargocatindex) do
					if (cargotable[usagecat].numcatwares > 0) then
						--print("adding category: " .. cargotable[usagecat].text)
						locrowdata = { false, (cargotable[usagecat].text .. ReadText(1001, 120)) }
						local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata)
						for _, wareentry in ipairs(cargotable[usagecat].wares) do
							local ware = wareentry.ware
							local currentamount = wareentry.amount
							--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
							locrowdata = { GetWareData(ware, "name"), currentamount }
							local printedwarecapacity = GetWareProductionLimit(inputobject, ware)
							--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
							if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
								printedwarecapacity = currentamount
							end

							local buttondata = {
								inputtable = inputtable,
								buttoncolumn = 2,
								buttoncolspan = 7,
								barcolumn = 1,
								currentamount = currentamount,
								futureamount = currentamount,
								maxcapacity = printedwarecapacity,
								warename = GetWareData(ware, "name")
							}

							if reservationscargo[ware] then
								buttondata.futureamount = buttondata.futureamount + reservationscargo[ware]
							end

							buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
							menu.addWareInfoButtonRow(buttondata)
						end
					end
				end
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(7):createText(ReadText(1001, 3210))
		end

		-- build storage
		local storagemodules = {}
		local cargotable = {}
		local numwares = 0
		local sortedwarelist = {}
		local list_allresources = {}
		local resources = {}
		local reservationsbuildcapacity = 0
		local reservationsbuildcargo = 0
		if buildstorage then
			-- insert build storage details
			storagemodules = GetStorageData(buildstorage)
			list_allresources = GetComponentData(buildstorage, "allresources")
			-- build storage reservations
			reservationsbuildcapacity = menu.getReservationsAmountTotal(buildstorage)
			reservationsbuildcargo = menu.getReservationsAmountByWareType(buildstorage)
		end
		for _, resource in ipairs(list_allresources) do
			if not resources[resource] then
				resources[resource] = { name = tostring(GetWareData(resource, "name")), amount = 0, ware = resource }
				resources[resource].listed = false
				--print("registering resource: " .. tostring(resource))
			end
		end
		for _, storagemodule in ipairs(storagemodules) do
			for _, ware in ipairs(storagemodule) do
				table.insert(sortedwarelist, ware)
				--print("ware in storage. adding " .. tostring(ware.ware))
				if resources[ware.ware] then
					resources[ware.ware].listed = true
					--print(tostring(ware.ware) .. "is a resource.")
				end
			end
		end
		for _, resource in pairs(resources) do
			if not resource.listed then
				table.insert(sortedwarelist, resource)
				resource.listed = true
				--print("adding unlisted resource: " .. tostring(resource.ware))
			end
		end
		table.sort(sortedwarelist, function(a, b) return a.name < b.name end)
		for _, ware in ipairs(sortedwarelist) do
			table.insert(cargotable, { ware = ware.ware, amount = ware.amount })
			numwares = numwares + 1
		end
		--print("storageinfo_warelist: " .. tostring(storageinfo_warelist) .. " numwares > 0: " .. tostring(numwares > 0))
		--print("buildstorage: " .. ffi.string(C.GetComponentName(buildstorage)) .. " " .. tostring(buildstorage) .. " numwares: " .. tostring(numwares))

		-- title
		if buildstorage then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(8):createText(ReadText(20104, 80101), Helper.headerRowCenteredProperties)
			if storageinfo_warelist then
				local n = C.GetNumCargoTransportTypes(buildstorage, true)
				local transporttype = ffi.new("StorageInfo[?]", n)
				n = C.GetCargoTransportTypes(transporttype, n, buildstorage, true, false)
				for i = 0, n - 1 do
					-- slider showing total filled capacity
					local rowdata = {
						inputtable = inputtable,
						textcolumn = 2,
						textcolspan = 7,
						barcolumn = 1,
						currentamount = transporttype[i].spaceused,
						futureamount = transporttype[i].spaceused + reservationsbuildcapacity,
						maxcapacity = transporttype[i].capacity,
						transporttypename = ReadText(20104, 23003)
					}

					menu.addCapacityRow(rowdata)
				end

				local loccapacity = storageinfo_capacity and storagemodules.capacity or unknowntext
				local locamount = storageinfo_amounts and storagemodules.stored or unknowntext
				local printednumwares = storageinfo_amounts and ConvertIntegerString(numwares, true, 0, true) or unknowntext
				locrowdata = { "info_station_buildstorage_storage", (ReadText(1001, 1400) .. " (" .. printednumwares .. " " .. ((printednumwares == "1") and ReadText(1001, 45) or ReadText(1001, 46)) .. ")") }	-- Storage, Ware, Wares
				local row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, true, (numwares > 0) and true or false, 1, indentsize)
				local setting, list = menu.getTradeWareFilter(true)
				if menu.isInfoExtended(locrowdata[1], instance) then
					for _, wareentry in ipairs(cargotable) do
						local ware = wareentry.ware
						local currentamount = wareentry.amount
						--print("ware: " .. tostring(ware) .. ", amount: " .. tostring(currentamount))
						local printedwarecapacity = GetWareProductionLimit(buildstorage, ware)
						--print("printedwarecapacity: " .. tostring(printedwarecapacity) .. ", amount: " .. tostring(currentamount))
						if (printedwarecapacity < 1) or (printedwarecapacity < currentamount) then
							printedwarecapacity = currentamount
						end
						locrowdata = { GetWareData(ware, "name"), currentamount }

						local buttondata = {
							inputtable = inputtable,
							buttoncolumn = 2,
							buttoncolspan = 7,
							barcolumn = 1,
							currentamount = currentamount,
							futureamount = currentamount,
							maxcapacity = printedwarecapacity,
							warename = GetWareData(ware, "name")
						}

						if reservationsbuildcargo[ware] then
							buttondata.futureamount = buttondata.futureamount + reservationsbuildcargo[ware]
						end

						buttondata.textcolor, buttondata.buttonscript = menu.getWareButtonColorAndScript(list, setting, ware)
						menu.addWareInfoButtonRow(buttondata)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(7):createText(ReadText(1001, 3210))
			end
		end

	elseif mode == "sector" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		local owner = GetComponentData(object64, "ownername")
		if C.IsContestedSector(object64) then
			owner = owner .. " " .. ReadText(1001, 3247)
		end
		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, owner) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local stationtable = GetContainedStations(object64, true)
		local numstations = #stationtable
		local productiontable = {}
		local products = {}
		local sectorpopulation = 0
		for _, station in ipairs(stationtable) do
			local workforceinfo = C.GetWorkForceInfo(ConvertStringTo64Bit(tostring(station)), "")
			sectorpopulation = sectorpopulation + workforceinfo.current
			table.insert(productiontable, GetComponentData(station, "products"))
		end
		for _, entry in ipairs(productiontable) do
			for _, product in ipairs(entry) do
				local notincremented = true
				for compproduct, count in pairs(products) do
					if compproduct == product then
						products[product] = count + 1
						notincremented = false
						break
					end
				end
				if notincremented then
					products[product] = 1
				end
			end
		end
		local maxproductgrp = ReadText(1001, 9002)	-- Unknown
		local maxcount = 0
		for product, count in pairs(products) do
			if not maxproductgrp or (count > maxcount) then
				maxproductgrp = GetWareData(product, "groupName")
				maxcount = count
			end
		end

		locrowdata = { false, ReadText(1001, 9041), ConvertIntegerString(tonumber(C.GetSectorPopulation(object64)), true, 3, true) }	-- Population
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 11296), string.format("%+.0f%%", GetComponentData(object64, "populationworkforcefactor") * 100) }	-- Workforce Availability Bonus
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2456), ConvertIntegerString(sectorpopulation, true, 3, true) }	-- Station Workforce
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9042), (numstations > 0 and numstations or 0) }	-- Known Stations
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9050), maxproductgrp }	-- Main Production
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		-- natural resources
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 9423), Helper.headerRowCenteredProperties) -- Natural Resources
		local sunlight = (GetComponentData(object64, "sunlight") * 100 .. "%")
		locrowdata = { false, ReadText(1001, 2412), sunlight }	-- Sunlight
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local resources = {}
		local n = C.GetNumDiscoveredSectorResources(object64)
		local buf = ffi.new("WareYield[?]", n)
		n = C.GetDiscoveredSectorResources(buf, n, object64)
		for i = 0, n - 1 do
			table.insert(resources, { name = GetWareData(ffi.string(buf[i].ware), "name"), current = buf[i].current, max = buf[i].max })
		end
		table.sort(resources, Helper.sortName)

		for _, entry in ipairs(resources) do
			locrowdata = { false, entry.name, ConvertIntegerString(entry.current, true, 3, true) }
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		-- TODO: Add Region info: NB: Matthias says that yield numbers for regions could be too big to be useful, and that retrieving that info is very inefficient. But we'll try when the function is up.

	elseif mode == "gate" then
		-- general info
		local isgateactive = GetComponentData(object64, "isactive")
		local gatedestinationsector, gatedestinationsector64
		local gatedestination = unknowntext
		if isgateactive then
			local destgate = GetComponentData(object64, "destination")
			if destgate then
				gatedestinationsector = GetContextByClass(destgate, "sector")
				gatedestinationsector64 = ConvertStringTo64Bit(tostring(gatedestinationsector))
				local destspace = Helper.getDisplayableGateDestinationSpace(object64)
				if destspace then
					gatedestination = GetComponentData(destspace, "name")
				end
			end
		end
		locrowdata = { false, ReadText(1001, 3215), tostring(gatedestination) }	-- (gate) Destination
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local destinationowner = unknowntext
		if gatedestinationsector64 and C.IsInfoUnlockedForPlayer(gatedestinationsector64, "name") then
			destinationowner = GetComponentData(gatedestinationsector, "ownername") or ""
			if C.IsContestedSector(gatedestinationsector64) then
				destinationowner = destinationowner .. " " .. ReadText(1001, 3247)
			end
		end
		locrowdata = { false, ReadText(1001, 9424), tostring(destinationowner) }	-- Destination Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 9425), (isgateactive and ReadText(1001, 2617) or ReadText(1001, 2618)) }	-- Active, Yes, No
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
	elseif mode == "deployable" then
		-- general info
		locrowdata = { "info_name", ReadText(1001, 2809), objectname }	-- Name
		if isplayerowned then
			row = inputtable:addRow(locrowdata[1], {  })
			row[2]:setColSpan(2):createText(locrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = Helper.standardFont, x = Helper.standardTextOffsetx + (1 * indentsize) })
			row[4]:setColSpan(5):createEditBox({ height = config.mapRowHeight, description = locrowdata[2] }):setText(objectname, { halign = "right" })
			row[4].handlers.onEditBoxDeactivated = function(_, text, textchanged) return menu.infoChangeObjectName(inputobject, text, textchanged) end
		else
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end

		locrowdata = { false, ReadText(1001, 9040), Helper.unlockInfo(ownerinfo, GetComponentData(inputobject, "ownername")) }	-- Owner
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		locrowdata = { false, ReadText(1001, 2943), GetComponentData(inputobject, "sector") }	-- Location
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local hull_max = defenceinfo_low and ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hullmax")), true, 4, true, true, true) or unknowntext
		locrowdata = { false, ReadText(1001, 1), (defenceinfo_high and (function() return (ConvertIntegerString(Helper.round(GetComponentData(inputobject, "hull")), true, 4, true, true, true) .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. GetComponentData(inputobject, "hullpercent") .. "%)") end) or (unknowntext .. " / " .. hull_max .. " " .. ReadText(1001, 118) .. " (" .. unknowntext .. "%)")) }	-- Hull, MJ
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local radarrange, resourcedetectionrange = unknowntext, unknowntext
		if defenceinfo_low then
			radarrange, resourcedetectionrange = GetComponentData(inputobject, "maxradarrange", "resourcedetectionrange")
		end

		if C.IsComponentClass(menu.infoSubmenuObject, "mine") then
			-- add if mines are made selectable in the map again:
			--	detonation output (s), tracking capability (s), friend/foe (s), proximity (s)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "resourceprobe") then
			if resourcedetectionrange and resourcedetectionrange ~= unknowntext then
				resourcedetectionrange = Helper.round(resourcedetectionrange / 1000)
			end
			locrowdata = { "info_radarrange", ReadText(1001, 9082), (resourcedetectionrange .. " " .. ReadText(1001, 108)) }	-- Scanning Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		elseif C.IsComponentClass(menu.infoSubmenuObject, "satellite") then
			if radarrange and radarrange ~= unknowntext then
				radarrange = Helper.round(radarrange / 1000)
			end
			locrowdata = { false, ReadText(1001, 2426), (radarrange .. " " .. ReadText(1001, 108)) }	-- Radar Range, km
			row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)
		end
	elseif mode == "asteroid" then
		-- general info
		local rawlength = GetComponentData(inputobject, "length")
		local rawwidth = GetComponentData(inputobject, "width")
		local rawheight = GetComponentData(inputobject, "height")
		local loclength = ConvertIntegerString(rawlength, true, 0, true)
		local locwidth = ConvertIntegerString(rawwidth, true, 0, true)
		local locheight = ConvertIntegerString(rawheight, true, 0, true)
		locrowdata = { false, ReadText(1001, 9229), (loclength .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locwidth .. ReadText(1001, 107) .. " " .. ReadText(1001, 42) .. " " .. locheight .. ReadText(1001, 107)) }	-- m, x
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local rawvolume = rawlength * rawwidth * rawheight
		local locvolume = ConvertIntegerString(rawvolume, true, 0, true)
		locrowdata = { false, ReadText(1001, 1407), (locvolume .. " " .. ReadText(1001, 110)) }	-- Volume, m^3
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

		local wares = GetComponentData(inputobject, "wares")
		local hasyield = false
		if wares then
			for _, ware in ipairs(wares) do
				if ware.amount > 0 then
					hasyield = true
					break
				end
			end

			if hasyield then
				locrowdata = { false, ReadText(1001, 3214) .. ReadText(1001, 120) }	-- Yield, :
				row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 1, indentsize)

				for i, ware in ipairs(wares) do
					if ware.amount > 0 then
						local warename = GetWareData(ware.ware, "name")
						locrowdata = { false, warename, ware.amount }
						row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false, 2, indentsize)
					end
				end
			end
		end
	elseif mode == "none" then
		local locrowdata = { "info_none", ReadText(1001, 6526) }
		row = menu.addInfoSubmenuRow(instance, inputtable, row, locrowdata, false, false, false)
	else
		DebugError("menu.setupInfoSubmenuRows(): called with unsupported mode: " .. tostring(mode) .. ".")
	end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if menu.uix_callbacks ["utRenaming_setupInfoSubmenuRows_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_setupInfoSubmenuRows_on_end"]) do
			uix_callback(mode, inputtable, inputobject, instance)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback
end

function menu.setupCrewInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local operatorinfo =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_name")
	local operatorinfo_details =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_details")
	local operatorinfo_commands =		cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "operator_commands")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(7):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))

	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[7]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(6):setColSpan(5):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[6]:createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[6].properties.halign = "right"
		row[6].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(6):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedpilot"))
		local pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- pilot
		local printedtitle = isbigship and ReadText(1001, 4848) or ReadText(1001, 4847)	-- Captain, Pilot
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if pilot then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(pilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow({ "info_pilot", pilot, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
			-- replace pilot
			if isplayerowned then
				local line_replace = isbigship and ReadText(1001, 9430) or ReadText(1001, 9431)	-- Replace captain with best crewmember, Replace pilot with best crewmember
				-- button is clickable if:
				-- we have crew,
				-- we have a pilot,
				-- the pilot is not in a critical state (NPC_State_Machines),
				-- the controllable is not running an order in a critical state,
				-- and one of our crew members is better than the current pilot.
				-- NB: check to see if there is a pilot is necessary since there is a delay between pressing this button and the old pilot getting dismissed leading to errors in the later checks.
				local row = inputtable:addRow("ReplacePilot", {  })
				row[2]:setColSpan(6):createButton({ height = config.mapRowHeight, active = function() local locpilot = GetComponentData(inputobject, "assignedpilot"); return (infocrew.current.total > 0) and locpilot and IsValidComponent(locpilot) and (not C.IsCurrentOrderCritical(inputobject)) and menu.infoSubmenuReplacePilot(inputobject, ConvertIDTo64Bit(locpilot), nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, pilot, nil, nil, nil, instance) end
			end
		else
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, pilotname)
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText("-")
			row[6]:setColSpan(2):createText("-", { halign = "right", mouseOverText = ReadText(1026, 2) })
			if isplayerowned then
				-- replace pilot
				local line_replace = ReadText(1001, 9432) .. " " .. printedtitle	-- Promote best crewmember to
				local row = inputtable:addRow("ReplacePilot", {  })
				row[2]:setColSpan(5):createButton({ height = config.mapRowHeight, active = function () return (infocrew.current.total > 0) and menu.infoSubmenuReplacePilot(inputobject, nil, nil, true, nil, instance) end }):setText(line_replace, { halign = "center", fontsize = config.mapFontSize })
				row[2].handlers.onClick = function() return menu.infoSubmenuReplacePilot(inputobject, nil, nil, nil, nil, instance) end
			end
		end
		-- commander
		local commander
		if C.IsComponentClass(inputobject, "controllable") then
			commander = GetCommander(menu.infoSubmenuObject)
		end
		local commandername, commandercolor = "-", Color["text_normal"]
		if commander then
			commandername, commandercolor = menu.getContainerNameAndColors(commander, 0, false, false)
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(3):createText(ReadText(1001, 1112) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(commandername, { halign = "right", color = commandercolor })
		-- subordinates
		local subordinates = {}
		if C.IsComponentClass(inputobject, "controllable") then
			subordinates = GetSubordinates(inputobject)
		end
		local row = inputtable:addRow("info_subordinates", {  })
		row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
		row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
		row[1].properties.uiTriggerID = "info_subordinates_toggle"
		row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
		row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
		if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
			for i, locship in ipairs(subordinates) do
				local locship64 = ConvertIDTo64Bit(locship)
				subordinates[i] = { id = locship64, name = ffi.string(C.GetComponentName(locship64)), objectid = ffi.string(C.GetObjectIDCode(locship64)), class = ffi.string(C.GetComponentClass(locship64)), purpose = GetComponentData(locship, "primarypurpose") }
			end
			table.sort(subordinates, Helper.sortShipsByClassAndPurpose)

			for i, shipentry in ipairs(subordinates) do
				local shipname, textcolor = menu.getContainerNameAndColors(shipentry.id, 0, false, false)

				local row = inputtable:addRow("info_subordinate" .. i, {  })
				row[3]:setColSpan(4):createText(shipname, { color = textcolor })
				row[7]:createButton({ height = config.mapRowHeight }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, shipentry.id, true) end
			end
		end
		-- current order
		local numorders = C.GetNumOrders(inputobject)
		local currentorders = ffi.new("Order[?]", numorders)
		local activeorder = ffi.new("Order")
		if numorders > 0 then
			numorders = C.GetOrders(currentorders, numorders, inputobject)
			activeorder = currentorders[0]
		else
			C.GetDefaultOrder(activeorder, inputobject)
		end
		local ordername = ReadText(1001, 31)
		local orderdefinition = ffi.new("OrderDefinition")
		if activeorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, activeorder.orderdef) then
			ordername = Helper.unlockInfo(operatorinfo_commands, ffi.string(orderdefinition.name))
		end
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(3):createText(ReadText(1001, 8392) .. ReadText(1001, 120))
		row[5]:setColSpan(3):createText(ordername, { halign = "right" })
		-- command
		if pilot and IsValidComponent(pilot) then
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[3]:setColSpan(2):createText(ReadText(1001, 78) .. ReadText(1001, 120))
			if #aicommandstack > 0 then
				aicommand = aicommandstack[1].command
				aicommandparam = aicommandstack[1].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil)), { halign = "right" })
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			local numaicommands = #aicommandstack
			if numaicommands > 1 then
				aicommandaction = aicommandstack[numaicommands].command
				aicommandactionparam = aicommandstack[numaicommands].param
			end
			row[5]:setColSpan(3):createText(Helper.unlockInfo(operatorinfo_commands, string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil)), { halign = "right" })
		end
		-- # orders
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(4):createText(ReadText(1001, 9402) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo_commands, numorders), { halign = "right" })
		-- inventory
		if isplayerowned and pilot and IsValidComponent(pilot) then
			local inventory = GetInventory(pilot)
			local onlineitems = OnlineGetUserItems()

			-- kuertee start:
			if not onlineitems then
				onlineitems = {}
			end
			-- kuertee end

			local sortedWares = {}
			local totalamount = 0
			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(sortedWares, { ware = ware, name = entry.name, amount = entry.amount })
					totalamount = totalamount + entry.amount
				end
			end
			-- title
			local row = inputtable:addRow("info_pilot_inventory", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = totalamount > 0 }):setText(function() return ((totalamount > 0) and menu.isInfoExtended("info_pilot_inventory", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_pilot_inventory", instance) end
			row[2]:setColSpan(4):createText(ReadText(1001, 2202) .. ReadText(1001, 120))
			row[6]:setColSpan(2):createText(totalamount, { halign = "right" })
			if next(inventory) and menu.isInfoExtended("info_pilot_inventory", instance) then
				if #sortedWares > 0 then
					table.sort(sortedWares, Helper.sortName)
					-- wares
					for i, entry in ipairs(sortedWares) do
						local row = inputtable:addRow({ "info_inventory", entry.ware, inputobject }, {  })
						row[3]:setColSpan(3):createText(entry.name)
						row[6]:setColSpan(2):createText(ConvertIntegerString(entry.amount, true, 0, true), { halign = "right" })
					end
					-- drop inventory
					local row = inputtable:addRow("DropPilotInventory", {  })
					row[2]:setColSpan(3):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 7733), { halign = "center" })
					row[2].handlers.onClick = function() return menu.buttonDropPilotInventory(pilot, sortedWares) end
				end
			end
		end
		-- relief pilot
		local aipilot = ConvertIDTo64Bit(GetComponentData(inputobject, "assignedaipilot"))
		if aipilot and aipilot ~= pilot then
			local aipilotname, aipilotskilltable = GetComponentData(aipilot, "name", "skills")
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9403), Helper.headerRowCenteredProperties)
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(aipilot, nil, "aipilot") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedpilotname = Helper.unlockInfo(operatorinfo, aipilotname)
			local row = inputtable:addRow({ "info_pilot", aipilot, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedpilotname)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(aipilotskilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(aipilotskilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		end
		if C.IsComponentClass(inputobject, "controllable") then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
		end
	elseif mode == "station" then
		local manager, shiptrader, individualtrainee = GetComponentData(inputobject, "tradenpc", "shiptrader", "individualtrainee")
		manager = ConvertIDTo64Bit(manager)
		shiptrader = ConvertIDTo64Bit(shiptrader)
		local managername, skilltable, postname, isfemale = "-", {}, ReadText(1001, 4847)
		if manager then
			managername, skilltable, postname, isfemale = GetComponentData(manager, "name", "skills", "postname", "isfemale")
		end

		-- manager
		local printedtitle = (manager and isfemale) and ReadText(20208, 30302) or ReadText(20208, 30301)
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(printedtitle, Helper.headerRowCenteredProperties)
		if manager then
			local adjustedskill = math.floor(C.GetEntityCombinedSkill(manager, nil, "manager") * 15 / 100)
			local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill))
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow({ "info_manager", manager, inputobject }, {  })
			row[2]:setColSpan(4):createText(printedmanagername)
			local locfontcolor
			if operatorinfo_details then
				locfontcolor = Color["text_skills"]
			end
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = ReadText(1026, 2) })
			-- skills
			table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
			for _, skillproperties in ipairs(skilltable) do
				local skillname = ReadText(1013, skillproperties.textid)
				local adjustedskill = skillproperties.value
				local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
				local mouseovertext = ReadText(1013, skillproperties.descriptionid)
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				local locfontcolor
				if operatorinfo_details then
					locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
				end
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
			end
		else
			-- name
			local printedmanagername = Helper.unlockInfo(operatorinfo, managername)
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText("-")
			row[6]:setColSpan(2):createText("-", { halign = "right", mouseOverText = ReadText(1026, 2) })
		end
		if isplayerowned then
			-- budget
			local recommendedfunds = GetComponentData(inputobject, "productionmoney") or 0
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(4):createText(ReadText(1001, 9434) .. ReadText(1001, 120)) -- Expected operating budget
			row[6]:setColSpan(2):createText(ConvertMoneyString(recommendedfunds, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- subordinates
		if C.IsComponentClass(inputobject, "controllable") then
			local subordinates = GetSubordinates(inputobject)
			local row = inputtable:addRow("info_subordinates", {  })
			row[1]:createButton({ height = config.mapRowHeight, active = #subordinates > 0 }):setText(function() return (#subordinates > 0 and menu.isInfoExtended("info_subordinates", instance)) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_subordinates", instance) end
			row[1].properties.uiTriggerID = "info_subordinates_toggle"
			row[2]:setColSpan(4):createText(ReadText(1001, 1503) .. ReadText(1001, 120)) -- Subordinates
			row[6]:setColSpan(2):createText(#subordinates, { halign = "right" })
			if (#subordinates > 0) and menu.isInfoExtended("info_subordinates", instance) then
				for i, locship in ipairs(subordinates) do
					local locship64 = ConvertIDTo64Bit(locship)
					subordinates[i] = { id = locship64, name = ffi.string(C.GetComponentName(locship64)), objectid = ffi.string(C.GetObjectIDCode(locship64)), class = ffi.string(C.GetComponentClass(locship64)), purpose = GetComponentData(locship, "primarypurpose") }
				end
				table.sort(subordinates, Helper.sortShipsByClassAndPurpose)

				for i, shipentry in ipairs(subordinates) do
					local shipname, textcolor = menu.getContainerNameAndColors(shipentry.id, 0, false, false)

					local row = inputtable:addRow("info_subordinate" .. i, { interactive = false })
					row[3]:setColSpan(4):createText(shipname, { color = textcolor })
					row[7]:createButton({ height = config.mapRowHeight }):setIcon("menu_center_selection", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[7].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, shipentry.id, true) end
				end
			end
		end
		-- shiptrader
		if shiptrader then
			shiptrader = ConvertIDTo64Bit(shiptrader)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(GetComponentData(shiptrader, "isfemale") and ReadText(20208, 30502) or ReadText(20208, 30501), Helper.headerRowCenteredProperties) -- Ship Trader (female), Ship Trader (male)
			-- name
			local name = GetComponentData(shiptrader, "name")
			local row = inputtable:addRow({ "info_shiptrader", shiptrader, inputobject }, {  })
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
		end
		-- individualtrainee
		if individualtrainee then
			individualtrainee = ConvertIDTo64Bit(individualtrainee)
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(GetComponentData(individualtrainee, "isfemale") and ReadText(20208, 20602) or ReadText(20208, 20601), Helper.headerRowCenteredProperties)
			-- name
			local name, skilltable = GetComponentData(individualtrainee, "name", "skills")
			local row = inputtable:addRow({ "info_individualtrainee", individualtrainee, inputobject }, {  })
			row[1]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended("info_individualtrainee", instance) and "-" or "+" end, { halign = "center" })
			row[1].handlers.onClick = function() return menu.buttonExtendInfo("info_individualtrainee", instance) end
			row[2]:setColSpan(6):createText(Helper.unlockInfo(operatorinfo, tostring(name)))
			-- skills
			if menu.isInfoExtended("info_individualtrainee", instance) then
				table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
				for _, skillproperties in ipairs(skilltable) do
					local skillname = ReadText(1013, skillproperties.textid)
					local adjustedskill = skillproperties.value
					local printedskill = Helper.unlockInfo(operatorinfo_details, Helper.displaySkill(adjustedskill, skillproperties.relevance > 0))
					local mouseovertext = ReadText(1013, skillproperties.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[3]:setColSpan(3):createText(skillname, { font = (skillproperties.relevance > 0) and Helper.standardFontBold or nil, color = (skillproperties.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
					local locfontcolor
					if operatorinfo_details then
						locfontcolor = (skillproperties.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"]
					end
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = locfontcolor, mouseOverText = mouseovertext })
				end
			end
		end
		-- workforce
		local races = {}
		local n = C.GetNumAllRaces()
		local buf = ffi.new("RaceInfo[?]", n)
		n = C.GetAllRaces(buf, n)
		for i = 0, n - 1 do
			local entry = {}
			entry.id = ffi.string(buf[i].id)
			entry.name = ffi.string(buf[i].name)
			entry.workforceinfo = C.GetWorkForceInfo(inputobject, entry.id)
			if entry.workforceinfo.capacity > 0 then
				table.insert(races, entry)
			end
		end
		table.sort(races, Helper.sortName)
		if #races > 0 then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9415), Helper.headerRowCenteredProperties) -- Workforce
			for _, race in ipairs(races) do
				local row = inputtable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(4):createText(race.name)
				row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, race.workforceinfo.current .. " / " .. race.workforceinfo.capacity), { halign = "right" })
			end
		end
		-- player personnel
		local npctable = GetNPCs(inputobject)
		for i = #npctable, 1, -1 do
			if not GetComponentData(npctable[i], "isplayerowned") then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == manager then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == shiptrader then
				table.remove(npctable, i)
			elseif ConvertIDTo64Bit(npctable[i]) == individualtrainee then
				table.remove(npctable, i)
			end
		end
		if #npctable > 0 then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(7):createText(ReadText(1001, 9416), Helper.headerRowCenteredProperties) -- Player Employees On Board
			for i, npc in ipairs(npctable) do
				npc = ConvertIDTo64Bit(npc)
				local extendinfoid = string.format("info_crewperson_r%d", i)
				local row = inputtable:addRow({ "info_crewnpc", npc, inputobject }, {  })
				row[2]:createButton({ height = config.mapRowHeight }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
				row[2].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
				row[3]:setColSpan(3):createText(GetComponentData(npc, "name"), { mouseOverText = mouseovertext })
				row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Color["text_skills"], mouseOverText = ReadText(1026, 2) })
				if menu.isInfoExtended(extendinfoid, instance) then
					local skilltable = GetComponentData(npc, "skills")
					table.sort(skilltable, function(a, b) return a.relevance > b.relevance end)
					for _, skill in ipairs(skilltable) do
						local skillname = ReadText(1013, skill.textid)
						local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
						local mouseovertext = ReadText(1013, skill.descriptionid)
						local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
						row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, x = Helper.standardIndentStep, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
						row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
					end
				end
			end
		end

		if C.CanControllableHaveAnyTrainees(inputobject) then
			menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, nil, isplayerowned)
		end
	elseif mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(6):createText(ReadText(1001, 6526))
	end
end

function menu.addCrewSection(mode, inputtable, inputobject, instance, infocrew, operatorinfo, aipilot, isplayerowned)
	-- capacity
	local peoplecapacity = C.GetPeopleCapacity(inputobject, "", false)
	local totalcrewcapacity = infocrew.capacity
	if mode == "ship" then
		totalcrewcapacity = totalcrewcapacity + 1
	end
	local totalnumpeople = infocrew.total
	if aipilot then
		totalnumpeople = totalnumpeople + 1
	end
	local titlerow
	if (mode == "ship") or (totalnumpeople > 0) then
		-- crew
		titlerow = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		titlerow[1]:setColSpan(7):createText(ReadText(1001, 80), Helper.headerRowCenteredProperties)
		titlerow[1].properties.helpOverlayID = "crew_assigncrew"
		titlerow[1].properties.helpOverlayText = " "
		titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
		titlerow[1].properties.helpOverlayHighlightOnly = true
		titlerow[1].properties.helpOverlayScaling = false
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(4):createText(ReadText(1001, 9078) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createText(Helper.unlockInfo(operatorinfo, tostring(totalnumpeople)) .. " / " .. Helper.unlockInfo(operatorinfo, tostring(totalcrewcapacity)), { halign = "right" })
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end
	-- crew assignment
	if operatorinfo and totalnumpeople > 0 then
		local sliderrows = {}
		local slidercounter = 0
		-- unassigned
		local row = inputtable:addRow(true, { bgColor = Color["row_background_unselectable"] })
		row[1]:setBackgroundColSpan(6)
		row[2]:setColSpan(4):createText(ReadText(1001, 5207)) -- Unassigned
		row[6]:createText(function() return (tostring(infocrew.unassigned.total)) end, { halign = "right" })
		row[7]:createButton({ active = function () return infocrew.unassigned.total > 0 end, mouseOverText = ReadText(1026, 8002) }):setIcon("menu_dismiss")
		row[7].handlers.onClick = function () return menu.infoSubmenuFireAllNPCConfirm(inputobject, instance) end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize

		local rolewhitelist = {
			["prisoner"] = true,
			["passenger"] = true,
		}
		if mode == "ship" then
			rolewhitelist["service"] = true
			rolewhitelist["marine"] = true
		end
		if C.CanControllableHaveAnyTrainees(inputobject) then
			rolewhitelist["trainee_group"] = true
		end

		for i, roletable in ipairs(infocrew.current.roles) do
			if rolewhitelist[roletable.id] and (roletable.amount > 0 or roletable.canhire) then
				slidercounter = slidercounter + 1
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				--{
				--	id = ffi.string(peopletable[i].id),
				--	name = ffi.string(peopletable[i].name),
				--	desc = ffi.string(peopletable[i].desc),
				--	amount = peopletable[i].amount,
				--	canhire = peopletable[i].canhire,
				--	numtiers = peopletable[i].numtiers,
				--	tiers = {}
				--}
				local row = inputtable:addRow(ffi.string(roletable.id), { interactive = isplayerowned and roletable.canhire })
				--print("name: " .. ffi.string(roletable.name) .. ", canhire: " .. tostring(roletable.canhire))
				local maxselect = math.min(peoplecapacity, roletable.amount + infocrew.reassigned.roles[i].amount + infocrew.unassigned.total)
				local start = math.min(maxselect, roletable.amount + infocrew.reassigned.roles[i].amount)
				row[2]:setColSpan(6):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = roletable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned or not roletable.canhire }):setText(ffi.string(roletable.name), { fontsize = config.mapFontSize })
				sliderrows[slidercounter] = { ["row"] = row, ["col"] = 2, ["roleindex"] = i,["id"] = roletable.id, ["name"] = roletable.name, ["desc"] = roletable.desc, ["amount"] = roletable.amount, ["numtiers"] = roletable.numtiers, ["canhire"] = roletable.canhire, ["tiers"] = {} }
				titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
				local numtiers = roletable.numtiers
				for j, tiertable in ipairs(roletable.tiers) do
					if not tiertable.hidden then
						-- can query: .name, .skilllevel, .amount
						--{
						--	name = ffi.string(tiertable[j].name),
						--	skilllevel = tiertable[j].skilllevel,
						--	amount = tiertable[j].amount,
						--	persons = {}
						--}
						--print("tier name: " .. ffi.string(tiertable.name) .. ", skill level: " .. tostring(tiertable.skilllevel) .. ", num: " .. tostring(tiertable.amount))
						local row = inputtable:addRow(ffi.string(roletable.id) .. j, { interactive = isplayerowned })
						local maxselect = math.min(peoplecapacity, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						local start = math.min(maxselect, tiertable.amount + infocrew.reassigned.roles[i].tiers[j].amount)
						row[3]:setColSpan(5):createSliderCell({ height = config.mapRowHeight, start = start, minSelect = tiertable.transferring, max = peoplecapacity, maxSelect = maxselect, readOnly = not isplayerowned }):setText(ffi.string(tiertable.name), { fontsize = config.mapFontSize })
						sliderrows[slidercounter].tiers[j] = { ["row"] = row, ["col"] = 3, ["roleindex"] = i, ["name"] = tiertable.name, ["skilllevel"] = tiertable.skilllevel, ["amount"] = tiertable.amount }
						titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
					end
				end
			end
		end
		if isplayerowned then
			local row = inputtable:addRow("UpdateCrew", {  })
			row[2]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return (infocrew.reassigned.total > 0) end }):setText(ReadText(1001, 2821), { halign = "center", fontsize = config.mapFontSize })	-- Confirm
			row[2].handlers.onClick = function() return menu.infoSubmenuConfirmCrewChanges(instance) end
			row[5]:setColSpan(3):createButton({ height = config.mapRowHeight, active = function() return (infocrew.reassigned.total > 0) end }):setText(ReadText(1001, 3318), { halign = "center", fontsize = config.mapFontSize })	-- Reset
			row[5].handlers.onClick = function() return menu.resetInfoSubmenu(nil, instance) end
			titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
			for i, role in ipairs(sliderrows) do
				-- TODO: cleanup these tables. not all data is used.
				local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = role.col, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
				for j, tier in ipairs(role.tiers) do
					table.insert(sliderupdatetable.tierrows, { ["row"] = tier.row, ["col"] = tier.col, ["text"] = tier.name, ["xoffset"] = tier.row[2].properties.x, ["width"] = tier.row[2].properties.width })
				end

				role.row[2].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, false, nil, sliderupdatetable) end
				role.row[2].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
				role.row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				role.row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				for j, tier in ipairs(role.tiers) do
					tier.row[3].handlers.onSliderCellChanged = function(_, newamount) return menu.infoSubmenuUpdateCrewChanges(instance, newamount, sliderrows, i, true, j, sliderupdatetable) end
					tier.row[3].handlers.onSliderCellConfirm = function() return menu.refreshInfoFrame() end
					tier.row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
					tier.row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				end
			end
		end
		-- full crew list
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(7):createText(ReadText(1001, 9404), Helper.headerRowCenteredProperties) -- Full Crew List
		-- sorting
		local arrowWidth = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, {  })
		row[2]:setColSpan(2):createText(ReadText(1001, 2906) .. ReadText(1001, 120))
		row[4]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 2809)):setIcon((menu.crewSort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "name") or (menu.crewSort == "name_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[4].handlers.onClick = function () menu.crewSort = (menu.crewSort == "name") and "name_inv" or "name"; menu.refreshInfoFrame() end
		row[5]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11200)):setIcon((menu.crewSort == "role_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "role") or (menu.crewSort == "role_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[5].handlers.onClick = function () menu.crewSort = (menu.crewSort == "role") and "role_inv" or "role"; menu.refreshInfoFrame() end
		row[6]:setColSpan(2):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 9124)):setIcon((menu.crewSort == "skill_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[6].handlers.onClick = function () menu.crewSort = (menu.crewSort == "skill") and "skill_inv" or "skill"; menu.refreshInfoFrame() end
		-- skill display
		local roleOptions = {
			{ id = "post:aipilot",		text = ReadText(20208, 30101), icon = "", displayremoveoption = false },
			{ id = "post:manager",		text = ReadText(20208, 30301), icon = "", displayremoveoption = false },
			{ id = "post:shiptrader",	text = ReadText(20208, 30501), icon = "", displayremoveoption = false },
			{ id = "role:service",		text = ReadText(20208, 20103), icon = "", displayremoveoption = false },
			{ id = "role:marine",		text = ReadText(20208, 20203), icon = "", displayremoveoption = false },
		}
		table.sort(roleOptions, function (a, b) return a.text < b.text end)
		table.insert(roleOptions, 1, { id = "current", text = ReadText(1001, 8373), icon = "", displayremoveoption = false })
		local row = inputtable:addRow(true, {  })
		row[2]:setColSpan(4):createText(ReadText(1001, 8399) .. ReadText(1001, 120))
		row[6]:setColSpan(2):createDropDown(roleOptions, { startOption = menu.crewRole })
		row[6].handlers.onDropDownConfirmed = function (_, newrole) menu.noupdate = false; if menu.crewRole ~= newrole then menu.crewRole = newrole; menu.refreshInfoFrame() end end
		row[6].handlers.onDropDownActivated = function () menu.noupdate = true end

		inputtable:addEmptyRow(config.mapRowHeight / 2)

		local role, post, rolename
		if menu.crewRole ~= "current" then
			local type, id = string.match(menu.crewRole, "(.+):(.+)")
			if type == "post" then
				post = id
			elseif type == "role" then
				role = id
			end
			for _, option in ipairs(roleOptions) do
				if option.id == menu.crewRole then
					rolename = option.text
					break
				end
			end
		end

		local tierinfo
		if role then
			tierinfo = {}
			local numpeople = C.GetNumAllRoles()
			local peopletable = ffi.new("PeopleInfo[?]", numpeople)
			numpeople = C.GetPeople2(peopletable, numpeople, inputobject, true)
			for i = 0, numpeople - 1 do
				if ffi.string(peopletable[i].id) == role then
					local numtiers = peopletable[i].numtiers
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, inputobject, role)
					for j = 0, numtiers - 1 do
						tierinfo[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel }
					end
					table.sort(tierinfo, function (a, b) return a.skilllevel > b.skilllevel end)
				end
			end
		end

		local combinedcrew = menu.infoSubmenuCombineCrewTables(instance)
		local prevrole, prevtier
		for _, personentry in ipairs(combinedcrew) do
			if (menu.crewSort == "role") or (menu.crewSort == "role_inv") then
				if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then
					prevrole = personentry.rolename
					prevtier = personentry.tiername

					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(7):createText(personentry.rolename .. (personentry.tiername and (" - " .. personentry.tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			elseif role and ((menu.crewSort == "skill") or (menu.crewSort == "skill_inv")) then
				local tiername
				for _, tierentry in ipairs(tierinfo) do
					if personentry.skill >= tierentry.skilllevel then
						tiername = tierentry.name
						break
					end
				end
				if (not prevrole) or (prevrole ~= rolename) or (prevtier ~= tiername) then
					prevrole = rolename
					prevtier = tiername

					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(7):createText(rolename .. (tiername and (" - " .. tiername) or ""), Helper.headerRowCenteredProperties)
					row[1].properties.font = Helper.standardFont
				end
			end

			local adjustedcombinedskill = math.floor(personentry.skill * 15 / 100)
			local extendinfoid = string.format("info_crewperson_%s", tostring(personentry.person))
			local printedname = personentry.name
			local mouseovertext = ""
			local color
			if C.IsPersonTransferScheduled(inputobject, personentry.person) then
				printedname = ColorText["crew_transfer"] .. "\027[warning]" .. printedname
				mouseovertext = ReadText(1026, 3228)
			elseif not C.HasPersonArrived(inputobject, personentry.person) then
				color = Color["text_inactive"]
				mouseovertext = ReadText(1026, 3247)
			end
			local printedskill = Helper.displaySkill(adjustedcombinedskill)
			local row = inputtable:addRow({ "info_crewperson", personentry.person, inputobject }, {  })
			row[1]:createButton({ height = config.mapRowHeight, helpOverlayID = "info_crewperson", helpOverlayText = " " }):setText(function() return menu.isInfoExtended(extendinfoid, instance) and "-" or "+" end, { halign = "center" })
			row[1].properties.uiTriggerID = "info_crewperson"
			row[1].handlers.onClick = function() return menu.buttonExtendInfo(extendinfoid, instance) end
			row[2]:setColSpan(3):createText(printedname, { mouseOverText = mouseovertext, color = color })
			local roleColor, mouseovertext
			if (menu.crewRole ~= "current") and (role ~= personentry.roleid) and (post ~= personentry.roleid) then
				roleColor = Color["text_inactive"]
				mouseovertext = string.format(ReadText(1026, 3231), rolename)
			end
			row[5]:createText(personentry.rolename, { color = roleColor, mouseOverText = mouseovertext })
			row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = Color["text_skills"], mouseOverText = ReadText(1026, 2) })
			if menu.isInfoExtended(extendinfoid, instance) then
				local numskills = C.GetNumSkills()
				local skilltable = ffi.new("Skill2[?]", numskills + 1)
				numskills = C.GetPersonSkillsForAssignment(skilltable, personentry.person, inputobject, role, post)
				local sortedskilltable = {}
				for i = 1, numskills do
					table.insert(sortedskilltable, skilltable[i])
				end
				table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
				for i, skill in ipairs(sortedskilltable) do
					local skillname = ReadText(1013, skill.textid)
					local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
					local mouseovertext = ReadText(1013, skill.descriptionid)
					local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
					row[3]:setColSpan(3):createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
					row[6]:setColSpan(2):createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
				end
			end
		end
	end
end

function menu.setupLoadoutInfoSubmenuRows(mode, inputtable, inputobject, instance)
	local object64 = ConvertStringTo64Bit(tostring(inputobject))
	local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(object64, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
	local titlecolor = Color["text_normal"]
	if isplayerowned then
		titlecolor = menu.holomapcolor.playercolor
		if object64 == C.GetPlayerObjectID() then
			titlecolor = menu.holomapcolor.currentplayershipcolor
		end
	elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
		titlecolor = menu.holomapcolor.visitorcolor
	elseif ishostile then
		titlecolor = menu.holomapcolor.hostilecolor
	elseif isenemy then
		titlecolor = menu.holomapcolor.enemycolor
	end

	local loadout = {}
	if mode == "ship" or mode == "station" then
		loadout = { ["component"] = {}, ["macro"] = {}, ["ware"] = {} }
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				loadout.component[upgradetype.type] = {}
				local numslots = 0
				if C.IsComponentClass(inputobject, "defensible") then
					numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", upgradetype.type))
				end
				for j = 1, numslots do
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, upgradetype.type, j)
					if current ~= 0 then
						table.insert(loadout.component[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "virtualmacro" then
				loadout.macro[upgradetype.type] = {}
				local numslots = tonumber(C.GetNumVirtualUpgradeSlots(inputobject, "", upgradetype.type))
				for j = 1, numslots do
					local current = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(inputobject, upgradetype.type, j))
					if current ~= "" then
						table.insert(loadout.macro[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "software" then
				loadout.ware[upgradetype.type] = {}
				local numslots = C.GetNumSoftwareSlots(inputobject, "")
				local buf = ffi.new("SoftwareSlot[?]", numslots)
				numslots = C.GetSoftwareSlots(buf, numslots, inputobject, "")
				for j = 0, numslots - 1 do
					local current = ffi.string(buf[j].current)
					if current ~= "" then
						table.insert(loadout.ware[upgradetype.type], current)
					end
				end
			elseif upgradetype.supertype == "ammo" then
				loadout.macro[upgradetype.type] = {}
			end
		end
	end

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo =					cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")
	local defenceinfo_low =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_level")
	local defenceinfo_high =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "defence_status")
	local unitinfo_capacity =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_capacity")
	local unitinfo_amount =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_amount")
	local unitinfo_details =			cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "units_details")
	local equipment_mods =				cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "equipment_mods")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(13):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties)

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	-- object name
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[13]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[13].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if (mode == "ship") or (mode == "station") then
		row[1]:setBackgroundColSpan(12):setColSpan(6):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		row[7]:setColSpan(6):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		row[7].properties.halign = "right"
		row[7].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(12):setColSpan(12):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if mode == "ship" then
		local pilot = GetComponentData(inputobject, "assignedpilot")
		pilot = ConvertIDTo64Bit(pilot)
		local pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = "-", {}, ReadText(1001, 4847), {}
		if pilot and IsValidComponent(pilot) then
			pilotname, skilltable, postname, aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(pilot, "name", "skills", "postname", "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
		end

		local isbigship = C.IsComponentClass(inputobject, "ship_m") or C.IsComponentClass(inputobject, "ship_l") or C.IsComponentClass(inputobject, "ship_xl")
		-- weapon config
		if isplayerowned and (#loadout.component.weapon > 0) then
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 9409), Helper.headerRowCenteredProperties) -- Weapon Configuration
			-- subheader
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[3]:setColSpan(5):createText(ReadText(1001, 9410), { font = Helper.standardFontBold }) -- Primary
			row[8]:setColSpan(6):createText(ReadText(1001, 9411), { font = Helper.standardFontBold }) -- Secondary
			-- active weapon groups
			local row = inputtable:addRow("info_weaponconfig_active", {  })
			row[2]:createText(ReadText(1001, 11218))
			for j = 1, 4 do
				row[2 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, true) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
				row[2 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, true, j) end
			end
			for j = 1, 4 do
				row[7 + j]:createCheckBox(function () return C.GetDefensibleActiveWeaponGroup(inputobject, false) == j end, { width = config.mapRowHeight, height = config.mapRowHeight, symbol = "arrow", bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
				row[7 + j].handlers.onClick = function () C.SetDefensibleActiveWeaponGroup(inputobject, false, j) end
			end
			inputtable:addEmptyRow(config.mapRowHeight / 2)
			-- weapons
			for i, gun in ipairs(loadout.component.weapon) do
				local gun = ConvertStringTo64Bit(tostring(gun))
				local numweapongroups = C.GetNumWeaponGroupsByWeapon(inputobject, gun)
				local rawweapongroups = ffi.new("UIWeaponGroup[?]", numweapongroups)
				numweapongroups = C.GetWeaponGroupsByWeapon(rawweapongroups, numweapongroups, inputobject, gun)
				local uiweapongroups = { primary = {}, secondary = {} }
				for j = 0, numweapongroups - 1 do
					-- there are two sets: primary and secondary.
					-- each set has four groups.
					-- .primary tells you if this particular weapon is active in a group in the primary or secondary group set.
					-- .idx tells you which group in that group set it is active in.
					if rawweapongroups[j].primary then
						uiweapongroups.primary[rawweapongroups[j].idx] = true
					else
						uiweapongroups.secondary[rawweapongroups[j].idx] = true
					end
					--print("primary: " .. tostring(rawweapongroups[j].primary) .. ", idx: " .. tostring(rawweapongroups[j].idx))
				end

				local row = inputtable:addRow("info_weaponconfig" .. i, {  })
				row[2]:createText(ffi.string(C.GetComponentName(gun)))

				-- primary weapon groups
				for j = 1, 4 do
					row[2 + j]:createCheckBox(uiweapongroups.primary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, true) end })
					row[2 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, true, j, not uiweapongroups.primary[j]) end
				end

				-- secondary weapon groups
				for j = 1, 4 do
					row[7 + j]:createCheckBox(uiweapongroups.secondary[j], { width = config.mapRowHeight, height = config.mapRowHeight, bgColor = function () return menu.infoWeaponGroupCheckBoxColor(inputobject, j, false) end })
					row[7 + j].handlers.onClick = function() menu.infoSetWeaponGroup(inputobject, gun, false, j, not uiweapongroups.secondary[j]) end
				end

				if IsComponentClass(gun, "missilelauncher") then
					local nummissiletypes = C.GetNumAllMissiles(inputobject)
					local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
					nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, nummissiletypes - 1 do
						local ammomacro = ffi.string(missilestoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(missilestoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), {  })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				elseif pilot and IsValidComponent(pilot) and IsComponentClass(gun, "bomblauncher") then
					local numbombtypes = C.GetNumAllInventoryBombs(pilot)
					local bombstoragetable = ffi.new("AmmoData[?]", numbombtypes)
					numbombtypes = C.GetAllInventoryBombs(bombstoragetable, numbombtypes, pilot)

					local gunmacro = GetComponentData(gun, "macro")
					local dropdowndata = {}
					for j = 0, numbombtypes - 1 do
						local ammomacro = ffi.string(bombstoragetable[j].macro)
						if C.IsAmmoMacroCompatible(gunmacro, ammomacro) then
							table.insert(dropdowndata, {id = ammomacro, text = GetMacroData(ammomacro, "name") .. " (" .. ConvertIntegerString(bombstoragetable[j].amount, true, 0, true) .. ")", icon = "", displayremoveoption = false})
						end
					end

					-- if the ship has no compatible ammunition in ammo storage, have the dropdown print "Out of ammo" and make it inactive.
					local currentammomacro = "empty"
					local dropdownactive = true
					if #dropdowndata == 0 then
						dropdownactive = false
						table.insert(dropdowndata, {id = "empty", text = ReadText(1001, 9412), icon = "", displayremoveoption = false})	-- Out of ammo
					else
						-- NB: currentammomacro can be null
						currentammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(gun))
					end

					row = inputtable:addRow(("info_weaponconfig" .. i .. "_ammo"), {  })
					row[2]:createText((ReadText(1001, 2800) .. ReadText(1001, 120)))	-- Ammunition, :
					row[3]:setColSpan(11):createDropDown(dropdowndata, {startOption = currentammomacro, active = dropdownactive})
					row[3].handlers.onDropDownConfirmed = function(_, newammomacro) C.SetAmmoOfWeapon(gun, newammomacro) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- turret behaviour
		menu.turrets = {}
		menu.turretgroups = {}
		if isplayerowned and #loadout.component.turret > 0 then
			local hasnormalturrets = false
			local hasmissileturrets = false
			local hasoperationalnormalturrets = false
			local hasoperationalmissileturrets = false
			local hasonlytugturrets = true

			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 8612), Helper.headerRowCenteredProperties) -- Turret Behaviour
			local numslots = tonumber(C.GetNumUpgradeSlots(inputobject, "", "turret"))
			for j = 1, numslots do
				local groupinfo = C.GetUpgradeSlotGroup(inputobject, "", "turret", j)
				if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
					local current = C.GetUpgradeSlotCurrentComponent(inputobject, "turret", j)
					if current ~= 0 then
						if (not hasmissileturrets) or (not hasnormalturrets) then
							local ismissileturret = C.IsComponentClass(current, "missileturret")
							hasmissileturrets = hasmissileturrets or ismissileturret
							hasnormalturrets = hasnormalturrets or (not ismissileturret)
						end
						if not GetComponentData(ConvertStringTo64Bit(tostring(current)), "istugweapon") then
							hasonlytugturrets = false
						end
						table.insert(menu.turrets, current)
					end
				end
			end

			local groups = {}
			local turretsizecounts = {}
			local n = C.GetNumUpgradeGroups(inputobject, "")
			local buf = ffi.new("UpgradeGroup2[?]", n)
			n = C.GetUpgradeGroups2(buf, n, inputobject, "")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
					table.insert(groups, { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
				end
			end
			table.sort(groups, function (a, b) return a.group < b.group end)
			for _, group in ipairs(groups) do
				local groupinfo = C.GetUpgradeGroupInfo2(inputobject, "", group.context, group.path, group.group, "turret")
				if (groupinfo.count > 0) then
					group.operational = groupinfo.operational
					group.currentcomponent = groupinfo.currentcomponent
					group.currentmacro = ffi.string(groupinfo.currentmacro)
					group.slotsize = ffi.string(groupinfo.slotsize)
					group.sizecount = 0
					if (not hasmissileturrets) or (not hasnormalturrets) then
						local ismissileturret = IsMacroClass(group.currentmacro, "missileturret")
						hasmissileturrets = hasmissileturrets or ismissileturret
						hasnormalturrets = hasnormalturrets or (not ismissileturret)
						if ismissileturret then
							if not hasoperationalmissileturrets then
								hasoperationalmissileturrets = group.operational > 0
							end
						else
							if not hasoperationalnormalturrets then
								hasoperationalnormalturrets = group.operational > 0
							end
						end
					end
					if not GetComponentData(ConvertStringTo64Bit(tostring(group.currentcomponent)), "istugweapon") then
						hasonlytugturrets = false
					end

					if group.slotsize ~= "" then
						if turretsizecounts[group.slotsize] then
							turretsizecounts[group.slotsize] = turretsizecounts[group.slotsize] + 1
						else
							turretsizecounts[group.slotsize] = 1
						end
						group.sizecount = turretsizecounts[group.slotsize]
					end

					table.insert(menu.turretgroups, group)
				end
			end

			if #menu.turretgroups > 0 then
				table.sort(menu.turretgroups, Helper.sortSlots)
			end

			if (#menu.turrets > 0) or (#menu.turretgroups > 0) then
				if mode == "ship" then
					local row = inputtable:addRow("info_turretconfig", {  })
					row[2]:setColSpan(3):createText(ReadText(1001, 2963))
					
					-- Start Subsystem Targeting Orders callback
					local sto_callbackVal
					if menu.uix_callbacks ["sto_addTurretBehavioursMapMenu"] then
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["sto_addTurretBehavioursMapMenu"]) do
							sto_callbackVal = uix_callback (row, inputobject)
						end
					end
					if not sto_callbackVal then
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(nil, not hasonlytugturrets), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all") end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllTurretModes(inputobject, newturretmode) end
					end
					-- End Subsystem Targeting Orders callback

					row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

					local row = inputtable:addRow("info_turretconfig_2", {  })
					row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
					row[5].handlers.onClick = function () return C.SetAllTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject)) end

					local dropdownCount = 1
					for i, turret in ipairs(menu.turrets) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)

						local row = inputtable:addRow("info_turretconfig" .. i, {  })
						row[2]:setColSpan(3):createText(ffi.string(C.GetComponentName(turret)))
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(turret), { startOption = function () return menu.getDropDownTurretModeOption(turret) end })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetWeaponMode(turret, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretconfig" .. i .. "_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsWeaponArmed(turret) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetWeaponArmed(turret, not C.IsWeaponArmed(turret)) end
					end

					for i, group in ipairs(menu.turretgroups) do
						inputtable:addEmptyRow(config.mapRowHeight / 2)

						local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")

						local row = inputtable:addRow("info_turretgroupconfig" .. i, {  })
						row[2]:setColSpan(3):createText(name, { color = (group.operational > 0) and Color["text_normal"] or Color["text_error"] })
						row[5]:setColSpan(9):createDropDown(Helper.getTurretModes(group.currentcomponent), { startOption = function () return menu.getDropDownTurretModeOption(inputobject, group.context, group.path, group.group) end, active = group.operational > 0 })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetTurretGroupMode2(inputobject, group.context, group.path, group.group, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end
						dropdownCount = dropdownCount + 1
						if dropdownCount == 14 then
							inputtable.properties.maxVisibleHeight = inputtable:getFullHeight()
						end

						local row = inputtable:addRow("info_turretgroupconfig" .. i .. "_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetTurretGroupArmed(inputobject, group.context, group.path, group.group, not C.IsTurretGroupArmed(inputobject, group.context, group.path, group.group)) end
					end
				elseif mode == "station" then
					local turretmodes = {
						[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false },
						[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false },
						[3] = { id = "attackcapital",	text = ReadText(1001, 8634),	icon = "",	displayremoveoption = false },
						[4] = { id = "prefercapital",	text = ReadText(1001, 8637),	icon = "",	displayremoveoption = false },
						[5] = { id = "attackfighters",	text = ReadText(1001, 8635),	icon = "",	displayremoveoption = false },
						[6] = { id = "preferfighters",	text = ReadText(1001, 8638),	icon = "",	displayremoveoption = false },
						[7] = { id = "missiledefence",	text = ReadText(1001, 8636),	icon = "",	displayremoveoption = false },
						[8] = { id = "prefermissiles",	text = ReadText(1001, 8639),	icon = "",	displayremoveoption = false },
					}

					if hasnormalturrets then
						-- non-missile
						local row = inputtable:addRow("info_turretconfig", {  })
						row[2]:setColSpan(3):createText(ReadText(1001, 8397))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", false) end, active = hasoperationalnormalturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllNonMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, false) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllNonMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, false)) end
					end
					if hasmissileturrets then
						-- missile
						local row = inputtable:addRow("info_turretconfig_missile", {  })
						row[2]:setColSpan(3):createText(ReadText(1001, 9031))
						row[5]:setColSpan(9):createDropDown(turretmodes, { startOption = function () return menu.getDropDownTurretModeOption(inputobject, "all", true) end, active = hasoperationalmissileturrets, mouseOverText = (not hasoperationalnormalturrets) and ReadText(1026, 3235) or nil })
						row[5].handlers.onDropDownConfirmed = function(_, newturretmode) menu.noupdate = false; C.SetAllMissileTurretModes(inputobject, newturretmode) end
						row[5].handlers.onDropDownActivated = function () menu.noupdate = true end

						local row = inputtable:addRow("info_turretconfig_missile_2", {  })
						row[5]:setColSpan(9):createButton({ height = config.mapRowHeight }):setText(function () return menu.areTurretsArmed(inputobject, true) and ReadText(1001, 8631) or ReadText(1001, 8632) end, { halign = "center" })
						row[5].handlers.onClick = function () return C.SetAllMissileTurretsArmed(inputobject, not menu.areTurretsArmed(inputobject, true)) end
					end
				end
			end
		end
		-- drones
		local isplayeroccupiedship = menu.infoSubmenuObject == ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))

		local unitstoragetable = C.IsComponentClass(object64, "defensible") and GetUnitStorageData(object64) or { stored = 0, capacity = 0 }
		local locunitcapacity = Helper.unlockInfo(unitinfo_capacity, tostring(unitstoragetable.capacity))
		local locunitcount = Helper.unlockInfo(unitinfo_amount, tostring(unitstoragetable.stored))
		menu.drones = {}
		local dronetypes = {
			{ id = "orecollector",	name = ReadText(20214, 500),	displayonly = true },
			{ id = "gascollector",	name = ReadText(20214, 400),	displayonly = true },
			{ id = "defence",		name = ReadText(20214, 300) },
			{ id = "transport",		name = ReadText(20214, 900) },
			{ id = "build",			name = ReadText(20214, 1000),	skipmode = true },
			{ id = "repair",		name = ReadText(20214, 1100),	skipmode = true },
		}
		for _, dronetype in ipairs(dronetypes) do
			if C.GetNumStoredUnits(inputobject, dronetype.id, false) > 0 then
				local entry
				if not dronetype.skipmode then
					entry = {
						type = dronetype.id,
						name = dronetype.name,
						current = ffi.string(C.GetCurrentDroneMode(inputobject, dronetype.id)),
						modes = {},
						displayonly = dronetype.displayonly,
					}
					local n = C.GetNumDroneModes(inputobject, dronetype.id)
					local buf = ffi.new("DroneModeInfo[?]", n)
					n = C.GetDroneModes(buf, n, inputobject, dronetype.id)
					for i = 0, n - 1 do
						local id = ffi.string(buf[i].id)
						if id ~= "trade" then
							table.insert(entry.modes, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
						end
					end
				else
					entry = {
						type = dronetype.id,
						name = dronetype.name,
					}
				end
				table.insert(menu.drones, entry)
			end
		end
		if unitstoragetable.capacity > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 8619), Helper.headerRowCenteredProperties)
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locunitcount .. " / " .. locunitcapacity, { halign = "right" })
			-- drones
			if unitinfo_details then
				for i, entry in ipairs(menu.drones) do
					if i ~= 1 then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					local hasmodes = (mode == "ship") and entry.current
					-- drone name, amount and mode
					local row1 = inputtable:addRow("drone_config", {  })
					row1[2]:createText(entry.name)
					row1[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumStoredUnits(inputobject, entry.type, false)) end, { halign = isplayerowned and "left" or "right" })
					-- active and armed status
					local row2 = inputtable:addRow("drone_config", {  })
					row2[2]:createText("    " .. ReadText(1001, 11229), { color = hasmodes and function () return C.IsDroneTypeArmed(inputobject, entry.type) and Color["text_normal"] or Color["text_inactive"] end or nil })
					row2[3]:setColSpan(isplayerowned and 2 or 11):createText(function () return Helper.unlockInfo(unitinfo_amount, C.GetNumUnavailableUnits(inputobject, entry.type)) end, { halign = isplayerowned and "left" or "right", color = hasmodes and function () return C.IsDroneTypeBlocked(inputobject, entry.type) and Color["text_warning"] or (C.IsDroneTypeArmed(inputobject, entry.type) and Color["text_normal"] or Color["text_inactive"]) end or nil })

					-- drone mode support - disabled for mining drones, to avoid conflicts with order defined drone behaviour
					if hasmodes then
						local isblocked = C.IsDroneTypeBlocked(inputobject, entry.type)
						if isplayerowned then
							local active = (isplayeroccupiedship or (not entry.displayonly)) and (not isblocked)
							local mouseovertext = ""
							if isblocked then
								mouseovertext = ReadText(1026, 3229)
							elseif (not isplayeroccupiedship) and entry.displayonly then
								mouseovertext = ReadText(1026, 3230)
							end

							row1[5]:setColSpan(9):createDropDown(entry.modes, { startOption = function () return menu.dropdownDroneStartOption(inputobject, entry.type) end, active = active, mouseOverText = mouseovertext })
							row1[5].handlers.onDropDownConfirmed = function (_, newdronemode) C.SetDroneMode(inputobject, entry.type, newdronemode) end

							row2[5]:setColSpan(9):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.IsDroneTypeArmed(inputobject, entry.type) and ReadText(1001, 8622) or ReadText(1001, 8623) end, { halign = "center" })
							row2[5].handlers.onClick = function () return C.SetDroneTypeArmed(inputobject, entry.type, not C.IsDroneTypeArmed(inputobject, entry.type)) end
						end
					end
				end
			end
		end
		-- subordinates
		if isplayerowned then
			if C.IsComponentClass(inputobject, "controllable") then
				local subordinates = GetSubordinates(inputobject)
				local groups = {}
				local usedassignments = {}
				for _, subordinate in ipairs(subordinates) do
					local purpose, shiptype = GetComponentData(subordinate, "primarypurpose", "shiptype")
					local group = GetComponentData(subordinate, "subordinategroup")
					if group and group > 0 then
						if groups[group] then
							table.insert(groups[group].subordinates, subordinate)
							if shiptype == "resupplier" then
								groups[group].numassignableresupplyships = groups[group].numassignableresupplyships + 1
							end
							if purpose == "mine" then
								groups[group].numassignableminingships = groups[group].numassignableminingships + 1
							end
							if shiptype == "tug" then
								groups[group].numassignabletugships = groups[group].numassignabletugships + 1
							end
						else
							local assignment = ffi.string(C.GetSubordinateGroupAssignment(inputobject, group))
							usedassignments[assignment] = group
							groups[group] = { assignment = assignment, subordinates = { subordinate }, numassignableresupplyships = (shiptype == "resupplier") and 1 or 0, numassignableminingships = (purpose == "mine") and 1 or 0, numassignabletugships = (shiptype == "tug") and 1 or 0 }
						end
					end
				end

				if #subordinates > 0 then
					-- title
					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(13):createText(ReadText(1001, 8626), Helper.headerRowCenteredProperties)

					local isstation = C.IsComponentClass(inputobject, "station")
					for i = 1, isstation and 5 or 10 do
						if groups[i] then
							local defenceactive = true
							if isstation then
								defenceactive = ((not usedassignments["defence"]) or (usedassignments["defence"] == i))
							end
							local supplyactive = (groups[i].numassignableresupplyships == #groups[i].subordinates) and ((not usedassignments["supplyfleet"]) or (usedassignments["supplyfleet"] == i))
							local subordinateassignments = {
								[1] = { id = "defence",			text = ReadText(20208, 40301),	icon = "",	displayremoveoption = false, active = defenceactive, mouseovertext = defenceactive and "" or ReadText(1026, 7840) },
								[2] = { id = "supplyfleet",		text = ReadText(20208, 40701),	icon = "",	displayremoveoption = false, active = supplyactive, mouseovertext = supplyactive and "" or ReadText(1026, 8601) },
							}
							local shiptype = GetComponentData(inputobject, "shiptype")
							if shiptype == "resupplier" then
								table.insert(subordinateassignments, { id = "trade",			text = ReadText(20208, 40101),	icon = "",	displayremoveoption = false })
							end

							if isstation then
								local miningactive = (groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i))
								table.insert(subordinateassignments, { id = "mining", text = ReadText(20208, 40201), icon = "", displayremoveoption = false, active = miningactive, mouseovertext = miningactive and "" or ReadText(1026, 8602) })
								local tradeactive = ((not usedassignments["trade"]) or (usedassignments["trade"] == i))
								table.insert(subordinateassignments, { id = "trade", text = ReadText(20208, 40101), icon = "", displayremoveoption = false, active = tradeactive, mouseovertext = tradeactive and ((groups[i].numassignableminingships > 0) and (ColorText["text_warning"] .. ReadText(1026, 8607)) or "") or ReadText(1026, 7840) })
								local tradeforbuildstorageactive = (groups[i].numassignableminingships == 0) and ((not usedassignments["tradeforbuildstorage"]) or (usedassignments["tradeforbuildstorage"] == i))
								table.insert(subordinateassignments, { id = "tradeforbuildstorage", text = ReadText(20208, 40801), icon = "", displayremoveoption = false, active = tradeforbuildstorageactive, mouseovertext = tradeforbuildstorageactive and "" or ReadText(1026, 8603) })
								local salvageactive = (groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i))
								table.insert(subordinateassignments, { id = "salvage", text = ReadText(20208, 41401), icon = "", displayremoveoption = false, active = salvageactive, mouseovertext = salvageactive and "" or ReadText(1026, 8610) })
							elseif C.IsComponentClass(inputobject, "ship") then
								-- position defence
								local parentcommander = ConvertIDTo64Bit(GetCommander(inputobject))
								local isfleetcommander = (not parentcommander) and (#subordinates > 0)
								if (shiptype == "carrier") and isfleetcommander then
									table.insert(subordinateassignments, { id = "positiondefence", text = ReadText(20208, 41501), icon = "", displayremoveoption = false })
								end

								-- start: aegs call-back
								if menu.uix_callbacks ["map_ship_subordinateassignments_insert"] then
									local ship_assignment
									for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_ship_subordinateassignments_insert"]) do
										ship_assignment = uix_callback (GetComponentData(inputobject, "macro"),(groups[i].numassignableminingships == #groups[i].subordinates) and ((not usedassignments["mining"]) or (usedassignments["mining"] == i)),(groups[i].numassignabletugships == #groups[i].subordinates) and ((not usedassignments["salvage"]) or (usedassignments["salvage"] == i)))
										if ship_assignment then
											table.insert(subordinateassignments, ship_assignment)
										end
									end
								end
								-- end: aegs call-back

								table.insert(subordinateassignments, { id = "attack", text = ReadText(20208, 40901), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "interception", text = ReadText(20208, 41001), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "bombardment", text = ReadText(20208, 41601), icon = "", displayremoveoption = false })
								table.insert(subordinateassignments, { id = "follow", text = ReadText(20208, 41301), icon = "", displayremoveoption = false })
								local active = true
								local mouseovertext = ""
								local buf = ffi.new("Order")
								if not C.GetDefaultOrder(buf, inputobject) then
									active = false
									mouseovertext = ReadText(1026, 8606)
								end
								table.insert(subordinateassignments, { id = "assist", text = ReadText(20208, 41201), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
							end

							local isdockingpossible = false
							for _, subordinate in ipairs(groups[i].subordinates) do
								if IsDockingPossible(subordinate, inputobject) then
									isdockingpossible = true
									break
								end
							end
							local active = function () return menu.buttonActiveSubordinateGroupLaunch(inputobject, i) end
							local mouseovertext = ""
							if isstation then
								active = false
							elseif not GetComponentData(inputobject, "hasshipdockingbays") then
								active = false
								mouseovertext = ReadText(1026, 8604)
							elseif not isdockingpossible then
								active = false
								mouseovertext = ReadText(1026, 8605)
							end

							local row = inputtable:addRow("subordinate_config", {  })
							row[2]:createText(function () menu.updateSubordinateGroupInfo(inputobject); return ReadText(20401, i) .. (menu.subordinategroups[i] and (" (" .. ((not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) and ((#menu.subordinategroups[i].subordinates - menu.subordinategroups[i].numdockedatcommander) .. "/") or "") .. #menu.subordinategroups[i].subordinates ..")") or "") end, { color = isblocked and Color["text_warning"] or nil })
							row[3]:setColSpan(11):createDropDown(subordinateassignments, { startOption = function () menu.updateSubordinateGroupInfo(inputobject); return menu.subordinategroups[i] and menu.subordinategroups[i].assignment or "" end })
							row[3].handlers.onDropDownActivated = function () menu.noupdate = true end
							row[3].handlers.onDropDownConfirmed = function(_, newassignment) return Helper.dropdownAssignment(_, nil, i, inputobject, newassignment) end
							local row = inputtable:addRow("subordinate_config", {  })
							-- Start Reactive Docking callback
							local rd_callbackVal
							if menu.uix_callbacks ["rd_addReactiveDockingMapMenu"] then
								for uix_id, uix_callback in pairs (menu.uix_callbacks ["rd_addReactiveDockingMapMenu"]) do
									rd_callbackVal = uix_callback (row, inputobject, i, mode, active, mouseovertext)
								end
							end
							if not rd_callbackVal then
								row[3]:setColSpan(11):createButton({ active = active, mouseOverText = mouseovertext, height = config.mapRowHeight }):setText(function () return C.ShouldSubordinateGroupDockAtCommander(inputobject, i) and ReadText(1001, 8630) or ReadText(1001, 8629) end, { halign = "center" })
								row[3].handlers.onClick = function () return C.SetSubordinateGroupDockAtCommander(inputobject, i, not C.ShouldSubordinateGroupDockAtCommander(inputobject, i)) end
							end
							-- End Reactive Docking callback
						end
					end
				end
			end
		end
		-- ammunition
		local nummissiletypes = C.GetNumAllMissiles(inputobject)
		local missilestoragetable = ffi.new("AmmoData[?]", nummissiletypes)
		nummissiletypes = C.GetAllMissiles(missilestoragetable, nummissiletypes, inputobject)
		local totalnummissiles = 0
		for i = 0, nummissiletypes - 1 do
			totalnummissiles = totalnummissiles + missilestoragetable[i].amount
		end
		local missilecapacity = 0
		if C.IsComponentClass(inputobject, "defensible") then
			missilecapacity = GetComponentData(inputobject, "missilecapacity")
		end
		local locmissilecapacity = Helper.unlockInfo(defenceinfo_low, tostring(missilecapacity))
		local locnummissiles = Helper.unlockInfo(defenceinfo_high, tostring(totalnummissiles))
		if totalnummissiles > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 2800), Helper.headerRowCenteredProperties) -- Ammunition
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnummissiles .. " / " .. locmissilecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, nummissiletypes - 1 do
					local macro = ffi.string(missilestoragetable[i].macro)
					local row = inputtable:addRow({ "info_weapons", macro, inputobject }, {  })
					row[2]:createText(GetMacroData(macro, "name"))
					row[8]:setColSpan(6):createText(tostring(missilestoragetable[i].amount), { halign = "right" })
				end
			end
		end
	end

	-- start: aegs call-back
		if menu.uix_callbacks ["map_loadoutinfo_double_insert"] then
			local state,title_text,label_text_1,label_text_2,subsystems
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_loadoutinfo_double_insert"]) do
				state,title_text,label_text_1,label_text_2,subsystems = uix_callback (GetComponentData(inputobject, "macro"))
				if state then
					local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
					row[1]:setColSpan(13):createText(title_text, Helper.headerRowCenteredProperties)
					for _, subsystem in ipairs(subsystems) do
						local row = inputtable:addRow(false, { interactive = false })
						row[1]:setColSpan(13):createText(subsystem.name, {halign = "center"})
						if subsystem.icon then
							local row = inputtable:addRow(false, { interactive = false })
							row[2]:setColSpan(11):createIcon(subsystem.icon, {height = config.mapRowHeight * 10, mouseOverText = subsystem.intro,halign = "center"})
						end
					end
				end
			end
		end
	-- end: aegs call-back

	if mode == "ship" then
		-- countermeasures
		local numcountermeasuretypes = C.GetNumAllCountermeasures(inputobject)
		local countermeasurestoragetable = ffi.new("AmmoData[?]", numcountermeasuretypes)
		numcountermeasuretypes = C.GetAllCountermeasures(countermeasurestoragetable, numcountermeasuretypes, inputobject)
		local totalnumcountermeasures = 0
		for i = 0, numcountermeasuretypes - 1 do
			totalnumcountermeasures = totalnumcountermeasures + countermeasurestoragetable[i].amount
		end
		local countermeasurecapacity = GetComponentData(object64, "countermeasurecapacity")
		local loccountermeasurecapacity = Helper.unlockInfo(defenceinfo_low, tostring(countermeasurecapacity))
		local locnumcountermeasures = Helper.unlockInfo(defenceinfo_high, tostring(totalnumcountermeasures))
		if totalnumcountermeasures > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(20215, 1701), Helper.headerRowCenteredProperties) -- Countermeasures
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(locnumcountermeasures .. " / " .. loccountermeasurecapacity, { halign = "right" })
			if defenceinfo_high then
				for i = 0, numcountermeasuretypes - 1 do
					local row = inputtable:addRow(true, { interactive = false })
					row[2]:createText(GetMacroData(ffi.string(countermeasurestoragetable[i].macro), "name"))
					row[8]:setColSpan(6):createText(tostring(countermeasurestoragetable[i].amount), { halign = "right" })
				end
			end
		end
		-- deployables
		local consumables = {
			{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites,		callback = C.LaunchSatellite },
			{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons,		callback = C.LaunchNavBeacon },
			{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes,	callback = C.LaunchResourceProbe },
			{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers,		callback = C.LaunchLaserTower },
			{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines,			callback = C.LaunchMine },
		}
		local totalnumdeployables = 0
		local consumabledata = {}
		for _, entry in ipairs(consumables) do
			local n = entry.getnum(inputobject)
			local buf = ffi.new("AmmoData[?]", n)
			n = entry.getdata(buf, n, inputobject)
			consumabledata[entry.id] = {}
			for i = 0, n - 1 do
				table.insert(consumabledata[entry.id], { macro = ffi.string(buf[i].macro), name = GetMacroData(ffi.string(buf[i].macro), "name"), amount = buf[i].amount, capacity = buf[i].capacity })
				totalnumdeployables = totalnumdeployables + buf[i].amount
			end
		end
		local deployablecapacity = C.GetDefensibleDeployableCapacity(inputobject)
		local printednumdeployables = Helper.unlockInfo(defenceinfo_low, tostring(totalnumdeployables))
		local printeddeployablecapacity = Helper.unlockInfo(defenceinfo_low, tostring(deployablecapacity))
		if totalnumdeployables > 0 then
			-- title
			local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(13):createText(ReadText(1001, 1332), Helper.headerRowCenteredProperties) -- Deployables
			-- capcity
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:createText(ReadText(1001, 8393))
			row[8]:setColSpan(6):createText(printednumdeployables .. " / " .. printeddeployablecapacity, { halign = "right" })
			if defenceinfo_high then
				for _, entry in ipairs(consumables) do
					if #consumabledata[entry.id] > 0 then
						for _, data in ipairs(consumabledata[entry.id]) do
							local row = inputtable:addRow({ "info_deploy", data.macro, inputobject }, {  })
							row[2]:createText(data.name)
							row[8]:setColSpan(6):createText(data.amount, { halign = "right" })
						end
					end
				end
				if isplayerowned then
					-- deploy
					local row = inputtable:addRow("info_deploy", {  })
					row[3]:setColSpan(11):createButton({ height = config.mapRowHeight, active = function () return next(menu.infoTablePersistentData[instance].macrostolaunch) ~= nil end }):setText(ReadText(1001, 8390), { halign = "center" })
					row[3].handlers.onClick = function () return menu.buttonDeploy(instance) end
				end
			end
		end
	end
	if (mode == "ship") or (mode == "station") then
		-- loadout
		if (#loadout.component.weapon > 0) or (#loadout.component.turret > 0) or (#loadout.component.shield > 0) or (#loadout.component.engine > 0) or (#loadout.macro.thruster > 0) or (#loadout.ware.software > 0) then
			if defenceinfo_high then
				local hasshown = false
				-- title
				local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(13):createText(ReadText(1001, 9413), Helper.headerRowCenteredProperties) -- Loadout
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(5):createText(ReadText(1001, 7935), { font = Helper.standardFontBold })
				row[7]:setColSpan(4):createText(ReadText(1001, 1311), { font = Helper.standardFontBold, halign = "right" })
				row[11]:setColSpan(3):createText(ReadText(1001, 12), { font = Helper.standardFontBold, halign = "right" })

				inputtable:addEmptyRow(config.mapRowHeight / 2)

				local macroequipment = {
					{ type = "weapon", encyclopedia = "info_weapon" },
					{ type = "turret", encyclopedia = "info_weapon" },
					{ type = "shield", encyclopedia = "info_equipment" },
					{ type = "engine", encyclopedia = "info_equipment" },
				}
				for _, entry in ipairs(macroequipment) do
					if #loadout.component[entry.type] > 0 then
						if hasshown then
							inputtable:addEmptyRow(config.mapRowHeight / 2)
						end
						hasshown = true
						local locmacros = menu.infoCombineLoadoutComponents(loadout.component[entry.type])
						for macro, data in pairs(locmacros) do
							local row = inputtable:addRow({ entry.encyclopedia, macro, inputobject }, {  })
							row[2]:setColSpan(5):createText(GetMacroData(macro, "name"))
							row[7]:setColSpan(4):createText(data.count .. " / " .. data.count + data.construction + data.wreck, { halign = "right" })
							local shieldpercent = data.shieldpercent
							local hullpercent = data.hullpercent
							if data.count > 0 then
								shieldpercent = shieldpercent / data.count
								hullpercent = hullpercent / data.count
							end
							row[11]:setColSpan(3):createShieldHullBar(shieldpercent, hullpercent, { scaling = false, width = row[11]:getColSpanWidth() / 2, x = row[11]:getColSpanWidth() / 4 })

							AddKnownItem(GetMacroData(macro, "infolibrary"), macro)
						end
					end
				end

				if #loadout.macro.thruster > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					-- ships normally only have 1 set of thrusters. in case a ship has more, this will list all of them.
					for i, val in ipairs(loadout.macro.thruster) do
						local row = inputtable:addRow({ "info_equipment", macro, inputobject }, {  })
						row[2]:setColSpan(12):createText(GetMacroData(val, "name"))

						AddKnownItem(GetMacroData(val, "infolibrary"), val)
					end
				end
				if #loadout.ware.software > 0 then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					for i, val in ipairs(loadout.ware.software) do
						local row = inputtable:addRow({ "info_software", val, inputobject }, {  })
						row[2]:setColSpan(12):createText(GetWareData(val, "name"))

						AddKnownItem("software", val)
					end
				end
			else
				local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[2]:setColSpan(12):createText(ReadText(1001, 3210))
			end
		end
	end
	if mode == "ship" then
		-- mods
		-- title
		local row = inputtable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(13):createText(ReadText(1001, 8031), Helper.headerRowCenteredProperties)
		if equipment_mods and GetComponentData(object64, "hasanymod") then
			local hasshown = false
			-- chassis
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("ship", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "ship", installedmod, ReadText(1001, 8008))
			end
			-- weapon
			for i, weapon in ipairs(loadout.component.weapon) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("weapon", weapon)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(weapon)))
				end
			end
			-- turret
			for i, group in ipairs(menu.turretgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", inputobject, group.context, group.group, true)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true

					local name = ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(group.slotsize) .. group.sizecount .. ((group.currentmacro ~= "") and (" (" .. Helper.getSlotSizeText(group.slotsize) .. " " .. GetMacroData(group.currentmacro, "shortname") .. ")") or "")
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, name)
				end
			end
			for i, turret in ipairs(menu.turrets) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("turret", turret)
				if hasinstalledmod then
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "weapon", installedmod, ffi.string(C.GetComponentName(turret)))
				end
			end
			-- shield
			local shieldgroups = {}
			local n = C.GetNumShieldGroups(inputobject)
			local buf = ffi.new("ShieldGroup[?]", n)
			n = C.GetShieldGroups(buf, n, inputobject)
			for i = 0, n - 1 do
				local entry = {}
				entry.context = buf[i].context
				entry.group = ffi.string(buf[i].group)
				entry.component = buf[i].component

				table.insert(shieldgroups, entry)
			end
			for i, entry in ipairs(shieldgroups) do
				if (entry.context == inputobject) and (entry.group == "") then
					shieldgroups.hasMainGroup = true
					-- force maingroup to first index
					table.insert(shieldgroups, 1, entry)
					table.remove(shieldgroups, i + 1)
					break
				end
			end
			for i, shieldgroupdata in ipairs(shieldgroups) do
				local hasinstalledmod, installedmod = Helper.getInstalledModInfo("shield", inputobject, shieldgroupdata.context, shieldgroupdata.group)
				if hasinstalledmod then
					local name = GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(shieldgroupdata.component)), "macro"), "name")
					if (i == 1) and shieldgroups.hasMainGroup then
						name = ReadText(1001, 8044)
					end
					if hasshown then
						inputtable:addEmptyRow(config.mapRowHeight / 2)
					end
					hasshown = true
					row = menu.addEquipmentModInfoRow(inputtable, "shield", installedmod, name)
				end
			end
			-- engine
			local hasinstalledmod, installedmod = Helper.getInstalledModInfo("engine", inputobject)
			if hasinstalledmod then
				if hasshown then
					inputtable:addEmptyRow(config.mapRowHeight / 2)
				end
				hasshown = true
				row = menu.addEquipmentModInfoRow(inputtable, "engine", installedmod, ffi.string(C.GetComponentName(loadout.component.engine[1])))
			end
		else
			local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[2]:setColSpan(12):createText(Helper.unlockInfo(equipment_mods, ReadText(1001, 8394)))
		end
	end
	if mode == "none" then
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(12):createText(ReadText(1001, 6526))
	end
end

function menu.dropdownDroneStartOption(ship, type)
	local curmode = ffi.string(C.GetCurrentDroneMode(ship, type))

	-- trade mode is a temporary, not user available setting, show the stored user setting instead
	if curmode == "trade" then
		curmode = ffi.string(C.GetUserTransportDroneMode(ship))
	end

	return curmode
end

function menu.infologbookSearchHelper(entry, text, text2)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.title), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.text), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.entityname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end
	if string.find(utf8.lower(entry.factionname), text, 1, true) then
		if text2 then
			return menu.infologbookSearchHelper(entry, text2)
		end
		return true
	end

	return false
end

function menu.setupLogbookInfoSubmenuRows(inputtable, inputobject, instance, isvalid)
	if (not menu.infoTablePersistentData[instance].logbookData) or (menu.infoTablePersistentData[instance].logbookData.curobject ~= inputobject) then
		local objecttext = "none", ""
		local isuseid, issector = false, false
		if isvalid then
			isuseid = true
			local macro = GetComponentData(inputobject, "macro")
			if C.IsRealComponentClass(inputobject, "ship") then
			elseif C.IsRealComponentClass(inputobject, "station") then
			elseif C.IsComponentClass(inputobject, "sector") then
				isuseid = false
				issector = true
			elseif C.IsComponentClass(inputobject, "gate") or C.IsComponentClass(inputobject, "highway") then
				isuseid = false
			elseif C.IsComponentClass(inputobject, "mine") or C.IsComponentClass(inputobject, "navbeacon") or C.IsComponentClass(inputobject, "resourceprobe") or C.IsComponentClass(inputobject, "satellite") then
			elseif C.IsComponentClass(inputobject, "asteroid") then
			elseif C.IsComponentClass(inputobject, "object") then
			end
			if isuseid then
				objecttext = ffi.string(C.GetObjectIDCode(inputobject))
			else
				objecttext = GetComponentData (inputobject, "name")
			end
		end
		menu.infoTablePersistentData[instance].logbookData = { curobject = inputobject, curPage = 1, objecttext = objecttext, searchtext = "", isuseid = isuseid, issector = issector }
	end
	-- DebugError("objecttext: " .. tostring(menu.infoTablePersistentData[instance].logbookData.objecttext) .. " isuseid: " .. tostring(menu.infoTablePersistentData[instance].logbookData.isuseid))

	local logbookData = menu.infoTablePersistentData[instance].logbookData

	local cheatsecrecy = false
	-- secrecy stuff
	local nameinfo = cheatsecrecy or C.IsInfoUnlockedForPlayer(inputobject, "name")

	--- title ---
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(10):createText(ReadText(1001, 2427), Helper.headerRowCenteredProperties)
	local row = inputtable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(10):createText(ReadText(1001, 5700), Helper.headerRowCenteredProperties)
	local isplayerowned = GetComponentData(inputobject, "isplayerowned")
	if not isplayerowned then
		local row = inputtable:addRow(false, { fixed = true })
		local ownername = GetComponentData(inputobject, "ownername")
		if not ownername or ownername == "" then
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(ReadText(1001, 11647))
			else
				row[1]:setColSpan(10):createText(ReadText(1001, 11645))
			end
		else
			if menu.infoTablePersistentData[instance].logbookData.issector then
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11646), ownername))
			else
				row[1]:setColSpan(10):createText(string.format(ReadText(1001, 11644), ownername))
			end
		end
	end

	local objectname = Helper.unlockInfo(nameinfo, ffi.string(C.GetComponentName(inputobject)))
	--- object name ---
	local row = inputtable:addRow("info_focus", { fixed = true, bgColor = Color["row_title_background"] })
	row[10]:createButton({ width = config.mapRowHeight, cellBGColor = Color["row_background"] }):setIcon("menu_center_selection", { width = config.mapRowHeight, height = config.mapRowHeight, y = (Helper.headerRow1Height - config.mapRowHeight) / 2 })
	row[10].handlers.onClick = function () return C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true) end
	if isvalid then
		row[1]:setBackgroundColSpan(9):setColSpan(7):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
		if menu.infoTablePersistentData[instance].logbookData.isuseid then
			row[8]:setColSpan(2):createText(Helper.unlockInfo(nameinfo, ffi.string(C.GetObjectIDCode(inputobject))), Helper.headerRow1Properties)
		else
			row[8]:setColSpan(2):createText(" ", Helper.headerRow1Properties) -- if "" border bottom will not render
		end
		row[8].properties.halign = "right"
		row[8].properties.color = titlecolor
	else
		row[1]:setBackgroundColSpan(9):setColSpan(9):createText(objectname, Helper.headerRow1Properties)
		row[1].properties.color = titlecolor
	end

	if isvalid then
		config.infoLogbook.category = "all"
		config.infoLogbook.logbookPage = 100
		config.infoLogbook.logbookQueryLimit= 1000

		-- entries
		local numEntries = GetNumLogbook(config.infoLogbook.category)
		logbookData.logbook = {}
		for i = 1, math.ceil(numEntries / config.infoLogbook.logbookQueryLimit) do
			local offset = (i - 1) * config.infoLogbook.logbookQueryLimit
			local numQuery = math.min(config.infoLogbook.logbookQueryLimit, numEntries - offset)
			local templogbook = GetLogbook(offset + 1, numQuery, config.infoLogbook.category) or {}
			if #templogbook > 0 then
				for j, entry in ipairs(templogbook) do
					entry.index = offset + j
					if menu.infologbookSearchHelper(entry, logbookData.objecttext, logbookData.searchtext) then
						table.insert(logbookData.logbook, entry)
					end
				end
			end
		end

		numEntries = #logbookData.logbook
		local logbook
		if numEntries <= config.infoLogbook.logbookPage then
			logbookData.curPage = 1
			logbook = logbookData.logbook
		else
			local startIndex = numEntries - config.infoLogbook.logbookPage * logbookData.curPage + 1
			local endIndex = config.infoLogbook.logbookPage + startIndex - 1
			if startIndex < 1 then
				startIndex = 1
			end
			logbook = { table.unpack(logbookData.logbook, startIndex, endIndex) }
		end
		logbookData.numPages = math.max(1, math.ceil(numEntries / config.infoLogbook.logbookPage))

		local buttonsize = Helper.scaleY(config.mapRowHeight)
		local row = inputtable:addRow(true, { fixed = true })
		row[1]:setColSpan(3):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250), height = Helper.subHeaderHeight }):setText(logbookData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= logbookData.searchtext then logbookData.searchtext = text; menu.refreshInfoFrame() end end

		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[4]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[4].handlers.onClick = function () logbookData.searchtext = ""; menu.refreshInfoFrame() end

		row[5]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[5].handlers.onClick = function () logbookData.curPage = 1; menu.refreshInfoFrame() end
		row[6]:createButton({ scaling = false, active = logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[6].handlers.onClick = function () logbookData.curPage = logbookData.curPage - 1; menu.refreshInfoFrame() end
		menu.logbookPageEditBox = row[7]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(logbookData.curPage .. " / " .. logbookData.numPages, { halign = "center" })
		row[7].handlers.onEditBoxActivated = function (widget) return menu.editboxInfoLogbookPageActivated(widget, instance) end
		row[7].handlers.onEditBoxDeactivated = function (_, text, textchanged) return menu.editboxInfoLogbookPage(instance, text, textchanged) end
		row[9]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[9].handlers.onClick = function () logbookData.curPage = logbookData.curPage + 1; menu.refreshInfoFrame() end
		row[10]:createButton({ scaling = false, active = logbookData.curPage < logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[10].handlers.onClick = function () logbookData.curPage = logbookData.numPages; menu.refreshInfoFrame() end

		inputtable:addEmptyRow(Helper.standardTextHeight / 2)

		if #logbook > 0 then
			for i = #logbook, 1, -1 do
				local entry = logbook[i]
				local textcolor = entry.highlighted and Color["text_logbook_highlight"] or Color["text_normal"]
				local row = inputtable:addRow(true, { borderBelow = false })
				if entry.interaction and IsValidComponent(entry.interactioncomponent) then
					local mouseoverobject = entry.interactioncomponent
					if IsComponentClass(mouseoverobject, "zone") and not IsComponentClass(mouseoverobject, "highway") then
						mouseoverobject = GetContextByClass(mouseoverobject, "sector")
					end
					row[1]:setColSpan(9):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
					row[10]:createButton({ scaling = false, bgColor = Color["button_background_hidden"], mouseOverText = string.format(entry.interactiontext, GetComponentData(mouseoverobject, "name")), height = buttonsize }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize })
					row[10].handlers.onClick = function () return menu.buttonLogbookInteraction(entry) end
				else
					row[1]:setColSpan(10):createText(entry.index .. " - " .. entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
				end

				if (entry.entityname ~= "") or (entry.factionname ~= "") then
					local row = inputtable:addRow(false, { borderBelow = false })
					if entry.entityname ~= "" then
						row[1]:setColSpan(2):createText(ReadText(1001, 5711) .. " " .. entry.entityname, { x = config.mapRowHeight })
					end
					row[3]:setColSpan(8):createText(entry.factionname, { halign = "right" })
				end

				if entry.text ~= "" then
					local row = inputtable:addRow(false, { borderBelow = false })
					row[1]:setColSpan(10):createText(entry.text, { x = config.mapRowHeight, color = textcolor, wordwrap = true })
				end

				local row = inputtable:addRow(false, {  })
				row[1]:setColSpan(2):createText(Helper.getPassedTime(entry.time), { mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.mapRowHeight })
				local moneystring = ""
				if entry.money ~= 0 then
					local moneycolor = (entry.money >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. Helper.convertColorToText(moneycolor) .. ((entry.bonus >= 0) and "+" or "-") .. ConvertMoneyString(entry.money, false, true, nil, true) .. " " .. ReadText(1001, 101)
				end
				if entry.bonus ~= 0 then
					local bonuscolor = (entry.bonus >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. " " .. Helper.convertColorToText(bonuscolor) .. "(" .. ((entry.bonus >= 0) and "+" or "-") .. " " .. ReadText(1001, 5712) .. " " .. ConvertMoneyString(entry.bonus, false, true, nil, true) .. " " .. ReadText(1001, 101) .. ")"
				end
				row[3]:setColSpan(8):createText(moneystring, { halign = "right" })

				if i ~= 1 then
					local row = inputtable:addRow(false, { bgColor = Color["row_background_blue"] })
					row[1]:setColSpan(10):createText("", { fontsize = 1, minRowHeight = 1 })
				end
			end
		else
			local row = inputtable:addRow(false, {  })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end
	else
		local row = inputtable:addRow(false, { bgColor = Color["row_background_unselectable"] })
		row[2]:setColSpan(9):createText(ReadText(1001, 6526))
	end
end

-- NB: numcolumns has to match number of entries in inputrowdata.
function menu.addInfoSubmenuRow(instance, inputtable, inputrow, inputrowdata, isheader, withbutton, buttonactive, indent, indentsize, inputfont, mouseovertext, interactive)
	if not indent then
		indent = 0
	end
	if not indentsize then
		indentsize = Helper.standardIndentStep
	end

	if not inputfont then
		inputfont = Helper.standardFont
		if isheader then
			inputfont = Helper.standardFontBold
		end
	end

	local rowbgcolor = Color["row_background_blue"]
	if not isheader then
		local isselectable
		if type(inputrowdata) ~= "table" then
			isselectable = inputrowdata
		else
			isselectable = inputrowdata[1]
		end
		if isselectable then
			rowbgcolor = nil
		else
			rowbgcolor = Color["row_background_unselectable"]
		end
	end

	if not mouseovertext then
		mouseovertext = ""
	end

	if type(inputrowdata) ~= "table" then
		DebugError("menu.addInfoSubmenuRow(): inputrowdata is not a table. inputrowdata: " .. tostring(inputrowdata) .. ".")
		inputrow = inputtable:addRow(inputrowdata, { bgColor = rowbgcolor, interactive = interactive })
	else
		inputrow = inputtable:addRow(inputrowdata[1], { bgColor = rowbgcolor, interactive = interactive })
	end

	if not buttonactive then
		buttonactive = false
	end

	if withbutton then
		inputrow[1]:createButton({ height = config.mapRowHeight, active = buttonactive }):setText(function() return (buttonactive and menu.isInfoExtended(inputrowdata[1], instance)) and "-" or "+" end, { halign = "center" })
		inputrow[1].handlers.onClick = function() return menu.buttonExtendInfo(inputrowdata[1], instance) end
		inputrow[1].properties.uiTriggerID = inputrowdata[1] .. "_toggle"
	end

	for i, val in ipairs(inputrowdata) do
		if i ~= 1 and type(val) == "number" then
			inputrowdata[i] = tostring(val)
		end
	end

	local xoffset = Helper.standardTextOffsetx + (indent * indentsize)

	if type(inputrowdata) ~= "table" then
		inputrow[2]:setColSpan(7)
		inputrow[2]:createText(inputrowdata, { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
	else
		if #inputrowdata == 2 then
			inputrow[2]:setColSpan(7):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
		elseif #inputrowdata == 3 then
			local row2span = 2
			if (type(inputrowdata[2]) ~= "function") and (type(inputrowdata[3]) ~= "function") then
				local str1width = C.GetTextWidth(inputrowdata[2], inputfont, Helper.scaleFont(inputfont, config.mapFontSize)) + Helper.scaleX(xoffset)
				local str2width = C.GetTextWidth(inputrowdata[3], inputfont, Helper.scaleFont(inputfont, config.mapFontSize))
				if (str1width > (inputrow[2]:getWidth() + inputrow[3]:getWidth() + Helper.borderSize)) and (str1width > str2width) then
					row2span = 4
				elseif str1width < inputrow[2]:getWidth() then
					row2span = 1
				end
			end
			inputrow[2]:setColSpan(row2span):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[2 + row2span]:setColSpan(7 - row2span):createText(inputrowdata[3], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 4 then
			inputrow[2]:setColSpan(2):createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[4], { halign = "right", minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		elseif #inputrowdata == 5 then
			inputrow[2]:createText(inputrowdata[2], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, x = xoffset, mouseOverText = mouseovertext })
			inputrow[3]:createText(inputrowdata[3], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[4]:setColSpan(2):createText(inputrowdata[4], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
			inputrow[6]:setColSpan(3):createText(inputrowdata[5], { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize, font = inputfont, mouseOverText = mouseovertext })
		else
			DebugError("menu.addInfoSubmenuRow(): inputrowdata has an invalid number of entries: " .. tostring(#inputrowdata) .. ". only up to four entries supported.")
		end
	end

	return inputrow
end

function menu.addEquipmentModInfoRow(inputtable, modclass, installedmod, name)
	local color = Helper.modQualities[installedmod.Quality].color
	local row = inputtable:addRow(true, {  })
	row[2]:createText(name .. "  \27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]")
	row[3]:setColSpan(10):createText(Helper.convertColorToText(color) .. installedmod.Name, { halign = "right" })

	-- default property
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key == installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				else
					effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end
				local row = inputtable:addRow(false, {  })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right", font = Helper.standardFontBold })
			end
			break
		end
	end
	-- other properties
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key ~= installedmod.PropertyType then
			if installedmod[property.key] ~= property.basevalue then
				local effectcolor
				if installedmod[property.key] > property.basevalue then
					effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				else
					effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end
				local row = inputtable:addRow(false, {  })
				row[2]:setColSpan(5):createText(property.text, { x = Helper.standardIndentStep })
				row[8]:setColSpan(5):createText(Helper.convertColorToText(effectcolor) .. property.eval(installedmod[property.key]), { halign = "right" })
			end
		end
	end

	return row
end

function menu.resetInfoSubmenu(i, instance)
	menu.infoTablePersistentData[instance].resetcrew = true
	if i then
		if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] then
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	else
		menu.infoTablePersistentData[instance].cashtransferdetails.transfers = {}
	end
	menu.infoTablePersistentData[instance].drops = {}

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.checkTransferDetails(i, instance)
	if menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i] and (menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount ~= 0) then
		return true
	end
	return false
end

function menu.infoSubmenuPrepareCrewInfo(instance)
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called with no selected object.")
		return
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuPrepareCrewInfo() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	--infocrew = {
	--	["object"] = nil,
	--	["capacity"] = 0,
	--	["total"] = 0,
	--	["current"] = { ["total"] = 0, ["roles"] = {} },
	--	["unassigned"] = { ["total"] = 0, ["persons"] = {} },
	--	["reassigned"] = { ["total"] = 0, ["roles"] = {} }
	--}
	infocrew.object = locobject
	infocrew.current.total = 0
	infocrew.unassigned.total = 0
	infocrew.unassigned.persons = {}
	infocrew.reassigned.total = 0
	infocrew.reassigned.roles = {}
	infocrew.total = 0
	infocrew.capacity = C.GetPeopleCapacity(locobject, "", false)

	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		infocrew.current.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = peopletable[i].amount, transferring = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		infocrew.reassigned.roles[i + 1] = { id = ffi.string(peopletable[i].id), name = ffi.string(peopletable[i].name), desc = ffi.string(peopletable[i].desc), amount = 0, canhire = peopletable[i].canhire, numtiers = peopletable[i].numtiers, tiers = {} }
		if ffi.string(peopletable[i].id) == "unassigned" then
			infocrew.reassigned.unassignedidx = i + 1
			infocrew.unassigned.total = peopletable[i].amount
			local locpersons = ffi.new("NPCSeed[?]", infocrew.unassigned.total)
			infocrew.unassigned.total = C.GetRoleTierNPCs(locpersons, infocrew.unassigned.total, locobject, "unassigned", 0)
			infocrew.unassigned.persons = {}
			for j = 0, infocrew.unassigned.total-1 do
				table.insert(infocrew.unassigned.persons, { ["person"] = locpersons[j], ["oldrole"] = nil })
			end
			--print(tostring(infocrew.unassigned.total) .. " unassigned people")
		end
		infocrew.current.total = infocrew.current.total + peopletable[i].amount
		infocrew.total = infocrew.current.total + infocrew.reassigned.total

		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, infocrew.current.roles[i + 1].id)
		for j = 0, numtiers - 1 do
			infocrew.current.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = tiertable[j].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, amount = 0, persons = {} }

			local numpersons = tiertable[j].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, infocrew.current.roles[i + 1].tiers[j + 1].skilllevel)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[j + 1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[j + 1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
		if numtiers == 0 then
			infocrew.current.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = peopletable[i].amount, persons = {} }
			infocrew.reassigned.roles[i + 1].tiers[1] = { hidden = true, name = "temp", skilllevel = 0, amount = 0, persons = {} }

			local numpersons = peopletable[i].amount
			local persontable = ffi.new("NPCSeed[?]", numpersons)
			numpersons = C.GetRoleTierNPCs(persontable, numpersons, locobject, infocrew.current.roles[i + 1].id, 0)
			local numTransferScheduled = 0
			for k = 0, numpersons - 1 do
				if C.IsPersonTransferScheduled(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				elseif not C.HasPersonArrived(locobject, persontable[k]) then
					numTransferScheduled = numTransferScheduled + 1
				end
				table.insert(infocrew.current.roles[i + 1].tiers[1].persons, persontable[k])
			end
			infocrew.current.roles[i + 1].tiers[1].transferring = numTransferScheduled
			infocrew.current.roles[i + 1].transferring = infocrew.current.roles[i + 1].transferring + numTransferScheduled
		end
	end
	for i, roletable in ipairs(infocrew.current.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			--int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
			table.sort(tiertable.persons, function(a, b) return C.GetPersonCombinedSkill(menu.infoSubmenuObject, a, nil, nil) > C.GetPersonCombinedSkill(menu.infoSubmenuObject, b, nil, nil) end)
		end
	end
end

function menu.infoSubmenuCombineCrewTables(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	-- combines infocrew.current and infocrew.reassigned into one table for display
	local result = {}
	local locobject = menu.infoSubmenuObject
	if not locobject or (locobject == 0) then
		DebugError("menu.infoSubmenuCombineCrewTables() called with no selected object.")
		return result
	elseif (not C.IsComponentClass(locobject, "ship")) and (not C.IsComponentClass(locobject, "station")) then
		DebugError("menu.infoSubmenuCombineCrewTables() called on " .. ffi.string(C.GetComponentName(locobject)) .. " which is not of class ship or station.")
		return result
	end

	local role, post
	if menu.crewRole ~= "current" then
		local type, id = string.match(menu.crewRole, "(.+):(.+)")
		if type == "post" then
			post = id
		elseif type == "role" then
			role = id
		end
	end

	local checktable = {}
	local numpeople = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopletable, numpeople, locobject, true)
	for i = 0, numpeople - 1 do
		local roleid = ffi.string(peopletable[i].id)
		local rolename = ffi.string(peopletable[i].name)
		local numtiers = peopletable[i].numtiers
		local tiertable = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers(tiertable, numtiers, locobject, roleid)
		for j = 0, numtiers - 1 do
			local tiername = ffi.string(tiertable[j].name)
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[j + 1].persons) do
				if C.IsPerson(person, menu.infoSubmenuObject) then
					if not checktable[person] then
						table.insert(result, {
							person = person,
							name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
							roleid = roleid,
							rolename = rolename,
							tiername = tiername
						})
						checktable[person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[j + 1].persons) do
				if C.IsPerson(person.person, menu.infoSubmenuObject) then
					if not checktable[person.person] then
						table.insert(result, {
							person = person.person,
							name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
							roleid = roleid,
							rolename = rolename,
							tiername = tiername
						})
						checktable[person.person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
		end
		if numtiers == 0 then
			for _, person in ipairs(infocrew.current.roles[i + 1].tiers[1].persons) do
				if C.IsPerson(person, menu.infoSubmenuObject) then
					if not checktable[person] then
						table.insert(result, {
							person = person,
							name = ffi.string(C.GetPersonName(person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person, role, post),
							roleid = roleid,
							rolename = rolename
						})
						checktable[person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
			for _, person in ipairs(infocrew.reassigned.roles[i + 1].tiers[1].persons) do
				if C.IsPerson(person.person, menu.infoSubmenuObject) then
					if not checktable[person.person] then
						table.insert(result, {
							person = person.person,
							name = ffi.string(C.GetPersonName(person.person, menu.infoSubmenuObject)),
							currentskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, nil, nil),
							skill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, person.person, role, post),
							roleid = roleid,
							rolename = rolename
						})
						checktable[person.person] = true
					end
				else
					menu.updatePeopleInfo = getElapsedTime() + 0.1
				end
			end
		end
	end

	if menu.crewSort == "name" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, false) end)
	elseif menu.crewSort == "name_inv" then
		table.sort(result, function (a, b) return Helper.sortName(a, b, true) end)
	elseif menu.crewSort == "skill" then
		table.sort(result, function (a, b) return a.skill > b.skill end)
	elseif menu.crewSort == "skill_inv" then
		table.sort(result, function (a, b) return a.skill < b.skill end)
	elseif menu.crewSort == "role" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, false) end)
		result = menu.sortBySkillinTiers(result)
	elseif menu.crewSort == "role_inv" then
		table.sort(result, function (a, b) return menu.roleSorter(a, b, true) end)
		result = menu.sortBySkillinTiers(result)
	end

	return result
end

function menu.roleSorter(a, b, invert)
	if a.rolename == b.rolename then
		return a.currentskill > b.currentskill
	end
	if invert then
		return a.rolename > b.rolename
	else
		return a.rolename < b.rolename
	end
end

-- after current role skill was used to sort the crew by current tiers, sort the tiers by the skill according to menu.crewRole
function menu.sortBySkillinTiers(result)
	local tiergroups = {}
	for _, personentry in ipairs(result) do
		local prevrole, prevtier
		if (not prevrole) or (prevrole ~= personentry.rolename) or (prevtier ~= personentry.tiername) then
			prevrole = personentry.rolename
			prevtier = personentry.tiername

			table.insert(tiergroups, { personentry })
		else
			table.insert(tiergroups[#tiergroups], personentry)
		end
	end
	result = {}
	for _, group in ipairs(tiergroups) do
		table.sort(group, function (a, b) return a.skill > b.skill end)
		for _, personentry in ipairs(group) do
			table.insert(result, personentry)
		end
	end
	return result
end

function menu.infoSubmenuConfirmDrops(object, instance)
	local isplayeroccupiedship = (object == C.GetPlayerOccupiedShipID())
	for ware, amount in pairs(menu.infoTablePersistentData[instance].drops) do
		if amount > 0 then
			local s = (amount > 1) and "s" or ""
			if C.DropCargo(object, ware, amount) then
				--print(ffi.string(C.GetComponentName(object)) .. " successfully dropped " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. ".")
			else
				print(ffi.string(C.GetComponentName(object)) .. "'s attempt to drop " .. tostring(amount) .. " unit" .. s .. " of " .. tostring(ware) .. " was unsuccessful.")
			end
		end
	end
	menu.infoTablePersistentData[instance].drops = {}
	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateDrops(ware, oldamount, newamount, instance)
	menu.infoTablePersistentData[instance].drops[ware] = oldamount - newamount
end

function menu.infoSubmenuUpdateCrewChanges(instance, newamount, slidertable, sliderindex, istier, tierindex, sliderupdatetable)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("peopletype: " .. ffi.string(slidertable[sliderindex].name) .. ", current actual amount: " .. (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount) .. ", new amount: " .. newamount)
	local oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount
	if istier then
		oldamount = infocrew.current.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].tiers[tierindex].amount
	end
	local amountchange = newamount - oldamount
	local linkedtiers = {}
	-- TODO: review. there was a problem when reducing from tier after reducing from category and adding back from category without confirming. might get fixed after slider updating is fixed.
	--print("newamount: " .. newamount .. ", oldamount: " .. oldamount .. ", amount to change: " .. amountchange)

	if amountchange < 0 then
		-- reduce
		--print("reducing")
		local amountchanged = 0
		local done
		if infocrew.reassigned.total > 0 then
			for i, roletable in ipairs(infocrew.reassigned.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k].person) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from reassigned is of type table.")
									end
									--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
									--reassignedcrew[0].seed = tiertable.persons[k].person
									--reassignedcrew[0].newroleid = "unassigned"
									--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
									table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k].person, ["oldrole"] = roletable.id })
									infocrew.unassigned.total = infocrew.unassigned.total + 1

									table.insert(infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].persons, { ["person"] = tiertable.persons[k].person, ["oldrole"] = roletable.id, ["newrole"] = "unassigned", ["newtier"] = 1, ["combinedskill"] = 0 })
									infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount + 1
									infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount + 1

									table.remove(infocrew.reassigned.roles[i].tiers[j].persons, k)
									infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == j then
												linkedtier.amount = linkedtier.amount - 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
									else
										table.insert(linkedtiers, { index = j, amount = -1 })
									end
									amountchanged = amountchanged - 1
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
		if not done then
			for i, roletable in ipairs(infocrew.current.roles) do
				-- can query: .id, .name, .desc, .amount, .numtiers, .canhire
				if roletable.id == slidertable[sliderindex].id then
					for j, tiertable in ipairs(roletable.tiers) do
						--print("role: " .. tostring(roletable.id) .. ", tier: " .. tostring(j))
						local go
						if istier then
							-- can query: name, skilllevel, amount
							if tiertable.skilllevel == slidertable[sliderindex].tiers[tierindex].skilllevel then
								go = true
							end
						else
							go = true
						end
						if go then
							for k = #tiertable.persons, 1, -1 do
								if amountchanged ~= amountchange then
									if type(tiertable.persons[k]) == "table" then
										DebugError("menu.infoSubmenuUpdateCrewChanges(): person " .. k .. " from current is of type table.")
									end
									if (not C.IsPersonTransferScheduled(menu.infoSubmenuObject, tiertable.persons[k])) and C.HasPersonArrived(menu.infoSubmenuObject, tiertable.persons[k]) then
										--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
										--reassignedcrew[0].seed = tiertable.persons[k]
										--reassignedcrew[0].newroleid = "unassigned"
										--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
										table.insert(infocrew.unassigned.persons, { ["person"] = tiertable.persons[k], ["oldrole"] = roletable.id })
										infocrew.unassigned.total = infocrew.unassigned.total + 1

										table.insert(infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].persons, { ["person"] = tiertable.persons[k], ["oldrole"] = roletable.id, ["newrole"] = "unassigned", ["newtier"] = 1, ["combinedskill"] = 0 })
										infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].tiers[1].amount + 1
										infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount = infocrew.reassigned.roles[infocrew.reassigned.unassignedidx].amount + 1
										infocrew.reassigned.total = infocrew.reassigned.total + 1

										table.remove(infocrew.current.roles[i].tiers[j].persons, k)
										infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount - 1
										infocrew.current.roles[i].amount = infocrew.current.roles[i].amount - 1
										infocrew.current.total = infocrew.current.total - 1

										if #linkedtiers > 0 then
											local linkdone
											for l, linkedtier in ipairs(linkedtiers) do
												if linkedtier.index == j then
													linkedtier.amount = linkedtier.amount - 1
													linkdone = true
													break
												end
											end
											if not linkdone then
												table.insert(linkedtiers, { index = j, amount = -1 })
											end
										else
											table.insert(linkedtiers, { index = j, amount = -1 })
										end
										amountchanged = amountchanged - 1
									end
								else
									done = true
									break
								end
							end
							go = nil
						end
						if done then
							break
						end
					end
				end
			end
		end
	else
		-- add
		--print("adding")
		if infocrew.unassigned.total < 1 then
			DebugError("menu.infoSubmenuUpdateCrewChanges(): tried reallocating crew with none unassigned.")
		else
			for i, roletable in ipairs(infocrew.current.roles) do
				if roletable.id == slidertable[sliderindex].id then
					local amountchanged = 0
					local done
					for j = #infocrew.unassigned.persons, 1, -1 do
						if amountchanged ~= amountchange then
							local newtier = C.GetPersonTier(infocrew.unassigned.persons[j].person, roletable.id, menu.infoSubmenuObject)
							local newcombinedskill = C.GetPersonCombinedSkill(menu.infoSubmenuObject, infocrew.unassigned.persons[j].person, roletable.id, nil)
							if infocrew.reassigned.roles[i].id ~= roletable.id then
								DebugError("menu.infoSubmenuUpdateCrewChanges(): reassigned role id: " .. tostring(infocrew.reassigned.roles[i].id) .. " does not match current role id: " .. tostring(roletable.id) .. ".")
							end
							for k, tiertable in ipairs(roletable.tiers) do
								if newtier == tiertable.skilllevel then
									table.insert(infocrew.reassigned.roles[i].tiers[k].persons, { ["person"] = infocrew.unassigned.persons[j].person, ["oldrole"] = infocrew.unassigned.persons[j].oldrole, ["newrole"] = roletable.id, ["newtier"] = newtier, ["combinedskill"] = newcombinedskill })
									infocrew.reassigned.roles[i].tiers[k].amount = infocrew.reassigned.roles[i].tiers[k].amount + 1
									infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount + 1
									infocrew.reassigned.total = infocrew.reassigned.total + 1

									if #linkedtiers > 0 then
										local linkdone
										for l, linkedtier in ipairs(linkedtiers) do
											if linkedtier.index == k then
												linkedtier.amount = linkedtier.amount + 1
												linkdone = true
												break
											end
										end
										if not linkdone then
											table.insert(linkedtiers, { index = k, amount = 1 })
										end
									else
										table.insert(linkedtiers, { index = k, amount = 1 })
									end
									break
								end
							end

							--local reassignedcrew = ffi.new("CrewTransferContainer[?]", 1)
							--reassignedcrew[0].seed = infocrew.unassigned.persons[j].person
							--reassignedcrew[0].newroleid = roletable.id
							--C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, 1)
							table.remove(infocrew.unassigned.persons, j)
							infocrew.unassigned.total = infocrew.unassigned.total - 1

							amountchanged = amountchanged + 1
						else
							done = true
							break
						end
					end
					if done then
						break
					end
				end
			end
		end
	end

	-- update all linked sliders.
	--local sliderupdatetable = { ["table"] = inputtable, ["row"] = role.row, ["col"] = 2, ["tierrows"] = {}, ["text"] = role.name, ["xoffset"] = role.row[2].properties.x, ["width"] = role.row[2].properties.width }
	if type(sliderupdatetable) == "table" and #sliderupdatetable.tierrows > 0 then
		-- update linked category slider
		local linkedrows = { {["row"] = sliderupdatetable.row, ["col"] = sliderupdatetable.col, ["amount"] = sliderupdatetable.row[sliderupdatetable.col].properties.start + amountchange} }
		--local linkedrows = { {["row"] = sliderupdatetable.row, ["amount"] = newamount} }
		if not istier then
			-- update linked tier slider/s
			if linkedtiers then
				linkedrows = {}
				for i, linkedtier in ipairs(linkedtiers) do
					table.insert(linkedrows, {["row"] = sliderupdatetable.tierrows[linkedtier.index].row, ["col"] = sliderupdatetable.tierrows[linkedtier.index].col, ["amount"] = sliderupdatetable.tierrows[linkedtier.index].row[sliderupdatetable.tierrows[linkedtier.index].col].properties.start + linkedtier.amount})
				end
			end
		end
		for i, linkedrow in ipairs(linkedrows) do
			local newlinkedslidervalue = linkedrow.amount
			--print("is tier? " .. tostring(istier) .. ", linked row: " .. tostring(linkedrow.row.index) .. ", category row: " .. tostring(sliderupdatetable.row.index))
			linkedrow.row[linkedrow.col].properties.start = newlinkedslidervalue
			if istier then
				sliderupdatetable.tierrows[tierindex].row[sliderupdatetable.tierrows[tierindex].col].properties.start = newamount
			else
				sliderupdatetable.row[sliderupdatetable.col].properties.start = newamount
			end
			--linkedrow.row[linkedrow.col].properties.maxSelect = (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total)
			--linkedrow.row[linkedrow.col].properties.maxSelect = istier and (infocrew.current.roles[slidertable[sliderindex].roleindex].amount + infocrew.reassigned.roles[slidertable[sliderindex].roleindex].amount + infocrew.unassigned.total) or (linkedrow.row[linkedrow.col].properties.start)
			Helper.setSliderCellValue(sliderupdatetable.table.id, linkedrow.row.index, linkedrow.col, newlinkedslidervalue)
		end
	end
end

function menu.infoSubmenuConfirmCrewChanges(instance)
	local infocrew = menu.infoTablePersistentData[instance].crew

	--print("reassigning " .. infocrew.reassigned.total .. " crew members.")
	local reassignedcrew = ffi.new("CrewTransferContainer[?]", infocrew.reassigned.total)
	local crewcounter = 0
	for i, roletable in ipairs(infocrew.reassigned.roles) do
		for j, tiertable in ipairs(roletable.tiers) do
			for k, persontable in ipairs(tiertable.persons) do
				--print("evaluating person " .. k .. ": " .. tostring(persontable.person))
				crewcounter = crewcounter + 1
				reassignedcrew[crewcounter - 1].seed = persontable.person
				reassignedcrew[crewcounter - 1].newroleid = Helper.ffiNewString(persontable.newrole)
				--print(tostring(crewcounter) .. ": reassigning person " .. k .. " with seed " .. tostring(persontable.person) .. " to role " .. tostring(persontable.newrole))

				table.insert(infocrew.current.roles[i].tiers[j].persons, persontable.person)
				infocrew.current.roles[i].tiers[j].amount = infocrew.current.roles[i].tiers[j].amount + 1
				infocrew.current.roles[i].amount = infocrew.current.roles[i].amount + 1
				infocrew.current.total = infocrew.current.total + 1

				infocrew.reassigned.roles[i].tiers[j].amount = infocrew.reassigned.roles[i].tiers[j].amount - 1
				infocrew.reassigned.roles[i].amount = infocrew.reassigned.roles[i].amount - 1
				infocrew.reassigned.total = infocrew.reassigned.total - 1
			end
			infocrew.reassigned.roles[i].tiers[j].persons = {}
		end
	end
	C.ReassignPeople(menu.infoSubmenuObject, reassignedcrew, crewcounter)
	if instance == "left" then
		menu.infoTablePersistentData["right"].resetcrew = true
	elseif instance == "right" then
		menu.infoTablePersistentData["left"].resetcrew = true
	end
	menu.refreshInfoFrame()
end

function menu.infoSubmenuReplacePilot(ship, oldpilot, newpilot, checkonly, contextmenu, instance)
	if not C.IsComponentClass(ship, "controllable") then
		return false
	end

	local infocrew = menu.infoTablePersistentData[instance].crew

	local oldpilotluaid = oldpilot and ConvertStringToLuaID(tostring(oldpilot))
	local post = (oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "poststring") or "aipilot"

	if not C.CanControllableHaveControlEntity(ship, post) then
		return false
	end

	-- select best pilot from entire crew for now.
	local bestpilot = newpilot or oldpilot or nil
	local bestcombinedskill = newpilot and C.GetPersonCombinedSkill(ship, newpilot, nil, post) or ((oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "combinedskill") or -1)
	--if oldpilot then
	--	print("old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " (" .. tostring(oldpilot) .. ")" .. ", combined skill: " .. tostring(bestcombinedskill))
	--end
	if not newpilot then
		-- if we want to restrict pilot candidates to people with a particular role, do that here.
		for i, roletable in ipairs(infocrew.current.roles) do
			if (roletable.id == "service") or (roletable.id == "marine") then
				for j, tiertable in ipairs(roletable.tiers) do
					for k, person in ipairs(tiertable.persons) do
						local evalcombinedskill = C.GetPersonCombinedSkill(ship, person, nil, post)
						if evalcombinedskill > bestcombinedskill then
							bestpilot = person
							bestcombinedskill = evalcombinedskill
						end
					end
				end
			end
		end
	end

	--print("bestpilot: " .. tostring(bestpilot))
	if bestpilot == oldpilot then
		--print("the old pilot: " .. ffi.string(C.GetComponentName(oldpilot)) .. " is already the best pilot in the crew. nothing changed.")
		return false
	elseif checkonly then
		--print("there is a better pilot available in the crew: " .. ffi.string(C.GetPersonName(bestpilot, ship)) .. ", combined skill: " .. tostring(bestcombinedskill))
		return true
	end

	local actor = { entity = nil, personcontrollable = ship, personseed = bestpilot }
	C.AssignHiredActor(actor, ship, post, nil, false)

	menu.infoSubmenuPrepareCrewInfo(instance)

	if contextmenu then
		menu.closeContextMenu()
	end
	menu.refreshInfoFrame(nil, 0)
end

function menu.infoSubmenuCancelTransfer(controllable, person)
	C.ReleasePersonFromCrewTransfer(controllable, person)

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireindividual", controllable = controllable, entity = entity, person = person, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireAllNPCConfirm(controllable, instance)
	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fireall", controllable = controllable, xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, instance = instance }

	menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
end

function menu.infoSubmenuFireNPC(controllable, entity, person, instance)
	if entity then
		SignalObject(ConvertStringTo64Bit(tostring(entity)), "npc__control_dismissed")
	else
		C.RemovePerson(controllable, person)
	end
	menu.closeContextMenu()
	menu.updatePeopleInfo = getElapsedTime()
end

function menu.infoSubmenuUpdateTransferAmount(instance, value, idx, containercash)
	if not value then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no value")
		return
	end
	if not idx then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no idx")
		return
	end
	if not containercash then
		DebugError("menu.infoSubmenuUpdateTransferAmount with no containercash")
		return
	end

	menu.infoTablePersistentData[instance].cashtransferdetails.transfers[idx].amount = value - containercash
	-- do not refresh. prevents smoothly dragging the slider.
end

function menu.infoSubmenuSetManagerAccountToEstimate(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry then
		local containermoney, estimate, isplayerowned = GetComponentData(entry.object, "money", entry.estimatetype, "isplayerowned")
		if isplayerowned then
			if entry.supply then
				estimate = estimate + tonumber(C.GetSupplyBudget(entry.object)) / 100
			end
			if entry.tradewares then
				estimate = estimate + tonumber(C.GetTradeWareBudget(entry.object)) / 100
			end
			if C.IsComponentClass(entry.object, "station") then
				SetMaxBudget(entry.object, (estimate * 3) / 2)
				SetMinBudget(entry.object, estimate)
			end

			local amount = estimate - containermoney
			if amount > 0 then
				TransferPlayerMoneyTo(amount, entry.object)
			else
				TransferMoneyToPlayer(-amount, entry.object)
			end
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateManagerAccount(i, instance)
	local entry = menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i]
	if entry and entry.amount ~= 0 then
		local isplayerowned = GetComponentData(entry.object, "isplayerowned")
		if isplayerowned then
			if C.IsComponentClass(entry.object, "station") then
				local newstationcash = (GetAccountData(entry.object, "money") or 0) + entry.amount
				SetMaxBudget(entry.object, (newstationcash * 3) / 2)
				SetMinBudget(entry.object, newstationcash)
			end

			TransferPlayerMoneyTo(entry.amount, entry.object)
			menu.infoTablePersistentData[instance].cashtransferdetails.transfers[i].amount = 0
		end
	end

	menu.refreshInfoFrame()
end

function menu.infoSubmenuUpdateProductionTime(object64, moduleindex)
	local productionmodules = GetProductionModules(object64)
	if not productionmodules then
		print("no production modules found.")
		return ""
	end
	local productiondata = GetProductionModuleData(productionmodules[moduleindex])
	if not productiondata then
		print("no production data found.")
		return ""
	end
	local s = productiondata.remainingcycletime
	if not s then
		print("error: remaining cycle time is: " .. tostring(s))
		return ""
	end
	local formattedtime = ConvertTimeString(s, "%h:%M:%S")
	return formattedtime
end

function menu.buttonExtendInfo(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		menu.extendedinfo[buttondata .. instance] = nil
	else
		menu.extendedinfo[buttondata .. instance] = true
	end

	if instance == "left" then
		menu.settoprow = GetTopRow(menu.infoTable)
		menu.refreshInfoFrame()
	elseif instance == "right" then
		menu.settoprow = GetTopRow(menu.infoTableRight)
		menu.refreshInfoFrame2()
	end
end

function menu.isInfoExtended(buttondata, instance)
	if menu.extendedinfo[buttondata .. instance] then
		return true
	end
	return false
end

function menu.createMissionMode(frame)
	-- kuertee start: bug-fix of sideBarWidth being nil
	if menu.sideBarWidth == nil then
		menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	end
	-- kuertee end: bug-fix of sideBarWidth being nil

	menu.setrow = 3
	menu.missionDoNotUpdate = true

	if menu.infoTableMode == "missionoffer" then
		menu.updateMissionOfferList()
	elseif menu.infoTableMode == "mission" then
		menu.updateMissions()

		if menu.missionMode == menu.activeMissionMode then
			if menu.highlightLeftBar[menu.infoTableMode] then
				menu.highlightLeftBar[menu.infoTableMode] = nil
				menu.refreshMainFrame = true
			end
		end
	end

	local ftable
	local isonline = Helper.isOnlineGame()
	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") or (not isonline) then
		ftable = frame:addTable(9 , { tabOrder = 1 })
		ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
		ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

		ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
		ftable:setColWidth(2, Helper.scaleY(config.mapRowHeight), false)
		-- in smaller resolutions, e.g. 1280x720, this can get negative due to different scalings used (this would be solved if we unify the scaling support as planned)
		ftable:setColWidth(3, math.max(1, menu.sideBarWidth - 2 * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)), false)
		ftable:setColWidth(4, menu.sideBarWidth / 2, false)
		ftable:setColWidth(5, menu.sideBarWidth / 2 - Helper.borderSize, false)
		ftable:setColWidth(6, menu.sideBarWidth, false)
		ftable:setColWidth(7, menu.sideBarWidth, false)
		ftable:setColWidthPercent(9, 20)

		ftable:setDefaultBackgroundColSpan(2, 8)
	end

	if not isonline then
		menu.missionOfferMode = "normal"
	end

	if menu.infoTableMode == "missionoffer" then
		if (menu.missionOfferMode == "normal") or (not isonline) then
			local found = false
			-- important
			if #menu.missionOfferList["plot"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(9):createText(ReadText(1001, 3340), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionOfferList["plot"]) do
					found = true
					menu.addMissionRow(ftable, entry)
				end
				if not found then
					local row = ftable:addRow("plotnone", { interactive = false })
					if menu.missionModeCurrent == "plotnone" then
						menu.setrow = row.index
					end
					row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
				end
			end
			-- guild
			found = false
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3331), Helper.headerRowCenteredProperties)

			-- kuertee start: callback
			if menu.uix_callbacks ["createMissionMode_on_missionoffer_guild_start"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionMode_on_missionoffer_guild_start"]) do
					uix_callback (ftable)
				end
			end
			-- kuertee end: callback

			for _, data in ipairs(menu.missionOfferList["guild"]) do
				if #data.missions > 0 then
					found = true

					-- check if we need to expand for the current selected mission
					for _, entry in ipairs(data.missions) do
						if entry.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
						end
					end

					if menu.expandedMissionGroups[data.id .. "offer"] == nil then
						menu.expandedMissionGroups[data.id .. "offer"] = true
					end
					local isexpanded = menu.expandedMissionGroups[data.id .. "offer"]
					local row = ftable:addRow(data.id, {  })
					if data.id == menu.missionModeCurrent then
						menu.setrow = row.index
					end
					row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id .. "offer", row.index) end
					row[2]:setColSpan(7):createText(data.name)
					row[9]:createText((#data.missions == 1) and ReadText(1001, 3335) or string.format(ReadText(1001, 3336), #data.missions), { halign = "right" })

					if isexpanded then
						for _, entry in ipairs(data.missions) do
							menu.addMissionRow(ftable, entry, 1)
						end
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			found = false
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3332), Helper.headerRowCenteredProperties)
			for _, entry in ipairs(menu.missionOfferList["other"]) do
				found = true
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
		elseif menu.missionOfferMode == "operation" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "getVentures")
				Helper.updateVenturePlatforms()
				Helper.callExtensionFunction("multiverse", "createVentureOperation", menu, menu.infoFrame, "left", config.missionOfferTabs)
			end
		end
	elseif menu.infoTableMode == "mission" then
		local found = false

		-- kuertee start: callback
		if menu.uix_callbacks ["createMissionMode_replaceMissionModeCurrent"] then
			local oldMissionModeCurrent = menu.missionModeCurrent
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionMode_replaceMissionModeCurrent"]) do
				menu.missionModeCurrent = uix_callback (menu.missionModeCurrent)
				if menu.missionModeCurrent ~= oldMissionModeCurrent then
					-- break immediately if changed
					break
				end
			end
		end
		-- kuertee end: callback

		if menu.missionMode == "plot" then
			-- important
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3341), Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["plot"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("plotnone", { interactive = false })
				if menu.missionModeCurrent == "plotnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- guild
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3333), Helper.headerRowCenteredProperties)
			found = false
			for _, data in ipairs(menu.missionList["guild"]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[data.id] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[data.id] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[data.id]
				local row = ftable:addRow(data.id, {  })
				if data.id == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Color["text_normal"]
				if data.active then
					color = Color["text_mission"]
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(data.id, row.index) end
				row[2]:setColSpan(7):createText(data.name, { color = color, font = font })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })

				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, {  })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
			if not found then
				local row = ftable:addRow("guildnone", { interactive = false })
				if menu.missionModeCurrent == "guildnone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			-- other
			local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3334), Helper.headerRowCenteredProperties)
			found = false
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList["other"]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
			if not found then
				local row = ftable:addRow("othernone", { interactive = false })
				if menu.missionModeCurrent == "othernone" then
					menu.setrow = row.index
				end
				row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
			end
			found = true
			-- online
			if #menu.missionList["coalition"] > 0 then
				local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(9):createText(ReadText(1001, 11609), Helper.headerRowCenteredProperties)
				for _, entry in ipairs(menu.missionList["coalition"]) do
					menu.addMissionRow(ftable, entry)
				end
			end
		elseif menu.missionMode == "upkeep" then
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(ReadText(1001, 3305), Helper.headerRowCenteredProperties)
			for containeridstring, data in pairs(menu.missionList[menu.missionMode]) do
				found = true

				-- check if we need to expand for the current selected mission
				for _, entry in ipairs(data.missions) do
					if entry.ID == menu.missionModeCurrent then
						menu.expandedMissionGroups[containeridstring] = true
					end
					for i, submission in ipairs(entry.subMissions) do
						if submission.ID == menu.missionModeCurrent then
							menu.expandedMissionGroups[containeridstring] = true
							menu.expandedMissionGroups[entry.ID] = true
						end
					end
				end

				local isexpanded = menu.expandedMissionGroups[containeridstring]
				local row = ftable:addRow(containeridstring, {  })
				if containeridstring == menu.missionModeCurrent then
					menu.setrow = row.index
				end

				local color = Color["text_normal"]
				if data.active then
					color = Color["text_mission"]
				end

				row[1]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(containeridstring, row.index) end
				local container = ConvertStringTo64Bit(containeridstring)
				row[2]:setColSpan(7):createText(ffi.string(C.GetComponentName(container)) .. " (" .. ffi.string(C.GetObjectIDCode(container)) .. ")" , { color = color })
				row[9]:createText((#data.missions == 1) and ReadText(1001, 3337) or string.format(ReadText(1001, 3338), #data.missions), { halign = "right", color = color })

				if isexpanded then
					local hadThreadMission = false
					for _, entry in ipairs(data.missions) do
						if entry.threadtype ~= "" then
							hadThreadMission = true
						end
						if hadThreadMission and (entry.threadtype == "") then
							-- first non thread mission after threads
							hadThreadMission = false
							local row = ftable:addRow(false, {  })
							row[1]:setColSpan(9):createText("")
						end
						menu.addMissionRow(ftable, entry, 1)
					end
				end
			end
		else
			local title = ""
			for _, entry in ipairs(config.missionCategories) do
				if entry.category == menu.missionMode then
					title = entry.name
					break
				end
			end
			-- title
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(9):createText(title, Helper.headerRowCenteredProperties)
			local hadThreadMission = false
			for _, entry in ipairs(menu.missionList[menu.missionMode]) do
				found = true
				if entry.threadtype ~= "" then
					hadThreadMission = true
				end
				if hadThreadMission and (entry.threadtype == "") then
					-- first non thread mission after threads
					hadThreadMission = false
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(9):createText("")
				end
				menu.addMissionRow(ftable, entry)
			end
		end
		if not found then
			local row = ftable:addRow("othernone", { interactive = false })
			if menu.missionModeCurrent == "othernone" then
				menu.setrow = row.index
			end
			row[1]:setColSpan(9):createText("--- " .. ReadText(1001, 3302) .. " ---", { halign = "center" })
		end
	end

	if (menu.infoTableMode ~= "missionoffer") or (menu.missionOfferMode ~= "operation") then
		ftable:setTopRow(menu.settoprow)
		ftable:setSelectedRow(menu.setrow)
		ftable:setSelectedCol(menu.setcol or 0)
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	if (menu.infoTableMode ~= "missionoffer") or ((menu.missionOfferMode ~= "operation") and isonline) then
		local table_header = menu.createMissionModeHeader(frame, "left")

		ftable.properties.y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize

		menu.playerinfotable:addConnection(1, 2, true)
		table_header:addConnection(2, 2)
		ftable:addConnection(3, 2)
	else
		menu.playerinfotable:addConnection(1, 2, true)
		ftable:addConnection(2, 2)
	end
end

function menu.createMissionModeHeader(frame, instance)
	local categories = (menu.infoTableMode == "missionoffer") and config.missionOfferTabs or config.missionCategories

	local ftable
	if instance == "left" then
		menu.missionModeHeaderTableLeft = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableLeft
	elseif instance == "right" then
		menu.missionModeHeaderTableRight = frame:addTable(#categories + 1, { tabOrder = 1 })
		ftable = menu.missionModeHeaderTableRight
	end

	local count = 1
	for i, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if entry.empty then
				ftable:setColWidth(count, menu.sideBarWidth / 2, false)
			else
				ftable:setColWidth(count, menu.sideBarWidth, false)
			end
			count = count + 1
		end
	end

	local row = ftable:addRow("tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if not entry.empty then
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if menu.infoTableMode == "missionoffer" then
					if entry.category == menu.missionOfferMode then
						bgcolor = Color["row_background_selected"]
					end
					if entry.category == "operation" then
						local outcomes = GetVentureOutcomes()
						if next(outcomes) ~= nil then
							color = Color["icon_mission"]
						end
					end
				else
					if entry.category == menu.missionMode then
						bgcolor = Color["row_background_selected"]
					end
					if entry.category == menu.activeMissionMode then
						color = Color["icon_mission"]
					end
				end

				local loccount = count
				row[loccount]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
				if menu.infoTableMode == "missionoffer" then
					row[loccount].handlers.onClick = function () return menu.buttonMissionOfferSubMode(entry.category, loccount) end
				else
					row[loccount].handlers.onClick = function () return menu.buttonMissionSubMode(entry.category, loccount) end
				end
			end
			count = count + 1
		end
	end

	if menu.selectedRows["missionModeHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["missionModeHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["missionModeHeaderTable" .. instance] or 0)
		menu.selectedRows["missionModeHeaderTable" .. instance] = nil
		menu.selectedCols["missionModeHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.addMissionRow(ftable, missionentry, indented, seqidx)
	local name = missionentry.name
	if seqidx then
		name = seqidx .. ReadText(1001, 120) .. " " .. name
	end
	local icon = "\27[" .. "missiontype_" .. missionentry.type .. "]"
	local color = Color["text_normal"]
	if missionentry.active then
		color = Color["text_mission"]
	elseif missionentry.accepted then
		name = ReadText(1001, 6404) .. " - " .. name
		color = Color["text_mission"]
		missionentry.duration = 0
	elseif missionentry.expired then
		name = ReadText(1001, 6402) .. " - " .. name
		color = Color["text_inactive"]
		missionentry.duration = 0
	end
	local faction = ""
	if missionentry.faction ~= "" then
		faction = GetFactionData(missionentry.faction, "shortname")
	end
	if missionentry.faction == "player" then
		faction = ""
	end
	local reward = missionentry.rewardtext
	if missionentry.reward > 0 then
		reward = ConvertMoneyString(missionentry.reward, false, true, 7, true) .. " " .. ReadText(1001, 101)
	end
	if reward ~= "" then
		reward = ReadText(1001, 3301) .. ReadText(1001, 120) .. " " .. reward
	end
	local difficulty, difficultyMouseOverText = "", ""
	if missionentry.difficulty ~= 0 then
		difficulty, difficultyMouseOverText = ConvertMissionLevelString(missionentry.difficulty)
	end

	if menu.missionModeCurrent == nil then
		menu.missionModeCurrent = missionentry.ID
	end

	local bgColor = Color["row_background_blue"]
	if #missionentry.subMissions > 0 then
		bgColor = nil
	elseif missionentry.expired then
		bgColor = Color["row_background_unselectable"]
	elseif missionentry.ID == menu.missionModeCurrent then
		bgColor = Color["row_background_selected"]
	end

	local row = ftable:addRow((missionentry.expired or missionentry.accepted) and true or { missionentry.ID }, { bgColor = bgColor })
	row[5]:setColSpan(4)
	local font = Helper.standardFont
	if missionentry.ID == menu.missionModeCurrent then
		menu.setrow = row.index
		if #missionentry.subMissions > 0 then
			font = Helper.standardFontBold
		end
	end
	if reward ~= "" then
		local lines = GetTextLines(reward, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), row[5]:getWidth())
		if reward ~= lines[1] then
			reward = utf8.sub(lines[1], 1, -3) .. "..."
		end
	end

	local missioncol = 1
	if #missionentry.subMissions > 0 then
		local isexpanded = menu.expandedMissionGroups[missionentry.ID]

		if indented == 1 then
			row[1]:setBackgroundColSpan(9)
			row[2]:createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[3]:setColSpan(7):createText(name, { color = color, font = font })
		else
			row[1]:setBackgroundColSpan(9):createButton():setText(isexpanded and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExpandMissionGroup(missionentry.ID, row.index, function() return menu.showMissionContext(missionentry.ID) end) end
			row[2]:setColSpan(8):createText(name, { color = color, font = font })
		end

		if isexpanded then
			for i, submission in ipairs(missionentry.subMissions) do
				menu.addMissionRow(ftable, submission, (indented or 0) + 1, (missionentry.threadtype == "sequential") and i or nil)
			end
		end
	else
		if indented == 2 then
			row[2]:setBackgroundColSpan(1)
			row[1]:setColSpan(2)
			row[1].properties.cellBGColor = Color["row_background"]
			row[3]:setBackgroundColSpan(7):setColSpan(2):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
			missioncol = 3
		elseif indented == 1 then
			row[1].properties.cellBGColor = Color["row_background"]
			row[2]:setBackgroundColSpan(8):setColSpan(3):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
			missioncol = 2
		else
			row[1]:setColSpan(4):setBackgroundColSpan(9):createText(icon .. "\n" .. faction, { color = color })
			row[5]:createText(name .. "\n" .. reward, { color = color })
			row[9]:createText(function () return menu.getMissionTimeAndDifficulty(missionentry.ID, difficulty) end, { color = color, halign = "right", mouseOverText = difficultyMouseOverText })
		end
	end
	row[missioncol].properties.helpOverlayID = missionentry.helpOverlayID
	row[missioncol].properties.helpOverlayText = " "
	row[missioncol].properties.helpOverlayHighlightOnly = true
	row[missioncol].properties.helpOverlayUseBackgroundSpan = true
end

function menu.getMissionTimeAndDifficulty(missionid, difficulty)
	local rawduration = 0
	if menu.infoTableMode == "mission" then
		if menu.updateMissionTime ~= getElapsedTime() then
			menu.updateMissions()
		end
		local missionid64 = ConvertStringTo64Bit(missionid)
		if missionid64 ~= menu.staleMissionID then
			local missiondetails = C.GetMissionIDDetails(missionid64)
			rawduration = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)
		end
	else
		if menu.updateMissionOfferTime ~= getElapsedTime() then
			menu.updateMissionOfferList()
		end

		local found = false
		local expired = false
		for _, category in ipairs(config.missionOfferCategories) do
			for i, entry in ipairs(menu.missionOfferList[category.category] or {}) do
				if entry.ID == missionid then
					found = true
					expired = entry.expired or entry.accepted
					break
				end
			end
		end
		if found and (not expired) then
			local name, description, offerdifficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, offerduration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(missionid))
			rawduration = offerduration
		end
	end

	local duration = ""
	if rawduration > 0 then
		duration = ConvertTimeString(rawduration, (rawduration >= 3600) and "%h:%M:%S" or "%M:%S")
	end

	return duration .. "\n" .. difficulty
end

function menu.updateMissionOfferList(clear)
	menu.updateMissionOfferTime = getElapsedTime()
	if (not menu.missionOfferList) or (not next(menu.missionOfferList)) then
		clear = true
	end
	if clear then
		menu.missionOfferList = {}
		for _, entry in ipairs(config.missionOfferCategories) do
			menu.missionOfferList[entry.category] = {}
		end
		menu.missionOfferByOnlineID = {}
	end

	local missionOfferList, missionOfferIDs = {}, {}
	Helper.ffiVLA(missionOfferList, "uint64_t", C.GetNumCurrentMissionOffers, C.GetCurrentMissionOffers, true)
	for i, id in ipairs(missionOfferList) do
		missionOfferIDs[tostring(id)] = i
	end

	for _, entry in ipairs(config.missionOfferCategories) do
		if entry.category == "guild" then
			for i, data in ipairs(menu.missionOfferList[entry.category]) do
				for j = #data.missions, 1, -1 do
					if missionOfferIDs[data.missions[j].ID] then
						missionOfferIDs[menu.missionOfferList[entry.category][i].missions[j].ID] = nil
					else
						if not menu.missionOfferList[entry.category][i].missions[j].accepted then
							menu.missionOfferList[entry.category][i].missions[j].expired = true
						end
					end
				end
			end
		else
			for i = #menu.missionOfferList[entry.category], 1, -1 do
				if missionOfferIDs[menu.missionOfferList[entry.category][i].ID] then
					missionOfferIDs[menu.missionOfferList[entry.category][i].ID] = nil
				else
					if not menu.missionOfferList[entry.category][i].accepted then
						menu.missionOfferList[entry.category][i].expired = true
					end
				end
			end
		end
	end

	for id in pairs(missionOfferIDs) do
		local missionofferid64 = ConvertStringTo64Bit(id)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, _, _, _, _, actor = GetMissionOfferDetails(ConvertStringToLuaID(id))
		local missionGroup = C.GetMissionGroupDetails(missionofferid64)
		local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionofferid64))
		if maintype ~= "tutorial" then
			local entry = {
				["name"] = name,
				["description"] = description,
				["difficulty"] = difficulty,
				["missionGroup"] = { id = groupID, name = groupName },
				["threadtype"] = threadtype,
				["type"] = subtype,
				["faction"] = faction or "",
				["oppfaction"] = oppfaction or "",
				["licence"] = licence,
				["reward"] = reward,
				["rewardtext"] = rewardtext,
				["briefingobjectives"] = briefingobjectives,
				["activebriefingstep"] = activebriefingstep,
				["duration"] = duration,
				["missiontime"] = missiontime,
				["ID"] = id,
				["actor"] = actor,
				["onlinechapter"] = onlinechapter,
				["onlineID"] = onlineid,
				["helpOverlayID"] = helpoverlayid,
				["subMissions"] = {},
			}

			if entry.missionGroup.id ~= "" then
				local index = 0
				for i, data in ipairs(menu.missionOfferList["guild"]) do
					if data.id == entry.missionGroup.id then
						index = i
						break
					end
				end
				if index ~= 0 then
					table.insert(menu.missionOfferList["guild"][index].missions, entry)
				else
					table.insert(menu.missionOfferList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, missions = { entry } })
				end
			else
				if maintype == "plot" then
					table.insert(menu.missionOfferList["plot"], entry)
				elseif onlinechapter ~= "" then
					table.insert(menu.missionOfferList["coalition"], entry)
					menu.missionOfferByOnlineID[entry.onlineID] = entry
				else
					table.insert(menu.missionOfferList["other"], entry)
				end
			end
		end
	end

	table.sort(menu.missionOfferList["guild"], Helper.sortName)
	for _, entry in ipairs(menu.missionOfferList["guild"]) do
		table.sort(entry.missions, menu.missionOfferSorter)
	end
	table.sort(menu.missionOfferList["plot"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["coalition"], menu.missionOfferSorter)
	table.sort(menu.missionOfferList["other"], menu.missionOfferSorter)
end

function menu.missionOfferSorter(a, b)
	if a.name == b.name then
		return a.ID > b.ID
	end
	return a.name < b.name
end

function menu.getMissionInfoHelper(mission)
	local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, upkeepalertlevel, hasobjective, threadmissionid = GetMissionDetails(mission)
	local missionid64 = ConvertIDTo64Bit(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionid64)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionid64)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionid64))
	local objectiveText, timeout, progressname, curProgress, maxProgress = GetMissionObjective(mission)
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local entry = {
		["active"] = (mission == GetActiveMission()) or subactive,
		["name"] = name,
		["description"] = description,
		["difficulty"] = difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = threadtype,
		["maintype"] = maintype,
		["type"] = subtype,
		["faction"] = faction,
		["reward"] = reward,
		["rewardtext"] = rewardtext,
		["duration"] = (timeout and timeout ~= -1) and timeout or (missiontime or -1),		-- timeout can be nil, if mission has no objective
		["ID"] = tostring(missionid64),
		["associatedcomponent"] = ConvertIDTo64Bit(associatedcomponent),
		["abortable"] = abortable,
		["threadMissionID"] = ConvertIDTo64Bit(threadmissionid) or 0,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.getMissionIDInfoHelper(missionID)
	local missionGroup = C.GetMissionGroupDetails(missionID)
	local groupID, groupName = ffi.string(missionGroup.id), ffi.string(missionGroup.name)
	local onlineinfo = C.GetMissionOnlineInfo(missionID)
	local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
	local helpoverlayid = ffi.string(C.GetMissionHelpOverlayID(missionID))
	local subMissions, buf = {}, {}
	local subactive = false
	Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionID)
	for _, submission in ipairs(buf) do
		local submissionEntry = menu.getMissionIDInfoHelper(submission)
		table.insert(subMissions, submissionEntry)
		if submissionEntry.active then
			subactive = true
		end
	end
	local missiondetails = C.GetMissionIDDetails(missionID)
	local entry = {
		["active"] = (missionID == C.GetActiveMissionID()) or subactive,
		["name"] = ffi.string(missiondetails.missionName),
		["description"] = ffi.string(missiondetails.missionDescription),
		["difficulty"] = missiondetails.difficulty,
		["missionGroup"] = { id = groupID, name = groupName },
		["threadtype"] = ffi.string(missiondetails.threadType),
		["maintype"] = ffi.string(missiondetails.mainType),
		["type"] = ffi.string(missiondetails.subType),
		["faction"] = ffi.string(missiondetails.faction),
		["reward"] = tonumber(missiondetails.reward) / 100,
		["rewardtext"] = ffi.string(missiondetails.rewardText),
		["duration"] = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
		["ID"] = tostring(ConvertStringTo64Bit(tostring(missionID))),
		["associatedcomponent"] = missiondetails.associatedComponent,
		["abortable"] = missiondetails.abortable,
		["threadMissionID"] = missiondetails.threadMissionID,
		["subMissions"] = subMissions,
		["onlinechapter"] = onlinechapter,
		["onlineID"] = onlineid,
		["activebriefingstep"] = missiondetails.activeBriefingStep,
		["helpOverlayID"] = helpoverlayid,
	}

	return entry
end

function menu.addMissionToList(entry)
	if entry.maintype == "upkeep" then
		if entry.associatedcomponent then
			local container = C.GetContextByRealClass(entry.associatedcomponent, "container", true)
			if container ~= 0 then
				local containeridstring = tostring(container)

				if menu.missionList["upkeep"][containeridstring] then
					if entry.active then
						menu.missionList["upkeep"][containeridstring].active = true
					end
					table.insert(menu.missionList["upkeep"][containeridstring].missions, entry)
				else
					menu.missionList["upkeep"][containeridstring] = { active = entry.active, missions = { entry } }
				end
				if entry.active then
					menu.activeMissionMode = "upkeep"
				end
			end
		end
	elseif entry.maintype == "guidance" then
		table.insert(menu.missionList["guidance"], entry)
		if entry.active then
			menu.activeMissionMode = "guidance"
		end
	elseif entry.maintype == "plot" then
		table.insert(menu.missionList["plot"], entry)
		if entry.active then
			menu.activeMissionMode = "plot"
		end
	elseif entry.onlinechapter ~= "" then
		table.insert(menu.missionList["coalition"], entry)
		menu.missionByOnlineID[entry.onlineID] = entry
	else
		if entry.missionGroup.id ~= "" then
			local index = 0
			for i, data in ipairs(menu.missionList["guild"]) do
				if data.id == entry.missionGroup.id then
					index = i
					break
				end
			end
			if index ~= 0 then
				if entry.active then
					menu.missionList["guild"][index].active = true
				end
				table.insert(menu.missionList["guild"][index].missions, entry)
			else
				table.insert(menu.missionList["guild"], { id = entry.missionGroup.id, name = entry.missionGroup.name, active = entry.active, missions = { entry } })
			end
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		else
			table.insert(menu.missionList["other"], entry)
			if entry.active then
				menu.activeMissionMode = "plot"
			end
		end
	end
end

function menu.updateMissions()
	menu.updateMissionTime = getElapsedTime()
	menu.missionList = {}
	menu.missionByOnlineID = {}
	menu.activeMissionMode = nil
	for _, entry in ipairs(config.missionCategories) do
		menu.missionList[entry.category] = {}
	end

	local numMissions = GetNumMissions()
	for i = 1, numMissions do
		local entry = menu.getMissionInfoHelper(i)
		if maintype ~= "tutorial" then
			if entry.threadMissionID == 0 then
				menu.addMissionToList(entry)
			end
		end
	end

	for _, entry in ipairs(config.missionCategories) do
		if (entry.category == "guild") or (entry.category == "upkeep") then
			for _, data in pairs(menu.missionList[entry.category]) do
				table.sort(data.missions, menu.missionListSorter)
			end
		else
			table.sort(menu.missionList[entry.category], menu.missionListSorter)
		end
	end
end

function menu.missionListSorter(a, b)
	if ((a.threadtype ~= "") and (b.threadtype ~= "")) or ((a.threadtype == "") and (b.threadtype == "")) then
		if config.missionMainTypeOrder[a.maintype] == config.missionMainTypeOrder[b.maintype] then
			return a.name < b.name
		end
		return config.missionMainTypeOrder[a.maintype] < config.missionMainTypeOrder[b.maintype]
	end

	return a.threadtype ~= ""
end

function menu.createVentureSeasonHeader(frame, instance)
	local ftable
	if instance == "left" then
		menu.ventureSeasonHeaderTableLeft = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableLeft
	elseif instance == "right" then
		menu.ventureSeasonHeaderTableRight = frame:addTable(#config.infoCategories + 1, { tabOrder = 1 })
		ftable = menu.ventureSeasonHeaderTableRight
	end

	for i, entry in ipairs(config.seasonCategories) do
		if entry.empty then
			ftable:setColWidth(i, menu.sideBarWidth / 2, false)
		else
			ftable:setColWidth(i, menu.sideBarWidth, false)
		end
	end

	local isonline = Helper.isOnlineGame()
	local invitations = {}
	if not OnlineGetCurrentTeam().isvalid then
		invitations = Helper.callExtensionFunction("multiverse", "getTeamInvites") or {}
	end

	local row = ftable:addRow("orders_tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(config.seasonCategories) do
		if not entry.empty then
			local bgcolor = Color["row_title_background"]
			local color = Color["icon_normal"]
			if entry.category == menu.seasonMode[instance] then
				bgcolor = Color["row_background_selected"]
			end
			if entry.category == "ventureteam" then
				if not OnlineGetCurrentTeam().isvalid then
					if #invitations > 0 then
						color = Color["icon_mission"]
					end
				end
			end

			local active = (entry.category == "currentseason") or isonline
			-- TODO onlineUI
			if entry.category == "pastseasons" then
				active = false
			end

			local loccount = count
			row[loccount]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
			row[loccount].handlers.onClick = function () return menu.buttonVentureSeasonSubMode(entry.category, loccount, instance) end
			count = count + 1
		else
			count = count + 1
		end
	end

	if menu.selectedRows["ventureSeasonHeaderTable" .. instance] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["ventureSeasonHeaderTable" .. instance])
		ftable:setSelectedCol(menu.selectedCols["ventureSeasonHeaderTable" .. instance] or 0)
		menu.selectedRows["ventureSeasonHeaderTable" .. instance] = nil
		menu.selectedCols["ventureSeasonHeaderTable" .. instance] = nil
	end

	return ftable
end

function menu.createVentureSeason(frame, instance)
	local infoTableData = menu.infoTableData[instance]
	local infoTablePersistentData = menu.infoTablePersistentData[instance]

	local numCols = 2
	local table_desc = frame:addTable(numCols, { tabOrder = 1, highlightMode = "off" })
	table_desc:setColWidthPercent(2, 33)
	table_desc:setDefaultBackgroundColSpan(1, numCols)

	local season = OnlineGetCurrentSeason()

	-- title
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11322), Helper.titleTextProperties)

	-- description
	local row = table_desc:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11334), Helper.subHeaderTextProperties)

	local description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
	if #description > config.ventureSeasons.maxDescRows then
		-- scrollbar case
		description = GetTextLines(season.description, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), menu.infoTableWidth - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
	end
	for linenum, descline in ipairs(description) do
		local row = table_desc:addRow(true, {  })
		row[1]:setColSpan(numCols):createText(descline)
		if linenum == config.ventureSeasons.maxDescRows then
			visibleHeight = table_desc:getFullHeight()
		end
	end

	if visibleHeight then
		table_desc.properties.maxVisibleHeight = visibleHeight
	else
		table_desc.properties.maxVisibleHeight = table_desc:getFullHeight()
	end

	if menu.selectedRows["infotable" .. instance] then
		table_desc:setSelectedRow(menu.selectedRows["infotable" .. instance])
		menu.selectedRows["infotable" .. instance] = nil
		if menu.topRows["infotable" .. instance] then
			table_desc:setTopRow(menu.topRows["infotable" .. instance])
			menu.topRows["infotable" .. instance] = nil
		end
	end
	menu.setrow = nil
	menu.settoprow = nil
	menu.setcol = nil

	local numCols = 2
	local table_info = frame:addTable(numCols, { tabOrder = 2 })
	table_info:setColWidthPercent(2, 50)
	table_info:setDefaultBackgroundColSpan(1, numCols)

	table_info:addEmptyRow(config.mapRowHeight / 2)

	-- reward
	local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11335), Helper.subHeaderTextProperties)

	local row = table_info:addRow(nil, { fixed = true })
	row[1]:setColSpan(numCols):createIcon(season.rewardicon, { scaling = false, height = math.floor(menu.infoTableWidth * 9 / 32) })

	if season.isvalid then
		local rewardlist = { { text = season.rewardtext } }
		for i, entry in ipairs(rewardlist) do
			local row = table_info:addRow(nil, { fixed = true })
			if i == 1 then
				row[1]:createText(ReadText(1001, 11338) .. ReadText(1001, 120))
			end
			row[2]:createText(entry.text, { halign = "right" })
		end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		-- details
		local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11336), Helper.subHeaderTextProperties)

		local row = table_info:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11339) .. ReadText(1001, 120))
		local seasonname = ""
		if (season.seasonnumber < 1) or (season.seasonnumber > 25) then
			seasonname = string.format(ReadText(1001, 11576), season.seasonnumber)
		else
			seasonname = string.format(ReadText(1001, 11576), ReadText(20402, season.seasonnumber))
		end
		row[2]:createText(seasonname, { halign = "right" })

		local row = table_info:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11340) .. ReadText(1001, 120))
		row[2]:createText(Helper.ventureSeasonTimeLeftText(), { halign = "right" })

		-- coalition
		local row = table_info:addRow(true, { fixed = true })
		row[1]:createText(ReadText(1001, 11341) .. ReadText(1001, 120))

		local coalitionname = ""
		local currentcoalition = OnlineGetCurrentCoalition()
		if currentcoalition.isvalid then
			coalitionname = currentcoalition.name
		else
			coalitionname = ReadText(1001, 11577)
		end
		row[2]:createButton({ active = function() return (season.ispreseason or season.isrunning) and Helper.isOnlineGame() end }):setText(coalitionname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("coalition", 2, instance) end

		-- team
		local row = table_info:addRow(true, { fixed = true })
		row[1]:createText(ReadText(1001, 11582) .. ReadText(1001, 120))

		local teamname = ""
		local currentteam = OnlineGetCurrentTeam()
		if currentteam.isvalid then
			teamname = currentteam.name
		else
			teamname = ReadText(1001, 11583)
		end
		row[2]:createButton({ active = function () local currentcoalition = OnlineGetCurrentCoalition(); return Helper.isOnlineGame() and currentcoalition.isvalid end }):setText(teamname, { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonVentureSeasonSubMode("ventureteam", 3, instance) end

		table_info:addEmptyRow(config.mapRowHeight / 2)

		--[[
		-- progress
		local row = table_info:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11337), Helper.subHeaderTextProperties)

		-- TODO onlineUI
		local seasonprogress = { rank = "\27MEmperor", venturescompleted = 3210 } -- TEMPTEXT Florian
		local progresslist = {
			{ text = ReadText(1001, 11342),		value = "rank",					type = "string" },
			{ text = ReadText(1001, 11343),		value = "venturescompleted",	type = "number" },
			{ text = ReadText(1001, 11344),		value = "venturesfailed",		type = "number" },
		}
		for i, entry in ipairs(progresslist) do
			local row = table_info:addRow(nil, { fixed = true })
			row[1]:createText(entry.text .. ReadText(1001, 120))
			local value = seasonprogress[entry.value]
			if value and (entry.type == "number") then
				value = ConvertIntegerString(value, true, 0, true)
			end
			row[2]:createText(value, { halign = "right" })
		end--]]
	end

	local table_header = menu.createVentureSeasonHeader(frame, instance)

	table_desc.properties.y = table_header.properties.y + table_header:getFullHeight() + Helper.borderSize
	table_info.properties.y = table_desc.properties.y + table_desc:getVisibleHeight() + Helper.borderSize

	local isleft = instance == "left"
	if isleft then
		menu.playerinfotable:addConnection(1, 2, true)
	end
	table_header:addConnection(isleft and 2 or 1, isleft and 2 or 3, not isleft)
	table_desc:addConnection(isleft and 3 or 2, isleft and 2 or 3)
	table_info:addConnection(isleft and 4 or 3, isleft and 2 or 3)
end

function menu.createCheats(frame)
	-- (cheat only)
	local cheats = {
		[1] = {
			name = "Enable All Cheats",
			info = "Reveal stations, encyclopedia, map, research and adds money and seta.",
			callback = C.EnableAllCheats,
			shortcut = {"action", 290}, -- INPUT_ACTION_DEBUG_FEATURE_3
		},
		[2] = {
			name = "Reveal map",
			callback = C.RevealMap,
		},
		[3] = {
			name = "Reveal stations",
			callback = C.RevealStations,
		},
		[4] = {
			name = "Cheat 1bn Credits",
			callback = function () return C.AddPlayerMoney(100000000000) end,
		},
		[5] = {
			name = "Cheat SETA",
			callback = function () return AddInventory(nil, "inv_timewarp", 1) end,
		},
		[6] = {
			name = "Reveal encyclopedia",
			info = "Also reveals the map and completes all research.",
			callback = C.RevealEncyclopedia,
		},
		[7] = {
			name = "Spawn CVs",
			section = "gDebug_deployCVs",
		},
		[8] = {
			name = "Fill nearby Build Storages",
			section = "gDebug_station_buildresources",
		},
		[9] = {
			name = "Inc Crew skill",
			section = "gDebug_crewskill",
		},
		[10] = {
			name = "Open Flowchart Test",
			menu = "StationOverviewMenu",
		},
		[11] = {
			name = "Cheat All Research",
			callback = menu.cheatAllResearch,
		},
		[12] = {
			name = "Cheat Docking Traffic",
			sectionparam = C.CheatDockingTraffic,
			shortcut = {"action", 291}, -- INPUT_ACTION_DEBUG_FEATURE_4
		},
		[13] = {
			name = "Cheat Live Stream View Channels",
			info = "Makes all faction channels available in Live Stream View.",
			callback = C.CheatLiveStreamViewChannels,
		},
	}

	local ftable = frame:addTable(1 , { tabOrder = 1 })
	menu.playerinfotable:addConnection(1, 2, true)
	ftable:addConnection(2, 2)
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText("Cheats", Helper.headerRowCenteredProperties)

	for _, cheat in ipairs(cheats) do
		local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
		local shortcut = ""
		if cheat.shortcut then
			shortcut = Helper.formatOptionalShortcut(" " .. ColorText["text_inactive"] .. "(%s)", cheat.shortcut[1], cheat.shortcut[2])
		end
		row[1]:createButton({ mouseOverText = cheat.info or "" }):setText(cheat.name .. shortcut)
		if cheat.callback then
			row[1].handlers.onClick = function () return cheat.callback() end
		elseif cheat.menu then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, cheat.menu, {0, 0}) menu.cleanup() end
		elseif cheat.section then
			row[1].handlers.onClick = function () Helper.closeMenuForNewConversation(menu, cheat.section, ConvertStringToLuaID(tostring(C.GetPlayerComputerID())), nil, true) menu.cleanup() end
		end
	end
end

function menu.cheatAllResearch()
	local researchwares = {
		"research_module_build",
		"research_module_defence",
		"research_module_dock",
		"research_module_habitation",
		"research_module_production",
		"research_module_storage",
		"research_module_venture",
		"research_module_welfare_1",
		"research_module_welfare_2",
		"research_teleportation",
		"research_teleportation_range_01",
		"research_teleportation_range_02",
		"research_teleportation_range_03",
		"research_radioreceiver",
		"research_sensorbooster",
		"research_tradeinterface",
		"research_mod_engine_mk1",
		"research_mod_engine_mk2",
		"research_mod_engine_mk3",
		"research_mod_shield_mk1",
		"research_mod_shield_mk2",
		"research_mod_shield_mk3",
		"research_mod_ship_mk1",
		"research_mod_ship_mk2",
		"research_mod_ship_mk3",
		"research_mod_weapon_mk1",
		"research_mod_weapon_mk2",
		"research_mod_weapon_mk3",
		"research_warp_hq_01",
		"research_warp_hq_02",
		"research_diplomacy_network",
	}

	for _, research in ipairs(researchwares) do
		C.AddResearch(research)
	end
end

function menu.createPlayerInfo(frame, width, height, offsetx, offsety)
	local ftable = frame:addTable(3, { tabOrder = 18, width = width, height = height, x = offsetx, y = offsety, scaling = false })
	menu.playerinfotable = ftable
	ftable:setColWidth(1, height)
	ftable:setColWidthPercent(3, 30)

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["player_info_background"] })
	local icon = row[1]:setBackgroundColSpan(3):createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = height, height = height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, width - height - Helper.borderSize))

	if menu.showMultiverse then
		row[2]:createText(function (cell) return Helper.playerInfoConfigTextLeft(cell, nil, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	else
		local button = row[2]:createButton({
			width = row[2]:getColSpanWidth(),
			height = Helper.scaleY(config.mapRowHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))),
			bgColor = function () return menu.allowResetView() and Color["button_background_default"] or Color["button_background_inactive"] end,
			highlightColor = function () return menu.allowResetView() and Color["button_highlight_default"] or Color["button_highlight_inactive"] end,
			helpOverlayID = "map_resetview",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextLeft(cell, 0.7 * width - height - 2 * Helper.scaleY(Helper.standardTextHeight), menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0 })
		button:setText2("\27[menu_reset_view]", { halign = "right", scaling = true })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		button.handlers.onClick = function () return menu.allowResetView() and menu.buttonResetView() or nil end
	end

	if OnlineIsCurrentTeamValid() then
		local button = row[3]:createButton({
			width = row[3]:getColSpanWidth(),
			height = Helper.scaleY(Helper.standardTextHeight),
			x = Helper.borderSize,
			y = Helper.borderSize,
			mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_SHOW_CHAT_WINDOW"),
		})
		button:setText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, x = Helper.borderSize, y = 0, halign = "right" })
		button:setText2("\27[mt_chat_unread_low] " .. ReadText(1001, 11648), { scaling = true })
		button.handlers.onClick = function () return C.QuickMenuAccess("chat") end
	else
		row[3]:createText(function (cell) return Helper.playerInfoConfigTextRight(cell, menu.showMultiverse) end, { fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize, y = math.max(0, (height - textheight) / 4) })
	end

	ftable:addConnection(1, 2)
end

function menu.createSearchField(frame, width, height, offsetx, offsety, refresh)
	local editboxwidth = menu.infoTableWidth - Helper.round(2.5 * menu.editboxHeight) - Helper.borderSize

	local numCols = 7 + #config.layers
	local ftable = frame:addTable(numCols, { tabOrder = 4, width = width, height = height, x = offsetx, y = offsety, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
	if menu.searchTableMode ~= "info" then
		ftable:addConnection(1, 3, true)
	end
	ftable:setDefaultCellProperties("text", { minRowHeight = config.mapRowHeight, fontsize = config.mapFontSize })
	ftable:setDefaultCellProperties("button", { height = config.mapRowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.mapFontSize })

	ftable:setColWidth(1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(2, math.max(4, Helper.scaleY(Helper.headerRow1Height) - Helper.scaleY(config.mapRowHeight) - Helper.borderSize), false)
	ftable:setColWidth(3, menu.sideBarWidth - Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize, false)
	for i = 2, #config.layers + 1 do
		ftable:setColWidth(i + 2, menu.sideBarWidth, false)
	end
	ftable:setColWidth(numCols - 1, Helper.scaleY(config.mapRowHeight), false)
	ftable:setColWidth(numCols, Helper.scaleY(config.mapRowHeight), false)

	-- search field
	local rows = {
		[1] = ftable:addRow(true, { fixed = true }),
		[2] = ftable:addRow(true, { fixed = true }),
		[3] = ftable:addRow(true, { fixed = true }),
	}

	for i, entry in ipairs(config.layers) do
		local icon = entry.icon
		local onoffcolor = Color["text_normal"]
		if not menu.getFilterOption(entry.mode, false) then
			icon = icon .. "_disabled"
			onoffcolor = Color["text_negative"]
		end
		local mouseovertext = entry.name
		local hotkeyname = Helper.getInputMouseOverText("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i)
		if hotkeyname ~= "" then
			mouseovertext = mouseovertext .. " (" .. hotkeyname .. ")"
		end

		local button = rows[i][1]:setColSpan(5):createButton({ height = menu.editboxHeight, bgColor = bgcolor, mouseOverText = mouseovertext, scaling = false, helpOverlayID = entry.toggleHelpOverlayID, helpOverlayText = " ", helpOverlayHighlightOnly = true})
		button:setIcon(icon, { width = menu.editboxHeight, height = menu.editboxHeight })
		button:setText(entry.shortname, { x = menu.editboxHeight, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
		button:setIcon2("menu_on_off", { width = menu.editboxHeight, height = menu.editboxHeight, x = rows[i][1]:getWidth() - menu.editboxHeight, color = onoffcolor })
		button:setHotkey("INPUT_STATE_DETAILMONITOR_TOGGLE_FILTER_" .. i, { displayIcon = false })
		button.handlers.onClick = function () return menu.buttonSetFilterLayer(entry.mode, rows[i].index, i) end
	end
	-- editbox
	local active = true
	local mouseovertext = ""
	if menu.mode == "behaviourinspection" then
		active = false
		mouseovertext = ReadText(1026, 3285)
	end
	rows[1][7]:setColSpan(4):createEditBox({ active = active, mouseOverText = mouseovertext, height = menu.editboxHeight, defaultText = ReadText(1001, 3250), scaling = false, helpOverlayID = "map_searchbar", helpOverlayText = " ", helpOverlayHighlightOnly = true, restoreInteractiveObject = true }):setText("", { x = Helper.standardTextOffsetx, scaling = true }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	rows[1][7].handlers.onTextChanged = menu.searchTextChanged
	rows[1][7].handlers.onEditBoxDeactivated = menu.searchTextConfirmed
	menu.searchEditBoxData = {
		width = rows[1][7]:getColSpanWidth() + Helper.scrollbarWidth,
		x = offsetx + rows[1][7]:getOffsetX(),
		y = offsety + menu.editboxHeight + Helper.borderSize,
	}

	-- search terms
	local setting, warefilter = menu.getTradeWareFilter()
	__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
	local sectorfilter = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
	local maxsearchtermsdisplayed = 4

	local searchindex = 0
	for i = 1, math.min(maxsearchtermsdisplayed, #menu.searchtext) do
		local usedrow = rows[2]
		local col = 6 + i
		if col > 8 then
			usedrow = rows[3]
			col = col - 2
		end
		searchindex = searchindex + 1
		local untruncatedstring = menu.searchtext[i].text
		local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

		if menu.searchtext[i].blockRemove then
			usedrow[col]:createText(untruncatedstring, { halign = "center", cellBGColor = Color["button_background_default"] })
		else
			usedrow[col]:createButton({
				active = active,
				height = menu.editboxHeight,
				helpOverlayID = "FilterItem" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and (untruncatedstring .. "\n" .. mouseovertext) or mouseovertext,
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
			usedrow[col].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
		end
	end

	searchindex = 0
	if #menu.searchtext < maxsearchtermsdisplayed then
		for i = 1, math.min(maxsearchtermsdisplayed - #menu.searchtext, #warefilter) do
			local usedrow = rows[2]
			local col = 6 + i + #menu.searchtext
			if col > 8 then
				usedrow = rows[3]
				col = col - 2
			end
			searchindex = searchindex + 1
			local untruncatedstring = GetWareData(warefilter[i], "name")
			local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

			usedrow[col]:createButton({
				active = active,
				height = menu.editboxHeight,
				helpOverlayID = "FilterWare" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and (untruncatedstring .. "\n" .. mouseovertext) or mouseovertext,
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setIcon("maptr_supply", { width = menu.editboxHeight, height = menu.editboxHeight })
			usedrow[col].handlers.onClick = function () return menu.removeFilterOption(setting, setting.id, i) end
			usedrow[col].properties.uiTriggerID = "removefilteroption"
		end
	end

	searchindex = 0
	if (#menu.searchtext + #warefilter) < maxsearchtermsdisplayed then
		for i = 1, math.min(maxsearchtermsdisplayed - #menu.searchtext - #warefilter, #sectorfilter) do
			local usedrow = rows[2]
			local col = 6 + i + #menu.searchtext + #warefilter
			if col > 8 then
				usedrow = rows[3]
				col = col - 2
			end
			searchindex = searchindex + 1
			local untruncatedstring = GetComponentData(ConvertStringToLuaID(sectorfilter[i]), "name")
			local truncatedString = TruncateText(untruncatedstring, Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.mapFontSize), usedrow[col]:getWidth() - 2 * Helper.scaleX(10))

			usedrow[col]:createButton({
				active = active,
				height = menu.editboxHeight,
				helpOverlayID = "FilterSector" .. searchindex,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				scaling = false,
				mouseOverText = (truncatedString ~= untruncatedstring) and (untruncatedstring .. "\n" .. mouseovertext) or mouseovertext,
			}):setText(truncatedString, { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setText2("X", { halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) }):setIcon("maptr_hexagon", { width = menu.editboxHeight, height = menu.editboxHeight })
			usedrow[col].handlers.onClick = function () table.remove(sectorfilter, i); menu.setSectorFilter(); menu.refreshMainFrame = true end
			usedrow[col].properties.uiTriggerID = "removefilteroption"
		end
	end

	if (#menu.searchtext + #warefilter + #sectorfilter) > maxsearchtermsdisplayed then
		rows[3][numCols - 1]:setColSpan(2):createText(string.format("%+d", (#menu.searchtext + #warefilter + #sectorfilter) - maxsearchtermsdisplayed), { y = (menu.editboxHeight - Helper.standardTextHeight) / 2, scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, config.mapFontSize) })
	end

	menu.infoTable2OffsetY = ftable.properties.y + ftable:getFullHeight() + Helper.borderSize

	if menu.searchTableMode then
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", menu.infoTableOffsetX + menu.infoTableWidth + config.contextBorder)
		end
		if (#menu.searchtext + #warefilter) > 0 then
			local row = ftable:addRow(nil, { fixed = true })
			row[1]:createText("")
		end

		if menu.searchTableMode == "filter" then
			menu.createFilterMode(ftable, numCols)
		elseif menu.searchTableMode == "legend" then
			menu.createLegendMode(ftable, numCols)
		elseif menu.searchTableMode == "hire" then
			menu.createHireMode(ftable, numCols)
		end
	else
		if menu.holomap ~= 0 then
			C.SetMapStationInfoBoxMargin(menu.holomap, "right", 0)
		end
	end

	ftable:setTopRow(menu.topRows.filterTable)
	ftable:setSelectedRow(menu.selectedRows.filterTable)
	ftable:setSelectedCol(menu.selectedCols.filterTable or 0)

	menu.topRows.filterTable = nil
	menu.selectedRows.filterTable = nil
	menu.selectedCols.filterTable = nil

	if not refresh then
		menu.createInfoFrame2()
	end
end

function menu.allowResetView()
	if menu.holomap ~= 0 then
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		local radthreshold = math.rad(config.cameraResetThresholdAngle)
		-- offset rotation when camera is reset:
		--   yaw: 0
		--   pitch: -1.5533 = -179°
		--   roll: 0
		if (math.abs(mapstate.offset.yaw) > radthreshold) or (math.abs(mapstate.offset.roll) > radthreshold) or (mapstate.offset.pitch > -math.pi / 2 + radthreshold) then
			return true
		end

		return C.GetMapFocusComponent(menu.holomap) ~= C.GetPlayerObjectID()
	end
end

function menu.createInfoFrame2()
	menu.createInfoFrame2Running = true

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoFrameLayer2)

	-- infoTable
	local infoTableHeight = Helper.viewHeight - menu.infoTableOffsetY - menu.borderOffset

	menu.infoFrame2 = Helper.createFrameHandle(menu, {
		x = Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth,
		y = menu.infoTable2OffsetY,
		width = menu.infoTableWidth,
		height = infoTableHeight,
		layer = config.infoFrameLayer2,
		standardButtons = {},
		showBrackets = false,
		autoFrameHeight = true,
		helpOverlayID = "map_infoframe2",
	})
	menu.infoFrame2:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	if (menu.searchTableMode ~= "info") and (menu.mode ~= "orderparam_object") then
		menu.infoTablePersistentData.right.cashtransferdetails = {}
		menu.infoTablePersistentData.right.drops = {}
		menu.infoTablePersistentData.right.crew.object = nil
		menu.infoTablePersistentData.right.macrostolaunch = {}
	end

	menu.infoTableData = menu.infoTableData or {}
	menu.infoTableData.right = {}
	if (not menu.showMultiverse) and (menu.searchTableMode == "info") then
		if menu.infoMode.right == "objectinfo" then
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.createInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectcrew" then
			menu.createCrewInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectloadout" then
			menu.createLoadoutInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "objectlogbook" then
			menu.createLogbookInfoSubmenu(menu.infoFrame2, "right")
		elseif menu.infoMode.right == "orderqueue" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "orderqueue_advanced" then
			menu.createOrderQueue(menu.infoFrame2, menu.infoMode.right, "right")
		elseif menu.infoMode.right == "standingorders" then
			menu.createStandingOrdersMenu(menu.infoFrame2, "right")
		end
	else
		-- empty

		-- kuertee start: callback
		-- menu.infoFrame2.properties.background.icon = ""
		-- menu.infoFrame2.properties.showBrackets = false
		-- menu.infoFrame2.properties.autoFrameHeight = false
		-- menu.infoFrame2:addTable(0)

		local isCreated = false
		if menu.uix_callbacks ["createInfoFrame2_on_menu_infoModeRight"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame2_on_menu_infoModeRight"]) do
				if uix_callback (menu.infoFrame2) then
					isCreated = true
				end
			end
		end
		if isCreated ~= true then
			menu.infoFrame2.properties.background.icon = ""
			menu.infoFrame2.properties.showBrackets = false
			menu.infoFrame2.properties.autoFrameHeight = false
			menu.infoFrame2:addTable(0)
		end
		-- kuertee end: callback

	end

	menu.infoFrame2.properties.helpOverlayText = helpOverlayText
	menu.infoFrame2:display()
end

function menu.buttonRemoveSearchEntry(index)
	Helper.cancelEditBoxInput(menu.searchField, 1, 7)

	table.remove(menu.searchtext, index)
	menu.setTextFilter()
	menu.refreshMainFrame = true

	menu.refreshInfoFrame()
end

function menu.createSideBar(firsttime, frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if menu.uix_callbacks ["createSideBar_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createSideBar_on_start"]) do
			uix_callback (config)
		end
	end
	-- kuertee end: callback

	local spacingHeight = menu.sideBarWidth / 4
	local defaultInteractiveObject = false
	if menu.showMultiverse then
		defaultInteractiveObject = menu.ventureMode == nil
	else
		defaultInteractiveObject = menu.infoTableMode == nil
	end
	local ftable = frame:addTable(1, { tabOrder = 3, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, defaultInteractiveObject = defaultInteractiveObject })
	ftable:addConnection(1, 1, true)

	local foundselection
	local leftbar = menu.showMultiverse and config.leftBarMultiverse or config.leftBar
	local areventurescompatible = C.AreVenturesCompatible()
	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if not entry.spacing then
				entry.active = true
				if menu.showMultiverse then
					if entry.mode ~= "ventureseason" then
						entry.active = areventurescompatible
					end
				else
					if menu.mode == "selectCV" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "hire" then

						-- if entry.mode ~= "propertyowned" then
						-- kuertee start:
						if not string.find (entry.mode, "propertyowned") then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "orderparam_object" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					elseif menu.mode == "selectComponent" then

						-- if (entry.mode ~= "objectlist") and (entry.mode ~= "propertyowned") then
						-- kuertee start:
						if (not string.find (entry.mode, "objectlist")) and (not string.find (entry.mode, "propertyowned")) then
							-- kuertee end:

							entry.active = false
						end
					end
				end
				if entry.active then
					local selectedmode = false
					if type(entry.mode) == "table" then
						for _, mode in ipairs(entry.mode) do
							if menu.showMultiverse then
								if mode == menu.ventureMode then
									selectedmode = true
									break
								end
							else
								if mode == menu.infoTableMode then
									selectedmode = true
									break
								end
							end
						end
					else
						if menu.showMultiverse then
							if entry.mode == menu.ventureMode then
								selectedmode = true
							end
						else
							if entry.mode == menu.infoTableMode then
								selectedmode = true
							end
						end
					end
					if selectedmode then
						foundselection = true
					end
				end
			end
		end
	end

	for _, entry in ipairs(leftbar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
				local bgcolor = Color["row_title_background"]
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if menu.showMultiverse then
							if mode == menu.ventureMode then
								bgcolor = Color["row_background_selected"]
								break
							end
						else
							if mode == menu.infoTableMode then
								bgcolor = Color["row_background_selected"]
								break
							end
						end
					end
				else
					if menu.showMultiverse then
						if entry.mode == menu.ventureMode then
							bgcolor = Color["row_background_selected"]
						end
					else
						if entry.mode == menu.infoTableMode then
							bgcolor = Color["row_background_selected"]
						end
					end
				end
				local color = Color["icon_normal"]
				if menu.highlightLeftBar[mode] then
					color = Color["icon_mission"]
				end

				row[1]:createButton({ active = entry.active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color })
				row[1].handlers.onClick = function () return menu.buttonToggleObjectList(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.sideBar)
	menu.selectedRows.sideBar = nil
end

function menu.createRightBar(frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if menu.uix_callbacks ["createRightBar_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createRightBar_on_start"]) do
			uix_callback (config)
		end
	end
	-- kuertee end: callback

	local spacingHeight = menu.sideBarWidth / 4
	local ftable = frame:addTable(1, { tabOrder = 5, width = width, height = height, x = offsetx, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false, skipTabChange = true })
	ftable:addConnection(1, 4, true)

	for _, entry in ipairs(config.rightBar) do
		if (entry.condition == nil) or entry.condition() then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				local mode = entry.mode
				if type(entry.mode) == "table" then
					mode = mode[1]
				end
				local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
				local active = true
				if menu.mode == "selectCV" then
					active = false
				elseif menu.mode == "hire" then
					active = false
				elseif menu.mode == "selectComponent" then
					active = false
				end
				local bgcolor = Color["row_title_background"]
				if type(entry.mode) == "table" then
					for _, mode in ipairs(entry.mode) do
						if mode == menu.searchTableMode then
							bgcolor = Color["row_background_selected"]
							break
						end
					end
				else
					if entry.mode == menu.searchTableMode then
						bgcolor = Color["row_background_selected"]
					end
				end
				row[1]:createButton({ active = active, height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon)
				row[1].handlers.onClick = function () return menu.buttonToggleRightBar(mode) end
			end
		end
	end

	ftable:setSelectedRow(menu.selectedRows.rightBar)
	menu.selectedRows.rightBar = nil
end

function menu.createSelectedShips(frame)
	if (menu.getNumSelectedComponents() == 0) and (menu.mode ~= "behaviourinspection") then
		-- nothing to do
		frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
		return
	end

	-- sort ships
	local selectedobjects = {}
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsObjectKnown(selectedcomponent) then
			local class = ffi.string(C.GetComponentClass(selectedcomponent))
			local icon, primarypurpose, hullpercent, shieldpercent, isplayerowned, isenemy, ismodule, ishostile = GetComponentData(selectedcomponent, "icon", "primarypurpose", "hullpercent", "shieldpercent", "isplayerowned", "isenemy", "ismodule", "ishostile")
			if not ismodule then
				local color = "neutral"
				if isplayerowned then
					color = "player"
				elseif ishostile then
					color = "hostile"
				elseif isenemy then
					color = "enemy"
				end
				local i = menu.findEntryByShipIcon(selectedobjects, icon, color)
				if i then
					selectedobjects[i].count			= selectedobjects[i].count			+ 1
					selectedobjects[i].hullpercent		= selectedobjects[i].hullpercent	+ hullpercent
					selectedobjects[i].shieldpercent	= selectedobjects[i].shieldpercent	+ shieldpercent
				else
					table.insert(selectedobjects, { icon = icon, color = color, class = class, purpose = primarypurpose, count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent })
				end
			end
		end
	end
	table.sort(selectedobjects, menu.sortShipsByClassAndPurpose)

	local component = next(menu.selectedcomponents)
	if #selectedobjects == 0 then
		if menu.mode == "behaviourinspection" then
			component = menu.behaviourInspectionComponent
			local class = ffi.string(C.GetComponentClass(menu.behaviourInspectionComponent))
			local icon, primarypurpose, hullpercent, shieldpercent, isplayerowned, isenemy, ismodule, ishostile = GetComponentData(menu.behaviourInspectionComponent, "icon", "primarypurpose", "hullpercent", "shieldpercent", "isplayerowned", "isenemy", "ismodule", "ishostile")
			local color = "neutral"
			if isplayerowned then
				color = "player"
			elseif ishostile then
				color = "hostile"
			elseif isenemy then
				color = "enemy"
			end
			table.insert(selectedobjects, { icon = icon, color = color, class = class, purpose = primarypurpose, count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent })
		else
			-- nothing to do
			frame:addTable(1, { tabOrder = 0, width = 1, scaling = false, reserveScrollBar = false })
			return
		end
	end

	local ftable
	if (#selectedobjects > 1) or (selectedobjects[1].count > 1) then
		-- display
		local numcolumns = 2 * menu.selectedShipsTableData.maxCols
		local columnwidth = math.ceil(menu.selectedShipsTableData.width / 2)
		local width = numcolumns * (columnwidth + Helper.borderSize) - Helper.borderSize
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
		for i = 1, numcolumns do
			ftable:setColWidth(i, columnwidth)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultComplexCellProperties("icon", "text", { font = Helper.standardFontOutlined, fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local titlewidth = math.ceil(C.GetTextWidth(" " .. ReadText(1001, 3251) .. " ", Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true)))
		local numtitlecols = math.ceil(titlewidth / (columnwidth + Helper.borderSize))
		if numtitlecols % 2 == 1 then
			numtitlecols = numtitlecols + 1
		end
		if numtitlecols > numcolumns - 2 then
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, bgColor = Color["row_background_blue_opaque"], scaling = true })
			row[1]:setColSpan(numcolumns):createText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, halign = "center" })
		else
			local numbordercols = (numcolumns - numtitlecols) / 2
			local bordericonsize = Helper.scaleX(Helper.headerRow1Height)

			local row = ftable:addRow(false, { fixed = true, borderBelow = false, scaling = true })
			row[1]:setBackgroundColSpan(numcolumns):setColSpan(numbordercols):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = numbordercols * (columnwidth + Helper.borderSize) - bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
			local width = numtitlecols * (columnwidth + Helper.borderSize)
			row[numbordercols + 1]:setColSpan(numtitlecols):createIcon("solid", { height = bordericonsize, width = width, scaling = false, color = Color["row_background_blue_opaque"] }):setText(ReadText(1001, 3251), { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = width / 2 })
			row[numbordercols + numtitlecols + 1]:setColSpan(numbordercols):createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
		end

		if menu.mode == "behaviourinspection" then
			local row = ftable:addRow(false, { fixed = true, borderBelow = false, scaling = true })
			row[1]:setColSpan(numcolumns):createText(ReadText(1001, 11661), { halign = "center", wordwrap = true, color = Color["behaviour_inspection_text"] })
		end

		-- example text used
		local textheight = math.ceil(C.GetTextHeight(ReadText(1001, 42) .. "1", Helper.standardFontOutlined, menu.selectedShipsTableData.fontsize, 0))
		-- ship rows
		for i = 1, math.floor(#selectedobjects / menu.selectedShipsTableData.maxCols) + 1 do
			local numshipcolums = math.min(#selectedobjects - (i -1) * menu.selectedShipsTableData.maxCols, menu.selectedShipsTableData.maxCols)
			local row = ftable:addRow(false, { fixed = true, borderBelow = false })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				local color = menu.holomapcolor.friendcolor
				if shipentry.color == "player" then
					color = menu.holomapcolor.playercolor
				elseif shipentry.color == "hostile" then
					color = menu.holomapcolor.hostilecolor
				elseif shipentry.color == "enemy" then
					color = menu.holomapcolor.enemycolor
				end
				row[colindex]:setColSpan(2):createIcon(C.IsIconValid(shipentry.icon) and shipentry.icon or "solid", { height = menu.selectedShipsTableData.height, width = menu.selectedShipsTableData.height + Helper.borderSize, color = color }):setText(ReadText(1001, 42) .. shipentry.count, { halign = "right", x = Helper.standardTextOffsetx, y = (menu.selectedShipsTableData.height - textheight) / 2 })
			end
			local row = ftable:addRow(false, { fixed = true, borderBelow = false })
			for j = 1, numshipcolums do
				local shipindex = (i - 1) * menu.selectedShipsTableData.maxCols + j
				local shipentry = selectedobjects[shipindex]
				local colindex = (j + 0.5 * (menu.selectedShipsTableData.maxCols - numshipcolums)) * 2 - 1
				row[colindex]:setColSpan(2):createShieldHullBar(shipentry.shieldpercent / shipentry.count, shipentry.hullpercent / shipentry.count, { height = 10, y = 5 })
			end
		end
	else
		local selectedcomponent = ConvertStringTo64Bit(component)
		local isplayerowned, isonlineobject, isenemy, ishostile = GetComponentData(selectedcomponent, "isplayerowned", "isonlineobject", "isenemy", "ishostile")
		local objecttitle = ffi.string(C.GetComponentName(selectedcomponent))
		if C.IsComponentClass(selectedcomponent, "container") then
			objecttitle = objecttitle .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")"
		end
		local objecttitlewidth = math.ceil(C.GetTextWidth(objecttitle, Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true))) + 2 * Helper.standardTextOffsetx
		local objecticon = GetComponentData(selectedcomponent, "icon")
		if C.IsComponentClass(selectedcomponent, "highway") then
			local entrygate = GetComponentData(selectedcomponent, "entrygate")
			objecticon = GetComponentData(entrygate, "icon")
		end
		local bordericonsize = Helper.scaleX(Helper.headerRow1Height)
		local colwidth = math.ceil(objecttitlewidth / 2)
		local bordercolwidth

		local numcolumns = 7
		local width = math.max(menu.selectedShipsTableData.singleObjectWidth, 2 * colwidth + 2 * menu.selectedShipsTableData.width + 2 * bordericonsize + (numcolumns - 1) * Helper.borderSize)
		if width > Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize) then
			if width > menu.selectedShipsTableData.singleObjectWidth then
				bordercolwidth = bordericonsize
				colwidth = nil
			end
			width = Helper.viewWidth - 2 * (menu.infoTableOffsetX + menu.infoTableWidth + 2 * Helper.borderSize)
		end
		ftable = frame:addTable(numcolumns, { tabOrder = 21, width = width, x = Helper.viewWidth / 2 - width / 2, y = 0, scaling = false, reserveScrollBar = false, skipTabChange = true, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })
		ftable:setColWidth(2, menu.selectedShipsTableData.width)
		ftable:setColWidth(4, 1)
		ftable:setColWidth(6, menu.selectedShipsTableData.width)
		if colwidth then
			ftable:setColWidth(3, colwidth)
			ftable:setColWidth(5, colwidth)
		end
		if bordercolwidth then
			ftable:setColWidth(1, bordercolwidth)
			ftable:setColWidth(7, bordercolwidth)
		else
			ftable:setColWidthMin(1, bordericonsize)
			ftable:setColWidthMin(7, bordericonsize)
		end
		ftable:setDefaultBackgroundColSpan(1, numcolumns)
		ftable:setDefaultCellProperties("text", { fontsize = menu.selectedShipsTableData.fontsize; minRowHeight = menu.selectedShipsTableData.textHeight })
		ftable:setDefaultComplexCellProperties("icon", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("icon", "text2", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text", { fontsize = menu.selectedShipsTableData.fontsize })
		ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = menu.selectedShipsTableData.fontsize })

		-- title
		local row = ftable:addRow(false, { fixed = true, borderBelow = false, scaling = true })

		local color = Color["row_background_blue_opaque"]
		local text = ReadText(1001, 11636)
		if selectedcomponent == menu.behaviourInspectionComponent then
			color = Color["behaviour_inspection"]
			text = "\27[menu_behaviourinspection] " .. ReadText(1001, 11660)
		end
		row[1]:setBackgroundColSpan(numcolumns):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = row[1]:getWidth() + Helper.borderSize - bordericonsize, scaling = false, color = color })
		row[2]:setColSpan(5)
		local middlewidth = row[2]:getColSpanWidth() + Helper.borderSize
		row[2]:createIcon("solid", { height = bordericonsize, width = middlewidth, scaling = false, color = color }):setText(text, { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = middlewidth / 2 })
		row[7]:createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = color })

		local row = ftable:addRow(nil, { fixed = true, borderBelow = false, scaling = true })
		local color = isplayerowned and menu.holomapcolor.playercolor or menu.holomapcolor.friendcolor
		if isplayerowned then
			color = menu.holomapcolor.playercolor
			if selectedcomponent == C.GetPlayerObjectID() then
				color = menu.holomapcolor.currentplayershipcolor
			end
		elseif isonlineobject and menu.getFilterOption("layer_other", false) and menu.getFilterOption("think_diplomacy_highlightvisitor", false) then
			color = menu.holomapcolor.visitorcolor
		elseif ishostile then
			color = menu.holomapcolor.hostilecolor
		elseif isenemy then
			color = menu.holomapcolor.enemycolor
		end
		row[2]:createText("\27[" .. objecticon .. "]", { color = color, halign = "right", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = 0 })
		row[3]:setColSpan(3):createText(objecttitle, { color = color, halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, minRowHeight = Helper.headerRow1Height })
		row[6]:createObjectShieldHullBar(selectedcomponent)

		local isship = C.IsComponentClass(selectedcomponent, "ship")
		if (isship and isplayerowned) or C.IsComponentClass(selectedcomponent, "collectablewares") then
			local row = ftable:addRow(nil, { fixed = true, borderBelow = false })
			row[1]:setColSpan(3):createText(ReadText(1001, 16), { halign = "center" })
			row[4]:createText("", { x = 0 })
			row[5]:setColSpan(3):createText(ReadText(1001, 8355), { halign = "center" })
			-- line
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_separator_white"] })
			row[1]:setColSpan(3):createText("", { height = 2 })
			row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
			row[5]:setColSpan(3):createText("", { height = 2 })

			local sideorder = { "left", "right" }
			local rows = {
				left = {},
				right = {},
			}
			if isship then
				-- order
				local _, _, _, name, _, _, _, targetname = menu.getOrderInfo(selectedcomponent, true)
				table.insert(rows.left, { entrytype = "text", text = name .. ((targetname ~= "") and (ReadText(1001, 120) .. " " .. targetname) or ""), properties = { halign = "center", color = menu.holomapcolor.playercolor } })
				-- failed orders
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				hasloop = hasloop[0]
				local n = C.GetNumOrderFailures(selectedcomponent, hasloop == true)
				if n > 0 then
					table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Color["text_warning"] } })

					local buf = ffi.new("OrderFailure[?]", n)
					n = C.GetOrderFailures(buf, n, selectedcomponent, hasloop == true)
					local failure = buf[0]

					local orderdefid = ffi.string(failure.orderdef)
					local orderfailuredef
					local found = false
					for _, orderdef in ipairs(menu.orderdefs) do
						if orderdef.id == orderdefid then
							orderfailuredef = orderdef
							found = true
							break
						end
					end
					if not found then
						DebugError("Order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
					end

					table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Color["text_warning"] } })
					table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Color["text_warning"] } })
					if n > 2 then
						table.insert(rows.left, { entrytype = "text", text = string.format(ReadText(1001, 11631), n - 1), properties = { halign = "center", color = Color["text_warning"] } })
					elseif n > 1 then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11630), properties = { halign = "center", color = Color["text_warning"] } })
					end
				else
					local failure = ffi.new("OrderFailure")
					if C.GetDefaultOrderFailure(failure, selectedcomponent) then
						table.insert(rows.left, { entrytype = "text", text = ReadText(1001, 11621) .. ReadText(1001, 120), properties = { halign = "center", color = Color["text_warning"] } })

						local orderdefid = ffi.string(failure.orderdef)
						local orderfailuredef
						local found = false
						for _, orderdef in ipairs(menu.orderdefs) do
							if orderdef.id == orderdefid then
								orderfailuredef = orderdef
								found = true
								break
							end
						end
						if not found then
							DebugError("Default order failure of '" .. tostring(selectedcomponent) .. "' is of unknown definition '" .. orderdefid .. "' [Florian]")
						end

						table.insert(rows.left, { entrytype = "text", text = orderfailuredef and orderfailuredef.name or "", properties = { halign = "center", color = Color["text_warning"] } })
						table.insert(rows.left, { entrytype = "text", text = ffi.string(failure.message), properties = { halign = "center", color = Color["text_warning"] } })
					end
				end
			end

			if isship then
				-- capacity
				local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
				local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)
				local futuretransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
				numtransporttypes = C.GetCargoTransportTypes(futuretransporttypes, numtransporttypes, selectedcomponent, true, true)
				for i = 0, numtransporttypes - 1 do
					table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. ffi.string(futuretransporttypes[i].name) .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futuretransporttypes[i].spaceused, capacity = futuretransporttypes[i].capacity })
				end
			end
			-- cargo
			local wares = {}
			if isship then
				local cargo = GetComponentData(selectedcomponent, "cargo")
				local futurecargo = isship and GetCargoAfterTradeOrders(selectedcomponent, true) or {}
				for ware, amount in pairs(cargo) do
					table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futurecargo[ware] or 0 })
				end
				for ware, amount in pairs(futurecargo) do
					if not cargo[ware] then
						table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = 0, future = amount })
					end
				end
			else
				local collectable = GetCollectableData(component)
				for _, ware in ipairs(collectable.wares) do
					table.insert(wares, { ware = ware.ware, name = GetWareData(ware.ware, "name"), current = ware.amount, future = ware.amount })
				end
			end
			table.sort(wares, function (a, b) return a.future > b.future end)
			local setting, list = menu.getTradeWareFilter(true)
			for i, entry in ipairs(wares) do
				local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
				table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = isship and GetWareCapacity(selectedcomponent, entry.ware) or 0, color = color, script = script })
			end
			-- display rows
			for i = 1, 5 do
				local row
				for _, side in ipairs(sideorder) do
					if rows[side][i] then
						local entry = rows[side][i]
						if not row then
							row = ftable:addRow(true, { fixed = true })
						end
						if entry.entrytype == "text" then
							row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
							if (side == "right") or (not rows["right"][i]) then
								row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
							end
						elseif entry.entrytype == "capacity" then
							if side == "right" then
								row[5]:setColSpan(3)

								local mouseovertext
								local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
								local text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[5]:getWidth() - menu.getAmountTextWidth(amounttext))
								if text ~= entry.text then
									mouseovertext = entry.text .. " " .. amounttext
								end

								local xoffset = 1 + Helper.borderSize
								local width = row[5]:getColSpanWidth()
								row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
								row[5]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
								row[5]:setText(text)
								row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
							end
						elseif entry.entrytype == "ware" then
							if side == "right" then
								row[5]:setColSpan(3)
								local xoffset = 1 + Helper.borderSize
								local width = row[5]:getColSpanWidth()
								row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
								row[5]:createButton({ bgColor = Color["button_background_hidden"], highlightColor = (menu.mode == "behaviourinspection") and Color["button_highlight_hidden"] or nil, height = menu.selectedShipsTableData.textHeight })
								row[5]:setText(entry.text, { color = entry.color })
								row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
								if menu.mode ~= "behaviourinspection" then
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
			end
			if #rows.right > 5 then
				local row = ftable:addRow(nil, { fixed = true })
				row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
				row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
			end
		elseif C.IsComponentClass(selectedcomponent, "station") then
			local row = ftable:addRow(nil, { fixed = true, borderBelow = false })
			row[1]:setColSpan(3):createText(ReadText(1001, 3305), { halign = "center" })
			row[4]:createText("", { x = 0 })
			row[5]:setColSpan(3):createText(ReadText(1001, 63), { halign = "center" })
			-- line
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_separator_white"] })
			row[1]:setColSpan(3):createText("", { height = 2 })
			row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
			row[5]:setColSpan(3):createText("", { height = 2 })

			local sideorder = { "left", "right" }
			local rows = {
				left = {},
				right = {},
			}
			-- upkeep missions
			local upkeepMissions = {}
			if menu.upkeepMissionData[tostring(selectedcomponent)] then
				for _, entry in ipairs(menu.upkeepMissionData[tostring(selectedcomponent)]) do
					table.insert(upkeepMissions, { alertLevel = entry.alertLevel, name = entry.name })
				end
			end
			table.sort(upkeepMissions, function (a, b) return a.alertLevel > b.alertLevel end)

			for i, entry in ipairs(upkeepMissions) do
				local color = Color["text_normal"]
				if entry.alertLevel == 1 then
					color = menu.holomapcolor.lowalertcolor
				elseif entry.alertLevel == 2 then
					color = menu.holomapcolor.mediumalertcolor
				else
					color = menu.holomapcolor.highalertcolor
				end
				table.insert(rows.left, { entrytype = "text", text = entry.name, properties = { halign = "center", color = color } })
			end

			-- ware reservations
			local reservationscapacity = menu.getReservationsVolumeByTransportType(selectedcomponent)
			local reservationscargo = menu.getReservationsAmountByWareType(selectedcomponent)

			-- capacity
			local numtransporttypes = C.GetNumCargoTransportTypes(selectedcomponent, true)
			local currenttransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
			numtransporttypes = C.GetCargoTransportTypes(currenttransporttypes, numtransporttypes, selectedcomponent, true, false)

			for i = 0, numtransporttypes - 1 do
				local storagename = ffi.string(currenttransporttypes[i].name)
				local futureamount = currenttransporttypes[i].spaceused
				if reservationscapacity[string.lower(storagename)] then
					futureamount = futureamount + reservationscapacity[string.lower(storagename)]
				end

				table.insert(rows.right, { entrytype = "capacity", text = ReadText(1001, 1402) .. " (" .. storagename .. ")" .. ReadText(1001, 120), currentused = currenttransporttypes[i].spaceused, futureused = futureamount, capacity = currenttransporttypes[i].capacity })
			end
			-- cargo
			local cargo = GetComponentData(selectedcomponent, "cargo")
			local wares = {}
			for ware, amount in pairs(cargo) do
				local futureamount = amount
				if reservationscargo[ware] then
					futureamount = futureamount + reservationscargo[ware]
				end

				table.insert(wares, { ware = ware, name = GetWareData(ware, "name"), current = amount, future = futureamount })
			end
			table.sort(wares, function (a, b) return a.future > b.future end)
			local setting, list = menu.getTradeWareFilter(true)
			for i, entry in ipairs(wares) do
				local color, script = menu.getWareButtonColorAndScript(list, setting, entry.ware)
				local productionlimit = GetWareProductionLimit(selectedcomponent, entry.ware)
				table.insert(rows.right, { entrytype = "ware", text = entry.name, current = entry.current, future = entry.future, max = math.max(entry.current, productionlimit), color = color, script = script })
			end
			-- display rows
			for i = 1, 5 do
				local row
				for _, side in ipairs(sideorder) do
					if rows[side][i] then
						local entry = rows[side][i]
						if not row then
							row = ftable:addRow(true, { fixed = true })
						end
						if entry.entrytype == "text" then
							row[(side == "left") and 1 or 5]:setColSpan(3):createText(entry.text, entry.properties)
							if (side == "right") or (not rows["right"][i]) then
								row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
							end
						elseif entry.entrytype == "capacity" then
							if side == "right" then
								row[5]:setColSpan(3)

								local mouseovertext
								local amounttext = menu.formatWareAmount(entry.currentused, entry.futureused, entry.capacity)
								local widthdelta = row[5]:getWidth() - menu.getAmountTextWidth(amounttext)
								local text = ""
								if widthdelta > 0 then
									text = TruncateText(entry.text, Helper.standardFont, menu.selectedShipsTableData.fontsize, widthdelta)
								end
								if text ~= entry.text then
									mouseovertext = entry.text .. " " .. amounttext
								end

								local xoffset = 1 + Helper.borderSize
								local width = row[5]:getColSpanWidth()
								row[4]:createStatusBar({ current = entry.futureused, start = entry.currentused, max = entry.capacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = xoffset, scaling = false })
								row[5]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext })
								row[5]:setText(text)
								row[5]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx })
							end
						elseif entry.entrytype == "ware" then
							if side == "right" then
								row[5]:setColSpan(3)
								local barxoffset = 1 + Helper.borderSize
								local width = row[5]:getColSpanWidth()
								row[4]:createStatusBar({ current = entry.future, start = entry.current, max = entry.max, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
								row[5]:createButton({ bgColor = Color["button_background_hidden"], highlightColor = (menu.mode == "behaviourinspection") and Color["button_highlight_hidden"] or nil, height = menu.selectedShipsTableData.textHeight })
								row[5]:setText(entry.text, { color = entry.color, x = Helper.standardIndentStep })
								row[5]:setText2(menu.formatWareAmount(entry.current, entry.future), { halign = "right", color = entry.color })
								if menu.mode ~= "behaviourinspection" then
									row[5].handlers.onClick = entry.script
								end
							end
						end
					end
				end
			end
			if (#rows.left > 5) or (#rows.right > 5) then
				local row = ftable:addRow(nil, { fixed = true })
				row[4]:createText("", { height = 2, cellBGColor = Color["row_background"], x = 0 })
				if #rows.left > 5 then
					row[1]:setColSpan(3):createText(string.format("%+d %s", #rows.left - 5, ((#rows.left - 5) > 1) and ReadText(1001, 5702) or ReadText(1001, 5702)))
				end
				if #rows.right > 5 then
					row[5]:setColSpan(3):createText(string.format("%+d %s", #rows.right - 5, ((#rows.right - 5) > 1) and ReadText(1001, 46) or ReadText(1001, 45)))
				end
			end
		end
	end

	ftable.properties.y = Helper.viewHeight - ftable:getFullHeight() - menu.borderOffset
end

function menu.sortShipsByClassAndPurpose(a, b)
	local aclass = config.classOrder[a.class] or 0
	local bclass = config.classOrder[b.class] or 0
	if aclass == bclass then
		local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
		local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
		return apurpose < bpurpose
	else
		return aclass < bclass
	end
end

function menu.sortShipsByClassAndPurposeReverse(a, b)
	local apurpose = (a.purpose ~= "") and config.purposeOrder[a.purpose] or 0
	local bpurpose = (b.purpose ~= "") and config.purposeOrder[b.purpose] or 0
	if apurpose == bpurpose then
		local aclass = config.classOrder[a.class] or 0
		local bclass = config.classOrder[b.class] or 0
		return aclass < bclass
	else
		return apurpose > bpurpose
	end
end

function menu.findEntryByShipIcon(array, icon, color)
	for i, entry in ipairs(array) do
		if (entry.icon == icon) and (entry.color == color) then
			return i
		end
	end
end

function menu.createTopLevel(frame)
	if (menu.mode == "hire") or (menu.mode == "selectCV") or (menu.mode == "orderparam_object") or (menu.mode == "selectComponent") then
		local width = 400
		local ftable = frame:addTable(1, {
			tabOrder = 20,
			width = width,
			x = Helper.viewWidth / 2 - width / 2,
			y = Helper.topLevelConfig.y,
			scaling = false,
			reserveScrollBar = false,
			skipTabChange = true,
			backgroundID = "solid",
			backgroundColor = Color["frame_background_semitransparent"],
		})
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })

		local title = ""
		if menu.mode == "hire" then
			title = (menu.modeparam[3] ~= 0) and ReadText(1001, 3500) or ReadText(1001, 3264)
		elseif menu.mode == "selectCV" then
			title = ReadText(1001, 7942)
		elseif menu.mode == "orderparam_object" then
			local sectorallowed, onlysectorallowed = false, false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							onlysectorallowed = #menu.modeparam[2].inputparams.class == 1
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end

			if onlysectorallowed then
				title = ReadText(1001, 11238)
			elseif sectorallowed then
				title = ReadText(1001, 11239)
			else
				title = ReadText(1001, 8325)
			end
		elseif menu.mode == "selectComponent" then
			title = menu.modeparam[5] or ReadText(1001, 8325)
		end

		row[1]:createText(title, Helper.titleTextProperties)
		row[1].properties.scaling = true

		local infotext
		if menu.mode == "hire" then
			infotext = function() return menu.selectModeInfoText(ReadText(1001, 11613)) end
		elseif menu.mode == "orderparam_object" then
			local sectorallowed = false
			if menu.modeparam[2].inputparams.class then
				if type(menu.modeparam[2].inputparams.class) == "table" then
					for _, class in ipairs(menu.modeparam[2].inputparams.class) do
						if class == "sector" then
							sectorallowed = true
							break
						end
					end
				else
					DebugError("Order parameter '" .. menu.modeparam[2].name .. "' - input parameter class is not a list. [Florian]")
				end
			end
			infotext = function() return menu.selectModeInfoText(sectorallowed and ReadText(1001, 11635) or ReadText(1001, 11634)) end
		end

		if infotext then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText(infotext, { wordwrap = true, scaling = true })
		end
	else
		local overridetext = ""
		if menu.mode == "tradecontext" then
			overridetext = ReadText(1001, 7104)
		elseif menu.mode == "behaviourinspection" then
			overridetext = ReadText(1001, 3245) .. "\n" .. ColorText["behaviour_inspection_text"] .. "(\27[menu_behaviourinspection] " .. ReadText(1001, 11144) .. ")"
		end
		menu.topLevelHeight = Helper.createTopLevelTab(menu, menu.showMultiverse and "multiversemap" or "map", frame, overridetext, menu.conversationMenu, true)
	end
end

function menu.selectModeInfoText(text)
	local mode = GetControllerInfo()
	if (mode == "gamepad") or (mode == "joystick") then
		return string.format(text, Helper.getInputMouseOverText("INPUT_STATE_CONTROLLERMOUSEBUTTON_RIGHT"))
	else
		return string.format(text, ReadText(1019, 3))
	end
end

function menu.onTabScroll(direction)
	menu.closeContextMenu()
	if direction == "right" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, menu.showMultiverse and "multiversemap" or "map", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.refreshMainFrame = true
	else
		menu.inputModeHasChanged = true
	end
end

function menu.createNewOrderContext(frame, instance)
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local aipilot = GetComponentData(menu.infoSubmenuObject, "assignedaipilot")
	local adjustedskill = aipilot and math.floor(C.GetEntityCombinedSkill(ConvertIDTo64Bit(aipilot), nil, "aipilot")) or -1

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(menu.contextMenuData.default and ReadText(1001, 8321) or ReadText(1001, 3238), Helper.headerRowCenteredProperties)

	for category, orderdefs in Helper.orderedPairs(menu.orderdefsbycategory) do
		if category ~= "internal" then
			if (not menu.contextMenuData.default) or (category ~= "coordination") then
				local header = false
				for _, orderdef in ipairs(orderdefs) do
					if (menu.contextMenuData.default and orderdef.infinite) or ((not menu.contextMenuData.default) and ((not menu.infoTableData[instance].hasloop) or orderdef.loopable)) then
						if not header then
							local row = ftable:addRow(false, {  })
							row[1]:createText(orderdef.categoryname, Helper.headerRowCenteredProperties)
							header = true
						end

						local row = ftable:addRow(true, {  })
						local button = row[1]:createButton({ active = C.IsOrderSelectableFor(orderdef.id, menu.infoSubmenuObject), helpOverlayID = "map_order_" .. orderdef.id, helpOverlayText = " ", helpOverlayHighlightOnly = true, bgColor = Color["button_background_hidden"], mouseOverText = orderdef.description }):setText(orderdef.name)
						if menu.contextMenuData.default then
							local printedSkillReq = math.floor(orderdef.requiredSkill * 15 / 100)
							button.properties.active = button.properties.active and (orderdef.requiredSkill <= adjustedskill)
							button:setText2(Helper.displaySkill(printedSkillReq), { halign = "right", color = Color["text_skills"] })
						end
						row[1].handlers.onClick = function () return menu.buttonNewOrder(orderdef.id, menu.contextMenuData.default, instance) end
						row[1].properties.uiTriggerID = orderdef.id
					end
				end
			end
		end
	end

	if menu.contextMenuData.default then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 11266), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(true, {  })
		local button = row[1]:createButton({ bgColor = Color["button_background_hidden"], mouseOverText = ReadText(1026, 3269) }):setText(ReadText(1001, 11267))
		if menu.contextMenuData.default then
			button.properties.active = button.properties.active and (math.floor(menu.orderloopskill * 100 / 15) <= adjustedskill)
			button:setText2(Helper.displaySkill(menu.orderloopskill), { halign = "right", color = Color["text_skills"] })
		end
		row[1].handlers.onClick = function () return menu.buttonNewOrder("loop", menu.contextMenuData.default, instance) end
		row[1].properties.uiTriggerID = "looporders"
	end
end

function menu.createOrderparamWareContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	menu.contextMenuData.wares = {}

	if param.inputparams.mining then
		local sector = ConvertIDTo64Bit(param.inputparams.mining[1])
		local pos = param.inputparams.mining[2]
		local nummineables = C.GetNumMineablesAtSectorPos(sector, pos)
		local mineables = ffi.new("YieldInfo[?]", nummineables)
		nummineables = C.GetMineablesAtSectorPos(mineables, nummineables, sector, pos)
		for i = 0, nummineables - 1 do
			table.insert(menu.contextMenuData.wares, ffi.string(mineables[i].wareid))
		end
	elseif param.inputparams.cargoof then
		local buf = GetComponentData(param.inputparams.cargoof, "cargo")
		for ware in pairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.soldby then
		local buf = GetComponentData(param.inputparams.soldby, "products")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	elseif param.inputparams.boughtby then
		local buf = GetComponentData(param.inputparams.boughtby, "allresources")
		for _, ware in ipairs(buf) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	else
		for name, ware in pairs(menu.economyWares) do
			table.insert(menu.contextMenuData.wares, ware)
		end
	end
	if param.inputparams.cancarry then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareCapacity(param.inputparams.cancarry, ware, true) == 0 then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end
	if param.inputparams.isminable then
		for i = #menu.contextMenuData.wares, 1, -1 do
			local ware = menu.contextMenuData.wares[i]
			if GetWareData(ware, "isminable") ~= (param.inputparams.isminable == 1) then
				table.remove(menu.contextMenuData.wares, i)
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedWares = {}
		menu.contextMenuData.origSelectedWares = {}
		if param.value then
			for _, ware in ipairs(param.value) do
				menu.contextMenuData.selectedWares[ware] = true
				menu.contextMenuData.origSelectedWares[ware] = true
			end
		end
	end

	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- do this first so we still have a table row for the buttons before the list can use them all up
	local buttontable
	if param.type == "list" then
		if #menu.contextMenuData.wares > 0 then
			buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedWares) ~= nil)) and menu.isWareSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedWares, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end
		end
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
				row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
			end

			local waresheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 8306), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.wares > 0 then
			for _, ware in ipairs(menu.contextMenuData.wares) do
				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"], height = config.mapRowHeight }):setText(GetWareData(ware, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, ware, instance) end
			end
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isWareSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedWares) do
		if not menu.contextMenuData.origSelectedWares[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedWares) do
		if not menu.contextMenuData.selectedWares[ware] then
			return true
		end
	end
	return false
end

function menu.createOrderparamSectorContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.sectors = {}

	if param.inputparams.hasresources then
		local neededresources = {}
		for _, ware in ipairs(param.inputparams.hasresources) do
			neededresources[ware] = true
		end

		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				local sector64 = ConvertIDTo64Bit(sector)
				local resources = {}
				local n = C.GetNumDiscoveredSectorResources(sector64)
				local buf = ffi.new("WareYield[?]", n)
				n = C.GetDiscoveredSectorResources(buf, n, sector64)
				for i = 0, n - 1 do
					if neededresources[ffi.string(buf[i].ware)] then
						table.insert(menu.contextMenuData.sectors, sector64)
						break
					end
				end
			end
		end
	else
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.sectors, ConvertIDTo64Bit(sector))
			end
		end
	end

	if (param.type == "list") then
		menu.contextMenuData.selectedSectors = {}
		menu.contextMenuData.origSelectedSectors = {}
		if param.value then
			for _, sector in ipairs(param.value) do
				menu.contextMenuData.selectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
				menu.contextMenuData.origSelectedSectors[tostring(ConvertIDTo64Bit(sector))] = true
			end
		end
	end

	table.sort(menu.contextMenuData.sectors, Helper.sortComponentName)

	if param.type == "list" then
		-- title
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedSectors) do count = count + 1 end; return #menu.contextMenuData.sectors == count end, { height = config.mapRowHeight })
		row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleSectorList(checked) end
		row[2]:setColSpan(2):createText(ReadText(1001, 9177), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedSectors[tostring(sector)] or false end, { height = config.mapRowHeight })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxSetSectorList(sector, checked) end
				row[2]:setColSpan(2):createText(GetComponentData(sector, "name"))
			end

			local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

			local row = buttontable:addRow(true, { fixed = true })
			row[1]:createButton({ active = function () return ((not param.required) or (next(menu.contextMenuData.selectedSectors) ~= nil)) and menu.isSectorSelectionChanged() end }):setText(ReadText(1001, 14), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, menu.contextMenuData.selectedSectors, instance) end
			row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
			row[2].handlers.onClick = function () return menu.onCloseElement("back") end

			local sectorsheight = ftable:getFullHeight()
			local buttonheight = buttontable:getFullHeight()
			if frame.properties.y + ftable.properties.y + sectorsheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
				buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
				ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
			else
				buttontable.properties.y = ftable.properties.y + sectorsheight + Helper.borderSize
			end

			ftable:addConnection(1, 3, true)
			buttontable:addConnection(2, 3)
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	else
		-- title
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 11238), Helper.headerRowCenteredProperties)

		if #menu.contextMenuData.sectors > 0 then
			for _, sector in ipairs(menu.contextMenuData.sectors) do
				local row = ftable:addRow(true, {  })
				row[1]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"], height = config.mapRowHeight }):setText(GetComponentData(sector, "name"))
				row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, sector, instance) end
			end
		else
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
		end
	end
end

function menu.isSectorSelectionChanged()
	for sector in pairs(menu.contextMenuData.selectedSectors) do
		if not menu.contextMenuData.origSelectedSectors[sector] then
			return true
		end
	end
	for sector in pairs(menu.contextMenuData.origSelectedSectors) do
		if not menu.contextMenuData.selectedSectors[sector] then
			return true
		end
	end
	return false
end

function menu.createFilterparamWareContext(frame)
	local buttontable = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.isWareSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
	row[1].handlers.onClick = function () return menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares) end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end

	local ftable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, config.mapRowHeight)
	ftable:setColWidthPercent(3, 50)

	menu.contextMenuData.wares = menu.contextMenuData.setting.listOptions()
	menu.contextMenuData.selectedWares = {}
	menu.contextMenuData.origSelectedWares = {}
	local list = menu.getFilterOption(menu.contextMenuData.setting.id, menu.contextMenuData.setting.savegame) or {}
	for _, ware in ipairs(list) do
		menu.contextMenuData.selectedWares[ware] = true
		menu.contextMenuData.origSelectedWares[ware] = true
	end
	table.sort(menu.contextMenuData.wares, Helper.sortWareName)

	-- title
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedWares) do count = count + 1 end; return #menu.contextMenuData.wares == count end, { height = config.mapRowHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleWareList(checked) end
	row[2]:setColSpan(2):createText(ReadText(1001, 8376), Helper.headerRowCenteredProperties)

	if #menu.contextMenuData.wares > 0 then
		for _, ware in ipairs(menu.contextMenuData.wares) do
			local row = ftable:addRow(true, {  })
			row[1]:createCheckBox(function () return menu.contextMenuData.selectedWares[ware] or false end, { height = config.mapRowHeight })
			row[1].handlers.onClick = function (_, checked) return menu.checkboxSetWareList(ware, checked) end
			row[2]:setColSpan(2):createText(GetWareData(ware, "name"))
		end
	else
		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
	end

	local waresheight = ftable:getFullHeight()
	local buttonheight = buttontable:getFullHeight()
	if frame.properties.y + ftable.properties.y + waresheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
		buttontable.properties.y = Helper.viewHeight - frame.properties.y - Helper.frameBorder - buttonheight
		ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
	else
		buttontable.properties.y = ftable.properties.y + waresheight + Helper.borderSize
	end

	ftable:addConnection(1, 3, true)
	buttontable:addConnection(2, 3)
end

function menu.createOrderparamFormationShapeContext(frame, instance)
	local param
	if menu.contextMenuData.order == "default" then
		param = menu.infoTableData[instance].defaultorder.params[menu.contextMenuData.param]
	elseif menu.contextMenuData.order == "planneddefault" then
		param = menu.infoTableData[instance].planneddefaultorder.params[menu.contextMenuData.param]
	else
		param = menu.infoTableData[instance].orders[menu.contextMenuData.order].params[menu.contextMenuData.param]
	end

	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(ReadText(1001, 8307), Helper.headerRowCenteredProperties)

	menu.contextMenuData.formationshapes = {}
	local n = C.GetNumFormationShapes()
	local buf = ffi.new("UIFormationInfo[?]", n)
	n = C.GetFormationShapes(buf, n)
	for i = 0, n - 1 do
		table.insert(menu.contextMenuData.formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape) })
	end

	table.sort(menu.contextMenuData.formationshapes, Helper.sortName)

	for _, formation in ipairs(menu.contextMenuData.formationshapes) do
		local row = ftable:addRow(true, {  })
		row[1]:createButton({ bgColor = Color["button_background_hidden"] }):setText(formation.name)
		row[1].handlers.onClick = function () return menu.buttonSetOrderParam(menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, formation.shape, instance) end
	end
end

function menu.defaultInteraction(component, posrot, posrotvalid, offsetx, offsety)
	local occupiedship = C.GetPlayerOccupiedShipID()
	if C.IsComponentClass(component, "sector") then
		local playerprecise = (#menu.selectedcomponents == 1)
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderMoveWait(selectedcomponent, component, posrot, playerprecise, false)
				end
			end
		end
	elseif GetComponentData(ConvertStringToLuaID(tostring(component)), "isenemy") then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			if (selectedcomponent ~= occupiedship) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
				if GetComponentData(selectedcomponent, "isplayerowned") then
					menu.orderAttack(selectedcomponent, component, false)
				end
			end
		end
	elseif C.IsComponentClass(component, "station") then
		local issingleloopship
		if menu.getNumSelectedComponents() == 1 then
			local component = next(menu.selectedcomponents)
			local selectedcomponent = ConvertStringTo64Bit(component)
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
			issingleloopship = hasloop[0]
		end

		if not issingleloopship then
			menu.contextMenuMode = "trade"
			menu.contextMenuData = { component = ConvertStringTo64Bit(tostring(component)), orders = {} }

			local numwarerows, numinforows = menu.initTradeContextData()
			menu.updateTradeContextDimensions(numwarerows, numinforows)

			local width = menu.tradeContext.width
			local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

			if offsetx + width > Helper.viewWidth - Helper.frameBorder then
				offsetx = Helper.viewWidth - width - Helper.frameBorder
			end
			if offsety + height > Helper.viewHeight - Helper.frameBorder then
				offsety = Helper.viewHeight - height - Helper.frameBorder
			end
			menu.createContextFrame(width, height, offsetx, offsety)
		end
	end
	if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced")) then
		menu.refreshInfoFrame()
	elseif (menu.infoTableMode == "mission") then
		menu.refreshIF = getElapsedTime()
	end
	if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced")) then
		menu.refreshInfoFrame2()
	end
end

function menu.getTransportTagsFromString(s)
	local types = {}
	for w in string.gmatch(s, "%S+") do		-- non-space
		types[w] = true
	end
	return types
end

function menu.getCargoTransportTypes(container, aftertradeorders)
	local transporttypes = { }
	local n = C.GetNumCargoTransportTypes(container, true)
	local buf = ffi.new("StorageInfo[?]", n)
	n = C.GetCargoTransportTypes(buf, n, container, true, aftertradeorders)

	-- Fill transporttypes list
	for i = 0, n - 1 do
		local tags = menu.getTransportTagsFromString(ffi.string(buf[i].transport))
		local name
		if tags.container and tags.solid and tags.liquid then -- do not add Condensate Storage!
			name = ReadText(20109, 801)		-- Universal Storage
		elseif tags.container then
			name = ReadText(20109, 101)		-- Container Storage
		elseif tags.solid then
			name = ReadText(20109, 301)		-- Solid Storage
		elseif tags.liquid then
			name = ReadText(20109, 601)		-- Liquid Storage
		elseif tags.condensate then
			name = ReadText(20109, 9801)	-- Condensate Storage
		else
			name = ffi.string(buf[i].name)	-- Should never happen
		end
		table.insert(transporttypes, { name = name, tags = tags, initialstored = 0, stored = 0, capacity = buf[i].capacity })
	end
	-- Sort transport types (first container, then solid, then liquid, then condensate, then universal, then anything else)
	-- NOTE: Universal storage isn't supposed to be mixed with container, solid, liquid or condensate storage, but if it is, then the order is important,
	-- so that the storage visualisation doesn't break completely (fill container/solid/liquid/condensate storage instead of universal storage)
	table.sort(transporttypes,
		function (a, b)
			if a.tags.condensate ~= b.tags.condensate then
				return not a.tags.condensate
			elseif a.tags.liquid ~= b.tags.liquid then
				return not a.tags.liquid
			elseif a.tags.solid ~= b.tags.solid then
				return not a.tags.solid
			elseif a.tags.container ~= b.tags.container then
				return not a.tags.container
			else
				return a.name < b.name
			end
		end)

	-- initialize initialstored
	menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)

	return transporttypes
end

function menu.initTradeContextData()
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))

	-- Ships
	local occupiedship = C.GetPlayerOccupiedShipID()
	menu.contextMenuData.isoccupiedshipdocked = false
	if occupiedship ~= 0 then
		menu.contextMenuData.isoccupiedshipdocked = C.GetCommonContext(occupiedship, menu.contextMenuData.component, true, true, C.GetContextByClass(occupiedship, "zone", false), false) ~= 0
	end
	menu.contextMenuData.ships = menu.getShipList(menu.contextMenuData.isoccupiedshipdocked, false)
	for i, ship in ipairs(menu.contextMenuData.ships) do
		if ConvertIDTo64Bit(ship.shipid) == menu.contextMenuData.component then
			table.remove(menu.contextMenuData.ships, i)
			break
		end
	end
	local convertedCurrentShip
	if not menu.contextMenuData.currentShip then
		for id, _ in pairs(menu.selectedcomponents) do
			local selectedcomponent = ConvertStringTo64Bit(id)
			if menu.contextMenuData.isoccupiedshipdocked or (selectedcomponent ~= occupiedship) then
				local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
				if isplayerowned and C.IsComponentClass(selectedcomponent, "ship") and (not isdeployable) then
					menu.contextMenuData.currentShip = selectedcomponent
					convertedCurrentShip = ConvertStringToLuaID(id)
					break
				end
			end
		end
		if not menu.contextMenuData.currentShip then
			if #menu.contextMenuData.ships > 0 then
				if menu.contextMenuData.isoccupiedshipdocked then
					for _, ship in ipairs(menu.contextMenuData.ships) do
						if ConvertIDTo64Bit(ship.shipid) == occupiedship then
							menu.contextMenuData.currentShip = ConvertIDTo64Bit(ship.shipid)
							convertedCurrentShip = ship.shipid
							break
						end
					end
				end
				if not menu.contextMenuData.currentShip then
					menu.contextMenuData.currentShip = ConvertIDTo64Bit(menu.contextMenuData.ships[1].shipid)
					convertedCurrentShip = menu.contextMenuData.ships[1].shipid
				end
			else
				menu.contextMenuData.currentShip = 0
				convertedCurrentShip = nil
			end
		end
	else
		convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	end

	local currentship64 = ConvertIDTo64Bit(convertedCurrentShip)
	local iscurrentshipdocked = currentship64 and C.GetCommonContext(currentship64, menu.contextMenuData.component, true, true, C.GetContextByClass(currentship64, "zone", false), false) ~= 0
	menu.contextMenuData.immediate = false
	if menu.contextMenuData.isoccupiedshipdocked and (menu.contextMenuData.currentShip == occupiedship) then
		-- occupied ship wants to trade with tradeoffercontainer, use trade computer
		menu.contextMenuData.immediate = true
		menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
	elseif iscurrentshipdocked then
		if not GetComponentData(convertedCurrentShip, "aipilot") then
			-- current ship has common context with tradeoffercontainer and no ai pilot, use trade computer
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.currentShip
		elseif C.IsComponentClass(menu.contextMenuData.component, "ship") and (not GetComponentData(convertedTradeOfferContainer, "aipilot")) then
			-- current ship has common context with tradeoffercontainer and the tradeoffercontainer is a ship and has no ai pilot, use trade computer on that ship
			menu.contextMenuData.immediate = true
			menu.contextMenuData.immediateObject = menu.contextMenuData.component
		end
	end
	menu.contextMenuData.playerMoney = GetPlayerMoney()

	-- virtual cargo mode
	if convertedCurrentShip then
		local numtradecomputertrades = tonumber(C.GetNumTradeComputerOrders(menu.contextMenuData.currentShip))
		SetVirtualCargoMode(convertedCurrentShip, true, menu.contextMenuData.immediate and numtradecomputertrades or -1)
	end
	if menu.contextMenuData.wareexchange then
		if C.IsComponentOperational(menu.contextMenuData.component) then
			SetVirtualCargoMode(convertedTradeOfferContainer, true, -1)
			menu.contextMenuData.currentothercargo = GetCargoAfterTradeOrders(convertedTradeOfferContainer)
			menu.contextMenuData.currentotherammo = GetAmmoCountAfterTradeOrders(convertedTradeOfferContainer)
		end
	end

	menu.contextMenuData.currentcargo = convertedCurrentShip and GetCargoAfterTradeOrders(convertedCurrentShip) or {}
	menu.contextMenuData.currentammo = convertedCurrentShip and GetAmmoCountAfterTradeOrders(convertedCurrentShip) or {}

	-- Trade offers
	menu.contextMenuData.buyoffers = {}
	menu.contextMenuData.selloffers = {}
	menu.contextMenuData.missionoffers = {}
	menu.contextMenuData.buywares = {}
	menu.contextMenuData.sellwares = {}
	menu.contextMenuData.missionwares = {}
	menu.contextMenuData.buyammowares = {}
	menu.contextMenuData.sellammowares = {}
	menu.contextMenuData.missionoffersbyid = {}

	local tradeoffers, nontradeoffers = {}, {}
	if menu.contextMenuData.wareexchange then
		tradeoffers = GetWareExchangeTradeList(convertedCurrentShip, convertedTradeOfferContainer)
		-- Mark any equipment wares as such (only relevant for ware exchange)
		for _, tradedata in pairs(tradeoffers) do
			if tradedata.ware then
				tradedata.ammotypename = menu.getAmmoTypeNameByWare(tradedata.ware)
			end
		end
	else
		tradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip)
		nontradeoffers = GetTradeList(convertedTradeOfferContainer, convertedCurrentShip, false)
	end
	for _, tradedata in pairs(tradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					if not buywares[tradedata.ware] then
						buywares[tradedata.ware] = { tradedata }
					else
						table.insert(buywares[tradedata.ware], tradedata)
					end
				end
				if tradedata.active and currentotherwares then
					currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
				end
			elseif tradedata.isselloffer then
				tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount, true)
				if tradedata.ismissionoffer then
					table.insert(menu.contextMenuData.missionoffers, tradedata)
					menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
					if menu.contextMenuData.missionwares[tradedata.ware] then
						table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
					else
						menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
					end
				else
					table.insert(menu.contextMenuData.selloffers, tradedata)
					if not sellwares[tradedata.ware] then
						sellwares[tradedata.ware] = { tradedata }
					else
						table.insert(sellwares[tradedata.ware], tradedata)
					end
				end
				if tradedata.active then
					currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
				end
			end
		end
	end
	for _, tradedata in pairs(nontradeoffers) do
		if tradedata.ware and ((not menu.contextMenuData.shadyOnly) or tradedata.isshady) then
			local currentwares = tradedata.ammotypename and menu.contextMenuData.currentammo or menu.contextMenuData.currentcargo
			local currentotherwares = tradedata.ammotypename and menu.contextMenuData.currentotherammo or menu.contextMenuData.currentothercargo	-- may be nil
			local buywares = tradedata.ammotypename and menu.contextMenuData.buyammowares or menu.contextMenuData.buywares
			local sellwares = tradedata.ammotypename and menu.contextMenuData.sellammowares or menu.contextMenuData.sellwares

			if tradedata.isbuyoffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and currentwares[tradedata.ware] and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active and currentotherwares then
							currentotherwares[tradedata.ware] = currentotherwares[tradedata.ware] or 0
						end
					end
				elseif not buywares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.buyoffers, tradedata)
					buywares[tradedata.ware] = { tradedata }
				end
			elseif tradedata.isselloffer then
				if tradedata.ismissionoffer then
					if not menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] then
						tradedata.active = convertedCurrentShip and CanTradeWith(tradedata.id, convertedCurrentShip, tradedata.minamount)
						table.insert(menu.contextMenuData.missionoffers, tradedata)
						menu.contextMenuData.missionoffersbyid[ConvertIDTo64Bit(tradedata.id)] = true
						if menu.contextMenuData.missionwares[tradedata.ware] then
							table.insert(menu.contextMenuData.missionwares[tradedata.ware], tradedata)
						else
							menu.contextMenuData.missionwares[tradedata.ware] = { tradedata }
						end
						if tradedata.active then
							currentwares[tradedata.ware] = currentwares[tradedata.ware] or 0
						end
					end
				elseif not sellwares[tradedata.ware] then
					tradedata.active = false
					tradedata.stale = true
					table.insert(menu.contextMenuData.selloffers, tradedata)
					sellwares[tradedata.ware] = { tradedata }
				end
			end
		end
	end

	-- Distribute cargo to transport type capacities
	menu.contextMenuData.transporttypes = (menu.contextMenuData.currentShip ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.currentShip, true) or {}
	menu.contextMenuData.othershiptransporttypes = (menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0) and menu.getCargoTransportTypes(menu.contextMenuData.component, true) or {}

	menu.contextMenuData.ammotypes = { }
	if menu.contextMenuData.wareexchange and menu.contextMenuData.component ~= 0 then
		-- ammo is only relevant and visible in ware exchange case
		local missilecapacity1, countermeasurecapacity1, deployablecapacity1 = GetComponentData(convertedCurrentShip, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local missilecapacity2, countermeasurecapacity2, deployablecapacity2 = GetComponentData(convertedTradeOfferContainer, "missilecapacity", "countermeasurecapacity", "deployablecapacity")
		local unitcapacity1 = GetUnitStorageData(convertedCurrentShip).capacity
		local unitcapacity2 = GetUnitStorageData(convertedTradeOfferContainer).capacity
		-- missiles
		if missilecapacity1 > 0 or missilecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 1304), type = "missile", stored = 0, otherstored = 0, capacity = missilecapacity1, othercapacity = missilecapacity2 })
		end
		-- countermeasures
		if countermeasurecapacity1 > 0 or countermeasurecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8063), type = "countermeasure", stored = 0, otherstored = 0, capacity = countermeasurecapacity1, othercapacity = countermeasurecapacity2 })
		end
		-- units
		if unitcapacity1 > 0 or unitcapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8), type = "unit", stored = 0, otherstored = 0, capacity = unitcapacity1, othercapacity = unitcapacity2 })
		end
		-- units
		if deployablecapacity1 > 0 or deployablecapacity2 > 0 then
			table.insert(menu.contextMenuData.ammotypes, { name = ReadText(1001, 8064), type = "deployable", stored = 0, otherstored = 0, capacity = deployablecapacity1, othercapacity = deployablecapacity2 })
		end
	end

	-- cost
	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0

	-- Merge selloffers and buyoffers into waredatalist
	local waredatatable = {}
	local waredatalist = {}
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, sell = tradedata, stale = tradedata.stale }
		waredatatable[tradedata.ware] = waredata
		table.insert(waredatalist, waredata)
	end
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		local waredata = waredatatable[tradedata.ware]
		if (not waredata) or tradedata.issupply then
			if not menu.contextMenuData.wareexchange then
				AddKnownItem("wares", tradedata.ware)
			end
			waredata = { ware = tradedata.ware, stale = tradedata.stale, issupply = tradedata.issupply }
			waredatatable[tradedata.ware] = waredata
			table.insert(waredatalist, waredata)
		end
		waredata.buy = tradedata
		waredata.active = waredata.active or tradedata.active
		waredata.stale = waredata.stale and tradedata.stale
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if not menu.contextMenuData.wareexchange then
			AddKnownItem("wares", tradedata.ware)
		end
		local waredata = { ware = tradedata.ware, active = tradedata.active, mission = ConvertIDTo64Bit(tradedata.mission), stale = tradedata.stale }
		if tradedata.isbuyoffer then
			waredata.buy = tradedata
		else
			waredata.sell = tradedata
		end
		table.insert(waredatalist, waredata)
	end
	-- Sort wares: First by cargo/ammo type, then active before inactive, then sorted by name
	table.sort(waredatalist,
		function (a, b)
			local aidx, bidx = menu.getAmmoDataIdxByWare(a.ware), menu.getAmmoDataIdxByWare(b.ware)
			if aidx ~= bidx then
				return aidx < bidx
			elseif (not a.active) ~= (not b.active) then
				return not b.active
			else
				return Helper.sortWareName(a.ware, b.ware)
			end
		end)

	-- Store waredatalist so we always know how many lines there are in the shiptable
	menu.contextMenuData.waredatalist = waredatalist

	-- If no wares, there is still a line displayed ("No known offers" / "No wares")
	local numwarerows = math.max(1, #menu.contextMenuData.waredatalist)
	local numinforows = math.max(#menu.contextMenuData.transporttypes, #menu.contextMenuData.othershiptransporttypes) + #menu.contextMenuData.ammotypes
	if not menu.contextMenuData.wareexchange and numinforows < 2 then
		numinforows = 2			-- reserve space for "Profits from sales" and "Transaction value"
	end
	return numwarerows, numinforows
end

function menu.sortByActiveAndName(a, b)
	if a.active == b.active then
		return Helper.sortName(a, b)
	end
	return a.active
end

function menu.sortByActiveAndWareName(a, b)
	if a.active == b.active then
		return GetWareData(a.ware, "name") < GetWareData(b.ware, "name")
	end
	return a.active
end

function menu.getAmmoTypeNameByWare(ware)
	local transport, macro = GetWareData(ware, "transport", "component")
	if transport == "equipment" and macro ~= "" then
		if IsMacroClass(macro, "missile") then
			return "missile"
		elseif IsMacroClass(macro, "countermeasure") then
			return "countermeasure"
		elseif GetMacroData(macro, "isunit") then
			return "unit"
		elseif GetMacroData(macro, "isdeployable") then
			return "deployable"
		end
	end
	return nil
end

function menu.getAmmoDataIdxByWare(ware)
	local ammotypename = menu.getAmmoTypeNameByWare(ware)
	if ammotypename then
		for idx, equipmentdata in ipairs(menu.contextMenuData.ammotypes) do
			if equipmentdata.type == ammotypename then
				return idx
			end
		end
	end
	return 0
end

function menu.getAmmoDataByWare(ware)
	local idx = menu.getAmmoDataIdxByWare(ware)
	if idx > 0 then
		return menu.contextMenuData.ammotypes[idx]
	end
	return nil
end

function menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip))
	local convertedTradeOfferContainer = ConvertStringToLuaID(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
		transporttype.stored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentcargo) do
		local transport, volume = GetWareData(ware, "transport", "volume")
		for _, transporttype in ipairs(menu.contextMenuData.transporttypes) do
			if transporttype.tags[transport] then
				local orderamount = menu.getCargoOrderAmountByWare(ware)
				transporttype.stored = transporttype.stored + (amount - orderamount) * volume
				break
			end
		end
	end

	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		ammotype.stored = 0
		ammotype.otherstored = 0
	end
	for ware, amount in pairs(menu.contextMenuData.currentammo) do
		local ammotype = menu.getAmmoDataByWare(ware)
		if ammotype then
			ammotype.stored = ammotype.stored + amount - menu.getAmmoOrderAmountByWare(ware)
		end
	end

	if menu.contextMenuData.wareexchange then
		for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
			transporttype.stored = transporttype.initialstored
		end
		for ware, amount in pairs(menu.contextMenuData.currentothercargo) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			-- below is done to handle trade partners that have more than one storage module type with a particular storage type (ex: solid and universal)
			local leftover = 0
			local orderamount = menu.getCargoOrderAmountByWare(ware)
			if orderamount ~= 0 then
				for _, transporttype in ipairs(menu.contextMenuData.othershiptransporttypes) do
					--print("init stored: " .. tostring(transporttype.stored))
					if transporttype.tags[transport] then
						local volumechange = orderamount * volume
						if leftover > 0 then
							volumechange = leftover * volume
							--print("1.1 ware: " .. tostring(ware) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						end

						--print(tostring(_) .. ": 2.0 ware: " .. tostring(ware) .. ", orderamount: " .. tostring(orderamount) .. ", volumechange: " .. tostring(volumechange) .. ", transporttype.capacity: " .. tostring(transporttype.capacity))
						if (transporttype.stored + volumechange) > transporttype.capacity then
							local evalamount = orderamount
							local evalvolume = transporttype.stored + volumechange
							while evalvolume > transporttype.capacity do
								evalamount = evalamount - 1
								evalvolume = transporttype.stored + evalamount * volume
							end
							transporttype.stored = evalvolume
							leftover = orderamount - evalamount
							--print("2.1 ware: " .. tostring(ware) .. ", leftover volume: " .. tostring(leftover * volume))
						else
							leftover = 0
							transporttype.stored = transporttype.stored + volumechange
							--print("2.2 ware: " .. tostring(ware) .. ", total stored: " .. tostring(transporttype.stored) .. ", capacity: " .. tostring(transporttype.capacity))
							break
						end
					end
				end
			end
		end
		for ware, amount in pairs(menu.contextMenuData.currentotherammo) do
			local ammotype = menu.getAmmoDataByWare(ware)
			if ammotype then
				ammotype.otherstored = ammotype.otherstored + amount + menu.getAmmoOrderAmountByWare(ware)
			end
		end
	end

	menu.contextMenuData.totalbuyprofit = 0
	menu.contextMenuData.totalsellcost = 0
	menu.contextMenuData.referenceprofit = 0
	if not isplayertradeoffercontainer then
		for id, amount in pairs(menu.contextMenuData.orders) do
			local tradeoffer = menu.getTradeOfferByID(ConvertStringToLuaID(tostring(id)))
			local price = tradeoffer and tradeoffer.price or 0
			if amount < 0 then
				-- station sells
				menu.contextMenuData.totalsellcost = menu.contextMenuData.totalsellcost + RoundTotalTradePrice(price * -amount)
			elseif amount > 0 then
				-- station buys
				menu.contextMenuData.totalbuyprofit = menu.contextMenuData.totalbuyprofit + RoundTotalTradePrice(price * amount)
			end
			if price ~= 0 and amount ~= 0 then
				local defaultrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, 0) or 0
				local newrefprofit = GetReferenceProfit(convertedCurrentShip, tradeoffer.ware, price, amount) or 0
				menu.contextMenuData.referenceprofit = menu.contextMenuData.referenceprofit + newrefprofit - defaultrefprofit
			end
		end
	end
end

function menu.getCargoOrderAmountByWare(ware)
	local result = 0
	if menu.contextMenuData.buywares[ware] then
		for _, buyoffer in ipairs(menu.contextMenuData.buywares[ware]) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
		end
	end
	if menu.contextMenuData.sellwares[ware] then
		for _, selloffer in ipairs(menu.contextMenuData.sellwares[ware]) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
		end
	end
	local missionoffers = menu.contextMenuData.missionwares[ware]
	if missionoffers then
		for _, missionoffer in ipairs(missionoffers) do
			result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(missionoffer.id)] or 0)
		end
	end
	return result
end

function menu.getAmmoOrderAmountByWare(ware)
	local result = 0
	local buyoffer = menu.contextMenuData.buyammowares[ware]
	if buyoffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(buyoffer.id)] or 0)
	end
	local selloffer = menu.contextMenuData.sellammowares[ware]
	if selloffer then
		result = result + (menu.contextMenuData.orders[ConvertIDTo64Bit(selloffer.id)] or 0)
	end
	return result
end

function menu.getTradeOfferByID(id)
	for _, tradedata in ipairs(menu.contextMenuData.buyoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.selloffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end
	for _, tradedata in ipairs(menu.contextMenuData.missionoffers) do
		if IsSameTrade(tradedata.id, id) then
			return tradedata
		end
	end

	return nil
end

function menu.getTradeContextStorableAmountAfterTradeOrders(ship, ware, ammotypename)
	if ammotypename == "missile" then
		return C.GetFreeMissileStorageAfterTradeOrders(ship)
	elseif ammotypename == "countermeasure" then
		return C.GetFreeCountermeasureStorageAfterTradeOrders(ship)
	elseif ammotypename == "unit" then
		return GetFreeUnitStorageAfterTradeOrders(ConvertStringToLuaID(tostring(ship)))
	elseif ammotypename == "deployable" then
		return C.GetFreeDeployableStorageAfterTradeOrders(ship)
	end
	return GetFreeCargoAfterTradeOrders(ConvertStringToLuaID(tostring(ship)), ware)
end

function menu.getTradeContextRowContent(waredata)
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))
	local nonVirtualShipCargo = {}
	if menu.contextMenuData.currentShip ~= 0 then
		nonVirtualShipCargo = GetComponentData(convertedCurrentShip, "cargo")
	end
	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer, hastradesubscription = GetComponentData(convertedTradeOfferContainer, "isplayerowned", "tradesubscription")
	local name = GetWareData(waredata.ware, "name")
	local activecolor = (waredata.active and Color["text_normal"] or Color["text_inactive"])
	local color = activecolor
	local mouseovertext = ""

	if waredata.mission then
		name = ColorText["text_mission"] .. "\027[menu_mission_trade]\027X" .. name
		local mission = menu.getMissionIDInfoHelper(waredata.mission)
		mouseovertext = ColorText["text_mission"] .. mission.name .. "\027X"
	elseif waredata.issupply then
		name = "\027[maptr_supply]" .. name
	end

	local numillegalfactions = C.GetNumIllegalToFactions(waredata.ware)
	if numillegalfactions > 0 then
		local buf = ffi.new("const char*[?]", numillegalfactions)
		numillegalfactions = C.GetIllegalToFactions(buf, numillegalfactions, waredata.ware)
		local factions = {}
		for i = 0, numillegalfactions - 1 do
			table.insert(factions, ffi.string(buf[i]))
		end

		local first = true
		for _, faction in ipairs(factions) do
			if IsKnownItem("factions", faction) then
				if first then
					name = "\027[workshop_error]" .. name
					color = waredata.active and Color["text_illegal"] or Color["text_illegal_inactive"]
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ColorText["text_illegal"] .. ReadText(1001, 2437) .. ReadText(1001, 120)
					first = false
				end
				mouseovertext = mouseovertext .. "\n" .. GetFactionData(faction, "name")
			end
		end
	end

	local warnings, optionalsellwarnings, optionalbuywarnings = {}, {}, {}
	local pricemodifiers = {}
	local hassellamount, hasbuyamount = false, false

	local buyoffer_curorder = 0
	if waredata.buy then
		buyoffer_curorder = math.max(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.buy.id)] or 0)
	end

	local selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
	if waredata.sell then
		if waredata.sell.amount > 0 then
			hassellamount = true
		end
		selloffer_curorder = math.min(0, menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0)
		local affordableamount = isplayertradeoffercontainer and waredata.sell.amount or GetNumAffordableTradeItems(GetPlayerMoney() - menu.contextMenuData.totalsellcost + RoundTotalTradePrice(-(menu.contextMenuData.orders[ConvertIDTo64Bit(waredata.sell.id)] or 0) * waredata.sell.price), waredata.sell.price)
		local storableamount = (menu.contextMenuData.currentShip ~= 0) and menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.currentShip, waredata.ware, waredata.sell.ammotypename) or 0
		-- curorder was already added to virtual cargo, don't count it twice
		-- if curorder is currently buying, we need to deduct this amount from the storage amount, too
		storableamount = storableamount - selloffer_curorder - buyoffer_curorder
		selloffer_max = waredata.sell.amount
		selloffer_maxselect = math.min(waredata.sell.amount, affordableamount, storableamount)

		if menu.contextMenuData.currentShip ~= 0 then
			if selloffer_maxselect == 0 then
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					warnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					warnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					warnings[2] = ReadText(1001, 8338)
				end
			else
				if not CheckSuitableTransportType(menu.contextMenuData.currentShip, waredata.ware) then
					optionalsellwarnings[1] = ReadText(1001, 2969)
				elseif storableamount < waredata.sell.amount and storableamount < affordableamount then
					optionalsellwarnings[1] = ReadText(1001, 8337)
				elseif affordableamount < waredata.sell.amount and affordableamount < storableamount then
					optionalsellwarnings[2] = ReadText(1001, 8338)
				end
			end
		end

		if not waredata.sell.active then
			selloffer_max, selloffer_maxselect, selloffer_curorder = 0, 0, 0
		end
	end

	local buyoffer_max, buyoffer_maxselect = 0, 0
	local hasdesiredbuyamount = false
	if waredata.buy then
		if waredata.buy.amount > 0 then
			hasbuyamount = true
		end
		if waredata.buy.desiredamount > 0 then
			hasdesiredbuyamount = true
		end
		local availableamount = (waredata.buy.ammotypename and menu.contextMenuData.currentammo[waredata.ware] or ((menu.contextMenuData.currentcargo[waredata.ware] or 0) - menu.getCargoOrderAmountByWare(waredata.ware) + buyoffer_curorder)) or 0
		buyoffer_maxselect = math.min(waredata.buy.amount, availableamount)
		buyoffer_max = waredata.buy.amount

		local othershipstorableamount
		if menu.contextMenuData.wareexchange then
			othershipstorableamount = menu.getTradeContextStorableAmountAfterTradeOrders(menu.contextMenuData.component, waredata.ware, waredata.buy.ammotypename)
			-- curorder was already added to virtual cargo, don't count it twice
			othershipstorableamount = othershipstorableamount + buyoffer_curorder
			buyoffer_maxselect = math.min(buyoffer_maxselect, othershipstorableamount)
		end

		if menu.contextMenuData.currentShip ~= 0 then
			if buyoffer_maxselect == 0 then
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					warnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					warnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			else
				if menu.contextMenuData.wareexchange and othershipstorableamount < waredata.buy.amount and othershipstorableamount < availableamount then
					optionalbuywarnings[3] = ReadText(1001, 8339)
				elseif availableamount < waredata.buy.amount then
					optionalbuywarnings[4] = ((nonVirtualShipCargo[waredata.ware] or 0) > 0) and ReadText(1001, 8375) or ReadText(1001, 8340)
				end
			end
		end

		if not waredata.buy.active then
			buyoffer_max, buyoffer_maxselect, buyoffer_curorder = 0, 0, 0
		end
	end

	if not hastradesubscription then
		warnings[6] = ReadText(1001, 11602)
	elseif (not hassellamount) and (not hasbuyamount) then
		if hasdesiredbuyamount then
			warnings[5] = ReadText(1001, 11213)
		else
			warnings[5] = ReadText(1001, 8341)
		end
	end

	-- In case both selloffer and buyoffer exist, we can show both offer amounts, but all other columns can only show data for one offer.
	-- In that case prefer selloffer data (for buying - change to buyoffer when player attempts to sell)
	local tradedata = waredata.sell
	if waredata.buy then
		if (buyoffer_curorder ~= 0) or ((not waredata.sell) or (waredata.sell.amount == 0)) then
			tradedata = waredata.buy
		end
	end

	local avgprice = GetWareData(waredata.ware, "avgprice")
	local adjustment = avgprice ~= 0 and (tradedata.price / avgprice - 1) or 0
	local adjustmentcolor = (adjustment > 0) and ColorText["text_price_good"] or ColorText["text_price_bad"]
	if tradedata.isselloffer then
		adjustmentcolor = (adjustment > 0) and ColorText["text_price_bad"] or ColorText["text_price_good"]
	end
	local pricecolor = Helper.interpolatePriceColor(waredata.ware, tradedata.price, tradedata == waredata.sell, activecolor)

	local strquantitybonustype = ""
	local quantitycolor
	if tradedata.quantityfactor > 1 then
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2929) or ReadText(1001, 2905)
		quantitycolor = tradedata.isselloffer and ColorText["text_price_bad"] or ColorText["text_price_good"]
	else
		strquantitybonustype = tradedata.isselloffer and ReadText(1001, 2904) or ReadText(1001, 2930)
		quantitycolor = tradedata.isselloffer and ColorText["text_price_good"] or ColorText["text_price_bad"]
	end

	local quantityamountstring, quantityamountvalue = Helper.diffpercent((tradedata.quantityfactor - 1) * 100, tradedata.isbuyoffer)
	pricemodifiers[1] = { text = strquantitybonustype, amount = quantitycolor .. quantityamountstring .. " %\27X", amountvalue = quantityamountvalue }

	if tradedata.pricemodifiers and #tradedata.pricemodifiers ~= 0 then
		for i, p in ipairs(tradedata.pricemodifiers) do
			local color = (p.amount > 0) and ColorText["text_price_good"] or ColorText["text_price_bad"]
			if tradedata.isselloffer then
				color = (p.amount > 0) and ColorText["text_price_bad"] or ColorText["text_price_good"]
			end
			local amountstring, amountvalue = Helper.diffpercent(p.amount, tradedata.isbuyoffer)
			table.insert(pricemodifiers, {
				text = p.name .. (p.expire >= 0 and " (" .. Helper.timeDuration(p.expire) .. ")" or ""),
				amount = color .. amountstring .. " %\27X",
				amountvalue = amountvalue,
				originalvalue = p.amount,
				isbuyoffer = tradedata.isbuyoffer,
			})
		end
	end
	local totalamountstring, totalamountvalue = Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer)
	table.insert(pricemodifiers, { text = ReadText(1001, 11212), amount = adjustmentcolor .. totalamountstring .. " %\27X", amountvalue = totalamountvalue })

	-- fix discrepancies in rounded modifiers vs rounded total modifier
	-- displayed difference between total modifier and quanity-based modifier
	local displayed_discountdiff = pricemodifiers[#pricemodifiers].amountvalue - pricemodifiers[1].amountvalue
	-- displayed sum of all other modifiers
	local displayed_discountsum = 0
	for i, entry in ipairs(pricemodifiers) do
		if (i ~= 1) and (i ~= #pricemodifiers) then
			displayed_discountsum = displayed_discountsum + entry.amountvalue
		end
	end
	-- the discrepancy
	local displayed_discrepancy = displayed_discountdiff - displayed_discountsum
	-- adjust displayed modifier values until there is no discrepancy left
	for i, entry in ipairs(pricemodifiers) do
		if displayed_discrepancy == 0 then
			break
		end
		if (i ~= 1) and (i ~= #pricemodifiers) then
			-- do the inverse of Helper.diffpercent() to find the value this modifier can be adjusted to
			local adjustedvalue
			if entry.isbuyoffer then
				adjustedvalue = math.ceil(entry.originalvalue * 10 + 0.0001) / 10 - entry.amountvalue
			else
				adjustedvalue = entry.amountvalue - math.floor(entry.originalvalue * 10 - 0.0001) / 10
			end
			adjustedvalue = math.min(adjustedvalue, displayed_discrepancy)

			if adjustedvalue ~= 0 then
				local color = (entry.originalvalue > 0) and ColorText["text_price_good"] or ColorText["text_price_bad"]
				if tradedata.isselloffer then
					color = (entry.originalvalue > 0) and ColorText["text_price_bad"] or ColorText["text_price_good"]
				end
				entry.amount, entry.amountvalue = Helper.diffpercent(entry.amountvalue + adjustedvalue, tradedata.isbuyoffer)
				entry.amount = color .. entry.amount .. " %\27X"

				displayed_discrepancy = displayed_discrepancy - adjustedvalue
			end
		end
	end

	local movedamount = -(selloffer_curorder < 0 and selloffer_curorder or buyoffer_curorder)
	local shipamount = (menu.contextMenuData.currentcargo[waredata.ware] or menu.contextMenuData.currentammo[waredata.ware] or 0) + movedamount
	local shipamountcolor = (movedamount > 0 and Color["text_positive"]) or (movedamount < 0 and Color["text_negative"]) or color

	local othershipamount = (menu.contextMenuData.currentothercargo and (menu.contextMenuData.currentothercargo[waredata.ware] or menu.contextMenuData.currentotherammo[waredata.ware]) or 0) - movedamount
	local othershipamountcolor = (movedamount > 0 and Color["text_negative"]) or (movedamount < 0 and Color["text_positive"]) or color

	local scale = {
		--min       = waredata.buy and waredata.buy.ammotypename and -buyoffer_max or -buyoffer_maxselect, -- use real max only for ammo
		min       = -buyoffer_maxselect, --TODO: max
		minselect = -buyoffer_maxselect,
		--max       = waredata.sell and waredata.sell.ammotypename and selloffer_max or selloffer_maxselect, -- use real max only for ammo
		max       = selloffer_maxselect, --TODO: max
		maxselect = selloffer_maxselect,
		start     = movedamount,
		step      = 1,
		suffix    = "",
		fromcenter = true,
		righttoleft = true
	}

	local shiptargetamount = (menu.contextMenuData.currentShip ~= 0) and GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware) or 0
	local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
	local othershipreserved = C.GetWareReservationsForWare(menu.contextMenuData.component, waredata.ware, false)

	local content = { {}, {}, {}, {}, nil, {}, {}, warnings, optionalsellwarnings, optionalbuywarnings, pricemodifiers }
	-- name
	content[1].text = name
	content[1].color = color
	content[1].mouseover = mouseovertext
	-- price
	if not menu.contextMenuData.wareexchange then
		content[2].text = (not waredata.stale) and ((isplayertradeoffercontainer and "-" or ConvertMoneyString(Helper.round(tradedata.price, 2), true, true, 0, true)) .. " " .. ReadText(1001, 101)) or ""
		content[2].color = pricecolor
		content[2].mouseover = (not waredata.stale) and (isplayertradeoffercontainer and "" or (Helper.diffpercent(adjustment * 100, tradedata.isbuyoffer) .. ReadText(1001, 8304))) or ""
	end
	-- amount
	content[3].text = ConvertIntegerString(shipamount, true, 0, true) .. ((shiptargetamount > 0) and (" (" .. ConvertIntegerString(shiptargetamount, true, 2, true, true) .. ")") or "")
	content[3].color = shipamountcolor
	-- slidercell
	content[4].scale = scale
	content[4].color = color
	if menu.contextMenuData.wareexchange then
		-- other ship amount
		content[6].text = ConvertIntegerString(othershipamount, true, 0, true) .. ((othershiptargetamount > 0) and (" (" .. ConvertIntegerString(othershiptargetamount, true, 2, true, true) .. ")") or "")
		content[6].color = othershipamountcolor
		if othershipreserved > 0 then
			content[6].mouseover = string.format(ReadText(1026, 3266), ConvertIntegerString(othershipreserved, true, 0, true))
		end
	else
		-- sell offer
		content[6].text = (waredata.sell and (not waredata.sell.stale)) and ConvertIntegerString(waredata.sell.amount - math.max(movedamount, 0), true, 0, true) or ""
		content[6].color = color
		-- buy offer
		content[7].text = (waredata.buy and (not waredata.buy.stale)) and (hasbuyamount and ConvertIntegerString(waredata.buy.amount - math.max(-movedamount, 0), true, 0, true) or (hasdesiredbuyamount and ConvertIntegerString(waredata.buy.desiredamount - math.max(-movedamount, 0), true, 0, true) or "")) or ""
		content[7].color = color
	end
	return content
end

-- Only use this to get initial storage data. If we use this with every virtual storage change, we have to reset virtual cargo every time wares are removed from virtual cargo of othercontainer in the menu. Otherwise, this will result in a mismatch between the storage data in the menu and after the actual trade because each change is treated as a separate trade in virtual cargo.
-- For example: If we add A, add B, then remove A; virtual cargo treats this as three separate transactions and will fill storage accordingly; but the actual trade will only have one transaction: add B.
function menu.getTradeContextInitialStorageData(container, transporttypes, aftertradeorders)
	local numtransporttypes = C.GetNumCargoTransportTypes(container, true)
	local virtualtransporttypes = ffi.new("StorageInfo[?]", numtransporttypes)
	numtransporttypes = C.GetCargoTransportTypes(virtualtransporttypes, numtransporttypes, container, true, aftertradeorders)

	--typedef struct {
	--	const char* name;
	--	const char* transport;
	--	uint32_t spaceused;
	--	uint32_t capacity;
	--} StorageInfo;

	for _, transporttype in ipairs(transporttypes) do
		for j = 0, numtransporttypes - 1 do
			local tags = menu.getTransportTagsFromString(ffi.string(virtualtransporttypes[j].transport))

			local invalid = false
			for tag, _ in pairs(tags) do
				if not transporttype.tags[tag] then invalid = true; break end
			end
			if not invalid then
				for tag, _ in pairs(transporttype.tags) do
					if not tags[tag] then invalid = true; break end
				end
			end
			if not invalid then
				transporttype.initialstored = virtualtransporttypes[j].spaceused
				break
			end
		end
	end
end

function menu.getTradeContextShipStorageContent(othership)
	local storagecontent = {}

	for i, transporttype in ipairs(othership and menu.contextMenuData.othershiptransporttypes or menu.contextMenuData.transporttypes) do
		if i > menu.tradeContext.numinforows then
			break
		end
		local spaceused = transporttype.stored
		spaceused = math.max(0, math.min(spaceused, transporttype.capacity))
		table.insert(storagecontent, {
			name = transporttype.name,
			color = Color["text_normal"],
			scale = {
				min       = 0,
				max       = transporttype.capacity,
				start     = spaceused,
				step      = 1,
				suffix    = ReadText(1001, 110),
				readonly  = true
			}
		})
	end

	-- add empty line if one ship has ammo of a type, but other doesn't
	for _, ammotype in ipairs(menu.contextMenuData.ammotypes) do
		if #storagecontent >= menu.tradeContext.numinforows then
			break
		end
		local spaceused = othership and ammotype.otherstored or ammotype.stored
		local capacity = othership and ammotype.othercapacity or ammotype.capacity
		spaceused = math.max(0, math.min(spaceused, capacity))
		table.insert(storagecontent, {
			name = ammotype.name,
			color = Color["text_normal"],
			scale = {
				min       = 0,
				max       = capacity,
				start     = spaceused,
				step      = 1,
				suffix    = "     ",
				readonly  = true
			}
		})
	end

	return storagecontent
end

function menu.createTradeContext(frame)
	menu.skipTradeRowChange = true

	local convertedTradeOfferContainer = ConvertStringTo64Bit(tostring(menu.contextMenuData.component))
	local isplayertradeoffercontainer = GetComponentData(convertedTradeOfferContainer, "isplayerowned")

	AddUITriggeredEvent(menu.name, "trade_context", ConvertStringToLuaID(convertedTradeOfferContainer))

	menu.updateTradeCost()
	local convertedCurrentShip = ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip))

	-- menu setup
	local width = menu.contextMenuData.width
	local amountcolumnwidth = 100
	local pricecolumnwidth = 100

	local columnwidth_ware   -- calculated below
	local columnwidth_price			= math.floor(width * 12 / 100)
	local columnwidth_shipstorage	= math.floor(width * 12 / 100)
	local columnwidth_sliderleft	= math.floor(width * 15 / 100)
	local columnwidth_sliderright	= math.floor(width * 15 / 100)
	local columnwidth_selloffer		= math.floor(width * 12 / 100)
	local columnwidth_buyoffer		= math.floor(width * 12 / 100)
	local columnwidth_reservation	= Helper.scaleY(config.mapRowHeight)
	if menu.contextMenuData.wareexchange then
		-- nearly symmetrical menu layout in ware exchange case:
		--   price column = only a dummy in this case, always included in colspan.
		--   selloffer column = other ship storage
		--   buyoffer column = unused (almost same width as ware column)
		columnwidth_price = 1
		local remainingwidth = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
		-- nearly symmetrical menu layout:
		columnwidth_ware = math.ceil(remainingwidth / 2)
		columnwidth_buyoffer = remainingwidth - columnwidth_ware
	else
		-- regular trade case
		columnwidth_ware = width - 6 * Helper.borderSize
			- columnwidth_price
			- columnwidth_shipstorage
			- columnwidth_sliderleft
			- columnwidth_sliderright
			- columnwidth_selloffer
			- columnwidth_buyoffer
	end

	-- ship
	local shiptable = frame:addTable(9, { tabOrder = 2, maxVisibleHeight = menu.tradeContext.shipheight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	shiptable:setColWidth(1, columnwidth_ware, false)
	shiptable:setColWidth(2, columnwidth_price, false)
	shiptable:setColWidth(3, columnwidth_shipstorage, false)
	shiptable:setColWidth(4, columnwidth_sliderleft, false)
	shiptable:setColWidth(5, columnwidth_sliderright, false)
	shiptable:setColWidth(6, columnwidth_reservation, false)
	shiptable:setColWidth(7, columnwidth_selloffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setColWidth(8, columnwidth_reservation, false)
	shiptable:setColWidth(9, columnwidth_buyoffer - columnwidth_reservation - Helper.borderSize, false)
	shiptable:setDefaultBackgroundColSpan(1, 9)

	local shipOptions = {}
	local curShipOption = tostring(convertedCurrentShip)

	local sortedShips = {}
	local found = false
	for _, ship in ipairs(menu.contextMenuData.ships) do
		local shipid = ConvertIDTo64Bit(ship.shipid)
		if shipid == convertedCurrentShip then
			found = true
		end

		local class = ffi.string(C.GetComponentClass(ConvertStringTo64Bit(tostring(ship.shipid))))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, { shipid = shipid, name = ship.name })
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { { shipid = shipid, name = ship.name } } })
		end
	end
	if (not found) and (menu.contextMenuData.currentShip ~= 0) then
		local ship = { shipid = convertedCurrentShip, name = ffi.string(C.GetComponentName(menu.contextMenuData.currentShip)) }

		local class = ffi.string(C.GetComponentClass(menu.contextMenuData.currentShip))
		local icon, primarypurpose = GetComponentData(ship.shipid, "icon", "primarypurpose")
		local i = menu.findEntryByShipIcon(sortedShips, icon)
		if i then
			table.insert(sortedShips[i].ships, ship)
		else
			table.insert(sortedShips, { icon = icon, class = class, purpose = primarypurpose, ships = { ship } })
		end
	end
	table.sort(sortedShips, menu.sortShipsByClassAndPurposeReverse)

	local dropdownwidth = columnwidth_ware + columnwidth_price + columnwidth_shipstorage + columnwidth_sliderleft + 3 * Helper.borderSize - Helper.scaleY(Helper.headerRow1Height) - 4 * 2 - Helper.standardTextOffsetx
	for _, data in ipairs(sortedShips) do
		table.sort(data.ships, Helper.sortName)
		for _, ship in ipairs(data.ships) do
			local name = "\27[" .. data.icon .. "] " .. ship.name
			local idcode = " (" .. ffi.string(C.GetObjectIDCode(ship.shipid)) .. ")"
			local sectorname = GetComponentData(ship.shipid, "sector")

			local fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)
			local namewidth = math.ceil(C.GetTextWidth(name, Helper.headerRow1Font, fontsize))
			local idcodewidth = math.ceil(C.GetTextWidth(idcode, Helper.headerRow1Font, fontsize))
			local sectornamewidth = math.ceil(C.GetTextWidth("  " .. sectorname, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize)))
			if namewidth + idcodewidth + sectornamewidth > dropdownwidth then
				name = TruncateText(name, Helper.headerRow1Font, fontsize, dropdownwidth - sectornamewidth - idcodewidth)
			end

			table.insert(shipOptions, { id = tostring(ship.shipid), text = name .. idcode, text2 = sectorname, icon = "", displayremoveoption = false })
		end
	end

	local iscapship = IsComponentClass(convertedCurrentShip, "ship_l") or IsComponentClass(convertedCurrentShip, "ship_xl")
	local ispartnersmallship = IsComponentClass(convertedTradeOfferContainer, "ship_m") or IsComponentClass(convertedTradeOfferContainer, "ship_s")
	local missingdrones = true
	if iscapship and (not ispartnersmallship) then
		local shipunits = GetUnitStorageData(convertedCurrentShip, "transport")
		local stationunits = GetUnitStorageData(convertedTradeOfferContainer, "transport")
		for _, unit in ipairs(shipunits) do
			if unit.amount > 0 then
				missingdrones = false
				break
			end
		end
		if missingdrones then
			for _, unit in ipairs(stationunits) do
				if unit.amount > 0 then
					missingdrones = false
					break
				end
			end
		end
	else
		missingdrones = false
	end
	local candock = true
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		if (not menu.contextMenuData.wareexchange) or IsComponentClass(convertedTradeOfferContainer, "station") then
			candock = IsDockingPossible(convertedCurrentShip, convertedTradeOfferContainer, nil, true)
		end
	end
	local isplayertraderestricted = isplayertradeoffercontainer and C.IsContainerTradingWithFactionRescricted(menu.contextMenuData.component, "player")

	local shipsectorname, blacklistgroup, name = "", "civilian", ""
	if convertedCurrentShip and (convertedCurrentShip ~= 0) then
		local loc_shipsectorname, loc_blacklistgroup, loc_name, loc_icon = GetComponentData(convertedCurrentShip, "sector", "blacklistgroup", "name", "icon")
		shipsectorname = loc_shipsectorname
		blacklistgroup = loc_blacklistgroup
		name = "\27[" .. loc_icon .. "] " .. loc_name .. " (" .. ffi.string(C.GetObjectIDCode(convertedCurrentShip)) .. ")"
	end
	local stationsector = ConvertIDTo64Bit(GetComponentData(convertedTradeOfferContainer, "sectorid"))

	-- title
	local row = shiptable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createDropDown(shipOptions, { startOption = curShipOption, height = Helper.headerRow1Height, textOverride = name, text2Override = " ", helpOverlayID = "trade_context_shipOptions", helpOverlayText = " ", helpOverlayHighlightOnly = true })
	row[1]:setTextProperties({ halign = "left", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, color = Color["text_player"] })
	row[1]:setText2Properties({ halign = "right", fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onDropDownConfirmed = menu.dropdownShip

	local othername = Helper.unlockInfo(IsInfoUnlockedForPlayer(convertedTradeOfferContainer, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.component)) .. ")")
	local color = Color["text_normal"]
	if isplayertradeoffercontainer then
		color = Color["text_player"]
	end
	local mouseovertext
	if C.IsComponentBlacklisted(convertedTradeOfferContainer, "objectactivity", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3257)
		else
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3256)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5)
	othername = TruncateText(othername, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), row[5]:getWidth() - 2 * Helper.scaleX(Helper.standardButtonWidth))
	row[5]:createText(othername, { halign = "center", color = color, font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = 0, y = Helper.headerRow1Offsety, cellBGColor = Color["row_background"], titleColor = Color["row_title"], mouseOverText = mouseovertext })

	-- locations
	local row = shiptable:addRow(true, { fixed = true })
	row[1]:setBackgroundColSpan(4):setColSpan(4):createText(ReadText(1001, 11039) .. ReadText(1001, 120) .. " " .. shipsectorname, { color = Color["text_inactive"] })

	local color = Color["text_inactive"]
	local mouseovertext
	if C.IsComponentBlacklisted(stationsector, "sectortravel", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3253)
		else
			mouseovertext = ColorText["text_warning"] .. ReadText(1026, 3252)
		end
	end
	if C.IsComponentBlacklisted(stationsector, "sectoractivity", blacklistgroup, convertedCurrentShip) then
		color = Color["text_warning"]
		if mouseovertext then
			mouseovertext = mouseovertext .. "\n"
		else
			mouseovertext = ""
		end
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. ColorText["text_warning"] .. ReadText(1026, 3255)
		else
			mouseovertext = mouseovertext .. ColorText["text_warning"] .. ReadText(1026, 3254)
		end
	end
	if mouseovertext then
		if convertedCurrentShip and (convertedCurrentShip ~= 0) then
			mouseovertext = mouseovertext .. "\27X\n" .. ReadText(1026, 3258)
		end
	end
	row[5]:setColSpan(5):createText(ffi.string(C.GetComponentName(stationsector)), { halign = "center", color = color, mouseOverText = mouseovertext })

	-- table header
	local hasshiptargetamounts = false
	local hasothershipttargetamounts = false
	for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
		local shiptargetamount = 0
		if menu.contextMenuData.currentShip ~= 0 then
			shiptargetamount = GetWareProductionLimit(menu.contextMenuData.currentShip, waredata.ware)
		end
		if shiptargetamount > 0 then
			hasshiptargetamounts = true
			if hasothershipttargetamounts then
				break
			end
		end
		local othershiptargetamount = GetWareProductionLimit(ConvertStringTo64Bit(tostring(menu.contextMenuData.component)), waredata.ware)
		if othershiptargetamount > 0 then
			hasothershipttargetamounts = true
			if hasshiptargetamounts then
				break
			end
		end
	end

	local headerproperties = { font = Helper.standardFontBold, cellBGColor = Color["row_background"], titleColor = Color["row_title"] }
	local row = shiptable:addRow(nil, { fixed = true })
	if menu.contextMenuData.wareexchange then
		row[1]:setColSpan(2):setBackgroundColSpan(1):createText(ReadText(1001, 45), headerproperties)
		row[3]:createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), headerproperties)
		row[4]:setColSpan(2):createText(" ", headerproperties)
		row[6]:setColSpan(2):createText(((C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 5)) or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 3)) or ReadText(1001, 9426)) .. (hasothershipttargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), headerproperties)
		row[8]:setColSpan(2):createText(" ", headerproperties)
	else
		row[1]:setBackgroundColSpan(1):createText(ReadText(1001, 45), headerproperties)
		row[2]:createText(ReadText(1001, 2808), headerproperties)
		row[3]:createText(ReadText(1001, 5) .. (hasshiptargetamounts and (" (" .. ReadText(1001, 2903) .. ")") or ""), headerproperties)
		row[4]:setColSpan(2):createText(" ", headerproperties)
		row[6]:setColSpan(2):createText(ReadText(1001, 8308), headerproperties)
		row[8]:setColSpan(2):createText(ReadText(1001, 8309), headerproperties)
	end

	-- line
	local row = shiptable:addRow(nil, { fixed = true, bgColor = Color["row_separator"] })
	row[1]:setColSpan(9):createText("", { fontsize = 1, height = 1 })

	-- ware list
	local warningcontent = {}
	local pricemodifiers = {}
	local warningcolor = Color["text_error"]

	local maxVisibleHeight

	if #menu.contextMenuData.waredatalist == 0 then
		menu.selectedTradeWare = nil
		local row = shiptable:addRow(nil, {  })
		row[1]:setColSpan(9):createText(menu.contextMenuData.wareexchange and ReadText(1001, 8310) or ReadText(1001, 8311))
	else
		-- check selectedTradeWare
		local tradewarefound = false
		if menu.selectedTradeWare then
			for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
				if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) then
					tradewarefound = true
					break
				end
			end
			if not tradewarefound then
				menu.selectedTradeWare = nil
			end
		end

		local reservations, missionreservations = {}, {}
		local n = C.GetNumContainerWareReservations2(menu.contextMenuData.component, true, true, true)
		local buf = ffi.new("WareReservationInfo2[?]", n)
		n = C.GetContainerWareReservations2(buf, n, menu.contextMenuData.component, true, true, true)
		for i = 0, n - 1 do
			if (buf[i].missionid ~= 0) or (not buf[i].isvirtual) then
				local ware = ffi.string(buf[i].ware)
				local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
				local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
				local reservationref = (buf[i].missionid ~= 0) and missionreservations or reservations
				if reservationref[ware] then
					table.insert(reservationref[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid })
				else
					reservationref[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, mission = buf[i].missionid } }, [invbuyflag] = {} }
				end
			end
		end
		for _, data in pairs(reservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end
		for _, data in pairs(missionreservations) do
			table.sort(data.buyoffer, menu.etaSorter)
			table.sort(data.selloffer, menu.etaSorter)
		end

		for i, waredata in ipairs(menu.contextMenuData.waredatalist) do
			local content = menu.getTradeContextRowContent(waredata)

			local row = shiptable:addRow({ ware = waredata.ware, mission = waredata.mission, issupply = waredata.issupply }, {  })
			local callback = menu.getAmmoTypeNameByWare(waredata.ware) and menu.slidercellShipAmmo or menu.slidercellShipCargo
			if menu.contextMenuData.wareexchange then
				row[1]:setColSpan(2):createText(content[1].text, { color = content[1].color })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end
				waredata.sellcol = 6
				row[6]:setColSpan(2):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
			else
				row[1]:createText(content[1].text, { color = content[1].color, mouseOverText = content[1].mouseover })
				row[2]:createText(content[2].text, { color = content[2].color, halign = "right", mouseOverText = content[2].mouseover })
				row[3]:createText(content[3].text, { color = content[3].color, halign = "right" })
				row[4]:setColSpan(2):createSliderCell({ start = content[4].scale.start, min = content[4].scale.min, minSelect = content[4].scale.minselect, max = content[4].scale.max, maxSelect = content[4].scale.maxselect, step = content[4].scale.step, suffix = content[4].scale.suffix, fromCenter = content[4].scale.fromcenter, rightToLeft = content[4].scale.righttoleft, height = Helper.standardTextHeight })
				row[4].handlers.onSliderCellChanged = function (_, value) return callback(waredata.sell and waredata.sell.id, waredata.buy and waredata.buy.id, waredata.ware, 0, value) end
				row[4].handlers.onSliderCellConfirm = function () return menu.slidercellTradeConfirmed(waredata.ware) end

				local reservationref = waredata.mission and missionreservations or reservations
				local colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].selloffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].selloffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and ColorText["text_mission"] or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[6]:createIcon("menu_hourglass", { color = waredata.mission and Color["text_mission"] or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.sellcol = 8 - colspan
				row[8 - colspan]:setColSpan(colspan):createText(content[6].text, { color = content[6].color, halign = "right", mouseOverText = content[6].mouseover })
				colspan = 2
				if reservationref[waredata.ware] and (#reservationref[waredata.ware].buyoffer > 0) then
					local mouseovertext = ""
					for i, reservation in ipairs(reservationref[waredata.ware].buyoffer) do
						if (not waredata.mission) or (waredata.mission == reservation.mission) then
							local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
							if isplayerowned or isplayertradeoffercontainer then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n"
								end
								local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
								mouseovertext = mouseovertext .. name .. " - " .. (waredata.mission and ColorText["text_mission"] or "") .. ReadText(1001, 1202) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(reservation.amount, true, 0, true) .. "\27X"
							end
						end
					end
					if mouseovertext ~= "" then
						colspan = 1
						mouseovertext = ReadText(1001, 7946) .. ReadText(1001, 120) .. "\n" .. mouseovertext
						row[8]:createIcon("menu_hourglass", { color = waredata.mission and Color["text_mission"] or nil, height = config.mapRowHeight, mouseOverText = mouseovertext })
					end
				end
				waredata.buycol = 10 - colspan
				row[10 - colspan]:setColSpan(colspan):createText(content[7].text, { color = content[7].color, halign = "right" })
			end

			if not menu.selectedRows.contextshiptable then
				if (waredata.sell and IsSameTrade(waredata.sell.id, menu.contextMenuData.tradeid)) or (waredata.buy and IsSameTrade(waredata.buy.id, menu.contextMenuData.tradeid)) then
					menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission, issupply = waredata.issupply }
					menu.topRows.contextshiptable = math.min(4 + i, 4 + #menu.contextMenuData.waredatalist - (menu.tradeContext.warescrollwindowsize - 1))
					shiptable:setSelectedRow(row.index)
				end
			end
			if not menu.selectedTradeWare then
				menu.selectedTradeWare = { ware = waredata.ware, mission = waredata.mission, issupply = waredata.issupply }
			end
			if (waredata.ware == menu.selectedTradeWare.ware) and (waredata.mission == menu.selectedTradeWare.mission) and (waredata.issupply == menu.selectedTradeWare.issupply) then
				warningcontent = content[8]
				if waredata.ware == menu.showOptionalWarningWare then
					if (content[4].scale.start ~= 0) and (content[4].scale.start == content[4].scale.maxselect) then
						warningcontent = content[9]
						warningcolor = Color["text_warning"]
					elseif (content[4].scale.start ~= 0) and (content[4].scale.start == content[4].scale.minselect) then
						warningcontent = content[10]
						warningcolor = Color["text_warning"]
					else
						menu.showOptionalWarningWare = nil
					end
				end

				pricemodifiers = content[11]
			end

			if i == menu.tradeContext.warescrollwindowsize then
				maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	end

	shiptable.properties.maxVisibleHeight = maxVisibleHeight or shiptable:getFullHeight()

	shiptable:setTopRow(menu.topRows.contextshiptable)
	if menu.selectedRows.contextshiptable then
		shiptable:setSelectedRow(menu.selectedRows.contextshiptable)
	end
	menu.topRows.contextshiptable = nil
	menu.selectedRows.contextshiptable = nil

	-- info and buttons
	-- the button table is split into left and right side below the "zero" position of the sliders
	local columnwidth_bottomleft		= columnwidth_ware + columnwidth_price + columnwidth_shipstorage + columnwidth_sliderleft + 3 * Helper.borderSize
	local columnwidth_bottomright		= columnwidth_sliderright + columnwidth_selloffer + columnwidth_buyoffer + 2 * Helper.borderSize
	-- trade menu case:
	-- split bottom right twice: Once into 2/3 + 1/3 for money output, and 1/2 + 1/2 for the buttons
	-- A-----------------------------------------B------------C----D--------E
	-- | Ship storage details  (bottomleft)      | Profits:        | 100 Cr |
	-- +-----------------------------------------+------------+----+--------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------------+------------+----+--------+
	local columnwidth_br_leftoutput		= math.floor((columnwidth_bottomright - Helper.borderSize) * 2 / 3)			-- BD
	local columnwidth_br_rightoutput	= columnwidth_bottomright - columnwidth_br_leftoutput - Helper.borderSize	-- DE
	local columnwidth_br_leftbutton		= math.floor((columnwidth_bottomright - Helper.borderSize) / 2)				-- BC
	local columnwidth_br_rightbutton	= columnwidth_bottomright - columnwidth_br_leftbutton - Helper.borderSize	-- CE
	local columnwidth_br_bottomoverlap	= columnwidth_bottomright - columnwidth_br_leftbutton - columnwidth_br_rightoutput - 2 * Helper.borderSize			-- CD
	-- ware exchange menu case:
	-- "zero" position is in the center. Split bottom right twice, so that each button occupies ca. 20% of the width (40% together)
	-- A-----------------------------------B-----C------------D-------------E
	-- | Ship storage details (bottomleft) | Other ship storage details     |
	-- +-----------------------------------+-----+------------+-------------+
	-- |                                         | LeftButton | RightButton |
	-- +-----------------------------------+-----+------------+-------------+
	local columnwidth_wx_br_leftbutton	= math.floor((columnwidth_bottomright - 2 * Helper.borderSize) * 2 / 5)		-- CD
	local columnwidth_wx_br_rightbutton	= columnwidth_wx_br_leftbutton												-- DE
	local columnwidth_wx_br_leftspacing	= columnwidth_bottomright - columnwidth_wx_br_leftbutton - columnwidth_wx_br_rightbutton - 2 * Helper.borderSize	-- BC

	local showdiscountinfo = (not menu.contextMenuData.wareexchange) and (not isplayertradeoffercontainer)
	local numcols = showdiscountinfo and 6 or 4
	local coloffset = showdiscountinfo and 2 or 0
	menu.tradeContext.coloffset = coloffset
	local buttontable = frame:addTable(numcols, { tabOrder = 3, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width, reserveScrollBar = false })
	if showdiscountinfo then
		buttontable:setColWidth(1, 2 * math.floor(columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(2, math.floor(0.6 * columnwidth_bottomleft / 3) - 2 * Helper.borderSize, false)
		buttontable:setColWidth(3, math.floor(0.4 * columnwidth_bottomleft / 3), false)
		buttontable:setColWidth(4, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(5, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(6, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 2)
		buttontable:setDefaultBackgroundColSpan(4, 3)
	elseif menu.contextMenuData.wareexchange then
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_wx_br_leftspacing, false)
		buttontable:setColWidth(3, columnwidth_wx_br_leftbutton,  false)
		buttontable:setColWidth(4, columnwidth_wx_br_rightbutton, false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	else
		buttontable:setColWidth(1, columnwidth_bottomleft, false)
		buttontable:setColWidth(2, columnwidth_br_leftbutton,     false)
		buttontable:setColWidth(3, columnwidth_br_bottomoverlap,  false)
		buttontable:setColWidth(4, columnwidth_br_rightoutput,    false)
		buttontable:setDefaultBackgroundColSpan(2, 3)
	end

	-- line
	local row = buttontable:addRow(nil, { fixed = true, bgColor = Color["row_separator"] })
	row[1]:setColSpan(numcols):createText("", { fontsize = 1, height = 1 })

	-- rows
	local headerrow = buttontable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	local inforows = {}
	local warningrows = {}
	for i = 1, menu.tradeContext.numinforows do
		inforows[i] = buttontable:addRow(nil, { fixed = true })
	end
	local headerrow2 = buttontable:addRow(nil, { fixed = true })
	for i = 1, menu.tradeContext.numwarningrows do
		warningrows[i] = buttontable:addRow(i == menu.tradeContext.numwarningrows, { fixed = true })
	end

	-- storage details
	local storagecontent = menu.getTradeContextShipStorageContent()
	local storageheader = #storagecontent > 0 and ReadText(1001, 11654) or ReadText(1001, 11655)
	for i, content in ipairs(storagecontent) do
		if i <= menu.tradeContext.numinforows then
			inforows[i][1]:createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
		end
	end

	-- warnings
	local i = 0
	if not candock then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6211), { color = Color["text_error"] })
		end
	end
	if missingdrones then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 2978), { color = Color["text_error"] })
		end
	end

	for _, content in pairs(warningcontent) do
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(content, { color = warningcolor, wordwrap = true })
		end
	end

	if isplayertraderestricted then
		i = i + 1
		if i <= menu.tradeContext.numwarningrows then
			warningrows[i][1]:createText(ReadText(1001, 6212), { color = Color["text_warning"] })
		end
	end

	local confirmbuttonactive = false
	if candock and (not missingdrones) then
		for _, amount in pairs(menu.contextMenuData.orders) do
			if amount ~= 0 then
				confirmbuttonactive = true
				break
			end
		end
	end

	local header2properties = { halign = "center", font = Helper.standardFontBold, cellBGColor = Color["row_background"], titleColor = Color["row_title"] }
	if menu.contextMenuData.wareexchange then
		local otherstoragecontent = menu.getTradeContextShipStorageContent(true)
		local otherstorageheader = #otherstoragecontent > 0 and
			(
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 11654))
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 11656))
				or ReadText(1001, 11658)
			)
			or (
				(C.IsComponentClass(menu.contextMenuData.component, "ship") and ReadText(1001, 11655))
				or (C.IsComponentClass(menu.contextMenuData.component, "station") and ReadText(1001, 11657))
				or ReadText(1001, 11659)
			)

		-- header
		headerrow[1]:createText(storageheader, header2properties)
		headerrow[2]:setColSpan(3):createText(otherstorageheader, header2properties)

		-- other ship info
		for i = 1, menu.tradeContext.numinforows do
			local content = otherstoragecontent[i]
			if content then
				inforows[i][2]:setColSpan(3):createSliderCell({ min = content.scale.min, max = content.scale.max, start = content.scale.start, step = content.scale.step, suffix = content.scale.suffix, readOnly = content.scale.readonly, height = Helper.standardTextHeight }):setText(content.name, { color = content.color })
			end
		end

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", header2properties)

		-- buttons
		warningrows[menu.tradeContext.numwarningrows][3]:createButton({ active = confirmbuttonactive, height = Helper.standardTextHeight }):setText(ReadText(1001, 2821), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3].handlers.onClick = menu.buttonConfirmTrade
		warningrows[menu.tradeContext.numwarningrows][3].properties.uiTriggerID = "confirmtrade"
		warningrows[menu.tradeContext.numwarningrows][4]:createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 64), { halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][4].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][4].properties.uiTriggerID = "canceltrade"
	else
		-- profits from sales
		local profit = menu.contextMenuData.referenceprofit
		local profitcolor = Color["text_normal"]
		if profit < 0 then
			profitcolor = Color["text_negative"]
		elseif profit > 0 then
			profitcolor = Color["text_positive"]
		end
		inforows[menu.tradeContext.numinforows - 1][2 + coloffset]:createText(ReadText(1001, 8305) .. ReadText(1001, 120))
		inforows[menu.tradeContext.numinforows - 1][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(profit, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = profitcolor })

		-- transaction value
		local total = menu.contextMenuData.totalbuyprofit - menu.contextMenuData.totalsellcost
		local transactioncolor = Color["text_normal"]
		if total < 0 then
			transactioncolor = Color["text_negative"]
		elseif total > 0 then
			transactioncolor = Color["text_positive"]
		end
		inforows[menu.tradeContext.numinforows][2 + coloffset]:createText(ReadText(1001, 2005) .. ReadText(1001, 120)) -- Transaction value, :
		inforows[menu.tradeContext.numinforows][3 + coloffset]:setColSpan(2):createText(ConvertMoneyString(total, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = transactioncolor })

		-- pricing details
		if showdiscountinfo and (#pricemodifiers > 0) then
			for i, entry in ipairs(pricemodifiers) do
				if i < #pricemodifiers then
					local row
					if i <= menu.tradeContext.numinforows then
						row = inforows[i]
					elseif i == menu.tradeContext.numinforows + 1 then
						row = headerrow2
					elseif i <= menu.tradeContext.numinforows + 1 + menu.tradeContext.numwarningrows - 1 then
						row = warningrows[i - menu.tradeContext.numinforows - 1]
					end
					if row then
						row[2]:createText(entry.text, { x = config.tradeContextMenuInfoBorder })
						row[3]:createText(entry.amount, { x = config.tradeContextMenuInfoBorder, halign = "right" })
					end
				end
			end
			local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
			warningrows[menu.tradeContext.numwarningrows][2]:createText(pricemodifiers[#pricemodifiers].text, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y })
			warningrows[menu.tradeContext.numwarningrows][3]:createText(pricemodifiers[#pricemodifiers].amount, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = Helper.scaleX(config.tradeContextMenuInfoBorder), y = y, halign = "right" })
		end

		-- header
		headerrow[1]:createText(storageheader, header2properties)
		if showdiscountinfo then
			headerrow[2]:setColSpan(2):createText(ReadText(1001, 11653), header2properties)
		end
		headerrow[2 + coloffset]:setColSpan(3):createText(ReadText(1001, 2006), header2properties)

		-- warning header
		headerrow2[1]:createText(next(warningcontent) and ReadText(1001, 8342) or "", header2properties)

		-- buttons
		local y = math.max(0, warningrows[menu.tradeContext.numwarningrows]:getHeight() - Helper.scaleY(Helper.standardTextHeight))
		if (not GetComponentData(menu.contextMenuData.component, "tradesubscription")) and (#menu.contextMenuData.missionoffers == 0) then
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = (menu.contextMenuData.currentShip ~= 0) and C.IsOrderSelectableFor("Player_DockToTrade", menu.contextMenuData.currentShip), scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 7858), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonDockToTrade
		else
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset]:createButton({ active = confirmbuttonactive, helpOverlayID = "map_confirmtrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 2821), { scaling = true, halign = "center" })
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].handlers.onClick = menu.buttonConfirmTrade
			warningrows[menu.tradeContext.numwarningrows][2 + coloffset].properties.uiTriggerID = "confirmtrade"
		end
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset]:setColSpan(2):createButton({ scaling = false, height = Helper.scaleY(Helper.standardTextHeight), y = y }):setText(ReadText(1001, 64), { scaling = true, halign = "center" })
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].handlers.onClick = menu.buttonCancelTrade
		warningrows[menu.tradeContext.numwarningrows][3 + coloffset].properties.uiTriggerID = "canceltrade"
	end

	if buttontable.properties.y + buttontable:getFullHeight() > Helper.viewHeight - frame.properties.y then
		frame.properties.y = Helper.viewHeight - buttontable.properties.y - buttontable:getFullHeight() - Helper.frameBorder
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index
end

function menu.createTradeLoopContext(frame)
	local shiptable = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11273), Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(nil, { fixed = true })
	local name, color = "", Color["text_normal"]
	if C.IsComponentClass(menu.contextMenuData.component, "container") then
		name, color = menu.getContainerNameAndColors(menu.contextMenuData.component, 0, false, false)
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11110 or 11111) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	else
		name = ffi.string(C.GetComponentName(menu.contextMenuData.component))
		row[1]:setColSpan(3):createText(ReadText(1001, (menu.contextMenuData.loop == "SingleBuy") and 11112 or 11113) .. ReadText(1001, 120) .. " " .. Helper.convertColorToText(color) .. name, Helper.headerRowCenteredProperties)
	end

	-- ware list
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11276) .. ReadText(1001, 120))

	local waresinloop = {}
	local maxbought, minsold = {}, {}
	local n = C.GetNumOrders(menu.contextMenuData.currentShip)
	local buf = ffi.new("Order[?]", n)
	n = C.GetOrders(buf, n, menu.contextMenuData.currentShip)
	for i = 0, n - 1 do
		if ffi.string(buf[i].orderdef) == "SingleBuy" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if maxbought[ware] then
						maxbought[ware] = math.max(maxamount, maxbought[ware])
					else
						maxbought[ware] = maxamount
					end
				end
			end
		elseif ffi.string(buf[i].orderdef) == "SingleSell" then
			local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.contextMenuData.currentShip)), i + 1)
			if next(orderparams) then
				local ware
				if orderparams[1].type == "ware" then
					ware = orderparams[1].value
				end
				local maxamount = 0
				if orderparams[5].type == "number" then
					maxamount = math.floor(orderparams[5].value)
				end
				if ware then
					if not waresinloop[ware] then
						waresinloop[ware] = GetWareData(ware, "name")
					end
					if minsold[ware] then
						minsold[ware] = math.min(maxamount, minsold[ware])
					else
						minsold[ware] = maxamount
					end
				end
			end
		end
	end

	local sortedwares = {}
	for ware, name in pairs(waresinloop) do
		table.insert(sortedwares, { ware = ware, name = name })
	end
	table.sort(sortedwares, Helper.sortName)
	if #sortedwares > 0 then
		for i, entry in ipairs(sortedwares) do
			local row = shiptable:addRow(true, {  })
			row[1]:setColSpan(2):createText("   " .. entry.name)
			local availableamount = 0
			if minsold[entry.ware] then
				if maxbought[entry.ware] then
					if minsold[entry.ware] > maxbought[entry.ware] then
						availableamount = maxbought[entry.ware]
					else
						availableamount = minsold[entry.ware]
					end
				end
			elseif maxbought[entry.ware] then
				availableamount = maxbought[entry.ware]
			end
			row[3]:createText(availableamount, { halign = "right" })
			if i == 5 then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end
		end
	else
		local row = shiptable:addRow(true, {  })
		row[1]:setColSpan(2):createText("   ---")
	end

	-- info & buttons
	local buttontable = frame:addTable(4, { tabOrder = 1, x = Helper.borderSize, y = shiptable.properties.y + shiptable:getVisibleHeight(), width = menu.contextMenuData.width })
	local colwidth = math.floor((menu.contextMenuData.width - 2 * Helper.borderSize) / 3)
	local checkboxwidth = Helper.scaleY(Helper.standardTextHeight)
	buttontable:setColWidth(1, checkboxwidth, false)
	buttontable:setColWidth(2, colwidth - checkboxwidth, false)

	-- cargo
	local cargo = GetComponentData(menu.contextMenuData.currentShip, "cargo")
	local extrawares = {}
	for ware, amount in pairs(cargo) do
		if not maxbought[ware] then
			extrawares[ware] = amount
		elseif amount > maxbought[ware] then
			extrawares[ware] = amount - maxbought[ware]
		end
	end

	local transporttypes = menu.getCargoTransportTypes(menu.contextMenuData.currentShip, false)
	for _, transporttype in ipairs(transporttypes) do
		transporttype.usedcargocapacity = 0
		for ware, amount in pairs(maxbought) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		for ware, amount in pairs(extrawares) do
			local transport, volume = GetWareData(ware, "transport", "volume")
			if transporttype.tags[transport] then
				transporttype.usedcargocapacity = transporttype.usedcargocapacity + amount * volume
			end
		end
		transporttype.usedcargocapacity = math.max(0, math.min(transporttype.capacity, transporttype.usedcargocapacity))
		local row = buttontable:addRow(nil, { fixed = true })
		row[1]:setColSpan(4):createSliderCell({ min = 0, max = transporttype.capacity, start = transporttype.usedcargocapacity, step = 1, suffix = ReadText(1001, 110), readOnly = true, height = Helper.standardTextHeight }):setText(ReadText(1001, 11277))
	end

	if menu.contextMenuData.loop == "SingleBuy" then
		-- use ware reservations
		local row = buttontable:addRow(true, { fixed = true })
		menu.contextMenuData.reservecargo = C.GetShipTradeLoopCargoReservationSetting(menu.contextMenuData.currentShip)
		row[1]:createCheckBox(menu.contextMenuData.reservecargo, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, mouseOverText = ReadText(1026, 3275) })
		row[1].handlers.onClick = function () C.SetShipTradeLoopCargoReservationOverride(menu.contextMenuData.currentShip, not menu.contextMenuData.reservecargo); menu.refreshContextFrame() end
		row[2]:setColSpan(3):createText(ReadText(1001, 11641), { mouseOverText = ReadText(1026, 3275) })
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	-- destination
	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 11278))
	row[3]:setColSpan(2):createText(name, { halign = "center" })

	local tradewares, foundwares, currentwareactive = {}, {}
	local tradeoffers = GetTradeList(menu.contextMenuData.component, menu.contextMenuData.currentShip, false)
	for _, tradedata in pairs(tradeoffers) do
		if ((menu.contextMenuData.loop == "SingleBuy") and tradedata.isselloffer) or ((menu.contextMenuData.loop == "SingleSell") and tradedata.isbuyoffer) then
			if not foundwares[tradedata.ware] then
				foundwares[tradedata.ware] = true

				local name, transport = GetWareData(tradedata.ware, "name", "transport")
				local active = C.CanContainerTransport(menu.contextMenuData.currentShip, transport)
				if (tradedata.ware == menu.contextMenuData.ware) and active then
					currentwareactive = true
				end
				table.insert(tradewares, { id = tradedata.ware, text = name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1001, 2969) })
			end
		end
	end
	table.sort(tradewares, function (a, b) return a.text < b.text end)
	if not currentwareactive then
		menu.contextMenuData.ware = nil
	end

	if menu.contextMenuData.loop == "SingleBuy" then
		-- buy ware
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11279))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- buy up to
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11281))
		menu.contextMenuData.max = 1
		if menu.contextMenuData.ware then
			local volume, transport = GetWareData(menu.contextMenuData.ware, "volume", "transport")
			for _, transporttype in ipairs(transporttypes) do
				if transporttype.tags[transport] then
					local capacity = transporttype.capacity
					if menu.contextMenuData.reservecargo then
						capacity = capacity - transporttype.usedcargocapacity
					end
					menu.contextMenuData.max = math.floor(capacity / volume)
					if menu.contextMenuData.reservecargo then
						menu.contextMenuData.max = menu.contextMenuData.max + (maxbought[menu.contextMenuData.ware] or 0)
					end
				end
			end
		end
		local minselect = 1
		if menu.contextMenuData.max == 0 then
			minselect = 0
			menu.contextMenuData.amount = 0
		elseif menu.contextMenuData.amount then
			menu.contextMenuData.amount = math.max(minselect, menu.contextMenuData.amount)
		end
		local start = menu.contextMenuData.amount or menu.contextMenuData.max
		start = math.min(start, menu.contextMenuData.max)
		row[3]:setColSpan(2):createSliderCell({ min = 0, minSelect = minselect, max = menu.contextMenuData.max, start = start, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- max price
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1041, 10059))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	else
		-- sell ware
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11280))
		row[3]:setColSpan(2):createDropDown(tradewares, { startOption = menu.contextMenuData.ware, height = config.mapRowHeight }):setTextProperties({ halign = "center" })
		row[3].handlers.onDropDownConfirmed = function (_, ware) menu.contextMenuData.ware = ware; menu.contextMenuData.amount = nil; menu.contextMenuData.price = nil; menu.refreshContextFrame() end

		-- sell all but
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 11601))
		menu.contextMenuData.max = 0
		if menu.contextMenuData.ware then
			menu.contextMenuData.max = GetWareCapacity(menu.contextMenuData.currentShip, menu.contextMenuData.ware)
		end
		row[3]:setColSpan(2):createSliderCell({ min = 0, max = menu.contextMenuData.max, start = menu.contextMenuData.amount or 0, step = 1, height = Helper.standardTextHeight })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.amount = value end

		-- min price
		local row = buttontable:addRow(true, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1041, 10070))
		local avgprice, minprice, maxprice = 0, 0, 0
		if menu.contextMenuData.ware then
			avgprice, minprice, maxprice = GetWareData(menu.contextMenuData.ware, "avgprice", "minprice", "maxprice")
		end
		row[3]:setColSpan(2):createSliderCell({ min = minprice, max = maxprice, start = menu.contextMenuData.price or avgprice, step = 1, height = Helper.standardTextHeight, suffix = ReadText(1001, 101), hideMaxValue = true })
		row[3].handlers.onSliderCellChanged = function (_, value) menu.contextMenuData.price = value end
	end

	buttontable:addEmptyRow(config.mapRowHeight / 2)

	local row = buttontable:addRow(true, { fixed = true })
	local active = true
	local mouseovertext = ""
	if menu.contextMenuData.ware == nil then
		active = false
		mouseovertext = ReadText(1026, 3260)
	elseif (menu.contextMenuData.loop == "SingleBuy") and (menu.contextMenuData.amount == 0) then
		active = false
		mouseovertext = ColorText["text_error"] .. ReadText(1001, 1605)
	end
	row[1]:setColSpan(2):createButton({ active = active, mouseOverText = mouseovertext }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmTradeLoop
	row[4]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[4].handlers.onClick = function () return menu.closeContextMenu("back") end

	if menu.contextselectedrow then
		buttontable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - Helper.frameBorder
	end
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.initCrewTransferData()
	menu.contextMenuData.crew = { left = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.leftShip, "", false), transferList = {} }, right = { total = 0, moved = 0, capacity = C.GetPeopleCapacity(menu.contextMenuData.rightShip, "", false), transferList = {} }, exchangeCaptains = false }
	menu.contextMenuData.crew.right.isplayerowned = true
	if C.IsComponentClass(menu.contextMenuData.rightShip, "station") then
		local isshipyard, iswharf, isequipmentdock, isplayerowned = GetComponentData(menu.contextMenuData.rightShip, "isshipyard", "iswharf", "isequipmentdock", "isplayerowned")
		menu.contextMenuData.crew.right.isstation = true
		menu.contextMenuData.crew.right.isplayerowned = isplayerowned
		if isshipyard or iswharf or isequipmentdock then
			menu.contextMenuData.crew.right.hasshiptraderpost = true
		end
		menu.contextMenuData.crew.right.canhavetrainees = C.CanControllableHaveAnyTrainees(menu.contextMenuData.rightShip)
	end
	local isrightassignmentrestricted = GetComponentData(menu.contextMenuData.rightShip, "isnpcassignmentrestricted")
	menu.contextMenuData.crew.right.canassignpilot = (not menu.contextMenuData.crew.right.isstation) and (not isrightassignmentrestricted)

	local missionnpcrequirements = {}
	menu.contextMenuData.rightMissionOffers = {}
	local numskills = C.GetNumSkills()
	if menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.isplayerowned) then
		-- mission npc requirements
		local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.rightShip)
		local buf = ffi.new("MissionNPCInfo[?]", n)
		for i = 0, n - 1 do
			buf[i].numskills = numskills
			buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
		end
		n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.rightShip)
		for i = 0, n - 1 do
			local skills = {}
			for j = 0, buf[i].numskills - 1 do
				table.insert(skills, { id = ffi.string(buf[i].skills[j].id), value = buf[i].skills[j].value })
			end
			local missionid = ConvertStringTo64Bit(tostring(buf[i].missionid))
			local amount = buf[i].amount
			table.insert(missionnpcrequirements, { missionid = missionid, amount = amount, requiredskills = skills })
			menu.contextMenuData.rightMissionOffers[tostring(missionid)] = { amount = amount, transferred = 0 }
		end
	end

	-- virtual crew
	local leftvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.leftShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.leftShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local name = ffi.string(buf[i].name)
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		local arrived = C.HasPersonArrived(menu.contextMenuData.leftShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.leftShip, seed))
		local missionids = menu.checkMissionNPCRequirement(missionnpcrequirements, menu.contextMenuData.leftShip, seed, numskills)

		if menu.contextMenuData.crew.right.isplayerowned or (#missionids > 0) then
			if leftvirtualpeople[role] then
				if leftvirtualpeople[role][tier] then
					table.insert(leftvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids })
					if arrived then
						leftvirtualpeople[role][tier].numarrived = leftvirtualpeople[role][tier].numarrived + 1
					end
				else
					leftvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } }
				end
			else
				leftvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived, missionids = missionids } } }
			end
		end
	end
	local rightvirtualpeople = {}
	local n = C.GetNumPeopleAfterOrders(menu.contextMenuData.rightShip, 0)
	local buf = ffi.new("NPCInfo[?]", n)
	n = C.GetPeopleAfterOrders(buf, n, menu.contextMenuData.rightShip, 0)
	for i = 0, n - 1 do
		local seed = buf[i].seed
		local name = ffi.string(buf[i].name)
		local role = ffi.string(buf[i].roleid)
		local tier = buf[i].tierid
		local skill = math.floor(buf[i].combinedskill * 15 / 100)
		if menu.contextMenuData.crew.right.canhavetrainees and (role == "trainee_group") then
			role = "marine"
			tier = C.GetPersonTier(seed, role, menu.contextMenuData.rightShip)
			skill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, role, nil) * 15 / 100)
		end
		local arrived = C.HasPersonArrived(menu.contextMenuData.rightShip, seed) and (not C.IsPersonTransferScheduled(menu.contextMenuData.rightShip, seed))

		if rightvirtualpeople[role] then
			if rightvirtualpeople[role][tier] then
				table.insert(rightvirtualpeople[role][tier], { seed = seed, name = name, skill = skill, arrived = arrived })
				if arrived then
					rightvirtualpeople[role][tier].numarrived = rightvirtualpeople[role][tier].numarrived + 1
				end
			else
				rightvirtualpeople[role][tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } }
			end
		else
			rightvirtualpeople[role] = { [tier] = { numarrived = arrived and 1 or 0, { seed = seed, name = name, skill = skill, arrived = arrived } } }
		end
	end

	-- left crew
	local numroles = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numroles)
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.leftShip, true)
	local index = 1
	for i = 0, numroles - 1 do
		local role = ffi.string(peopletable[i].id)
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			menu.contextMenuData.crew[index] = { id = role, name = ffi.string(peopletable[i].name), tiers = {} }

			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.leftShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1] = { name = ffi.string(tiertable[j].name), skilllevel = tiertable[j].skilllevel, left = { amount = virtualpeopleentry.numarrived, persons = {}, moved = {} }, right = { amount = 0, persons = {}, moved = {} } }
				menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].left.persons, entry)
				end
			end

			index = index + 1
		elseif role == "unassigned" then
			local name = ffi.string(peopletable[i].name)
			menu.contextMenuData.crew[index] = { id = role, name = name, tiers = {} }

			local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }

			menu.contextMenuData.crew[index].tiers[1] = { name = name, skilllevel = 0, left = { amount = virtualpeopleentry.numarrived, persons = {}, moved = {} }, right = { amount = 0, persons = {}, moved = {} } }
			menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry

			for k, entry in ipairs(virtualpeopleentry) do
				table.insert(menu.contextMenuData.crew[index].tiers[1].left.persons, entry)
			end

			index = index + 1
		else
			local virtualpeopleentry = leftvirtualpeople[role] and (leftvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }
			menu.contextMenuData.crew.left.total = menu.contextMenuData.crew.left.total + #virtualpeopleentry
		end
	end
	-- right crew
	numroles = C.GetPeople2(peopletable, numroles, menu.contextMenuData.rightShip, true)
	index = 1
	for i = 0, numroles - 1 do
		local role = ffi.string(peopletable[i].id)
		local numtiers = peopletable[i].numtiers
		if numtiers > 0 then
			role = menu.contextMenuData.crew[index].id
			local tiertable = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(tiertable, numtiers, menu.contextMenuData.rightShip, role)
			for j = 0, numtiers - 1 do
				local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][tiertable[j].skilllevel] or { numarrived = 0 }) or { numarrived = 0 }

				menu.contextMenuData.crew[index].tiers[j + 1].right.amount = virtualpeopleentry.numarrived
				menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry

				for k, entry in ipairs(virtualpeopleentry) do
					table.insert(menu.contextMenuData.crew[index].tiers[j + 1].right.persons, entry)
				end
			end

			index = index + 1
		elseif role == "unassigned" then
			local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }

			menu.contextMenuData.crew[index].tiers[1].right.amount = virtualpeopleentry.numarrived
			menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry

			for k, entry in ipairs(virtualpeopleentry) do
				table.insert(menu.contextMenuData.crew[index].tiers[1].right.persons, entry)
			end

			index = index + 1
		else
			local virtualpeopleentry = rightvirtualpeople[role] and (rightvirtualpeople[role][0] or { numarrived = 0 }) or { numarrived = 0 }
			menu.contextMenuData.crew.right.total = menu.contextMenuData.crew.right.total + #virtualpeopleentry
		end
	end
	-- sorting
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			table.sort(tierentry.left.persons, menu.crewTransferSorter)
			table.sort(tierentry.right.persons, menu.crewTransferSorter)
		end
	end
end

function menu.createCrewTransferContext(frame)
	local numberwidth = 50
	local separatorwidth = 2
	local namewidth = 0.35 * menu.contextMenuData.width - 2 * Helper.scaleY(Helper.standardTextHeight) - Helper.scaleX(numberwidth) - separatorwidth / 2 - 5 * Helper.borderSize
	local numListRows = 8

	-- warnings and buttons
	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, width = menu.contextMenuData.width })
	buttontable:setColWidthPercent(2, 25)
	buttontable:setColWidthPercent(3, 25)

	local leftname, lefticon =  GetComponentData(menu.contextMenuData.leftShip, "name", "icon")
	local rightname, righticon =  GetComponentData(menu.contextMenuData.rightShip, "name", "icon")

	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 1) end, { halign = "right", color = Color["text_error"] })
	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(function () return menu.crewTransferWarningText(leftname, rightname, 2) end, { halign = "right", color = Color["text_error"] })

	local row = buttontable:addRow(true, { fixed = true })
	row[2]:createButton({ active = menu.crewTransferAllowed }):setText(ReadText(1001, 2821), { halign = "center" })
	row[2].handlers.onClick = menu.buttonCrewTransferConfirm
	row[3]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.closeContextMenu("back") end

	local shiptable = frame:addTable(11, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	shiptable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(2, namewidth, false)
	shiptable:setColWidth(3, numberwidth)
	shiptable:setColWidthPercent(4, 15)
	shiptable:setColWidth(5, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidth(6, separatorwidth, false)
	shiptable:setColWidth(7, Helper.scaleY(Helper.standardTextHeight), false)
	shiptable:setColWidthPercent(8, 15)
	shiptable:setColWidth(9, numberwidth)
	shiptable:setColWidth(11, Helper.scaleY(Helper.standardTextHeight), false)

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(11):createText(ReadText(1001, 8385), Helper.headerRowCenteredProperties)

	-- ships
	local row = shiptable:addRow(nil, { fixed = true })
	local leftShipName = "\27[" .. lefticon .. "] " .. leftname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.leftShip)) .. ")"
	row[1]:setColSpan(5):createText(leftShipName, { halign = "center", color = Color["text_player"], font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })
	local rightShipName = "\27[" .. righticon .. "] " .. rightname .. " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.rightShip)) .. ")"
	row[7]:setColSpan(5):createText(rightShipName, { halign = "center", color = menu.contextMenuData.crew.right.isplayerowned and Color["text_player"] or Color["text_normal"], font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety })

	shiptable:addEmptyRow(config.mapRowHeight / 2)

	menu.contextMenuData.crew.left.captain = GetComponentData(menu.contextMenuData.leftShip, "assignedaipilot")
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.left.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.left.captain)
	end

	if menu.contextMenuData.crew.right.isplayerowned then
		-- captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.right.isstation then
			row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			row[7]:setColSpan(5):createText(ReadText(20208, 30301), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
		else
			row[1]:setColSpan(11):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
		end

		if menu.contextMenuData.crew.right.isstation then
			local tradenpc, shiptrader = GetComponentData(menu.contextMenuData.rightShip, "tradenpc", "shiptrader")
			menu.contextMenuData.crew.right.manager = tradenpc
			if menu.contextMenuData.crew.right.manager then
				menu.contextMenuData.crew.right.manager = ConvertIDTo64Bit(menu.contextMenuData.crew.right.manager)
			end
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				menu.contextMenuData.crew.right.shiptrader = shiptrader
				if menu.contextMenuData.crew.right.shiptrader then
					menu.contextMenuData.crew.right.shiptrader = ConvertIDTo64Bit(menu.contextMenuData.crew.right.shiptrader)
				end
			end
		else
			menu.contextMenuData.crew.right.captain = GetComponentData(menu.contextMenuData.rightShip, "assignedaipilot")
			if menu.contextMenuData.crew.right.captain then
				menu.contextMenuData.crew.right.captain = ConvertIDTo64Bit(menu.contextMenuData.crew.right.captain)
			end
		end

		-- current captains
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Color["text_inactive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_inactive"] })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Color["text_inactive"] })
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.manager then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.manager, nil, "manager") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.manager)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11255), { halign = "right", color = Color["text_inactive"] })
			end
		else
			if menu.contextMenuData.crew.right.captain then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11232), { halign = "right", color = Color["text_inactive"] })
			end
		end
		-- reassign captains
		local row = shiptable:addRow(true, { fixed = true })
		if not menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.canassignpilot then
			row[1]:createCheckBox(function () return menu.contextMenuData.crew.left.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.right.captain) })
			row[1].handlers.onClick = function () return menu.checkboxAssignCaptain("left") end
			row[2]:setColSpan(4):createText(menu.contextMenuData.crew.left.captain and ReadText(1001, 11234) or ReadText(1001, 11233))
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.right.isstation then
			if not menu.contextMenuData.crew.right.manager then
				row[7]:setColSpan(4):createText(ReadText(1001, 11256), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceCaptain = not menu.contextMenuData.crew.right.replaceCaptain; menu.checkForNewCaptains() end
			end
		elseif menu.contextMenuData.crew.right.canassignpilot then
			row[7]:setColSpan(4):createText(menu.contextMenuData.crew.right.captain and ReadText(1001, 11234) or ReadText(1001, 11233), { halign = "right" })
			row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceCaptain or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight, active = (not menu.contextMenuData.crew.exchangeCaptains) or (not menu.contextMenuData.crew.left.captain) })
			row[11].handlers.onClick = function () return menu.checkboxAssignCaptain("right") end
		end
		-- new captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.right.captain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.captain)), { color = Color["text_positive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_positive"] })
		elseif menu.contextMenuData.crew.left.newCaptain then
			-- sic! New captain on the left comes from the right ship!
			row[1]:setColSpan(3):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.left.newCaptain, menu.contextMenuData.rightShip)) or "" end, { color = Color["text_positive"] })
			row[4]:createText(function () return menu.contextMenuData.crew.left.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot") * 15 / 100) or "" end, { halign = "right", color = Color["text_positive"] })
		else
			row[1]:setColSpan(5):createText(function () return menu.contextMenuData.crew.left.replaceCaptain and ReadText(1001, 11235) or "" end, { color = Color["text_negative"] })
		end

		row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })

		if menu.contextMenuData.crew.exchangeCaptains and menu.contextMenuData.crew.left.captain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { color = Color["text_positive"] })
			row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { halign = "right", color = Color["text_positive"] })
		elseif menu.contextMenuData.crew.right.newCaptain then
			-- sic! New captain on the right comes from the left ship!
			row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" or "aipilot") * 15 / 100) or "" end, { color = Color["text_positive"] })
			row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newCaptain, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Color["text_positive"] })
		else
			row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceCaptain and ReadText(1001, 11235) or "" end, { halign = "right", color = Color["text_negative"] })
		end
		if ((menu.contextMenuData.crew.left.captain ~= nil) or (menu.contextMenuData.crew.right.captain ~= nil)) and (not menu.contextMenuData.crew.right.isstation) and menu.contextMenuData.crew.right.canassignpilot then
			-- exchange captains
			local row = shiptable:addRow(true, { fixed = true })
			row[1]:createCheckBox(menu.contextMenuData.crew.exchangeCaptains, {  })
			row[1].handlers.onClick = menu.checkboxCrewExchangeCaptains
			row[2]:setColSpan(4):createText(ReadText(1001, 11639))
		end

		-- shiptrader
		if menu.contextMenuData.crew.right.hasshiptraderpost then
			local row = shiptable:addRow(nil, { fixed = true })
			row[7]:setColSpan(5):createText(ReadText(20208, 30501), Helper.subHeaderTextProperties)
			row[7].properties.halign = "center"
			-- current ship trader
			local row = shiptable:addRow(nil, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if menu.contextMenuData.crew.right.shiptrader then
				row[8]:setColSpan(2):createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.right.shiptrader, nil, "shiptrader") * 15 / 100), { color = Color["text_inactive"] })
				row[10]:setColSpan(2):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.right.shiptrader)), { halign = "right", color = Color["text_inactive"] })
			else
				row[10]:setColSpan(2):createText(ReadText(1001, 11260), { halign = "right", color = Color["text_inactive"] })
			end
			-- reassign ship trader
			local row = shiptable:addRow(true, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if not menu.contextMenuData.crew.right.shiptrader then
				row[7]:setColSpan(4):createText(ReadText(1001, 11261), { halign = "right" })
				row[11]:createCheckBox(function () return menu.contextMenuData.crew.right.replaceShiptrader or false end, { height = Helper.standardTextHeight, width = Helper.standardTextHeight })
				row[11].handlers.onClick = function (id) menu.contextMenuData.crew.right.replaceShiptrader = not menu.contextMenuData.crew.right.replaceShiptrader; menu.checkForNewCaptains() end
			end
			-- new ship trader
			local row = shiptable:addRow(nil, { fixed = true })
			row[6]:createText("", { cellBGColor = Color["row_separator_white"], x = 0 })
			if menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				row[8]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and Helper.displaySkill(C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader") * 15 / 100) or "" end, { color = Color["text_positive"] })
				row[10]:setColSpan(2):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ffi.string(C.GetPersonName(menu.contextMenuData.crew.right.newShiptrader, menu.contextMenuData.leftShip)) or "" end, { halign = "right", color = Color["text_positive"] })
			else
				row[7]:setColSpan(5):createText(function () return menu.contextMenuData.crew.right.replaceShiptrader and ReadText(1001, 11235) or "" end, { halign = "right", color = Color["text_negative"] })
			end
		end

		-- roles
		if (not menu.contextMenuData.crew.right.isstation) or menu.contextMenuData.crew.right.canhavetrainees then
			for i, roleentry in ipairs(menu.contextMenuData.crew) do
				-- title
				local row = shiptable:addRow(nil, { fixed = true })
				if menu.contextMenuData.crew.right.canhavetrainees then
					row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
					row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
					row[7].properties.halign = "center"
				else
					row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
				end

				-- tiers
				for j, tierentry in ipairs(roleentry.tiers) do
					local color = Color["text_normal"]
					if (tierentry.left.amount == 0) and (tierentry.right.amount == 0) then
						color = Color["text_inactive"]
					end

					local row = shiptable:addRow(true, { fixed = true })
					row[1]:setColSpan(2):createText(tierentry.name, { color = color })
					row[3]:createText(function () return tierentry.left.amount - #tierentry.left.moved + #tierentry.right.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("left", tierentry, color) end })
					row[4]:setColSpan(5):createSliderCell({ start = #tierentry.right.moved - #tierentry.left.moved, min = -tierentry.left.amount, max = tierentry.right.amount, step = 1, fromCenter = true, rightToLeft = true, height = Helper.standardTextHeight })
					row[4].handlers.onSliderCellChanged = function (_, value) return menu.slidercellCrewTransfer(i, j, value) end
					row[4].handlers.onSliderCellConfirm = menu.checkForNewCaptains
					row[9]:createText(function () return tierentry.right.amount - #tierentry.right.moved + #tierentry.left.moved end, { halign = "right", color = function () return menu.crewTransferColorHelper("right", tierentry, color) end })
				end
			end

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- total
			local row = shiptable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 2637))
			row[3]:createText(function () return menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("left") end })
			row[4]:setColSpan(5):createText("/ " .. menu.contextMenuData.crew.left.capacity, { x = 0 })
			row[9]:createText(function () return menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved end, { halign = "right", color = function () return menu.crewTransferTotalColor("right") end })
			row[10]:setColSpan(2):createText("/ " .. menu.contextMenuData.crew.right.capacity, { x = 0 })

			shiptable:addEmptyRow(config.mapRowHeight / 2)

			-- full list toggle
			local row = shiptable:addRow(true, { fixed = true })
			row[1]:setColSpan(3):createButton({  }):setText(menu.contextMenuData.fullshown and ReadText(1001, 8387) or ReadText(1001, 8388), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCrewTransferToggleList
		end
	else
		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(20208, 30101), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"

		-- current captain
		local row = shiptable:addRow(nil, { fixed = true })
		if menu.contextMenuData.crew.left.captain then
			row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.contextMenuData.crew.left.captain)), { color = Color["text_inactive"] })
			row[4]:createText(Helper.displaySkill(C.GetEntityCombinedSkill(menu.contextMenuData.crew.left.captain, nil, "aipilot") * 15 / 100), { halign = "right", color = Color["text_inactive"] })
		else
			row[1]:setColSpan(3):createText(ReadText(1001, 11232), { color = Color["text_inactive"] })
		end

		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 11299), { wordwrap = true })
	end

	if menu.contextMenuData.fullshown or (menu.contextMenuData.crew.right.isstation and (not menu.contextMenuData.crew.right.canhavetrainees)) then
		-- title
		local row = shiptable:addRow(nil, { fixed = true })
		row[1]:setColSpan(11):createText(ReadText(1001, 8386), Helper.headerRowCenteredProperties)

		local rowcount = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			-- roles
			local row = shiptable:addRow(nil, {  })
			if menu.contextMenuData.crew.right.canhavetrainees then
				row[1]:setColSpan(5):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
				row[7]:setColSpan(5):createText(ReadText(20208, 20503), Helper.subHeaderTextProperties)
				row[7].properties.halign = "center"
			else
				row[1]:setColSpan(11):createText(roleentry.name, Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
			end
			rowcount = rowcount + 1
			if rowcount == numListRows then
				shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
			end

			-- tiers
			for j, tierentry in ipairs(roleentry.tiers) do
				local isextended = menu.contextMenuData.extendedTier[i .. j]

				local row = shiptable:addRow(true, {  })
				row[1]:createButton({ active = function () return #tierentry.left.persons + #tierentry.left.moved + #tierentry.right.persons + #tierentry.right.moved > 0 end }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonCrewTransferExtend(i, j) end
				row[2]:setColSpan(9):createText(tierentry.name, { color = color })
				rowcount = rowcount + 1
				if rowcount == numListRows then
					shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
				end

				if isextended then
					local personpool = {}
					for _, person in ipairs(tierentry.left.persons) do
						table.insert(personpool, person)
					end
					for _, person in ipairs(tierentry.left.moved) do
						table.insert(personpool, person)
					end
					table.sort(personpool, menu.crewTransferSorter)
					for _, person in ipairs(personpool) do
						local row = shiptable:addRow(true, {  })
						row[2]:setColSpan(2):createText("   " .. person.name, { color = function () return ((not person.arrived) or menu.contextMenuData.crew.left.transferList[person.seed]) and Color["text_inactive"] or Color["text_normal"] end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[4]:createText(Helper.displaySkill(person.skill), { halign = "right", color = function () return menu.contextMenuData.crew.left.transferList[person.seed] and Color["text_skills"] or Color["text_skills_irrelevant"] end })
						row[5]:createCheckBox(function () return not menu.contextMenuData.crew.left.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, true) end
						row[6]:createText("", { cellBGColor = Color["text_normal"], x = 0 })
						row[7]:createCheckBox(function () return menu.contextMenuData.crew.left.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = menu.isPersonTransferPossible(person), mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
						row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "left", person.seed, false) end
						if menu.contextMenuData.crew.right.isplayerowned then
							row[8]:createText(function () return menu.contextMenuData.crew.left.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { color = Color["text_positive"] })
							row[9]:setColSpan(3):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Color["text_positive"] })
						elseif menu.contextMenuData.crew.left.transferList[person.seed] then
							if #person.missionids == 1 then
								local mission = menu.getMissionIDInfoHelper(person.missionids[1])
								row[8]:setColSpan(2):createText(mission.name, { color = Color["text_mission"] })
							else
								local missions = {}
								for _, missionid in ipairs(person.missionids) do
									local mission = menu.getMissionIDInfoHelper(missionid)
									local active = (person.selectedmissionid == missionid) or (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred)
									table.insert(missions, { id = tostring(missionid), text = mission.name, icon = "", displayremoveoption = false, active = active, mouseovertext = active and "" or ReadText(1026, 3250) })
								end
								row[8]:setColSpan(2):createDropDown(missions, { startOption = tostring(person.selectedmissionid), height = config.mapRowHeight, optionWidth = 2 * row[8]:getColSpanWidth() }):setTextProperties({ color = Color["text_mission"] })
								row[8].handlers.onDropDownConfirmed = function (_, missionid) return menu.dropdownCrewTransferSelectMission(person, missionid) end
							end
							row[10]:setColSpan(2):createText(function () return menu.personName(person, "left", "right") end, { halign = "right", color = Color["text_positive"] })
						end

						rowcount = rowcount + 1
						if rowcount == numListRows then
							shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
						end
					end

					if menu.contextMenuData.crew.right.isplayerowned then
						personpool = {}
						for _, person in ipairs(tierentry.right.persons) do
							table.insert(personpool, person)
						end
						for _, person in ipairs(tierentry.right.moved) do
							table.insert(personpool, person)
						end
						table.sort(personpool, menu.crewTransferSorter)
						for _, person in ipairs(personpool) do
							local row = shiptable:addRow(true, {  })
							row[2]:setColSpan(2):createText(function () return menu.personName(person, "right", "left") end, { color = Color["text_positive"] })
							row[4]:createText(function () return menu.contextMenuData.crew.right.transferList[person.seed] and Helper.displaySkill(person.skill) or "" end, { halign = "right", color = Color["text_positive"] })
							row[5]:createCheckBox(function () return menu.contextMenuData.crew.right.transferList[person.seed] or false end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[5].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, false) end
							row[6]:createText("", { cellBGColor = Color["text_normal"], x = 0 })
							row[7]:createCheckBox(function () return not menu.contextMenuData.crew.right.transferList[person.seed] end, { height = Helper.standardTextHeight, active = person.arrived, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })
							row[7].handlers.onClick = function (id) return menu.checkboxCrewTransfer(id, i, j, "right", person.seed, true) end
							row[8]:createText(Helper.displaySkill(person.skill), { color = function () return (not menu.contextMenuData.crew.right.transferList[person.seed]) and Color["text_skills"] or Color["text_skills_irrelevant"] end })
							row[9]:setColSpan(3):createText(person.name, { halign = "right", color = function () return ((not person.arrived) or menu.contextMenuData.crew.right.transferList[person.seed]) and Color["text_inactive"] or Color["text_normal"] end, mouseOverText = (not person.arrived) and ReadText(1026, 3247) or "" })

							rowcount = rowcount + 1
							if rowcount == numListRows then
								shiptable.properties.maxVisibleHeight = shiptable:getFullHeight()
							end
						end
					end
				end
			end
		end
	end

	if menu.contexttoprow then
		shiptable:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		shiptable:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end

	buttontable.properties.y = shiptable.properties.y + shiptable:getVisibleHeight()

	shiptable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = shiptable.index

	-- adjust frame position
	local neededheight = buttontable.properties.y + buttontable:getVisibleHeight()
	if frame.properties.y + neededheight > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.isPersonTransferPossible(person)
	if menu.contextMenuData.crew.right.isstation then
		if person.missionids and (#person.missionids > 0) then
			local ispossible = false
			for _, missionid in ipairs(person.missionids) do
				if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
					ispossible = true
					break
				end
			end
			return person.arrived and ispossible
		else
			local missingmanager = false
			if (menu.contextMenuData.crew.right.replaceCaptain == true) and (not menu.contextMenuData.crew.right.newCaptain) then
				missingmanager = true
			end
			local missingshiptrader = false
			if menu.contextMenuData.crew.right.hasshiptraderpost then
				if (menu.contextMenuData.crew.right.replaceShiptrader == true) and (not menu.contextMenuData.crew.right.newShiptrader) then
					missingshiptrader = true
				end
			end
			return person.arrived and ((missingmanager or missingshiptrader) or menu.contextMenuData.crew.right.canhavetrainees)
		end
	else
		return person.arrived
	end
end

function menu.personName(person, origin, target)
	local name = ""
	if menu.contextMenuData.crew[origin].transferList[person.seed] then
		name = person.name
	end
	if menu.contextMenuData.crew[target].replaceCaptain and (menu.contextMenuData.crew[target].newCaptain == person.seed) then
		name = name .. " [" .. (menu.contextMenuData.crew[target].isstation and ReadText(1001, 11258) or ReadText(1001, 11236)) .. "]"
	end
	if menu.contextMenuData.crew[target].replaceShiptrader and (menu.contextMenuData.crew[target].newShiptrader == person.seed) then
		name = name .. " [" .. ReadText(1001, 11263) .. "]"
	end
	return name
end

function menu.checkMissionNPCRequirement(missionnpcrequirements, controllable, seed, numskills)
	local missionids = {}

	local skills = {}
	local buf = ffi.new("SkillInfo[?]", numskills)
	local n = C.GetPersonSkills3(buf, numskills, seed, controllable)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		skills[id] = buf[i].value
	end

	for _, entry in ipairs(missionnpcrequirements) do
		local matchesrequirement = true
		for _, requiredskill in ipairs(entry.requiredskills) do
			if requiredskill.value > skills[requiredskill.id] then
				matchesrequirement = false
				break
			end
		end
		if matchesrequirement then
			table.insert(missionids, entry.missionid)
		end
	end

	return missionids
end

function menu.crewTransferSorter(a, b)
	if a.skill == b.skill then
		return a.name < b.name
	end
	return a.skill > b.skill
end

function menu.slidercellCrewTransfer(i, j, value)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local current = #tierentry.right.moved - #tierentry.left.moved
	if value ~= current then
		local change = value - current
		if change > 0 then
			if #tierentry.left.moved > 0 then
				local moveAmount = math.min(change, #tierentry.left.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("left", i, j)
				end
				change = change - moveAmount
			end
			if change > 0 then
				for count = 1, change do
					menu.movePerson("right", i, j)
				end
			end
		elseif change < 0 then
			if #tierentry.right.moved > 0 then
				local moveAmount = math.min(-change, #tierentry.right.moved)
				for count = 1, moveAmount do
					menu.unmovePerson("right", i, j)
				end
				change = change + moveAmount
			end
			if change < 0 then
				for count = 1, -change do
					menu.movePerson("left", i, j)
				end
			end
		end

		table.sort(tierentry.left.persons, menu.crewTransferSorter)
		table.sort(tierentry.right.persons, menu.crewTransferSorter)
	end
end

function menu.checkForNewCaptains(forcerefresh)
	local changedcaptain
	if menu.contextMenuData.crew.left.replaceCaptain then
		local currentskill
		-- sic! New captain on the left comes from the right ship!
		if menu.contextMenuData.crew.left.newCaptain then
			if menu.contextMenuData.crew.right.transferList[menu.contextMenuData.crew.left.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, menu.contextMenuData.crew.left.newCaptain, nil, "aipilot")
			else
				menu.contextMenuData.crew.left.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.right.transferList) then
			for seed in pairs(menu.contextMenuData.crew.right.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.rightShip, seed, nil, "aipilot")
				if (not menu.contextMenuData.crew.left.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.left.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
	else
		menu.contextMenuData.crew.left.newCaptain = nil
	end

	if menu.contextMenuData.crew.right.replaceCaptain then
		local currentskill
		-- sic! New captain on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newCaptain then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newCaptain, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
			else
				menu.contextMenuData.crew.right.newCaptain = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, menu.contextMenuData.crew.right.isstation and "manager" and "aipilot")
				if (not menu.contextMenuData.crew.right.newCaptain) or (skill > currentskill) then
					menu.contextMenuData.crew.right.newCaptain = seed
					currentskill = skill
					changedcaptain = true
				end
			end
		end
		if menu.contextMenuData.crew.right.newCaptain == menu.contextMenuData.crew.right.newShiptrader then
			menu.contextMenuData.crew.right.newShiptrader = nil
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newCaptain then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newCaptain, "left")
		end
		menu.contextMenuData.crew.right.newCaptain = nil
	end
	if menu.contextMenuData.crew.right.replaceShiptrader then
		local currentskill
		-- sic! New ship trader on the right comes from the left ship!
		if menu.contextMenuData.crew.right.newShiptrader then
			if menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] then
				currentskill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, menu.contextMenuData.crew.right.newShiptrader, nil, "shiptrader")
			else
				menu.contextMenuData.crew.right.newShiptrader = nil
				changedcaptain = true
			end
		end
		if next(menu.contextMenuData.crew.left.transferList) then
			for seed in pairs(menu.contextMenuData.crew.left.transferList) do
				-- choose best npc for captain/manager and skip them for shiptrader
				if seed ~= menu.contextMenuData.crew.right.newCaptain then
					local skill = C.GetPersonCombinedSkill(menu.contextMenuData.leftShip, seed, nil, "shiptrader")
					if (not menu.contextMenuData.crew.right.newShiptrader) or (skill > currentskill) then
						menu.contextMenuData.crew.right.newShiptrader = seed
						currentskill = skill
						changedcaptain = true
					end
				end
			end
		end
	else
		if menu.contextMenuData.crew.right.isstation and menu.contextMenuData.crew.right.newShiptrader then
			menu.unmoveNewPostNPCHelper(menu.contextMenuData.crew.right.newShiptrader, "left")
		end
		menu.contextMenuData.crew.right.newShiptrader = nil
	end

	if forcerefresh or changedcaptain or menu.contextMenuData.crew.right.isstation then
		menu.refreshContextFrame()
	end
end

function menu.unmoveNewPostNPCHelper(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					menu.unmovePerson(origin, i, j, person, k)
					return
				end
			end
		end
	end
end

function menu.movePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	if person then
		table.remove(tierentry[origin].persons, k)
	else
		for i, possibleperson in ipairs(tierentry[origin].persons) do
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].persons, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].moved, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved + 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = true
	if person.missionids and (#person.missionids > 0) then
		for _, missionid in ipairs(person.missionids) do
			if menu.contextMenuData.rightMissionOffers[tostring(missionid)] and (menu.contextMenuData.rightMissionOffers[tostring(missionid)].amount > menu.contextMenuData.rightMissionOffers[tostring(missionid)].transferred) then
				person.selectedmissionid = missionid
				break
			end
		end
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1
		end
	end
end

function menu.unmovePerson(origin, i, j, person, k)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	if person then
		table.remove(tierentry[origin].moved, k)
	else
		for i = #tierentry[origin].moved, 1, -1 do
			local possibleperson = tierentry[origin].moved[i]
			if possibleperson.arrived then
				person = possibleperson
				table.remove(tierentry[origin].moved, i)
				break
			end
		end
	end
	table.insert(tierentry[origin].persons, person)
	menu.contextMenuData.crew[origin].moved = menu.contextMenuData.crew[origin].moved - 1
	menu.contextMenuData.crew[origin].transferList[person.seed] = nil
	if person.missionids and (#person.missionids > 0) then
		if menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)] then
			menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
			person.selectedmissionid = nil
		end
	end
end

function menu.crewTransferColorHelper(origin, tierentry, basecolor)
	if (#tierentry.left.moved > 0) or (#tierentry.right.moved > 0) then
		if #tierentry.left.moved == #tierentry.right.moved then
			return Color["crew_transfer"]
		elseif #tierentry.right.moved > #tierentry.left.moved then
			if origin == "left" then
				return Color["text_positive"]
			else
				return Color["text_negative"]
			end
		else
			if origin == "left" then
				return Color["text_negative"]
			else
				return Color["text_positive"]
			end
		end
	end
	return basecolor
end

function menu.crewTransferWarningText(leftname, rightname, row)
	local count = 0
	local warning = ""
	if menu.contextMenuData.crew.right.isplayerowned then
		if menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved > menu.contextMenuData.crew.left.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), leftname)
			end
		elseif menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved > menu.contextMenuData.crew.right.capacity then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 8389), rightname)
			end
		end
		if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11237), leftname)
			end
		end
		if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
			count = count + 1
			if count == row then
				return string.format(menu.contextMenuData.crew.right.isstation and ReadText(1001, 11259) or ReadText(1001, 11237), rightname)
			end
		end
		if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
			count = count + 1
			if count == row then
				return string.format(ReadText(1001, 11264), rightname)
			end
		end
		local valid, reason = menu.performCrewExchange(true)
		if not valid then
			count = count + 1
			if count == row then
				return menu.hireReasonLookup(reason, true)
			end
		end
	else
		local availablecrew = 0
		for i, roleentry in ipairs(menu.contextMenuData.crew) do
			for j, tierentry in ipairs(roleentry.tiers) do
				availablecrew = availablecrew + #tierentry.left.persons + #tierentry.left.moved
			end
		end
		if availablecrew == 0 then
			count = count + 1
			if count == row then
				return ReadText(1001, 11265)
			end
		end
	end
	return warning
end

function menu.crewTransferTotalColor(origin)
	if menu.contextMenuData.crew[origin].total - menu.contextMenuData.crew[origin].moved + menu.contextMenuData.crew[(origin == "left") and "right" or "left"].moved > menu.contextMenuData.crew[origin].capacity then
		return Color["text_error"]
	end
	return Color["text_normal"]
end

function menu.dropdownCrewTransferSelectMission(person, missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred - 1
	person.selectedmissionid = ConvertStringTo64Bit(missionid)
	menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred = menu.contextMenuData.rightMissionOffers[tostring(person.selectedmissionid)].transferred + 1

	menu.refreshContextFrame()
end

function menu.crewTransferAllowed()
	if not menu.contextMenuData.crew.right.isplayerowned then
		return menu.contextMenuData.crew.left.moved > 0
	end
	if menu.contextMenuData.crew.left.replaceCaptain and (not menu.contextMenuData.crew.left.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceCaptain and (not menu.contextMenuData.crew.right.newCaptain) then
		return false
	end
	if menu.contextMenuData.crew.right.replaceShiptrader and (not menu.contextMenuData.crew.right.newShiptrader) then
		return false
	end
	if (menu.contextMenuData.crew.left.moved > 0) or (menu.contextMenuData.crew.right.moved > 0) or menu.contextMenuData.crew.exchangeCaptains then
		if (menu.contextMenuData.crew.left.total - menu.contextMenuData.crew.left.moved + menu.contextMenuData.crew.right.moved <= menu.contextMenuData.crew.left.capacity) and
			(menu.contextMenuData.crew.right.total - menu.contextMenuData.crew.right.moved + menu.contextMenuData.crew.left.moved <= menu.contextMenuData.crew.right.capacity) then
				return menu.performCrewExchange(true)
		end
	end
	return false
end

function menu.getMissionInfoFromPerson(seed, origin)
	for i, roleentry in ipairs(menu.contextMenuData.crew) do
		for j, tierentry in ipairs(roleentry.tiers) do
			for k, person in ipairs(tierentry[origin].moved) do
				if person.seed == seed then
					return person.selectedmissionid
				end
			end
		end
	end
end

function menu.buttonCrewTransferConfirm()
	if not menu.contextMenuData.crew.right.isplayerowned then
		for seed in pairs(menu.contextMenuData.crew.left.transferList) do
			C.SignalObjectWithNPCSeedAndMissionID(menu.contextMenuData.rightShip, "npctemplate_mission_delivery", menu.getMissionInfoFromPerson(seed, "left"), seed, menu.contextMenuData.leftShip)
		end
	else
		if menu.contextMenuData.crew.right.isstation then
			if menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain then
				-- sic! New manager on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newCaptain }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "manager", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newCaptain] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newCaptain = nil
				menu.contextMenuData.crew.right.replaceCaptain = nil
			end
			if menu.contextMenuData.crew.right.replaceShiptrader and menu.contextMenuData.crew.right.newShiptrader then
				-- sic! New ship trader on the right comes from the left ship!
				local actor = { entity = nil, personcontrollable = menu.contextMenuData.leftShip, personseed = menu.contextMenuData.crew.right.newShiptrader }
				C.AssignHiredActor(actor, menu.contextMenuData.rightShip, "shiptrader", nil, false)
				-- need to clean this up in case we will transfer further npcs as trainees
				menu.contextMenuData.crew.left.transferList[menu.contextMenuData.crew.right.newShiptrader] = nil
				menu.contextMenuData.crew.left.moved = menu.contextMenuData.crew.left.moved - 1
				menu.contextMenuData.crew.right.newShiptrader = nil
				menu.contextMenuData.crew.right.replaceShiptrader = nil
			end
			if menu.contextMenuData.crew.right.canhavetrainees then
				menu.performCrewExchange(false)
			end
		else
			menu.performCrewExchange(false)
		end
	end
	menu.updatePeopleInfo = getElapsedTime()
	menu.closeContextMenu("back")
end

function menu.performCrewExchange(checkonly)
	local exchangecaptains = menu.contextMenuData.crew.exchangeCaptains
	local captainfromleft = menu.contextMenuData.crew.right.replaceCaptain and menu.contextMenuData.crew.right.newCaptain or 0
	local captainfromright = menu.contextMenuData.crew.left.replaceCaptain and menu.contextMenuData.crew.left.newCaptain or 0
	local hascaptainfromleft, hascaptainfromright

	if menu.contextMenuData.crew.left.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end
	if menu.contextMenuData.crew.right.moved < 0 then
		DebugError("Invalid amount of moved crew, aborting")
		print(TraceBack())
		return false, "invalid"
	end

	if exchangecaptains and ((menu.contextMenuData.crew.left.captain and (captainfromleft ~= 0)) or (menu.contextMenuData.crew.right.captain and (captainfromright ~= 0))) then
		return false, "invalid"
	end

	local i = 0
	local leftnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.left.moved)
	for seed in pairs(menu.contextMenuData.crew.left.transferList) do
		leftnpcs[i] = seed
		if seed == captainfromleft then
			hascaptainfromleft = true
		end
		i = i + 1
	end
	i = 0
	local rightnpcs = ffi.new("NPCSeed[?]", menu.contextMenuData.crew.right.moved)
	for seed in pairs(menu.contextMenuData.crew.right.transferList) do
		rightnpcs[i] = seed
		if seed == captainfromright then
			hascaptainfromright = true
		end
		i = i + 1
	end

	if (hascaptainfromleft or (captainfromleft == 0)) and (hascaptainfromright or (captainfromright == 0)) then
		local result = C.PerformCrewExchange2(menu.contextMenuData.leftShip, menu.contextMenuData.rightShip, leftnpcs, menu.contextMenuData.crew.left.moved, rightnpcs, menu.contextMenuData.crew.right.moved, captainfromleft, captainfromright, exchangecaptains, checkonly)
		local reason = ffi.string(result.reason)
		return reason == "", reason;
	end
	return false, "invalid"
end

function menu.buttonCrewTransferToggleList()
	menu.contextMenuData.fullshown = not menu.contextMenuData.fullshown
	menu.refreshContextFrame()
end

function menu.buttonCrewTransferExtend(i, j)
	if menu.contextMenuData.extendedTier[i .. j] then
		menu.contextMenuData.extendedTier[i .. j] = nil
	else
		menu.contextMenuData.extendedTier[i .. j] = true
	end
	menu.refreshContextFrame()
end

function menu.checkboxCrewTransfer(id, i, j, origin, seed, isorigin)
	local roleentry = menu.contextMenuData.crew[i]
	local tierentry = roleentry.tiers[j]

	local person, personidx
	if isorigin then
		for k, personentry in ipairs(tierentry[origin].moved) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	else
		for k, personentry in ipairs(tierentry[origin].persons) do
			if personentry.seed == seed then
				person = personentry
				personidx = k
				break
			end
		end
	end

	if person then
		if menu.contextMenuData.crew[origin].transferList[person.seed] and isorigin then
			menu.unmovePerson(origin, i, j, person, personidx)
		elseif (not menu.contextMenuData.crew[origin].transferList[person.seed]) and (not isorigin) then
			menu.movePerson(origin, i, j, person, personidx)
		end
		table.sort(tierentry[origin].persons, menu.crewTransferSorter)
		if not menu.contextMenuData.crew.right.isstation then
			Helper.setSliderCellValue(menu.contexttable, 5 + 4 * i + j, 4, #tierentry.right.moved - #tierentry.left.moved)
		end
	else
		C.SetCheckBoxChecked2(id, true, true)
	end

	menu.checkForNewCaptains()
end

function menu.checkboxCrewExchangeCaptains()
	menu.contextMenuData.crew.exchangeCaptains = not menu.contextMenuData.crew.exchangeCaptains
	-- If we have a captain on the left ship, we cannot replace the captain on the right ship with another crewmember anymore
	if menu.contextMenuData.crew.left.captain then
		menu.contextMenuData.crew.right.newCaptain = nil
		menu.contextMenuData.crew.right.replaceCaptain = nil
	end
	-- If we have a captain on the right ship, we cannot replace the captain on the left ship with another crewmember anymore
	if menu.contextMenuData.crew.right.captain then
		menu.contextMenuData.crew.left.newCaptain = nil
		menu.contextMenuData.crew.left.replaceCaptain = nil
	end

	menu.refreshContextFrame()
end

function menu.checkboxAssignCaptain(origin)
	menu.contextMenuData.crew[origin].replaceCaptain = not menu.contextMenuData.crew[origin].replaceCaptain
	local refresh = false
	if not menu.contextMenuData.crew[origin].captain then
		if menu.contextMenuData.crew[origin].replaceCaptain then
			menu.contextMenuData.crew[origin].capacity = menu.contextMenuData.crew[origin].capacity + 1
		else
			menu.contextMenuData.crew[origin].capacity = menu.contextMenuData.crew[origin].capacity - 1
		end
		refresh = true
	end
	menu.checkForNewCaptains(refresh)
end

function menu.createRenameContext(frame)
	local title = menu.contextMenuData.fleetrename and ReadText(1001, 7895) or ReadText(1001, 1114)
	local startname = menu.contextMenuData.fleetrename and ffi.string(C.GetFleetName(menu.contextMenuData.component)) or ffi.string(C.GetComponentName(menu.contextMenuData.component))

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if menu.uix_callbacks ["utRenaming_createRenameContext_get_startname"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_createRenameContext_get_startname"]) do
			uix_startname = uix_callback (frame)
			if uix_startname then
				startname = uix_startname
				break
			end
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	local shiptable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = shiptable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(title, Helper.headerRowCenteredProperties)

	local row = shiptable:addRow(true, { fixed = true })
	menu.contextMenuData.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = config.mapRowHeight, description = title }):setText(startname)
	row[1].handlers.onTextChanged = function (_, text, textchanged) menu.contextMenuData.newtext = text end
	row[1].handlers.onEditBoxDeactivated =function (_, text, textchanged, isconfirmed) return menu.buttonRenameConfirm(isconfirmed) end

	local row = shiptable:addRow(true, { fixed = true })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonRenameConfirm(true) end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.closeContextMenu("back") end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if menu.uix_callbacks ["utRenaming_createRenameContext_on_after_confirm_button"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_createRenameContext_on_after_confirm_button"]) do
			startname = uix_callback (frame, shiptable)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	-- adjust frame position
	local neededheight = shiptable.properties.y + shiptable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createChangeLogoContext(frame)
	local title = ReadText(1001, 11133)

	local colwidth = math.floor((menu.contextMenuData.width - 4 * Helper.borderSize) / 5)
	local logotable = frame:addTable(5, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })

	-- title
	local row = logotable:addRow(nil, { fixed = true })
	row[1]:setColSpan(5):createText(title, Helper.headerRowCenteredProperties)

	local logooptiondata = { {{}, ReadText(1001, 9126)}, {{}, ReadText(1001, 9127)} }

	local numlogos = C.GetNumPlayerLogos(true, false)
	local logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, true, false)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[1][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	numlogos = C.GetNumPlayerLogos(false, true)
	logos = ffi.new("UILogo[?]", numlogos)
	numlogos = C.GetPlayerLogos(logos, numlogos, false, true)
	for i = 0, numlogos - 1 do
		table.insert(logooptiondata[2][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
	end

	local row
	for _, logodata in ipairs(logooptiondata) do
		row = logotable:addRow(nil, { bgColor = Color["player_info_background"] })
		row[1]:setColSpan(5):createText(logodata[2], Helper.headerRowCenteredProperties)

		if #logodata[1] > 0 then
			for i, logo in ipairs(logodata[1]) do
				local loccol = i % 5
				if loccol == 0 then
					loccol = 5
				end
				if loccol == 1 then
					row = logotable:addRow("logos", {  })
				end

				row[loccol]:createButton({ height = colwidth, scaling = false }):setIcon(logo.icon):setIcon2(function() return menu.contextChangeLogoButtonIcon2(logo) end, { color = function() return menu.contextChangeLogoButtonIcon2Color(logo) end })
				row[loccol].handlers.onClick = function() return menu.buttonContextSetLogo(logo) end

				if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
					logotable:setSelectedRow(row.index)
					logotable:setSelectedCol(loccol)
				end
			end
		else
			row = logotable:addRow("logos", {  })
			row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 9132) .. " ---")
		end
	end

	local buttontable = frame:addTable(3, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = 5 * (colwidth + Helper.borderSize) - Helper.borderSize, highlightMode = "off" })
	buttontable:addEmptyRow()
	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = function () menu.contextMenuData.origlogo = nil; return menu.closeContextMenu("back") end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = menu.buttonChangeLogoCancel
	row[3]:createButton({ active = function () return menu.contextMenuData.currentlogo.file ~= "" end }):setText(ReadText(1001, 11640), { halign = "center" })
	row[3].handlers.onClick = function () menu.contextMenuData.currentlogo = { file = "", icon = "", ispersonal = false}; return C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.currentlogo) end

	local buttonheight = buttontable:getFullHeight()
	if logotable:getFullHeight() + buttonheight + Helper.borderSize > Helper.viewHeight - 2 * Helper.frameBorder then
		logotable.properties.maxVisibleHeight = Helper.viewHeight - 2 * Helper.frameBorder - buttonheight - Helper.borderSize
	end
	buttontable.properties.y = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize

	-- adjust frame position
	local neededheight = logotable.properties.y + logotable:getVisibleHeight() + Helper.borderSize + buttonheight
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.contextChangeLogoButtonIcon2(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return "be_upgrade_installed"
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return "be_upgrade_uninstalled"
	end
	return "solid"
end

function menu.contextChangeLogoButtonIcon2Color(logo)
	if (logo.icon == menu.contextMenuData.currentlogo.icon) and (logo.ispersonal == menu.contextMenuData.currentlogo.ispersonal) then
		return Color["text_positive"]
	end
	if (logo.icon == menu.contextMenuData.origlogo.icon) and (logo.ispersonal == menu.contextMenuData.origlogo.ispersonal) then
		return Color["text_negative"]
	end
	return Color["icon_hidden"]
end

function menu.createHireContext(frame)
	local isplayerowned = GetComponentData(menu.contextMenuData.hireObject, "isplayerowned")

	local ftable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local npcseed = C.ConvertStringTo64Bit(tostring(menu.modeparam[4]))
	local npc, object
	if npcseed ~= 0 then
		object = ConvertIDTo64Bit(menu.modeparam[2])
	else
		npc = ConvertIDTo64Bit(menu.modeparam[2])
	end
	local ishiring = menu.modeparam[3] ~= 0

	-- title
	local row = ftable:addRow(nil, { fixed = true })

	local name = ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))
	local idcode = " (" .. ffi.string(C.GetObjectIDCode(menu.contextMenuData.hireObject)) .. ")"

	local halign = "center"
	if math.ceil(C.GetTextWidth(name .. idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize))) > menu.contextMenuData.width - 2 * Helper.scaleX(Helper.standardButtonWidth) then
		halign = "left"
		local idcodewidth = math.ceil(C.GetTextWidth(idcode, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)))
		name = TruncateText(name, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), menu.contextMenuData.width - Helper.scaleX(Helper.standardTextOffsetx) - idcodewidth - Helper.scaleX(Helper.standardButtonWidth))
	end

	row[1]:setColSpan(2):createText(name .. idcode, Helper.headerRowCenteredProperties)
	row[1].properties.halign = halign
	if isplayerowned then
		row[1].properties.color = menu.holomapcolor.playercolor
	end

	-- Possible Roles
	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 3259))
	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	local actor = { entity = npc, personcontrollable = object, personseed = npcseed }

	local roleOptions = {}
	if isplayerowned then
		-- posts
		local n, buf
		if npc then
			n = C.GetNumSuitableControlPosts(menu.contextMenuData.hireObject, npc, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, npc, false)
		else
			n = C.GetNumPersonSuitableControlPosts(menu.contextMenuData.hireObject, object, npcseed, false)
			buf = ffi.new("ControlPostInfo[?]", n)
			n = C.GetPersonSuitableControlPosts(buf, n, menu.contextMenuData.hireObject, object, npcseed, false)
		end
		for i = 0, n - 1 do
			local postid = ffi.string(buf[i].id)
			local reason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, postid, "", true))
			local active = reason == ""
			local mouseovertext
			if reason ~= "" then
				mouseovertext = menu.hireReasonLookup(reason)
			end

			table.insert(roleOptions, { id = "post:" .. postid, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.IsComponentClass(menu.contextMenuData.hireObject, "ship") then
			-- service
			local servicereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "service", true))
			local active = servicereason == ""
			local mouseovertext
			if servicereason ~= "" then
				mouseovertext = menu.hireReasonLookup(servicereason)
			end
			table.insert(roleOptions, { id = "role:service", text = ReadText(20208, 20103), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
			-- marines
			local marinereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "marine", true))
			local active = marinereason == ""
			local mouseovertext
			if marinereason ~= "" then
				mouseovertext = menu.hireReasonLookup(marinereason)
			end
			table.insert(roleOptions, { id = "role:marine",  text = ReadText(20208, 20203), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
		if C.CanControllableHaveAnyTrainees(menu.contextMenuData.hireObject) then
			-- group trainee
			local grouptraineereason = ffi.string(C.AssignHiredActor(actor, menu.contextMenuData.hireObject, "", "trainee_group", true))
			local active = grouptraineereason == ""
			local mouseovertext
			if grouptraineereason ~= "" then
				mouseovertext = menu.hireReasonLookup(grouptraineereason)
			end
			table.insert(roleOptions, { id = "role:trainee_group", text = ReadText(20208, 20503), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
	end

	-- skills
	local numskills = C.GetNumSkills()
	local skills = {}
	if npc then
		local skilltable = GetComponentData(npc, "skills") or {}
		for _, entry in ipairs(skilltable) do
			skills[entry.name] = entry.value
		end
	else
		local buf = ffi.new("SkillInfo[?]", numskills)
		local n = C.GetPersonSkills3(buf, numskills, npcseed, object)
		for i = 0, n - 1 do
			local id = ffi.string(buf[i].id)
			skills[id] = buf[i].value
		end
	end
	-- mission npc requirements
	local n = C.GetNumRequestedMissionNPCs(menu.contextMenuData.hireObject)
	local buf = ffi.new("MissionNPCInfo[?]", n)
	for i = 0, n - 1 do
		buf[i].numskills = numskills
		buf[i].skills = Helper.ffiNewHelper("SkillInfo[?]", numskills)
	end
	n = C.GetRequestedMissionNPCs(buf, n, menu.contextMenuData.hireObject)
	for i = 0, n - 1 do
		if buf[i].amount > 0 then
			local matchesrequirement = true
			for j = 0, buf[i].numskills - 1 do
				local id = ffi.string(buf[i].skills[j].id)
				if buf[i].skills[j].value > skills[id] then
					matchesrequirement = false
					break
				end
			end

			local mission = menu.getMissionIDInfoHelper(buf[i].missionid)
			table.insert(roleOptions, { id = "mission:" .. tostring(buf[i].missionid), text = ColorText["text_mission"] .. mission.name, icon = "", displayremoveoption = false, active = matchesrequirement, mouseovertext = matchesrequirement and "" or ReadText(1026, 3251) })
		end
	end

	table.sort(roleOptions, function (a, b) return a.text < b.text end)

	if #roleOptions > 0 then
		local startOption = ""
		if menu.contextMenuData.hireIsMission then
			startOption = "mission:" .. menu.contextMenuData.hireRole
		elseif menu.contextMenuData.hireRole then
			startOption = (menu.contextMenuData.hireIsPost and "post:" or "role:") .. menu.contextMenuData.hireRole
		end
		row[1]:setColSpan(2):createDropDown(roleOptions, { startOption = startOption, height = config.mapRowHeight, helpOverlayID = "assign_staff_role", helpOverlayText = " " }):setTextProperties({ halign = "center" })
		row[1].handlers.onDropDownConfirmed = menu.dropdownHireRole
		row[1].properties.uiTriggerID = "npcrole"
		row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
	else
		row[1]:setColSpan(2):createText(string.format(ReadText(1001, 3260), ffi.string(C.GetComponentName(menu.contextMenuData.hireObject))), { halign = "center", color = Color["text_error"] })
	end
	-- warnings
	local warningtext = ""
	if npc and GetComponentData(npc, "isplayerowned") then
		if not GetComponentData(menu.contextMenuData.hireObject, "assignedpilot") then
			if menu.contextMenuData.hireRole and (not menu.contextMenuData.hireIsPost) then
				local inventory = GetInventory(npc)
				if next(inventory) then
					warningtext = ReadText(1001, 8384)
				end
			end
		end
	end
	if warningtext ~= "" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(2):createText(warningtext, { color = Color["text_error"], wordwrap = true })
	end

	menu.hiringdiscounts = GetComponentData(GetContextByClass(npc or object, "container", true), "hiringdiscounts")
	menu.hiringdiscounts.totalfactor = 1
	for _, entry in ipairs(menu.hiringdiscounts) do
		menu.hiringdiscounts.totalfactor = menu.hiringdiscounts.totalfactor - entry.amount / 100
	end

	local fee
	if ishiring and npc then
		fee = GetNPCBlackboard(npc, "$HiringFee")
	end
	local balance = GetPlayerMoney()
	if fee then
		balance = GetPlayerMoney() - fee
	end
	if ishiring then
		-- discounts
		if #menu.hiringdiscounts > 0 then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 3502))
			row[2]:createText(ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })

			ftable:addEmptyRow(config.mapRowHeight / 4)

			local row = ftable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 2819))
			for _, entry in ipairs(menu.hiringdiscounts) do
				local row = ftable:addRow(nil, { fixed = true })
				row[1]:createText("   " .. entry.name)
				row[2]:createText(entry.amount .. " %", { halign = "right" })
			end
			ftable:addEmptyRow(config.mapRowHeight / 4)
		end
		if fee then
			-- Fee
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createText((#menu.hiringdiscounts > 0) and ReadText(1001, 3503) or ReadText(1001, 3501))
			row[2]:createText(ConvertMoneyString(fee * menu.hiringdiscounts.totalfactor, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
		end
		-- Final Balance
		local row = ftable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 2004))
		row[2]:createText(ConvertMoneyString(balance, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right", color = (balance < 0) and Color["text_negative"] or Color["text_normal"] })
	end
	-- Buttons
	local row = ftable:addRow(true, { fixed = true })
	local mouseovertext = ""
	if not menu.contextMenuData.hireRole then
		mouseovertext = ReadText(1026, 3221)
	elseif ishiring and (balance < 0) then
		mouseovertext = ReadText(1026, 3222)
	end
	row[1]:createButton({ active = (menu.contextMenuData.hireRole ~= nil) and ((not ishiring) or (balance >= 0)), mouseOverText = mouseovertext, helpOverlayID = "assign_staff_hire_ok", helpOverlayText = " " }):setText(ishiring and ReadText(1001, 3262) or ReadText(1001, 3263), { halign = "center" })
	row[1].handlers.onClick = menu.buttonHire
	row[1].properties.uiTriggerID = "hire_ok"

	row[2]:createButton({helpOverlayID = "assign_staff_hire_cancel", helpOverlayText = " " }):setText(ReadText(1001, 64), { halign = "center"})
	row[2].handlers.onClick = function () return menu.onCloseElement("back") end
	row[2].properties.uiTriggerID = "hire_cancel"

	-- adjust frame position
	local neededheight = ftable.properties.y + ftable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createSearchFieldContext(frame)
	local ftable = frame:addTable(1, { tabOrder = 2, x = 0, y = 0, width = menu.contextMenuData.width, highlightMode = "off" })

	local founditems_prio = {}
	local founditems = {}
	for name, ware in Helper.orderedPairs(menu.economyWares) do
		local index = utf8.find(utf8.lower(name), menu.searchFieldContextText)
		if index then
			if index == 1 then
				table.insert(founditems_prio, { ware = ware, name = name })
			else
				table.insert(founditems, { ware = ware, name = name })
			end
		end
	end
	for name, sector in Helper.orderedPairs(menu.knownSectors) do
		local index = utf8.find(utf8.lower(name), menu.searchFieldContextText)
		if index then
			if index == 1 then
				table.insert(founditems_prio, { sector = sector, name = name })
			else
				table.insert(founditems, { sector = sector, name = name })
			end
		end
	end

	local maxVisibleHeight

	table.sort(founditems_prio, Helper.sortName)
	for i, item in ipairs(founditems_prio) do
		if (i > 10) and (not maxVisibleHeight) then
			maxVisibleHeight = ftable:getFullHeight()
		end
		local row = ftable:addRow(true, { borderBelow = false })
		row[1]:createButton({ bgColor = Color["row_background"], height = menu.editboxHeight, scaling = false }):setText(item.ware and ("\27[maptr_supply] " .. GetWareData(item.ware, "name")) or (item.sector and ("\27[maptr_hexagon] " .. GetComponentData(item.sector, "name")) or ""), { scaling = true, x = 2 })
		row[1].handlers.onClick = function () return menu.searchTextConfirmed(_, item.name, true) end
	end

	table.sort(founditems, Helper.sortName)
	for i, item in ipairs(founditems) do
		if (i > (10 - #founditems_prio)) and (not maxVisibleHeight) then
			maxVisibleHeight = ftable:getFullHeight()
		end
		local row = ftable:addRow(true, { borderBelow = false })
		row[1]:createButton({ bgColor = Color["row_background"], height = menu.editboxHeight, scaling = false }):setText(item.ware and ("\27[maptr_supply] " .. GetWareData(item.ware, "name")) or (item.sector and ("\27[maptr_hexagon] " .. GetComponentData(item.sector, "name")) or ""), { scaling = true, x = 2 })
		row[1].handlers.onClick = function () return menu.searchTextConfirmed(_, item.name, true) end
	end

	if maxVisibleHeight then
		ftable.properties.maxVisibleHeight = maxVisibleHeight
	end
end

function menu.createUserQuestionContext(frame)
	local useSaveOption = false
	if (menu.contextMenuData.mode == "markashostile") or (menu.contextMenuData.mode == "abortmission") or (menu.contextMenuData.mode == "abortguildmission") then
		useSaveOption = true
	end
	local hasExtraCheckBox = false
	if menu.contextMenuData.mode == "removeplot" then
		hasExtraCheckBox = true
	end
	local numCols = useSaveOption and 6 or (hasExtraCheckBox and 7 or 5)
	local ftable = frame:addTable(numCols, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })
	if useSaveOption then
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(5, 25)
		ftable:setColWidthPercent(6, 25)
	elseif hasExtraCheckBox then
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(3, 20)
		ftable:setColWidthPercent(5, 20)
		ftable:setColWidth(7, Helper.scaleY(Helper.standardButtonHeight), false)
	end

	if menu.contextMenuData.mode == "fireindividual" then
		local row = ftable:addRow(false, { fixed = true })
		if menu.contextMenuData.entity then
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetComponentName(menu.contextMenuData.entity))), Helper.headerRowCenteredProperties)
		else
			row[1]:setColSpan(numCols):createText(string.format(ReadText(1001, 11202), ffi.string(C.GetPersonName(menu.contextMenuData.person, menu.contextMenuData.controllable))), Helper.headerRowCenteredProperties)
		end

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11201))
	elseif menu.contextMenuData.mode == "fireall" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11250), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11249))

		local count = #menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons
		for i, entry in ipairs(menu.infoTablePersistentData[menu.contextMenuData.instance].crew.unassigned.persons) do
			local adjustedskill = math.floor(C.GetPersonCombinedSkill(menu.contextMenuData.controllable, entry.person, entry.oldrole, nil) * 15 / 100)

			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText("    · " .. ffi.string(C.GetPersonName(entry.person, menu.contextMenuData.controllable)))
			row[4]:setColSpan(2):createText(Helper.displaySkill(adjustedskill), { halign = "right", color = Color["text_skills"] })

			if i == 10 then
				break
			end
		end

		if count > 10 then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText("    · ... (+" .. count - 10 .. ")")
		end
	elseif menu.contextMenuData.mode == "markashostile" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11114), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9710), { wordwrap = true })
	elseif menu.contextMenuData.mode == "clearlogbook" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5722), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 5725), { wordwrap = true })
	elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 8320), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11611), { wordwrap = true })
	elseif menu.contextMenuData.mode == "abortmission" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 3407), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 3426), { wordwrap = true })
	elseif menu.contextMenuData.mode == "abortguildmission" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 3427), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 3428), { wordwrap = true })
	elseif menu.contextMenuData.mode == "removeplot" then 
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11664), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11665), { wordwrap = true })

		ftable:addEmptyRow()

		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.contextMenuData.destroyBuildStorage end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.contextMenuData.destroyBuildStorage = not menu.contextMenuData.destroyBuildStorage end
		row[2]:setColSpan(numCols - 1):createText(ReadText(1001, 11666), { wordwrap = true })
	elseif menu.contextMenuData.mode == "removebuildstorage" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11667), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11668), { wordwrap = true })
	end


	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText("")

	if useSaveOption then
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.contextMenuData.saveOption end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[2]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 9709))
		row[2].handlers.onClick = function () menu.contextMenuData.saveOption = not menu.contextMenuData.saveOption end
		row[5]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[5].handlers.onClick = menu.buttonConfirmUserQuestion
		row[6]:createButton({ helpOverlayID = "custom_" .. menu.contextMenuData.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		if (menu.contextMenuData.mode == "abortmission") or (menu.contextMenuData.mode == "abortguildmission") then
			row[6].handlers.onClick = function () menu.showMissionContext(menu.contextMenuData.missionid, false) end
		else
			row[6].handlers.onClick = menu.closeContextMenu
		end
		ftable:setSelectedCol(6)
	else
		local col1, col2 = 2, 4
		if hasExtraCheckBox then
			col1, col2 = 3, 5
		end

		local row = ftable:addRow(true, { fixed = true })
		row[col1]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
		if menu.contextMenuData.mode == "fireindividual" then
			row[col1].handlers.onClick = function () return menu.infoSubmenuFireNPC(menu.contextMenuData.controllable, menu.contextMenuData.entity, menu.contextMenuData.person, menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "fireall" then
			row[col1].handlers.onClick = function () return menu.buttonFireCrew(menu.contextMenuData.instance, menu.contextMenuData.controllable) end
		elseif menu.contextMenuData.mode == "clearlogbook" then
			row[col1].handlers.onClick = function () return menu.buttonInfoLogbookClear(menu.contextMenuData.instance) end
		elseif menu.contextMenuData.mode == "discardplanneddefaultbehaviour" then
			row[col1].handlers.onClick = menu.contextMenuData.callback
		elseif menu.contextMenuData.mode == "removeplot" then
			row[col1].handlers.onClick = function () return menu.buttonRemovePlot(menu.contextMenuData.station, true, menu.contextMenuData.destroyBuildStorage) end
		elseif menu.contextMenuData.mode == "removebuildstorage" then
			row[col1].handlers.onClick = function () return menu.buttonRemoveBuildStorage(menu.contextMenuData.buildstorage) end
		end
		row[col2]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
		row[col2].handlers.onClick = menu.closeContextMenu
		ftable:setSelectedRow(row.index)
		ftable:setSelectedCol(col2)
	end
end

function menu.createOnlineModeContext(frame)
	local ftable = frame:addTable(2, { tabOrder = 1, reserveScrollBar = false, highlightMode = "off", x = (Helper.viewWidth - menu.onlineModeHintWidth) / 2, y = Helper.viewHeight / 2 - frame.properties.y, width = menu.onlineModeHintWidth - Helper.borderSize, backgroundID = "solid", backgroundColor = Color["frame_background_notification"] })
	ftable:setDefaultColSpan(1, 2)

	local counter = 1

	local hassession = OnlineHasSession()
	local hasdocks = false
	local hasmultipledocksperplatform = false
	for _, entry in ipairs(Helper.ventureplatforms) do
		if #entry.docks > 0 then
			hasdocks = true
			if #entry.docks > 1 then
				hasmultipledocksperplatform = true
			end
		end
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	if menu.contextMenuData.confirmoverwrite then
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11329), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Color["text_warning"] })

		local row = ftable:addRow(true, {  })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 14), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = menu.buttonConvertVentureSave

		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
		ftable:setSelectedCol(2)
	elseif hassession and hasdocks and (not hasmultipledocksperplatform) then
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11332), Helper.titleTextProperties)

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11328), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local savegames = GetSaveList(Helper.validSaveFilenames)
		local hasonlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline and (save.filename == "online_save") then
				hasonlinesave = true
				break
			end
		end
		if hasonlinesave then
			ftable:addEmptyRow()

			local row = ftable:addRow(nil, {  })
			row[1]:createText(ReadText(1001, 11361), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true, color = Color["text_warning"] })
		end

		ftable:addEmptyRow()

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11362), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		ftable:addEmptyRow()

		while not C.IsSaveListLoadingComplete() do
			-- wait until loading the savegame list is complete
		end
		local savegames = GetSaveList(Helper.validSaveFilenames)
		local onlinesave = false
		for _, save in ipairs(savegames) do
			if save.isonline then
				onlinesave = true
				break
			end
		end

		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11331), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })

		local row = ftable:addRow(true, {  })
		row[1]:setColSpan(1):createButton({ active = function () return IsOnlineSavePossible() end }):setText(ReadText(1001, 11333), { fontsize = 10, halign = "center" })
		row[1].handlers.onClick = onlinesave and menu.buttonConfirmConvertVentureSave or menu.buttonConvertVentureSave

		row[2]:createButton({  }):setText(ReadText(1001, 64), { fontsize = 10, halign = "center" })
		row[2].handlers.onClick = menu.buttonToggleMultiverseMap
		ftable:setSelectedCol(2)
	else
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 11306), Helper.titleTextProperties)

		local completed = hassession
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11301) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = C.GetVentureDLCStatus() == 0
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11358) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = true
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11302) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		completed = hasdocks
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11573) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1

		if hasmultipledocksperplatform then
			completed = false
			local row = ftable:addRow(nil, {  })
			row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11597) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
			counter = counter + 1
		end

		completed = false
		local row = ftable:addRow(nil, {  })
		row[1]:createText((completed and ColorText["text_positive"] or "") .. counter .. ". " .. ReadText(1001, 11574) .. (completed and " \27[widget_tick_01]" or ""), { fontsize = 10, x = 3 * Helper.standardTextOffsetx, wordwrap = true })
		counter = counter + 1
	end

	ftable:addEmptyRow(Helper.standardTextHeight / 2)

	ftable.properties.y = ftable.properties.y - ftable:getFullHeight() / 2

	return ftable
end

function menu.buttonRenameConfirm(isconfirmed)
	if isconfirmed then
		-- kuertee start: multi-rename
		local uix_isMultiRename = menu.contextMenuData.uix_multiRename_objects and #menu.contextMenuData.uix_multiRename_objects > 1 and (not menu.contextMenuData.fleetrename)
		if uix_isMultiRename then
			local newtext = menu.contextMenuData.newtext
			if not newtext then
				newtext = GetComponentData(menu.contextMenuData.uix_multiRename_objects[1], "name")
			end
			if menu.uix_callbacks ["buttonRenameConfirm_onMultiRename_on_before_rename"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonRenameConfirm_onMultiRename_on_before_rename"]) do
					uix_callback ()
				end
			end
			table.sort(menu.contextMenuData.uix_multiRename_objects, function (a, b) return menu.sortDanger(a, b, true) end)
			for uix_index, uix_object in ipairs(menu.contextMenuData.uix_multiRename_objects) do
				local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(uix_object)), "isplayerowned")
				if isplayerowned then
					local uix_name = menu.uix_multiRename_formatName(uix_object, newtext, uix_index)
					SetComponentName(uix_object, uix_name)
					-- local dpsTable = ffi.new("DPSData[?]", 6)
					-- C.GetDefensibleDPS(dpsTable, uix_object, true, true, true, false, true, false, false)
					-- Helper.debugText_forced(ffi.string(C.GetObjectIDCode(uix_object)), dpsTable[0].dps)
					-- Helper.debugText_forced("    ", dpsTable[1].dps)
					-- Helper.debugText_forced("    ", dpsTable[2].dps)
					-- Helper.debugText_forced("    ", dpsTable[3].dps)
					-- Helper.debugText_forced("    ", dpsTable[4].dps)
					-- Helper.debugText_forced("    ", dpsTable[5].dps)
				end
			end
			if menu.uix_callbacks ["buttonRenameConfirm_onMultiRename_on_after_rename"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonRenameConfirm_onMultiRename_on_after_rename"]) do
					uix_callback ()
				end
			end

			-- [UniTrader's Advanced Renaming] Forleyor start: callback
			if menu.uix_callbacks ["utRenaming_buttonRenameConfirm"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_buttonRenameConfirm"]) do
					uix_callback ()
				end
			end
			-- [UniTrader's Advanced Renaming] Forleyor end: callback
		-- kuertee end: multi-rename

		-- kuertee start: multi-rename
		-- if menu.contextMenuData.newtext then
		elseif menu.contextMenuData.newtext then
		-- kuertee end: multi-rename

			if menu.contextMenuData.fleetrename then
				C.SetFleetName(menu.contextMenuData.component, menu.contextMenuData.newtext)
			else
				-- kuertee start: debug
				local uix_name_old = GetComponentData(menu.contextMenuData.component, "name")
				local uix_idcode = C.GetObjectIDCode(menu.contextMenuData.component)
				Helper.debugText_forced(menu.contextMenuData.component, uix_name_old .. tostring(uix_idcode))
				Helper.debugText_forced("newtext", menu.contextMenuData.newtext)
				-- kuertee end: debug

				SetComponentName(menu.contextMenuData.component, menu.contextMenuData.newtext)

				-- [UniTrader's Advanced Renaming] Forleyor start: callback
				if menu.uix_callbacks ["utRenaming_buttonRenameConfirm"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_buttonRenameConfirm"]) do
						uix_callback ()
					end
				end
				-- [UniTrader's Advanced Renaming] Forleyor end: callback

			end
		end
	end
	menu.noupdate = false
	menu.refreshInfoFrame()
	menu.closeContextMenu("back")
end

-- kuertee start: multi-rename
function menu.uix_multiRename_formatName(object, newName, uix_index)
	local uix_name = newName
	if string.find(uix_name, "$name") then
		uix_name = string.gsub(uix_name, "%$name", GetComponentData(object, "name"))
	end
	if string.find(uix_name, "$name_UTAR") then
		local editName
		-- start: from utrenaming.lua utRenaming.setupInfoSubmenuRows() --
		local editNames = GetNPCBlackboard(ConvertStringTo64Bit(tostring(C.GetPlayerID())) , "$unformatted_names")
		if editNames then
			for k,v in pairs(editNames) do
				--DebugError(tostring(k))
				--DebugError("ID: "..tostring(inputobject))
				if tostring(k) == "ID: "..tostring(station) then
					editName = v
					--DebugError(editName)
					break
				end
			end
		end
		uix_name = string.gsub(uix_name, "%$name_UTAR", GetComponentData(object, "editName"))
	end
	if string.find(uix_name, "$i") then
		uix_name = string.gsub(uix_name, "%$i", uix_index)
	end
	return uix_name
end
-- kuertee end: multi-rename

function menu.initializeBoardingData(target)
	menu.boardingData = {
							target = target, ships = {}, shipdata = {}, selectedship = nil,
							marinelevels = {}, casualties = {0, 0, 0},
							currentphase = "setup", phaseindices = {}, phasedata = {}, progresslevels = {},
							risk1 = nil, risk2 = nil, risklevels = {}, riskleveldata = {},
							shipactions = {},
							changed = false, iscapturable = GetComponentData(target, "iscapturable")
						}
	local numtiers = C.GetNumTiersOfRole("marine")
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetTiersOfRole(tierdata, numtiers, "marine")
	for i = 0, numtiers - 1 do
		table.insert(menu.boardingData.marinelevels, { skilllevel = tierdata[i].skilllevel, text = ffi.string(tierdata[i].name) })
	end

	local numphases = C.GetNumAllBoardingPhases()
	local phases = ffi.new("BoardingPhase[?]", numphases)
	numphases = C.GetAllBoardingPhases(phases, numphases)
	for i = 0, numphases-1 do
		if ffi.string(phases[i].id) ~= "" then
			local phaseid = ffi.string(phases[i].id)
			menu.boardingData.phaseindices[phaseid] = (i+1)
			if phaseid == "approach" or phaseid == "infiltration" or phaseid == "internalfight" then
				table.insert(menu.boardingData.phasedata, { text = ffi.string(phases[i].text), state = "waiting", mouseOverText = "" })
			end
		end
	end
	menu.boardingData.phasedata[1].mouseOverText = ReadText(1026, 8201)		-- Destroy turrets to improve chances of boarding pods arriving safely.
	menu.boardingData.phasedata[2].mouseOverText = ReadText(1026, 8202)		-- Damage hull to reduce the time needed to breach the target.
	menu.boardingData.phasedata[3].mouseOverText = ReadText(1026, 8203)		-- Send more or better marines to improve chances of success.

	menu.boardingData.phasedata[1].helpOverlayID = "boarding_stage1"
	menu.boardingData.phasedata[2].helpOverlayID = "boarding_stage2"
	menu.boardingData.phasedata[3].helpOverlayID = "boarding_stage3"

	menu.boardingData.phasedata[1].helpOverlayText = " "
	menu.boardingData.phasedata[2].helpOverlayText = " "
	menu.boardingData.phasedata[3].helpOverlayText = " "

	menu.boardingData.phasedata[1].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[2].helpOverlayHighlightOnly = true
	menu.boardingData.phasedata[3].helpOverlayHighlightOnly = true

	menu.boardingData.progresslevels = { -- Stage not started, Stage in progress, Stage completed
		waiting = {text = ReadText(1001, 9510), color = Color["text_boarding_waiting"]},
		started = {text = ReadText(1001, 9511), color = Color["text_boarding_started"]},
		done	= {text = ReadText(1001, 9512), color = Color["text_boarding_done"]},
	}

	menu.boardingData.risklevels = { "verylow", "low", "medium", "high", "veryhigh" }
	menu.boardingData.riskleveldata = {
		verylow		= { index = 1, text = ReadText(1037, 3001), textlower = ReadText(1037, 4001), threshold = 20, hulldescription = ReadText(1037, 5001), color = Color["text_boarding_risk_verylow"] },
		low			= { index = 2, text = ReadText(1037, 3002), textlower = ReadText(1037, 4002), threshold = 30, hulldescription = ReadText(1037, 5002), color = Color["text_boarding_risk_low"] },
		medium		= { index = 3, text = ReadText(1037, 3003), textlower = ReadText(1037, 4003), threshold = 50, hulldescription = ReadText(1037, 5003), color = Color["text_boarding_risk_medium"] },
		high		= { index = 4, text = ReadText(1037, 3004), textlower = ReadText(1037, 4004), threshold = 80, hulldescription = ReadText(1037, 5004), color = Color["text_boarding_risk_high"] },
		veryhigh	= { index = 5, text = ReadText(1037, 3005), textlower = ReadText(1037, 4005), threshold = 100, hulldescription = ReadText(1037, 5005), color = Color["text_boarding_risk_veryhigh"] },
		impossible	= { index = 6, text = ReadText(1037, 3006), textlower = ReadText(1037, 4006), threshold = 120, hulldescription = ReadText(1037, 5005), color = Color["text_boarding_risk_impossible"] },
	}
	if not menu.boardingData.risk1 then
		-- Approach risk threshold. default: low
		menu.boardingData.risk1 = menu.boardingData.risklevels[2]
	end
	if not menu.boardingData.risk2 then
		-- Infiltrate risk threshold. default: high (marines don't die while drilling through anymore, but it does increase risk for them in the assault phase since defenders have more time to organize.)
		menu.boardingData.risk2 = menu.boardingData.risklevels[4]
	end

	local numactions = C.GetNumAllBoardingBehaviours()
	local actions = ffi.new("BoardingBehaviour[?]", numactions)
	numactions = C.GetAllBoardingBehaviours(actions, numactions)
	for i = 0, numactions-1 do
		if ffi.string(actions[i].id) ~= "" then
			table.insert(menu.boardingData.shipactions, { id = ffi.string(actions[i].id), text = ffi.string(actions[i].text) })
		end
	end
end

function menu.createBoardingContext(frame, target, boarders)
	if not menu.boardingData or not menu.boardingData.target then
		menu.initializeBoardingData(target)
	end

	local activeop = C.IsDefensibleBeingBoardedBy(target, "player")
	local unknowntext = ReadText(1001, 3210)
	local unknowncolor = Color["text_negative"]
	local boardingcheatsecrecy = false

	-- if op is already running, add all ships that are already assigned to the boarding operation.
	if activeop then
		menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
		-- get risk thresholds
		local rawriskthresholds = ffi.new("BoardingRiskThresholds")
		rawriskthresholds = C.GetBoardingRiskThresholds(target, "player")
		--print("rawrisk1: " .. tostring(rawriskthresholds[0]) .. ", rawrisk2: " .. tostring(rawriskthresholds[1]))
		local found1, found2 = nil
		for _, risklevel in ipairs(menu.boardingData.risklevels) do
			if not found1 and rawriskthresholds.approach <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk1 = risklevel
				found1 = true
			end
			if not found2 and rawriskthresholds.insertion <= menu.boardingData.riskleveldata[risklevel].threshold then
				menu.boardingData.risk2 = risklevel
				found2 = true
			end
			if found1 and found2 then
				break
			end
		end
		--print("retrieved risk levels. approach: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk1].text) .. ", insertion: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risk2].text))

		local numattackers = C.GetNumAttackersOfBoardingOperation(target, "player")
		local attackers = ffi.new("UniverseID[?]", numattackers)
		numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, target, "player")
		--print("num attackers: " .. tostring(numattackers) .. ". attackers: ")
		for i = 0, numattackers-1 do
			local boarder = ConvertStringTo64Bit(tostring(attackers[i]))
			--print(" " .. ffi.string(C.GetComponentName(boarder)))

			if not menu.boardingData.shipdata[boarder] then
				table.insert(menu.boardingData.ships, boarder)
				menu.boardingData.shipdata[boarder] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = ffi.string(C.GetBoardingActionOfAttacker(target, boarder, "player")) }

				-- only update assignedmarines if shipdata is to be reset.
				local numtiers = #menu.boardingData.marinelevels
				local marinetieramounts = ffi.new("uint32_t[?]", numtiers)
				local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					marineskilllevellist[j-1] = leveldata.skilllevel
				end
				C.GetBoardingMarineTierAmountsFromAttacker(marinetieramounts, marineskilllevellist, numtiers, target, boarder, "player")
				for j, leveldata in ipairs(menu.boardingData.marinelevels) do
					menu.boardingData.shipdata[boarder].assignedmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					menu.boardingData.shipdata[boarder].assignedgroupmarines[leveldata.skilllevel] = marinetieramounts[j-1]
					--print("retrieving. index: " .. tostring(j-1) .. ", num marines: " .. tostring(marinetieramounts[j-1]) .. ", skill level: " .. tostring(leveldata.skilllevel))
				end
			end
		end
	end

	-- add all boarders that were passed in and are not yet listed to menu.boardingData.ships and initialize menu.boardingData.shipdata for them.
	for _, ship in ipairs(boarders) do
		if not menu.boardingData.shipdata[ship] then
			--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " to boarding operation.")
			table.insert(menu.boardingData.ships, ship)
			menu.boardingData.shipdata[ship] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = true, issubordinate = false, action = menu.boardingData.shipactions[2].id }
		end
	end

	-- populate marine and subordinate data for menu.boardingData.ships in menu.boardingData.shipdata
	for _, ship in ipairs(menu.boardingData.ships) do
		local numpeople = C.GetNumAllRoles()
		local peopledata = ffi.new("PeopleInfo[?]", numpeople)
		numpeople = C.GetPeople2(peopledata, numpeople, ship, false)
		local numtiers = #menu.boardingData.marinelevels
		local tierdata = ffi.new("RoleTierData[?]", numtiers)
		numtiers = C.GetRoleTiers2(tierdata, numtiers, ship, "marine", false)
		for i = 0, numtiers - 1 do
			menu.boardingData.shipdata[ship].marines[tierdata[i].skilllevel] = tierdata[i].amount
			menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
		end

		local subordinates = GetSubordinates(ship, nil, true)
		--print("found " .. tostring(#subordinates) .. " subordinates")
		for _, subordinate in ipairs(subordinates) do
			local subordinate = ConvertIDTo64Bit(subordinate)
			if not C.IsUnit(subordinate) then
				if not menu.boardingData.shipdata[subordinate] then
					menu.boardingData.shipdata[subordinate] = { assignedmarines = {}, marines = {}, assignedgroupmarines = {}, groupmarines = {}, subordinates = {}, isprimaryboarder = false, issubordinate = true, action = menu.boardingData.shipactions[2].id }

					local alreadylisted = false
					for _, evalsubordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
						if subordinate == evalsubordinate then
							alreadylisted = true
							break
						end
					end
					if not alreadylisted then
						--print("adding subordinate " .. ffi.string(C.GetComponentName(subordinate)) .. " to boarding operation.")
						table.insert(menu.boardingData.shipdata[ship].subordinates, subordinate)
					end
				else
					menu.boardingData.shipdata[subordinate].issubordinate = true
				end

				if not menu.boardingData.shipdata[subordinate].isprimaryboarder then
					numpeople = C.GetNumAllRoles()
					peopledata = ffi.new("PeopleInfo[?]", numpeople)
					numpeople = C.GetPeople2(peopledata, numpeople, subordinate, false)
					numtiers = #menu.boardingData.marinelevels
					tierdata = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinate, "marine", false)
					for i = 0, numtiers - 1 do
						if tierdata[i].amount > 0 then
							--print("subordinate: " .. ffi.string(C.GetComponentName(subordinate)) .. ": adding " .. tierdata[i].amount .. " marines with skill " .. tostring(tierdata[i].skilllevel) .. " to entry of " .. ffi.string(C.GetComponentName(ship)))
							menu.boardingData.shipdata[subordinate].marines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[subordinate].groupmarines[tierdata[i].skilllevel] = tierdata[i].amount
							menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] = menu.boardingData.shipdata[ship].groupmarines[tierdata[i].skilllevel] + tierdata[i].amount
						end
					end
				end

				for _, tierdata in ipairs(menu.boardingData.marinelevels) do
					if not menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedmarines[tierdata.skilllevel] = 0
					end
					if not menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] then
						menu.boardingData.shipdata[subordinate].assignedgroupmarines[tierdata.skilllevel] = 0
					end
				end
			end
		end
		for _, tierdata in ipairs(menu.boardingData.marinelevels) do
			if not menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedmarines[tierdata.skilllevel] = 0
			end
			if not menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] then
				menu.boardingData.shipdata[ship].assignedgroupmarines[tierdata.skilllevel] = 0
			end
		end
	end

	local targetname, targetowner, hullpercentage = GetComponentData(target, "name", "ownername", "hullpercent")

	local numoperationalturrets = 0
	local numtotalturrets = 0
	local numpotentialturrets = 0
	local numslots = tonumber(C.GetNumUpgradeSlots(target, "", "turret"))
	for i = 1, numslots do
		numpotentialturrets = numpotentialturrets + 1
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(target, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 then
			numtotalturrets = numtotalturrets + 1
			if IsComponentOperational(currentcomponent) then
				numoperationalturrets = numoperationalturrets + 1
			end
		end
	end

	local targetcrewcapacity = C.GetPeopleCapacity(target, "", false)

	local currentboardingresistance = GetComponentData(target, "boardingresistance")
	local numdefendingcrew = menu.getNumDefendingCrew(target)

	-- tally total assigned marines and fill in empty marine tier entries.
	local totalassignedmarines = 0
	if activeop then
		totalassignedmarines = totalassignedmarines + C.GetNumBoardingMarinesFromOperation(target, "player")
	else
		for _, boarder in ipairs(menu.boardingData.ships) do
			for _, tierdata in ipairs(menu.boardingData.marinelevels) do
				if not menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedmarines[tierdata.skilllevel] = 0
				end
				if not menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] then
					menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] = 0
				end
				totalassignedmarines = totalassignedmarines + menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel]
				--print("assigned marines: adding " .. menu.boardingData.shipdata[boarder].assignedgroupmarines[tierdata.skilllevel] .. " " .. tostring(tierdata.text) .. " marines from " .. ffi.string(C.GetComponentName(boarder)) .. " " .. tostring(boarder) .. " to total tally.\n total: " .. tostring(totalassignedmarines))
			end
		end
	end

	if not menu.boardingData.selectedship or not menu.boardingData.shipdata[menu.boardingData.selectedship] then
		menu.boardingData.selectedship = menu.boardingData.ships[1]
	end

	local boardingstrength = 0
	if activeop then
		boardingstrength = boardingstrength + C.GetBoardingStrengthFromOperation(target, "player")
	else
		for i, ship in ipairs(menu.boardingData.ships) do
			local locnumtiers = #menu.boardingData.marinelevels
			local locmarinetieramounts = ffi.new("uint32_t[?]", locnumtiers)
			local locmarineskilllevels = ffi.new("uint32_t[?]", locnumtiers)
			for j, level in ipairs(menu.boardingData.marinelevels) do
				locmarinetieramounts[j-1] = menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]
				locmarineskilllevels[j-1] = level.skilllevel
				--print("tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[ship].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
			end
			boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(ship, locmarinetieramounts, locmarineskilllevels, locnumtiers)
			if #menu.boardingData.shipdata[ship].subordinates > 0 then
				for _, subordinate in ipairs(menu.boardingData.shipdata[ship].subordinates) do
					for j, level in ipairs(menu.boardingData.marinelevels) do
						locmarinetieramounts[j-1] = menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]
						locmarineskilllevels[j-1] = level.skilllevel
						--print("subordinate. tier: " .. j .. " num tiers: " .. locnumtiers .. " tier amount: " .. tostring(menu.boardingData.shipdata[subordinate].assignedmarines[level.skilllevel]) .. " skill level: " .. level.skilllevel)
					end
					boardingstrength = boardingstrength + C.GetBoardingStrengthOfControllableTierAmounts(subordinate, locmarinetieramounts, locmarineskilllevels, locnumtiers)
				end
			end
			--print("calculating boarding strength. num ships evaluated: " .. i .. " boarding strength: " .. boardingstrength)
		end
	end

	-- max potential boarding resistance: only for comparison with boardingstrength to be expressed as an adjective for crew strength estimate in stage III. always use potential? that would tend to make the approximation safer if very conservative.
	-- we're now using combinedskill to calculate boarding strength, so max potential is max number of crew * maxcombinedskill
	--local maxpotentialboardingresistance = targetcrewcapacity * 100
	local maxpotentialboardingresistance = numdefendingcrew * 100

	-- NB: risk numbers will be updated every time the text widgets that use them are.
	local risk = {}
	-- chance that launched marines will get to target compared to target ship type with maximum loadout
	table.insert(risk, ((numoperationalturrets / math.max(numtotalturrets, 1)) * 100))
	--table.insert(risk, ((numoperationalturrets / numpotentialturrets) * 100))
	-- chance that assaulting marines will survive entry
	table.insert(risk, hullpercentage)
	-- chance that attacking ships will accidentally destroy target
	table.insert(risk, 100 - risk[2])
	-- chance that assaulting marines will defeat opposition within the ship
	table.insert(risk, ((1.0 - math.min((boardingstrength / math.max(currentboardingresistance, 1.0)), 1.0)) * 100))
	--print("risk 1: " .. tostring(risk[1]) .. "\nrisk 2: " .. tostring(risk[2]) .. "\nrisk 3: " .. tostring(risk[3]))

	-- Boarding
	local table_header = frame:addTable(1, { x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })

	local row = table_header:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(ReadText(1001, 9500), Helper.headerRowCenteredProperties)		-- Boarding

	-- Boarding Plan
	local table_bottom = frame:addTable(9, { tabOrder = 5, x = Helper.borderSize, y = menu.contextMenuData.height * 3 / 4 + Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "column" })
	table_bottom:setColWidthPercent(2, 5)
	table_bottom:setColWidthPercent(3, 10)
	table_bottom:setColWidthPercent(5, 5)
	table_bottom:setColWidthPercent(6, 10)
	table_bottom:setColWidthPercent(8, 5)
	table_bottom:setColWidthPercent(9, 10)

	row = table_bottom:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(9):createText(ReadText(1001, 9501), Helper.headerRowCenteredProperties)		-- Boarding Plan

	row = table_bottom:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	for i, phase in ipairs(menu.boardingData.phasedata) do
		row[3*i-2]:setColSpan(3):createText(phase.text, { font = Helper.standardFontBold, halign = "center", mouseOverText = phase.mouseOverText,  helpOverlayID = phase.helpOverlayID, helpOverlayText = phase.helpOverlayText, helpOverlayHighlightOnly = phase.helpOverlayHighlightOnly})
	end

	if activeop then
		row = table_bottom:addRow(false, {  })

		for i, phase in ipairs(menu.boardingData.phasedata) do
			row[3*i-2]:createText((ReadText(1001, 9513) .. ReadText(1001, 120)), { mouseOverText = phase.mouseOverText })		-- Progress, :
			row[3*i-1]:setColSpan(2):createText(function()
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						-- get current phase. updated here to dynamically update the phase for this section of the menu.
						menu.boardingData.currentphase = ffi.string(C.GetCurrentBoardingPhase(target, "player"))
					else
						-- this is for displaying the state of each phase so "succeeded" or "failed" doesn't really matter as long as its index is > that of all of the other phases.
						menu.boardingData.currentphase = "succeeded"
					end

					-- update phase data depending on current phase.
					if i == 1 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] > menu.boardingData.phaseindices.approach and "done") or "started"
					elseif i == 2 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.pre_infiltration and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "started") or "done"
					elseif i == 3 then
						phase.state = (menu.boardingData.phaseindices[menu.boardingData.currentphase] < menu.boardingData.phaseindices.internalfight and "waiting") or (menu.boardingData.phaseindices[menu.boardingData.currentphase] == menu.boardingData.phaseindices.internalfight and "started") or "done"
					end
					return menu.boardingData.progresslevels[phase.state].text
				end, { halign = "right", color = function() return menu.boardingData.progresslevels[phase.state].color end, mouseOverText = phase.mouseOverText })
		end
	end

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Risk, :
	row[3]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risk1].color or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9515) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk of destroying target, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[6 - menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9516) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Defending crew, :
	row[9]:createText(function()
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(2):createText((ReadText(1001, 9517) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Target combat effectiveness, :
	row[3]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			risk[1] = ((locnumoperationalturrets / math.max(numtotalturrets, 1)) * 100)
			local risktext = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[1] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[1].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row[4]:setColSpan(2):createText((ReadText(1001, 9518) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Risk to marines, :
	row[6]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].text or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and menu.boardingData.riskleveldata[menu.boardingData.risklevels[menu.boardingData.riskleveldata[menu.boardingData.risk2].index]].color or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9519) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Attacking marines, :
	row[9]:createText(function()
		local loctotalassignedmarines = totalassignedmarines
		if activeop then
			loctotalassignedmarines = C.GetNumBoardingMarinesFromOperation(target, "player")
		end
		return loctotalassignedmarines .. " / " .. targetcrewcapacity end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(3):createText("", { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })

	row[4]:setColSpan(2):createText((ReadText(1001, 9520) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Target hull, :
	row[6]:createText(function()
			risk[2] = GetComponentData(target, "hullpercent")
			local hulldescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if risk[2] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
					hulldescription = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].hulldescription
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and hulldescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[2].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row[7]:setColSpan(2):createText((ReadText(1001, 9514) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Risk, :
	row[9]:createText(function()
			local risktext = ""
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						--print("risk: " .. tostring(risk[4]) .. ". strength: " .. tostring(boardingstrength) .. ", resistance: " .. tostring(loccurrentboardingresistance) .. ", current threshold: " .. tostring(menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold))
						risktext = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].text
						break
					end
				end
			else
				risktext = menu.boardingData.riskleveldata.impossible.text
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and risktext or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function()
			local riskcolor = nil
			local isimpossible = nil
			if menu.boardingData.iscapturable then
				local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
				risk[4] = ((2.0 - math.min((boardingstrength / math.max(loccurrentboardingresistance, 1.0)), 2.0)) * 100) / 2
				for i = 1, #menu.boardingData.risklevels do
					if risk[4] <= menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].threshold then
						riskcolor = menu.boardingData.riskleveldata[menu.boardingData.risklevels[i]].color
						break
					end
				end
			else
				riskcolor = menu.boardingData.riskleveldata.impossible.color
				isimpossible = true
			end
			return (boardingcheatsecrecy or isimpossible or C.IsInfoUnlockedForPlayer(target, "operator_details")) and riskcolor or unknowncolor
		end })

	row = table_bottom:addRow(false, {  })

	row[1]:setColSpan(3):createText((ReadText(1001, 9521) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[1].mouseOverText })		-- Launch pods at combat effectiveness, :

	row[4]:setColSpan(3):createText((ReadText(1001, 9522) .. ReadText(1001, 120)), { mouseOverText = menu.boardingData.phasedata[2].mouseOverText })		-- Start breaching at hull strength, :

	row[7]:setColSpan(2):createText((ReadText(1001, 1325) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Attack Strength, :
	row[9]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText })

	local dropdowndata = {}
	for _, levelid in ipairs(menu.boardingData.risklevels) do
		table.insert(dropdowndata, {id = levelid, text = menu.boardingData.riskleveldata[levelid].hulldescription, icon = "", displayremoveoption = false})
	end
	row = table_bottom:addRow(true, {  })

	-- TODO: make dropdown being active dependent on current phase (certainly inactive after phase this applies to is done, but also while the phase is currently active?)
	row[1]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk1, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[1].mouseOverText, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 1) end
	row[4]:setColSpan(3):createDropDown(dropdowndata, {startOption = menu.boardingData.risk2, height = config.mapRowHeight, mouseOverText = menu.boardingData.phasedata[2].mouseOverText, active = not activeop})
	row[4].handlers.onDropDownConfirmed = function(_, newrisklevel) return menu.dropdownBoardingSetRisk(newrisklevel, 2) end

	row[7]:setColSpan(2):createText((ReadText(1001, 1324) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Boarding Resistance, :
	row[9]:createText(function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and tostring(GetComponentData(target, "boardingresistance")) or unknowntext end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })
	--[[
	row[7]:setColSpan(2):createText((ReadText(1001, 9523) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2, mouseOverText = menu.boardingData.phasedata[3].mouseOverText })		-- Crew strength, :
	row[9]:createText(function()
			local loccurrentboardingresistance = GetComponentData(target, "boardingresistance")
			local targetcrewstrength = loccurrentboardingresistance / math.max(maxpotentialboardingresistance, 1.0)
			--print("crewstrength: " .. tostring(targetcrewstrength) .. ", currentboardingresistance: " .. tostring(currentboardingresistance) .. ", maxpotentialboardingresistance: " .. tostring(maxpotentialboardingresistance))
			local crewdescription = ""
			for i = 1, #menu.boardingData.risklevels do
				if targetcrewstrength <= menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].threshold then
					crewdescription = menu.boardingData.riskleveldata[ menu.boardingData.risklevels[i] ].text
					break
				end
			end
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and crewdescription or unknowntext
		end, { halign = "right", mouseOverText = menu.boardingData.phasedata[3].mouseOverText, color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor end })
	--]]

	-- Ship Configuration
	local table_left = frame:addTable(2, { tabOrder = 4, x = Helper.borderSize, width = menu.contextMenuData.width / 2 - Helper.borderSize / 2 })

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setBackgroundColSpan(2):createText(ReadText(1001, 9502) .. ReadText(1001, 120))		-- Configuring, :
	row[2]:createText(ffi.string(C.GetComponentName(menu.boardingData.selectedship)) .. " (" .. ffi.string(C.GetObjectIDCode(menu.boardingData.selectedship)) .. ")", { halign = "right" })

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setColSpan(2):createText((ReadText(1001, 9524) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Ship behaviour while engaging the target, :

	local dropdowndata2 = {}
	for _, actiondata in ipairs(menu.boardingData.shipactions) do
		table.insert(dropdowndata2, {id = actiondata.id, text = actiondata.text, icon = "", displayremoveoption = false})
	end

	-- TODO: make dropdown being active dependent on current phase? disable after op has started?
	row = table_left:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createDropDown(dropdowndata2, {startOption = menu.boardingData.shipdata[menu.boardingData.selectedship].action, height = config.mapRowHeight, active = not activeop})
	row[1].handlers.onDropDownConfirmed = function(_, newaction) return menu.dropdownBoardingSetAction(menu.boardingData.selectedship, newaction) end

	titlerow = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	titlerow[1]:setColSpan(2):createText((ReadText(1001, 9529) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 3})	-- Select marines to board with, :
	titlerow[1].properties.helpOverlayID = "boarding_selectmarines"
	titlerow[1].properties.helpOverlayText = " "
	titlerow[1].properties.helpOverlayHeight = titlerow:getHeight()
	titlerow[1].properties.helpOverlayHighlightOnly = true
	titlerow[1].properties.helpOverlayScaling = false
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		row = table_left:addRow(true, { fixed = true })
		-- TODO: set slider to readOnly depending on phase? will depend on whether or not we allow sending more marines later in the operation to reinforce.
		--print("assigned: " .. tostring(assignedmarines[menu.boardingData.selectedship][leveldata.skilllevel]) .. ", available: " .. tostring(availablemarines[leveldata.skilllevel]))
		--print("start: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. ", maxSelect: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\n poss1: " .. tostring(targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]) .. "\n poss2: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. "\ntargetcrewcapacity: " .. tostring(targetcrewcapacity) .. "\ntotalassignedmarines: " .. tostring(totalassignedmarines))
		--print("skilllevel: " .. tostring(leveldata.skilllevel) .. ", groupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel]) .. ", marines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].marines[leveldata.skilllevel]) .. ", assignedgroupmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) .. ", assignedmarines: " .. tostring(menu.boardingData.shipdata[menu.boardingData.selectedship].assignedmarines[leveldata.skilllevel]))
		row[1]:setColSpan(2):createSliderCell({ start = menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel], max = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], maxSelect = menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel] > (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) and (targetcrewcapacity - totalassignedmarines + menu.boardingData.shipdata[menu.boardingData.selectedship].assignedgroupmarines[leveldata.skilllevel]) or menu.boardingData.shipdata[menu.boardingData.selectedship].groupmarines[leveldata.skilllevel], height = config.mapRowHeight, x = Helper.standardTextOffsetx * 4, readOnly = activeop }):setText(leveldata.text)
		row[1].handlers.onSliderCellChanged = function(_, val) return menu.slidercellBoardingAssignedMarines(menu.boardingData.selectedship, leveldata.skilllevel, val) end
		row[1].handlers.onSliderCellConfirm = function() return menu.refreshContextFrame() end
		titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	end

	row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setBackgroundColSpan(2):createText((ReadText(1001, 9525) .. ReadText(1001, 120)), { x = Helper.standardTextOffsetx * 2 })		-- Boarding strength, :
	row[2]:createText(function()
			local locboardingstrength = boardingstrength
			if activeop then
				locboardingstrength = C.GetBoardingStrengthFromOperation(target, "player")
			end
			return locboardingstrength
		end, { halign = "right" })
	titlerow[1].properties.helpOverlayHeight = titlerow[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
	if activeop then
		row = table_left:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(2):createText(ReadText(1001, 9526), { halign = "center" })		-- Total Casualties

		for lvl, leveldata in ipairs(menu.boardingData.marinelevels) do
			row = table_left:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(2):createText(leveldata.text)
			-- if boarding op had already started but is now finished, print last saved data.
			row[2]:createText(function()
					local locskilllevel = leveldata.skilllevel
					local loclvl = lvl
					--print("skill level: " .. tostring(locskilllevel) .. " lvl: " .. tostring(loclvl))
					if C.IsDefensibleBeingBoardedBy(target, "player") then
						--local oldcasualties = menu.boardingData.casualties[loclvl]
						menu.boardingData.casualties[loclvl] = C.GetBoardingCasualtiesOfTier(locskilllevel, target, "player")
						--if menu.boardingData.casualties[loclvl] ~= oldcasualties then
						--	print("updating casualties of tier: " .. loclvl .. ". from: " .. oldcasualties .. " to: " .. menu.boardingData.casualties[loclvl])
						--end
					end
					return menu.boardingData.casualties[loclvl]
				end, { halign = "right" })
		end
	end

	table_left.properties.y = table_bottom.properties.y - table_header.properties.y - table_left:getVisibleHeight() - Helper.borderSize

	-- name might be confusing. table containing the button for the topleft table, rather than the button on the top-left.
	local table_button_topleft = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = table_left.properties.width })
	row = table_button_topleft:addRow(true, { fixed = true })
	-- TODO: activate button when mode boarding_selectplayerobject is implemented. disable depending on phase?
	--row[1]:createButton({ active = false }):setText(ReadText(1001, 9527), { halign = "center" })		-- Add ship to boarding operation
	--row[1].handlers.onClick = function() return menu.buttonBoardingAddShip() end

	-- Ships assigned to boarding operation. has to be initialized after table_bottom because we need that table's y-offset
	menu.boardingtable_shipselection = frame:addTable(3, { tabOrder = 2, x = Helper.borderSize, y = table_header.properties.y + table_header:getVisibleHeight() + Helper.borderSize, width = table_left.properties.width })
	menu.boardingtable_shipselection:setColWidth(2, config.mapRowHeight * 2)
	menu.boardingtable_shipselection:setColWidth(3, Helper.scaleY(config.mapRowHeight), false)

	row = menu.boardingtable_shipselection:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 9528))		-- Ships assigned to boarding operation

	for _, shipid in ipairs(menu.boardingData.ships) do
		row = menu.boardingtable_shipselection:addRow({"boardingship", shipid}, {  })
		local nameappendix = ""
		if #menu.boardingData.shipdata[shipid].subordinates > 0 then
			nameappendix = (" + " .. #menu.boardingData.shipdata[shipid].subordinates .. " " .. ReadText(1001, 1504))		-- subordinates
		end
		row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. " (" .. ffi.string(C.GetObjectIDCode(shipid)) .. ")" .. nameappendix))
		--row[1]:setBackgroundColSpan(3):createText((ffi.string(C.GetComponentName(shipid)) .. nameappendix), { x = menu.boardingData.shipdata[shipid].issubordinate and (Helper.standardTextOffsetx + Helper.standardIndentStep) or nil })

		local nummarines = 0
		for _, leveldata in ipairs(menu.boardingData.marinelevels) do
			nummarines = nummarines + menu.boardingData.shipdata[shipid].groupmarines[leveldata.skilllevel]
		end
		row[2]:createText(nummarines, { halign = "right" })
		if not menu.boardingData.shipdata[shipid].issubordinate then
			row[3]:createButton({ height = row[3]:getWidth(), scaling = false }):setText("x", { halign = "center", font = Helper.standardFontBold })
			row[3].handlers.onClick = function() return menu.buttonBoardingRemoveShip(shipid) end
		end

		if menu.boardingData.selectedship == shipid then
			menu.boardingtable_shipselection:setSelectedRow(row.index)
		end
	end

	menu.boardingtable_shipselection.properties.maxVisibleHeight = table_left.properties.y - Helper.scaleY(table_button_topleft:getVisibleHeight()) - Helper.scaleY(table_header:getVisibleHeight()) - Helper.borderSize * 3
	table_button_topleft.properties.y = menu.boardingtable_shipselection.properties.y + menu.boardingtable_shipselection:getVisibleHeight() + Helper.borderSize
	--print("topleft maxvisibleheight: " .. tostring(menu.boardingtable_shipselection.properties.maxVisibleHeight) .. "\n left y offset: " .. tostring(table_left.properties.y) .. "\n buttontopleft height: " .. tostring(table_button_topleft:getVisibleHeight()) .. "\n header height: " .. tostring(table_header:getVisibleHeight()) .. "\n 3 borders: " .. tostring(Helper.borderSize * 3))

	-- Boarding Target
	local table_right = frame:addTable(2, { x = table_left.properties.x + table_left.properties.width + Helper.borderSize, y = menu.boardingtable_shipselection.properties.y, width = table_left.properties.width, height = table_bottom.properties.y - Helper.scaleY(table_header:getVisibleHeight())  - Helper.borderSize * 2 })
	table_right:setColWidthPercent(1, 20)

	row = table_right:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 9503), { halign = "center" })	-- Boarding Target

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 5) .. ReadText(1001, 120))		-- Ship, :
	row[2]:createText(targetname, { halign = "right" })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))		-- Faction, :
	row[2]:createText(targetowner, { halign = "right" })

	row = table_right:addRow(false, {  })
	row[1]:setColSpan(2):createText("")

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 1319) .. ReadText(1001, 120))		-- Turrets, :
	row[2]:createText(function()
			local locnumoperationalturrets = menu.getNumOperationalTurrets(target, numtotalturrets)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (locnumoperationalturrets .. " / " .. numtotalturrets) or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 1) .. ReadText(1001, 120))		-- Hull, :
	row[2]:createText(function()
			local lochullpercentage = GetComponentData(target, "hullpercent")
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and (lochullpercentage .. "%") or unknowntext
		end, { halign = "right", color = function() return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "defence_status")) and Color["text_normal"] or unknowncolor end })

	row = table_right:addRow(false, {  })
	row[1]:createText(ReadText(1001, 80) .. ReadText(1001, 120))		-- Crew, :
	row[2]:createText(function()
			local locnumdefendingcrew = menu.getNumDefendingCrew(target)
			return (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and (locnumdefendingcrew .. " / " .. targetcrewcapacity) or unknowntext
		end, { halign = "right", color = (boardingcheatsecrecy or C.IsInfoUnlockedForPlayer(target, "operator_details")) and Color["text_normal"] or unknowncolor })

	local table_button = frame:addTable(3, { tabOrder = 6, x = Helper.borderSize, y = table_bottom.properties.y + table_bottom:getVisibleHeight() + Helper.borderSize, width = menu.contextMenuData.width })
	table_button:setColWidthPercent(2, 15)
	table_button:setColWidthPercent(3, 15)

	row = table_button:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	-- handler: if no boarding op, create a boarding op with defined specifications. (and refresh menu?)
	-- if op already created, update boarding op data. (changes in ship and marine assignments.)
	-- approachthreshold == menu.boardingData.risk1
	-- insertionthreshold == menu.boardingData.risk2
	-- activate button only if anything was changed (number of marines, thresholds, actions)
	row[2]:createButton({ active = function() return menu.boardingData.iscapturable and menu.boardingData.changed and totalassignedmarines > 0 end, helpOverlayID = "boarding_operation_start", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(activeop and ReadText(1001, 9531) or ReadText(1001, 9530), { halign = "center" })		-- Update Operation, Start Operation
	row[2].handlers.onClick = function() return menu.buttonUpdateBoardingOperation(activeop) end
	row[2].properties.uiTriggerID = "startboarding"
	row[3]:createButton({ active = true, helpOverlayID = "boarding_operation_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true  }):setText(activeop and ReadText(1001, 8035) or ReadText(1001, 64), { halign = "center" })		-- "Close Menu", "Cancel"
	row[3].handlers.onClick = function() return menu.closeContextMenu() end
	row[3].properties.uiTriggerID = "cancelboarding"

	if menu.contexttoprow then
		menu.boardingtable_shipselection:setTopRow(menu.contexttoprow)
		menu.contexttoprow = nil
	end
	if menu.contextselectedrow then
		menu.boardingtable_shipselection:setSelectedRow(menu.contextselectedrow)
		menu.contextselectedrow = nil
	end
end

function menu.createMissionContext(frame)
	AddUITriggeredEvent(menu.name, "mission_context", ConvertStringToLuaID(menu.contextMenuData.missionid))

	local tablespacing = Helper.standardTextHeight
	local maxObjectiveLines = 10

	-- description table
	local desctable = frame:addTable(3, { tabOrder = 3, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	desctable:setColWidth(1, Helper.headerRowCenteredProperties.height)
	desctable:setColWidth(3, Helper.headerRowCenteredProperties.height)
	desctable:setDefaultColSpan(1, 3)

	-- kuertee start: callback
	if menu.uix_callbacks ["createMissionContext_startDescriptionTable"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_startDescriptionTable"]) do
			uix_callback (desctable)
		end
	end
	-- kuertee end: callback

	-- title
	local visibleHeight

	if menu.contextMenuData.onlinechapter ~= "" then
		local row = desctable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 11363), Helper.titleTextProperties)
	end

	local row = desctable:addRow(false, { fixed = true })
	if menu.contextMenuData.onlinechapter ~= "" then
		local icon = "vt_type_" .. menu.contextMenuData.subtype .. "_mission"
		if not C.IsIconValid(icon) then
			DebugError("Unknown online mission type icon '" .. icon .. "'. [Florian]")
			icon = "solid"
		end
		row[1]:setColSpan(1):createIcon(icon, { width = Helper.headerRowCenteredProperties.height, height = Helper.headerRowCenteredProperties.height })
		row[2]:setBackgroundColSpan(2):createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
		row[3]:createText(" ", Helper.headerRowCenteredProperties)
	else
		row[1]:createText(menu.contextMenuData.name, Helper.headerRowCenteredProperties)
	end

	-- briefing icon if any
	local icontable
	if menu.contextMenuData.briefingicon then
		icontable = frame:addTable(1, { tabOrder = 0, highlightMode = "off", maxVisibleHeight = menu.contextMenuData.descriptionHeight, x = Helper.borderSize, y = desctable.properties.y + desctable:getFullHeight() + Helper.borderSize, width = menu.contextMenuData.briefingiconwidth })

		local row = icontable:addRow(nil, {  })
		row[1]:createIcon(menu.contextMenuData.briefingicon, { scaling = false, height = menu.contextMenuData.briefingiconwidth })

		local row = icontable:addRow(nil, {  })
		row[1]:createText(menu.contextMenuData.briefingiconcaption, { wordwrap = true })
	end

	-- description
	for linenum, descline in ipairs(menu.contextMenuData.description) do
		local row = desctable:addRow(true, {  })
		row[1]:createText(descline, { scaling = false, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), x = menu.contextMenuData.briefingiconwidth and (menu.contextMenuData.briefingiconwidth + Helper.borderSize + Helper.scaleX(Helper.standardTextOffsetx)) or nil, minRowHeight = Helper.scaleY(Helper.standardTextHeight) })
		if linenum == menu.contextMenuData.descriptionLines then
			visibleHeight = desctable:getFullHeight()
		end
	end
	if visibleHeight then
		desctable.properties.maxVisibleHeight = visibleHeight
	else
		desctable.properties.maxVisibleHeight = desctable:getFullHeight()
	end

	local objectiveOffsetY = desctable.properties.y + desctable:getVisibleHeight()
	if icontable then
		objectiveOffsetY = math.max(objectiveOffsetY, menu.contextMenuData.descriptionHeight)
	end
	objectiveOffsetY = objectiveOffsetY + tablespacing + Helper.borderSize

	-- objectives table
	local objectivetable = frame:addTable(2, { tabOrder = 4, highlightMode = "off", x = Helper.borderSize, y = objectiveOffsetY, maxVisibleHeight = menu.contextMenuData.objectiveHeight, width = menu.contextMenuData.width })
	objectivetable:setColWidthPercent(2, 25)
	objectivetable:setDefaultColSpan(1, 2)

	-- objectives
	local visibleHeight
	if menu.contextMenuData.threadtype ~= "" then
		-- title
		local row = objectivetable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 3418), Helper.headerRowCenteredProperties)
		if menu.contextMenuData.isoffer then
			if #menu.contextMenuData.briefingmissions > 0 then
				for i, details in ipairs(menu.contextMenuData.briefingmissions) do
					local row = objectivetable:addRow(true, {  })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. details.name, textProperties)
					local timeouttext = ((details.duration and (details.duration > 0)) and ConvertTimeString(details.duration, (details.duration >= 3600) and "%h:%M:%S" or "%M:%S") or "")
					row[2]:createText(timeouttext .. "  \27[missiontype_" .. details.type .. "]", { halign = "right" })

					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, {  })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		else
			if #menu.contextMenuData.subMissions > 0 then
				for i, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
					local row = objectivetable:addRow(true, {  })
					row[1]:setColSpan(1):createText(((menu.contextMenuData.threadtype == "sequential") and (i .. ReadText(1001, 120)) or "·") .. " " .. submissionEntry.name, textProperties)
					row[2]:createText(function () return menu.getSubMissionTimer(submissionEntry) end, { halign = "right" })
					if i == maxObjectiveLines then
						visibleHeight = objectivetable:getFullHeight()
					end
				end
			else
				local row = objectivetable:addRow(true, {  })
				row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
			end
		end
	else
		-- title
		local row = objectivetable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(ReadText(1001, 3402), Helper.headerRowCenteredProperties)
		if #menu.contextMenuData.briefingobjectives > 0 then
			for linenum, briefingobjective in ipairs(menu.contextMenuData.briefingobjectives) do
				local infotext = ""
				local textProperties = {}
				if linenum < menu.contextMenuData.activebriefingstep then
					infotext = " - " .. (briefingobjective.failed and ReadText(1001, 3422) or ReadText(1001, 3416))
					textProperties.color = Color["text_inactive"]
				elseif linenum == menu.contextMenuData.activebriefingstep then
					if (not menu.isOffer) and (menu.contextMenuData.missionid == C.GetActiveMissionID()) then
						textProperties.color = Color["text_mission"]
					end
				else
					if briefingobjective.completedoutofsequence then
						infotext = " - " .. ReadText(1001, 3416)
						textProperties.color = Color["text_inactive"]
					end
				end
				local row = objectivetable:addRow(true, {  })
				row[1]:setColSpan(briefingobjective.encyclopedia and 1 or 2):createText(briefingobjective.step .. ReadText(1001, 120) .. " " .. briefingobjective.text .. infotext, textProperties)

				if menu.infoTableMode == "mission" and linenum == menu.contextMenuData.activebriefingstep then
					if menu.contextMenuData.curProgress and menu.contextMenuData.maxProgress then
						if menu.contextMenuData.curProgress > 0 or menu.contextMenuData.maxProgress > 0 then
							if not string.find(briefingobjective.text, tostring(menu.contextMenuData.curprogress) .. " / ") then
								local row = objectivetable:addRow(true, {  })
								local progressText
								if menu.contextMenuData.progressname ~= nil then
									progressText = "    " .. menu.contextMenuData.progressname .. ReadText(1001, 120) .. " "
								else
									progressText = "    " .. ReadText(1001, 9513) .. ReadText(1001, 120) .. " "
								end
								progressText = progressText .. tostring(menu.contextMenuData.curProgress) .. " / " .. tostring(menu.contextMenuData.maxProgress)
								row [1]:setColSpan(2):createText(progressText, textProperties)
							end
						end
					end
				end

				if briefingobjective.encyclopedia then
					local buttonsize = Helper.scaleY(Helper.standardTextHeight)
					row[2]:createButton({ scaling = false, active = briefingobjective.encyclopedia.known, height = buttonsize, width = buttonsize, x = row[2]:getWidth() - buttonsize, mouseOverText = briefingobjective.encyclopedia.known and ReadText(1001, 2416) or ReadText(1026, 3259) }):setIcon("mm_externallink")
					row[2].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, briefingobjective.encyclopedia.mode, briefingobjective.encyclopedia.library, briefingobjective.encyclopedia.id, briefingobjective.encyclopedia.object }); menu.cleanup() end
				end
				if linenum == maxObjectiveLines then
					visibleHeight = objectivetable:getFullHeight()
				end
			end
		else
			local row = objectivetable:addRow(true, {  })
			row[1]:createText("--- " .. ReadText(1001, 3410) .. " ---")
		end
	end
	if visibleHeight then
		objectivetable.properties.maxVisibleHeight = visibleHeight
	else
		objectivetable.properties.maxVisibleHeight = objectivetable:getFullHeight()
	end

	-- bottom table (info and buttons)
	local bottomtable = frame:addTable(2, { tabOrder = 2, x = Helper.borderSize, y = objectivetable.properties.y + objectivetable:getVisibleHeight() + tablespacing, width = menu.contextMenuData.width, highlightMode = "off" })

	-- faction
	if menu.contextMenuData.factionName then
		local row = bottomtable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 43) .. ReadText(1001, 120))
		row[2]:createText(menu.contextMenuData.factionName, { halign = "right" })
	end
	-- opposing faction
	if menu.contextMenuData.oppFactionName then
		local row = bottomtable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 3411) .. ReadText(1001, 120))
		row[2]:createText(menu.contextMenuData.oppFactionName, { halign = "right" })
	end
	-- reward
	local rewardtext
	if menu.contextMenuData.rewardmoney ~= 0 then
		rewardtext = ConvertMoneyString(menu.contextMenuData.rewardmoney, false, true, 0, true) .. " " .. ReadText(1001, 101)
		if menu.contextMenuData.rewardtext ~= "" then
			rewardtext = rewardtext .. " \n" .. menu.contextMenuData.rewardtext
		end
	else
		rewardtext = menu.contextMenuData.rewardtext
	end
	local row = bottomtable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 3301) .. ReadText(1001, 120))
	row[2]:createText(rewardtext, { halign = "right", wordwrap = true })
	-- difficulty
	if menu.contextMenuData.difficulty ~= 0 then
		local row = bottomtable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 3403) .. ReadText(1001, 120))
		local difficulty, mouseovertext = ConvertMissionLevelString(menu.contextMenuData.difficulty)
		row[2]:createText(difficulty, { halign = "right", mouseOverText = mouseovertext })
	end
	-- time left
	local row = bottomtable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 3404) .. ReadText(1001, 120))
	row[2]:createText(menu.getMissionContextTime, { halign = "right" })

	-- buttons
	if menu.contextMenuData.isoffer then
		-- Accept & Briefing
		local row = bottomtable:addRow(true, { fixed = true })
		local active = true
		local mouseovertext
		if C.IsMissionLimitReached(false, false, false) then
			active = false
			mouseovertext = ReadText(1026, 3242)
		elseif menu.contextMenuData.onlinechapter ~= "" then
			if C.HasAcceptedOnlineMission() then
				mouseovertext = ColorText["text_negative"] .. ReadText(1026, 11301)
			end
		end

		-- kuertee start: callback
		if active then
			if menu.uix_callbacks ["createMissionContext_getIsMissionAcceptable"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_getIsMissionAcceptable"]) do
					active = uix_callback (menu.contextMenuData.missionid)
					if active == 0 or active == false then
						break
					end
				end
			end
		end
		-- kuertee end: callback

		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_acceptmission", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 57), { halign = "center" })
		row[1].handlers.onClick = menu.buttonMissionOfferAccept
		row[1].properties.uiTriggerID = "missionofferaccept"

		-- kuertee start: callback
		local kEM_isBriefingAvailable = nil
		if menu.uix_callbacks ["createMissionContext_getIsMissionBriefingAvailable"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_getIsMissionBriefingAvailable"]) do
				kEM_isBriefingAvailable = uix_callback (menu.contextMenuData.missionid)
				if kEM_isBriefingAvailable == 0 or kEM_isBriefingAvailable == false then
					break
				end
			end
		end
				
		if kEM_isBriefingAvailable == nil then
			-- Vanilla do original logic
			row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		else
			-- Emergent Missions is installed do modified logic
			row[2]:createButton({active = kEM_isBriefingAvailable}):setText(ReadText(1001, 3326), { halign = "center" })
		end
		-- kuertee end: callback

		row[2].handlers.onClick = menu.buttonMissionOfferBriefing
		row[2].properties.uiTriggerID = "missionofferbriefing"

		local row
		if menu.contextMenuData.briefingbuttontext ~= "" then
			row = bottomtable:addRow(true, { fixed = true })

			row[2]:createButton({  }):setText(menu.contextMenuData.briefingbuttontext, { halign = "center" })
			row[2].handlers.onClick = menu.buttonMissionInteractionButton
			row[2].properties.uiTriggerID = "missioninteractionbutton"
		end

		-- kuertee start: callback
		if menu.uix_callbacks ["createMissionContext_addMissionOfferButtons"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_addMissionOfferButtons"]) do
				active = uix_callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback

	else
		-- Abort & Briefing
		local active = menu.contextMenuData.abortable
		local mouseovertext = ""
		if menu.contextMenuData.threadMissionID ~= 0 then
			local details = menu.getMissionIDInfoHelper(menu.contextMenuData.threadMissionID)
			active = active and (details.threadtype ~= "sequential")
			if details.threadtype == "sequential" then
				mouseovertext = ReadText(1026, 3405)
			end
		end
		local row = bottomtable:addRow(true, { fixed = true })
		row[1]:createButton({ active = active, mouseOverText = mouseovertext, helpOverlayID = "map_abortmission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(ReadText(1001, 3407), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonMissionAbort() end
		row[1].properties.uiTriggerID = "missionabort"
		row[2]:createButton({  }):setText(ReadText(1001, 3326), { halign = "center" })
		row[2].handlers.onClick = menu.buttonMissionBriefing
		row[2].properties.uiTriggerID = "missionbriefing"

		local row

		-- kuertee start: allow buttons in guidance missions
		-- if menu.contextMenuData.type ~= "guidance" then
		-- kuertee end: allow buttons in guidance missions

			-- Set active
			local active = menu.contextMenuData.missionid == C.GetActiveMissionID()
			for _, submissionEntry in ipairs(menu.contextMenuData.subMissions) do
				if submissionEntry.active then
					active = true
				end
			end
			row = bottomtable:addRow(true, { fixed = true })
			row[1]:createButton({ helpOverlayID = "map_activatemission", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(active and ReadText(1001, 3413) or ReadText(1001, 3406), { halign = "center" })
			row[1].handlers.onClick = menu.buttonMissionActivate
			row[1].properties.uiTriggerID = "missionactivate"

		-- kuertee start: allow buttons in guidance missions
		-- end
		-- kuertee end: allow buttons in guidance missions

		-- deliver wares
		if #menu.contextMenuData.deliveryWares > 0 then
			if not row then
				row = bottomtable:addRow(true, { fixed = true })
			end

			row[2]:createButton({ active = menu.checkDeliverWaresCargo, mouseOverText = function () return menu.checkDeliverWaresCargo() and "" or (ColorText["text_error"] .. ReadText(1026, 3406)) end }):setText(ReadText(1001, 3423), { halign = "center" })
			row[2].handlers.onClick = menu.buttonMissionDeliverWares
			row[2].properties.uiTriggerID = "missiondeliverwares"
		end

		if menu.contextMenuData.briefingbuttontext ~= "" then
			if (not row) or (#menu.contextMenuData.deliveryWares > 0) then
				row = bottomtable:addRow(true, { fixed = true })
			end

			row[2]:createButton({  }):setText(menu.contextMenuData.briefingbuttontext, { halign = "center" })
			row[2].handlers.onClick = menu.buttonMissionInteractionButton
			row[2].properties.uiTriggerID = "missioninteractionbutton"
		end

		-- kuertee start: callback
		if menu.uix_callbacks ["createMissionContext_addMissionAcceptedButtons"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_addMissionAcceptedButtons"]) do
				active = uix_callback (bottomtable, menu.contextMenuData.missionid)
			end
		end
		-- kuertee end: callback

	end
	local neededheight = bottomtable.properties.y + bottomtable:getFullHeight() + Helper.frameBorder
	if frame.properties.y + neededheight > Helper.viewHeight then
		frame.properties.y = math.max(0, Helper.viewHeight - neededheight)
	end

	desctable.properties.nextTable = objectivetable.index
	objectivetable.properties.prevTable = desctable.index

	objectivetable.properties.nextTable = bottomtable.index
	bottomtable.properties.prevTable = objectivetable.index

	-- kuertee start: callback
	if menu.uix_callbacks ["createMissionContext_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createMissionContext_on_end"]) do
			uix_callback (frame)
		end
	end
	-- kuertee end: callback
end

function menu.checkDeliverWaresCargo()
	local hascargo = true
	local cargo = GetComponentData(ConvertStringTo64Bit(tostring(menu.contextMenuData.deliveryWares.target)), "cargo") or {}
	for _, entry in ipairs(menu.contextMenuData.deliveryWares) do
		if (cargo[entry.ware] or 0) == 0 then
			hascargo = false
			break
		end
	end
	return hascargo
end

function menu.getMissionContextTime()
	if not menu.contextMenuData.expired then
		if (not menu.contextMenuData.isoffer) and menu.contextMenuData.missionid then
			local missiondetails = C.GetMissionIDDetails(menu.contextMenuData.missionid)
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			return (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		else
			return (menu.contextMenuData.timeout > 0 and ConvertTimeString(menu.contextMenuData.timeout, (menu.contextMenuData.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "-")
		end
	else
		return "-"
	end
end

function menu.getSubMissionTimer(submissionentry)
	local text
	if not submissionentry.expired then
		if not menu.isOffer then
			local missiondetails = C.GetMissionIDDetails(ConvertStringTo64Bit(submissionentry.ID))
			local timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1)

			text = (timeout > 0 and ConvertTimeString(timeout, (timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		else
			text = (submissionentry.timeout > 0 and ConvertTimeString(submissionentry.timeout, (submissionentry.timeout >= 3600) and "%h:%M:%S" or "%M:%S") or "")
		end
	else
		text = ""
	end

	return text .. "  \27[missiontype_" .. submissionentry.type .. "]"
end

function menu.createInfoContext(frame)
	local instance = menu.contextMenuData.instance

	local controllable = menu.contextMenuData.component
	local entity = menu.contextMenuData.entity
	local person = menu.contextMenuData.person
	local inv_ware = menu.contextMenuData.inv_ware
	local weaponmacro = menu.contextMenuData.weaponmacro
	local equipmentmacro = menu.contextMenuData.equipmentmacro
	local software = menu.contextMenuData.software
	local personrole = ""
	if not (controllable and (person or entity or inv_ware or weaponmacro or equipmentmacro or software)) then
		DebugError(string.format("menu.createInfoContext called with invalid controllable or invalid actor, invalid ware and invalid macro. controllable: %s, person: %s, entity: %s, inv_ware: %s, software: %s, weaponmacro: %s, equipmentmacro: %s", tostring(controllable), tostring(person), tostring(entity), tostring(inv_ware), tostring(software), tostring(weaponmacro), tostring(equipmentmacro)))
		return
	end
	if person then
		--print("person: " .. ffi.string(C.GetPersonName(person, controllable)) .. ", combinedskill: " .. C.GetPersonCombinedSkill(controllable, person, nil, nil))
		-- get real NPC if instantiated
		local instance = C.GetInstantiatedPerson(person, controllable)
		entity = (instance ~= 0 and instance or nil)
		personrole = ffi.string(C.GetPersonRole(person, controllable))
	end
	entity = entity and ConvertStringTo64Bit(tostring(entity)) or nil

	local loctable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	local title = ""
	local isunlocked = false
	if entity then
		isunlocked = IsInfoUnlockedForPlayer(controllable, "operator_name")
		title = Helper.unlockInfo(isunlocked, ffi.string(C.GetComponentName(entity)))
	elseif person then
		isunlocked = IsInfoUnlockedForPlayer(controllable, "name")
		title = Helper.unlockInfo(isunlocked, ffi.string(C.GetPersonName(person, controllable)))
	elseif inv_ware or software then
		title = GetWareData(inv_ware or software, "name")
	elseif weaponmacro or equipmentmacro then
		title = GetMacroData(weaponmacro or equipmentmacro, "name")
	end

	-- title
	local row = loctable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(title, Helper.headerRowCenteredProperties)

	local oldpilot = GetComponentData(controllable, "assignedaipilot")
	if oldpilot then
		oldpilot = ConvertStringTo64Bit(tostring(oldpilot))
	end

	local transferscheduled = false
	local hasarrived = true
	if person then
		transferscheduled = C.IsPersonTransferScheduled(controllable, person)
		hasarrived = C.HasPersonArrived(controllable, person)
	end

	local player = C.GetPlayerID()
	if person then
		if GetComponentData(controllable, "isplayerowned") then
			if transferscheduled then
				local row = loctable:addRow("info_person_cancel_transfer", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 9435))	-- Cancel all scheduled transfers
				row[1].handlers.onClick = function () return menu.infoSubmenuCancelTransfer(controllable, person) end
			elseif hasarrived then
				if (personrole == "service") or (personrole == "marine") then
					local printedtitle = C.IsComponentClass(controllable, "ship_s") and ReadText(1001, 4847) or ReadText(1001, 4848)	-- Pilot, Captain
					local row = loctable:addRow("info_person_promote", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight, active = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, true, true, instance) end }):setText(ReadText(1001, 9433) .. " " .. printedtitle)	-- Promote to(followed by "captain" or "pilot")
					row[1].handlers.onClick = function () return menu.infoSubmenuReplacePilot(controllable, oldpilot, person, false, true, instance) end
				end
			end
		end
	end
	if person or (entity and (entity ~= player)) then
		if GetComponentData(controllable, "isplayerowned") then
			if (person and ((personrole == "service") or (personrole == "marine") or (personrole == "trainee_group") or (personrole == "unassigned"))) or (entity and GetComponentData(entity, "isplayerowned") and GetComponentData(entity, "caninitiatecomm")) then
				if hasarrived then
					-- work somewhere else
					local row = loctable:addRow("info_person_worksomewhere", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 3008))
					if entity then
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", entity, 0 } }); menu.cleanup() end
					else
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", controllable, 0, person} }); menu.cleanup() end
					end
				end
				-- fire
				local row = loctable:addRow("info_person_fire", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 15800))
				row[1].handlers.onClick = function () return menu.infoSubmenuFireNPCConfirm(controllable, entity, person, instance) end
			end
		end
	elseif inv_ware or weaponmacro or equipmentmacro or software then
		local row = loctable:addRow("info_inv_ware", { fixed = true })
		row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 2416))	-- Show Encyclopedia Entry
		if inv_ware then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "inventory_wares", inv_ware }); menu.cleanup() end
		elseif weaponmacro then
			local library = GetMacroData(weaponmacro, "infolibrary")
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Weapons", library, weaponmacro }); menu.cleanup() end
		elseif equipmentmacro then
			local library = GetMacroData(equipmentmacro, "infolibrary")
			local mode = "Equipment"
			if library == "mines" then
				mode = "Weapons"
			end
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, mode, library, equipmentmacro }); menu.cleanup() end
		elseif software then
			row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Equipment", "software", software }); menu.cleanup() end
		end
	end
	local conversationactor = entity
	if person and (not entity or C.GetContextByClass(entity, "container", false) ~= C.GetContextByClass(player, "container", false)) then
		-- Talking to person - either not instantiated as a real entity, or the instance is far away.
		-- Note: Only start comms with instantiated NPCs if they are on the player container, otherwise they are likely to get despawned during the conversation.
		conversationactor = { context = ConvertStringToLuaID(tostring(controllable)), person = ConvertStringToLuaID(tostring(person)) }
	end
	if person or entity then
		if (not transferscheduled) and hasarrived then
			row = loctable:addRow("info_actor_comm", { fixed = true })
			row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight, active = ((not entity) or (entity ~= player)) and isunlocked }):setText(ReadText(1001, 3216))	-- (initiate comm)Comm
			row[1].handlers.onClick = function () menu.openCommWithActor(conversationactor) end
		end
	end

	-- adjust frame position
	local neededheight = loctable.properties.y + loctable:getVisibleHeight()
	if frame.properties.y + neededheight + Helper.frameBorder > Helper.viewHeight then
		menu.contextMenuData.yoffset = Helper.viewHeight - neededheight - Helper.frameBorder
		frame.properties.y = menu.contextMenuData.yoffset
	end
end

function menu.createSellShipsContext(frame)
	-- description table
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })
	ftable:setColWidthPercent(1, 60)

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 7857), Helper.headerRowCenteredProperties)
	-- ships
	local issellingpossible = false
	menu.contextMenuData.totalprice = 0
	for i, data in ipairs(menu.contextMenuData.ships) do
		local errors, warnings = {}, {}
		local n = C.GetNumOrders(data)
		local buf = ffi.new("Order[?]", n)
		n = C.GetOrders(buf, n, data)
		for i = 0, n - 1 do
			if ffi.string(buf[i].orderdef) == "Equip" then
				errors[1] = ReadText(1001, 3267)
				break
			end
		end
		local hasanymod = GetComponentData(data, "hasanymod")
		if hasanymod then
			warnings[1] = ReadText(1001, 3268)
		end
		menu.contextMenuData.ships[i] = { data, errors }
		local ship = menu.contextMenuData.ships[i][1]
		local price = GetTotalValue(ship, true, menu.contextMenuData.shipyard)

		local color = Color["text_normal"]
		if #errors > 0 then
			color = Color["text_inactive"]
		else
			issellingpossible = true
			menu.contextMenuData.totalprice = menu.contextMenuData.totalprice + price
		end

		-- keep these selectable to support scrolling when selling a lot of ships
		local row = ftable:addRow(true, { interactive = false })
		row[1]:createText(ffi.string(C.GetComponentName(ship)) .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")", { color = color })
		row[2]:createText(ConvertMoneyString(price, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", color = color })

		for _, error in ipairs(errors) do
			local row = ftable:addRow(true, { interactive = false })
			row[1]:setColSpan(2):createText(error, { halign = "right", color = Color["text_error"] })
		end
		for _, warning in ipairs(warnings) do
			local row = ftable:addRow(true, { interactive = false })
			row[1]:setColSpan(2):createText(warning, { halign = "right", color = Color["text_warning"] })
		end
	end
	-- button
	local row = ftable:addRow(true, {  })
	row[2]:createButton({ active = issellingpossible, height = Helper.standardTextHeight }):setText(ReadText(1001, 2917), { halign = "center" })
	row[2].handlers.onClick = menu.buttonSellShips

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		local newypos = Helper.viewHeight - height - config.contextBorder
		frame.properties.y = math.max(config.contextBorder, newypos)
	end
end

function menu.createSelectContext(frame)
	-- description table
	local ftable = frame:addTable(1, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width, highlightMode = "off" })

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(Helper.unlockInfo(IsInfoUnlockedForPlayer(menu.contextMenuData.component, "name"), ffi.string(C.GetComponentName(menu.contextMenuData.component))), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true })
	local active = true
	local mouseovertext = ""
	if menu.mode == "selectCV" then
		local assignedpilot, isplayerowned, isenemy = GetComponentData(menu.contextMenuData.component, "assignedpilot", "isplayerowned", "isenemy")
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.contextMenuData.component, hasloop)

		if isenemy then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 8014)
		elseif hasloop[0] then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7852)
		elseif menu.contextMenuData.component == C.GetPlayerOccupiedShipID() then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 3224)
		elseif C.IsBuilderBusy(menu.contextMenuData.component) then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7820)
		elseif not assignedpilot then
			active = false
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 7801)
		elseif not isplayerowned then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney < fee then
				active = false
				mouseovertext = ColorText["text_error"] .. ReadText(1026, 3222)
			end
		end
	elseif menu.mode == "selectComponent" then
		active = menu.checkForSelectComponent(menu.contextMenuData.component)
	end
	row[1]:createButton({ active = active, height = Helper.standardTextHeight, mouseOverText = mouseovertext, helpOverlayID = "selectactive", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 3102))
	row[1].handlers.onClick = menu.buttonSelectHandler
	row[1].properties.uiTriggerID = "selectactive"

	if frame.properties.x + menu.contextMenuData.width > Helper.viewWidth then
		frame.properties.x = Helper.viewWidth - menu.contextMenuData.width - config.contextBorder
	end
	local height = frame:getUsedHeight()
	if frame.properties.y + height > Helper.viewHeight then
		frame.properties.y = Helper.viewHeight - height - config.contextBorder
	end
end

function menu.createWeaponConfigContext(frame, instance)
	local ftable = frame:addTable(2, { tabOrder = 3, x = Helper.borderSize, y = Helper.borderSize, width = menu.contextMenuData.width })
	ftable:setColWidth(1, Helper.standardTextHeight)

	-- title
	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 1105), Helper.headerRowCenteredProperties)

	if not menu.contextMenuData.usedefault then
		for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
			if entry.id == "default" then
				local row = ftable:addRow(true, {  })
				row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
				row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
				row[2]:createText(entry.name)
				break
			end
		end
	end

	ftable:addEmptyRow(1)

	if menu.contextMenuData.default then
		menu.contextMenuData.weaponsystems = {}
		local n = C.GetNumAllowedWeaponSystems()
		local buf = ffi.new("WeaponSystemInfo[?]", n)
		n = C.GetAllowedWeaponSystems(buf, n, menu.contextMenuData.component, 0, true)
		for i = 0, n - 1 do
			table.insert(menu.contextMenuData.weaponsystems, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), active = buf[i].active })
		end
	end

	for _, entry in ipairs(menu.contextMenuData.weaponsystems) do
		if entry.id ~= "default" then
			local color = Color["text_normal"]
			if menu.contextMenuData.default then
				color = Color["text_inactive"]
			end
			local row = ftable:addRow(true, {  })
			row[1]:createCheckBox(entry.active, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[1].handlers.onClick = function () return menu.checkboxSetWeaponConfig(entry.id, not entry.active) end
			row[2]:createText(entry.name, { color = color })
		end
	end

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton({ active = not menu.contextMenuData.default }):setText(ReadText(1001, 5706), { halign = "center" })
	row[1].handlers.onClick = menu.buttonClearWeaponConfig

	local row = ftable:addRow(false, {  })
	row[1]:setColSpan(2):createText("")

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonConfirmWeaponConfig

	local row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[1].handlers.onClick = menu.buttonCancelWeaponConfig
end

-- update
menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.updatePeopleInfo and (menu.updatePeopleInfo <= curtime) then
		menu.refreshCrewInfo()
		menu.updatePeopleInfo = nil
	end

	if menu.mainFrame then
		menu.mainFrame:update()
	end
	if menu.infoFrame then
		menu.infoFrame:update()
	end
	if menu.infoFrame2 then
		menu.infoFrame2:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if menu.map and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.map)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end

	local refreshing = false
	if menu.refreshIF and (menu.refreshIF < curtime) then
		refreshing = true
		menu.refreshIF = nil
	end

	if menu.refreshMissionContext and (menu.refreshMissionContext.time < curtime) then
		menu.showMissionContext(menu.refreshMissionContext.id, false)
		menu.refreshMissionContext = nil
	end

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainFrameLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.rendertargetWidth / menu.rendertargetHeight, 1)
			if menu.holomap ~= 0 then
				C.ClearSelectedMapComponents(menu.holomap)
				if menu.showMultiverse then
					C.ShowMultiverseMap(menu.holomap)
				elseif menu.mode == "selectbuildlocation" then
					C.ShowBuildPlotPlacementMap(menu.holomap, menu.currentsector)
				else
					if menu.focuscomponent and menu.focusoffset then
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", menu.focuscomponent, menu.focusoffset)
						menu.focuscomponent = nil
					else
						local startpos = ffi.new("UIPosRot")
						C.ShowUniverseMap2(menu.holomap, true, menu.showzone, menu.mode == "selectCV", 0, startpos)
					end
					menu.focusoffset = nil
				end
			end

			if menu.focuscomponent then
				C.SetFocusMapComponent(menu.holomap, menu.focuscomponent, true)
			end

			if menu.mapstate then
				C.SetMapState(menu.holomap, menu.mapstate)
				menu.mapstate = nil
			end

			if menu.mode == "hire" then
				local classes = ffi.new("const char*[?]", 2)
				classes[0] = Helper.ffiNewString("ship")
				classes[1] = Helper.ffiNewString("station")
				C.SetMapObjectFilter(menu.holomap, classes, 2, 1, true)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "selectComponent" then
				local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
				local classes = ffi.new("const char*[?]", numclasses)
				if numclasses > 0 then
					for i, class in ipairs(menu.modeparam[2]) do
						classes[i - 1] = Helper.ffiNewString(class)
					end
				end
				C.SetMapObjectFilter(menu.holomap, classes, numclasses, menu.modeparam[4] or -1, false)
				Helper.ffiClearNewHelper()
				C.ClearMapOrderParamObjectFilter(menu.holomap)
			elseif menu.mode == "orderparam_object" then
				if type(menu.modeparam[5]) == "string" then
					C.SetMapDefaultOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
				else
					C.SetMapOrderParamObjectFilter(menu.holomap, ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
				end
				C.ClearMapObjectFilter(menu.holomap)
			else
				C.ClearMapOrderParamObjectFilter(menu.holomap)
				C.ClearMapObjectFilter(menu.holomap)
			end
			if menu.behaviourInspectionComponent then
				C.SetMapBehaviourInspectionComponent(menu.holomap, menu.behaviourInspectionComponent)
			end
			menu.setTextFilter()
			menu.applyFilterSettings()

			menu.activatemap = false
			if menu.infoTableMode == "objectlist" then
				menu.refreshIF = getElapsedTime()
			end
		end
	end

	if not menu.refreshed then
		if menu.holomap and (menu.holomap ~= 0) then
			if menu.picking ~= menu.pickstate then
				menu.pickstate = menu.picking
				C.SetMapPicking(menu.holomap, menu.pickstate)
			end
		end
	end
	menu.refreshed = nil

	if menu.lock and curtime > menu.lock + 0.01 then
		menu.lock = nil
	end
	if menu.over then
		menu.refreshInfoFrame()
		menu.over = nil
		return
	end

	-- evaluate mouse cursor overrides
	if menu.holomap and (menu.holomap ~= 0) then
		menu.updateMouseCursor()
		if menu.plotData.active then
			local offset = ffi.new("UIPosRot")
			local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
			if offsetsector ~= 0 then
				if C.IsCurrentBuildMapPlotPositionDiscovered(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000) then
					local price = tonumber(C.GetBuildPlotPrice(offsetsector, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000, "player"))
					SetMouseOverOverride(menu.map, ReadText(1001, 2808) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tostring(price), false, true, 0, true) .. " " .. ReadText(1001, 101))
				else
					SetMouseOverOverride(menu.map, nil)
				end
			end
		end
	end

	local range = 100
	if menu.contextMenuData and menu.contextMenuData.mouseOutPos then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] > menu.contextMenuData.mouseOutPos[1] + range) or (curpos[1] < menu.contextMenuData.mouseOutPos[1] - range)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.contextMenuData.mouseOutPos[2] + range) or (curpos[2] < menu.contextMenuData.mouseOutPos[2] - range)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.lastHighlightCheck + 1.0 < curtime then
		menu.lastHighlightCheck = curtime
		if menu.highlightLeftBar["mission"] then
			if C.GetActiveMissionID() == 0 then
				menu.highlightLeftBar["mission"] = nil
				menu.refreshMainFrame = true
			end
		end
		if menu.showMultiverse then
			local outcomes = GetVentureOutcomes()
			if (next(outcomes) ~= nil) ~= menu.highlightLeftBar["ventureoperation"] then
				menu.highlightLeftBar["ventureoperation"] = next(outcomes) ~= nil
				menu.refreshMainFrame = true
			end
		end
	end

	if ((menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders"))) or
	   ((menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders"))) then
		if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) then
			local orders = {}
			if menu.isInfoModeValidFor(menu.infoSubmenuObject, "orderqueue") then
				local n = C.GetNumOrders(menu.infoSubmenuObject)
				local buf = ffi.new("Order[?]", n)
				n = C.GetOrders(buf, n, menu.infoSubmenuObject)
				for i = 0, n - 1 do
					local entry = {}
					entry.state = ffi.string(buf[i].state)
					entry.orderdef = ffi.string(buf[i].orderdef)
					entry.actualparams = tonumber(buf[i].actualparams)
					table.insert(orders, entry)
				end
			end

			if (menu.infoTableMode == "info") and ((menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders")) then
				if menu.infoTableData.left.orders then
					if #orders ~= #menu.infoTableData.left.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.left.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
			if (menu.searchTableMode == "info") and ((menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders")) then
				if menu.infoTableData.right.orders then
					if #orders ~= #menu.infoTableData.right.orders then
						refreshing = true
					else
						for i, order in ipairs(orders) do
							local oldorder = menu.infoTableData.right.orders[i]
							if (order.state ~= oldorder.state) or (order.orderdef ~= oldorder.orderdef) then
								refreshing = true
								break
							end
						end
					end
				end
			end
		end
	end

	if menu.orderdrag and menu.orderdrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.orderdrag.isclick = false
			if menu.orderdrag.isintermediate then
				if menu.orderdrag.component ~= C.GetPlayerOccupiedShipID() then
					local posrot = ffi.new("UIPosRot")
					local eclipticoffset = ffi.new("UIPosRot")
					local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)
					if posrotcomponent ~= 0 then
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
						local curindex = C.GetOrderQueueCurrentIdx(menu.orderdrag.component)
						if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
							local orderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
							if orderidx > 0 then
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
								SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, 5, nil, true)
								-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
								if menu.orderdrag.order.queueidx == 0 then
									menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
								end
								C.AdjustOrder(menu.orderdrag.component, orderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
								if hasloop[0] and (menu.orderdrag.order.queueidx == curindex) then
									C.SetCurrentLoopOrder(menu.orderdrag.component, menu.orderdrag.order.queueidx, true, false, false)
								end
							end
							if menu.infoTableMode == "mission" then
								menu.refreshIF = curtime
							end
						end
					else
						-- we should create a new order, but there is no valid position here (e.g. between clusters), store the need to create a new order for later
						menu.orderdrag.createneworder = true
					end
				end
			end
		end
	end
	if menu.orderdrag and (not menu.orderdrag.isclick) then
		if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
			if menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")
				local eclipticoffset = ffi.new("UIPosRot")
				local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)

				if posrotcomponent ~= 0 then
					local hasloop = ffi.new("bool[1]", 0)
					C.GetOrderQueueFirstLoopIdx(menu.orderdrag.component, hasloop)
					local curindex = C.GetOrderQueueCurrentIdx(menu.orderdrag.component)
					if C.IsOrderSelectableFor("MoveWait", menu.orderdrag.component) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["MoveWait"].loopable) then
						local neworderidx = C.CreateOrder(menu.orderdrag.component, "MoveWait", false)
						if neworderidx > 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 1, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), neworderidx, 5, nil, true)
							-- If we added the new move order in front of a default order, menu.orderdrag.order.queueidx == 0 -> change it to length of the queue for the new order now on the queue
							if menu.orderdrag.order.queueidx == 0 then
								menu.orderdrag.order.queueidx = C.GetNumOrders(menu.orderdrag.component)
							end
							C.AdjustOrder(menu.orderdrag.component, neworderidx, menu.orderdrag.order.queueidx, menu.orderdrag.order.enabled, false, false)
							if hasloop[0] and (menu.orderdrag.order.queueidx == curindex) then
								C.SetCurrentLoopOrder(menu.orderdrag.component, menu.orderdrag.order.queueidx, true, false, false)
							end
						end
						if menu.infoTableMode == "mission" then
							menu.refreshIF = curtime
						end
					end
					menu.orderdrag.createneworder = nil
				end
			end

			if not menu.orderdrag.createneworder then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				-- the order queue can change while we are dragging the new order (previous order stops because it was only waiting)
				-- recheck the pickedorder on the map and adjust the queueidx if there is a picked non-intermediate order (during dragging this must be the order we are dragging)
				local pickedorder = ffi.new("Order")
				local isintermediate = ffi.new("bool[1]", 0)
				local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
				if (pickedordercomponent == menu.orderdrag.component) and (not isintermediate[0]) then
					menu.orderdrag.order.queueidx = pickedorder.queueidx
				end

				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])

						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onUpdate(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
	end

	if menu.intersectordrag and menu.intersectordrag.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if menu.leftdown and ((menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5)) then
			menu.intersectordrag.isclick = false
		end
	end
	if menu.intersectordrag and (not menu.intersectordrag.isclick) then
		local posrot = ffi.new("UIPosRot")
		local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
		local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)

		local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
		if posrotcomponent ~= 0 then
			C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
		end
	end

	if menu.panningmap and menu.panningmap.isclick then
		local offset = table.pack(GetLocalMousePosition())
		if (menu.leftdown.time + 0.5 < curtime) or Helper.comparePositions(menu.leftdown.position, offset, 5) then
			menu.panningmap.isclick = false
		end
	end

	if menu.lastzoom then
		if not menu.zoom_newdir or menu.zoom_newdir ~= menu.lastzoom.dir then
			if menu.zoom_newdir then
				if menu.sound_zoom then
					StopPlayingSound(menu.sound_zoom)
				end
				menu.sound_zoom = nil
			end

			if menu.lastzoom.dir == "in" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomin")
				menu.zoom_newdir = "in"
			elseif menu.lastzoom.dir == "out" then
				menu.sound_zoom = StartPlayingSound("ui_scroll_zoomout")
				menu.zoom_newdir = "out"
			end
		elseif menu.sound_zoom and menu.lastzoom.time + 0.3 < curtime then
			StopPlayingSound(menu.sound_zoom)
			menu.sound_zoom = nil
			menu.zoom_newdir = nil
			menu.lastzoom = nil
		end
	end

	if menu.leftdown then
		if not menu.leftdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.leftdown.position, offset, 5) then
				menu.leftdown.wasmoved = true
			end
		end
		if menu.leftdown.wasmoved and menu.leftdown.time + 0.1 < curtime and not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object") then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.panningmap and Helper.comparePositions(menu.leftdown.dynpos, currentmousepos, 5) then
				if not menu.sound_panmap then
					menu.sound_panmap = StartPlayingSound("ui_scroll_wasd")
				end
				menu.leftdown.dynpos = currentmousepos
			elseif menu.sound_panmap then
				StopPlayingSound(menu.sound_panmap)
				menu.sound_panmap = nil
			end
		end
	end

	if menu.rightdown then
		if not menu.rightdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 5) then
				menu.rightdown.wasmoved = true
				if menu.mode == "selectbuildlocation" then
					C.StartRotateMap(menu.holomap)
				end
			end
		end
		if menu.rightdown.wasmoved and ((menu.rightdown.time + 0.1) < curtime) and (not C.IsComponentClass(C.GetPickedMapComponent(menu.holomap), "object")) then
			local currentmousepos = table.pack(GetLocalMousePosition())
			if menu.rotatingmap then
				if currentmousepos[2] > menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "down" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_down"), dir = "down"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif currentmousepos[2] < menu.rightdown.dynpos[2] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_pitch_up"), dir = "up"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.rightdown.dynpos[1] ~= currentmousepos[1] then
					if menu.sound_rotatemap then
						if menu.sound_rotatemap.dir ~= "up" then
							if menu.sound_rotatemap.sound then
								StopPlayingSound(menu.sound_rotatemap.sound)
							end
							menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
						end
					else
						menu.sound_rotatemap = { sound = StartPlayingSound("ui_scroll_cirle"), dir = "rot"}
					end
					menu.rightdown.dynpos = currentmousepos
				elseif menu.sound_rotatemap then
					if menu.sound_rotatemap.sound then
						StopPlayingSound(menu.sound_rotatemap.sound)
					end
					menu.sound_rotatemap = nil
				end
			end
		end
	end

	if (menu.infoTableMode == "objectlist") then
		if menu.lastrefresh + 2.0 < curtime then
			refreshing = true
		end
	end

	if Helper.hasExtension("multiverse") then
		if Helper.callExtensionFunction("multiverse", "updateVentures", menu) then
			refreshing = true
		end
	end

	if menu.infoSubmenuObject and (menu.infoSubmenuObject ~= 0) and (not IsValidComponent(menu.infoSubmenuObject)) then
		menu.infoSubmenuObject = 0
		refreshing = true
	end

	if refreshing and (not menu.noupdate) then
		menu.lastrefresh = curtime
		menu.refreshInfoFrame()
	end

	if menu.refreshFilterSettings then
		menu.applyFilterSettings()
		menu.refreshMainFrame = true
		menu.refreshFilterSettings = nil
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refreshMainFrame = true
			menu.inputModeHasChanged = nil
		end
	end

	if not menu.panningmap then
		if menu.refreshMainFrame then
			if not menu.createMainFrameRunning then
				if not menu.disregardFilterTable then
					menu.topRows.filterTable = GetTopRow(menu.searchField)
					menu.selectedRows.filterTable = Helper.currentTableRow[menu.searchField]
					menu.selectedCols.filterTable = Helper.currentTableCol[menu.searchField]
				end

				menu.selectedRows.sideBar = Helper.currentTableRow[menu.sideBar]
				menu.selectedRows.rightBar = Helper.currentTableRow[menu.rightBar]

				menu.createMainFrame(nil, (menu.contextMenuMode == "trade") and menu.contextMenuData.tradeModeHeight or nil, true)
				menu.disregardFilterTable = nil
				menu.refreshMainFrame = nil
			end
		end
	end

	if menu.contextMenuMode == "trade" then
		if (not menu.tradeSliderLock) then
			local playermoney = GetPlayerMoney()
			if playermoney ~= menu.contextMenuData.playerMoney then
				menu.contextMenuData.playerMoney = playermoney
				menu.queuetradecontextrefresh = true
			end
		end
	elseif menu.contextMenuMode == "rename" then
		if menu.contextMenuData.nameEditBox then
			ActivateEditBox(menu.contextMenuData.nameEditBox.id)
			menu.contextMenuData.nameEditBox = nil
		end
	end

	if menu.queuecontextrefresh and (menu.queuecontextrefresh < curtime) then
		menu.refreshContextFrame()
		menu.queuecontextrefresh = nil
	end

	if menu.queuetradecontextrefresh then
		menu.topRows.contextshiptable = GetTopRow(menu.contextshiptable)
		menu.selectedRows.contextshiptable = Helper.currentTableRow[menu.contextshiptable]
		menu.createContextFrame()
		menu.queuetradecontextrefresh = nil
	end

	if menu.behaviourInspectionComponent then
		local isplayerowned = GetComponentData(menu.behaviourInspectionComponent, "isplayerowned")
		if (not isplayerowned) or (not C.IsComponentOperational(menu.behaviourInspectionComponent)) then
			menu.behaviourInspectionComponent = nil
			C.SetMapBehaviourInspectionComponent(menu.holomap, 0)

			menu.mode = nil
			menu.refreshMainFrame = true
			menu.setTextFilter()
			menu.applyFilterSettings()
		end
	end
end

-- row changes
function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	-- Lock button over updates
	menu.lock = getElapsedTime()

	-- handle map modes without a holomap first
	if (menu.mode == "boardingcontext") and menu.boardingtable_shipselection and (uitable == menu.boardingtable_shipselection.id) and (type(rowdata) == "table") and (rowdata[1] == "boardingship") and C.IsComponentClass(rowdata[2], "defensible") and (menu.boardingData.selectedship ~= rowdata[2]) then
		--print("queueing refresh on next frame. ship: " .. ffi.string(C.GetComponentName(rowdata[2])) .. " " .. tostring(rowdata[2]))
		menu.boardingData.selectedship = rowdata[2]
		menu.queuecontextrefresh = menu.lock
	elseif menu.contextMenuMode == "trade" then
		if uitable == menu.contextshiptable then
			if rowdata then
				if (type(rowdata) == "table") and next(rowdata) then
					menu.selectedTradeWare = rowdata
				else
					menu.selectedTradeWare = nil
				end
				if (not menu.skipTradeRowChange) and (not menu.tradeSliderLock) then
					menu.queuetradecontextrefresh = true
				end
				menu.skipTradeRowChange = nil
			end
		end
	end

	if menu.holomap == 0 then
		return
	end

	if menu.showMultiverse then
		if (menu.ventureMode == "ventureoperation") or (menu.ventureMode == "ventureseason") then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onRowChanged", menu, menu.ventureMode, row, rowdata, uitable, modified, input, source)
			end
		end
	else
		
		-- start Forleyor_infoCenter Callback:
		if menu.uix_callbacks ["ic_onRowChanged"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["ic_onRowChanged"]) do
				uix_callback (row, rowdata, uitable, modified, input, source)
			end
		end
		-- end Forleyor_infoCenter:

		if (menu.infoTableMode == "info") then
			if uitable == menu.infoTable then
				if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") then
					menu.selectedRows.infotableleft = row
					if menu.infoMode.left == "objectloadout" then
						local infomacrostolaunch = menu.infoTablePersistentData.left.macrostolaunch
						if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
							if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { lasertower = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { mine = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { navbeacon = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { resourceprobe = rowdata[2] }
							elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
								menu.infoTablePersistentData.left.macrostolaunch = { satellite = rowdata[2] }
							end
						else
							menu.infoTablePersistentData.left.macrostolaunch = {}
						end
					end
				elseif (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") or (menu.infoMode.left == "standingorders") then
					if type(rowdata) == "table" then
						menu.infoTablePersistentData.left.selectedorder = rowdata
						menu.infoTablePersistentData.left.selectedorder.object = menu.infoSubmenuObject
					else
						menu.infoTablePersistentData.left.selectedorder = nil
					end
				end
			end

		-- kuertee start:
		-- elseif (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		elseif (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end:

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedComponent = ConvertIDTo64Bit(rowdata[2])
					if (source ~= "auto") and convertedComponent then
						local convertedcomponentclass = ffi.string(C.GetComponentClass(convertedComponent))
						if convertedcomponentclass  == "station" then
							AddUITriggeredEvent(menu.name, "selection_station", convertedComponent)
						end
						if (convertedcomponentclass  == "ship_s") or (convertedcomponentclass  == "ship_m") or (convertedcomponentclass  == "ship_l") or (convertedcomponentclass  == "ship_xl") then
							AddUITriggeredEvent(menu.name, "selection_ship", convertedComponent)
						end
						if (convertedcomponentclass == "resourceprobe") then
							AddUITriggeredEvent(menu.name, "selection_resourceprobe", convertedComponent)
						end

						if (menu.mode ~= "orderparam_object") and (input ~= "rightmouse") then
							menu.setInfoSubmenuObjectAndRefresh(convertedComponent)
						end
					end
					menu.updateSelectedComponents(modified, source == "auto", convertedComponent, row)
					menu.setSelectedMapComponents()
				else
					menu.updateSelectedComponents(modified, true, nil, row)
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				menu.settoprow = GetTopRow(menu.table_plotlist)
				menu.setrow = Helper.currentTableRow[menu.table_plotlist]
				if not rowdata then
					print("rowdata empty. table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata))
				elseif input == "mouse" then
					--print("table id: " .. tostring(uitable) .. ", row: " .. tostring(row) .. ", rowdata: " .. tostring(rowdata) .. ", menu.table_plotlist.id: " .. tostring(menu.table_plotlist.id) .. ", uitable == menu.table_plotlist.id? " .. tostring(uitable == menu.table_plotlist.id))
					if rowdata ~= "plots_new" then
						C.SetFocusMapComponent(menu.holomap, rowdata, true)
					end
					menu.updatePlotData(rowdata)
				end
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onRowChanged", menu, "ventureoperation", row, rowdata, uitable, modified, input, source)
				else
					local oldmission = menu.missionModeCurrent
					if type(rowdata) == "table" then
						local missionid = ConvertStringTo64Bit(rowdata[1])
						menu.missionModeCurrent = rowdata[1]
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
								menu.closeContextMenu()
								menu.missionModeContext = nil
							else
								menu.closeContextMenu()
								menu.showMissionContext(missionid)
								menu.missionModeContext = true
							end
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						elseif input == "mouse" then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
					if menu.missionDoNotUpdate then
						menu.missionDoNotUpdate = nil
					elseif menu.missionModeCurrent ~= oldmission then
						if source ~= "auto" then
							menu.refreshInfoFrame()
						end
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if uitable == menu.infoTableRight then
			if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") or (menu.infoMode.right == "objectloadout") then
				menu.selectedRows.infotableright = row
				if menu.infoMode.right == "objectloadout" then
					local infomacrostolaunch = menu.infoTablePersistentData.right.macrostolaunch
					if (type(rowdata) == "table") and (rowdata[1] == "info_deploy") then
						if GetMacroData(rowdata[2], "islasertower") and (infomacrostolaunch.lasertower ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { lasertower = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "mine") and (infomacrostolaunch.mine ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { mine = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "navbeacon") and (infomacrostolaunch.navbeacon ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { navbeacon = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "resourceprobe") and (infomacrostolaunch.resourceprobe ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { resourceprobe = rowdata[2] }
						elseif IsMacroClass(rowdata[2], "satellite") and (infomacrostolaunch.satellite ~= rowdata[2]) then
							menu.infoTablePersistentData.right.macrostolaunch = { satellite = rowdata[2] }
						end
					else
						menu.infoTablePersistentData.right.macrostolaunch = {}
					end
				end
			elseif (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") or (menu.infoMode.right == "standingorders") then
				if type(rowdata) == "table" then
					menu.infoTablePersistentData.right.selectedorder = rowdata
					menu.infoTablePersistentData.right.selectedorder.object = menu.infoSubmenuObject
				else
					menu.infoTablePersistentData.right.selectedorder = nil
				end
			end
		end
	end
end

function menu.onRowChangedSound(row, rowdata, uitable, layer, modified, input)
	if (menu.frames[layer] == GetActiveFrame()) and (uitable == GetInteractiveObject(menu.frames[layer])) then
		local playsound = false
		if uitable == menu.infoTable then
			if (not menu.sound_rowChangedRowLeft) or (menu.sound_rowChangedRowLeft ~= row) then
				playsound = true
			end
		elseif uitable ~= menu.infoTableRight then
			if (not menu.sound_rowChangedRowRight) or (menu.sound_rowChangedRowRight ~= row) then
				playsound = true
			end
		else
			playsound = true
		end
		if playsound then
			PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
		end
	end
	if uitable == menu.infoTable then
		menu.sound_rowChangedRowLeft = row
	elseif uitable == menu.infoTableRight then
		menu.sound_rowChangedRowRight = row
	end
end

function menu.setSelectedMapComponents()
	if menu.holomap and (menu.holomap ~= 0) then
		local numcomponents = 0
		for _, _ in pairs(menu.selectedcomponents) do
			numcomponents = numcomponents + 1
		end
		local components = ffi.new("UniverseID[?]", numcomponents)
		local i = 0
		for id, _ in pairs(menu.selectedcomponents) do
			components[i] = ConvertStringTo64Bit(id)
			i = i + 1
		end
		C.SetSelectedMapComponents(menu.holomap, components, numcomponents)
	end
end

function menu.onSelectElement(uitable, modified, row, isdblclick, input)
	local rowdata = Helper.getCurrentRowData(menu, uitable)
	if menu.showMultiverse then
		if menu.ventureMode == "ventureoperation" then
			if uitable == menu.infoTable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			elseif uitable == menu.contextinfotable then
				Helper.callExtensionFunction("multiverse", "onSelectRow", menu, menu.ventureMode, uitable, modified, row, isdblclick, input)
			end
		end
	else

		-- start Forleyor_infoCenter Callback:
		if menu.uix_callbacks ["ic_onSelectElement"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["ic_onSelectElement"]) do
				uix_callback (uitable, modified, row, isdblclick, input)
			end
		end
		-- end Forleyor_infoCenter:

		-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
		-- kuertee start: callback
		if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
			-- kuertee end: callback

			if uitable == menu.infoTable then
				if type(rowdata) == "table" then
					local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
					menu.setSelectedMapComponents()

					if convertedRowComponent and (convertedRowComponent ~= 0) then
						local isonlineobject, isplayerowned = GetComponentData(rowdata[2], "isonlineobject", "isplayerowned")
						if (isdblclick or (input ~= "mouse")) and (ffi.string(C.GetComponentClass(convertedRowComponent)) ~= "sector") then
							if string.find(rowdata[1], "subordinates") then
								local subordinates = menu.infoTableData.left.subordinates[tostring(rowdata[2])] or {}
								local groups = {}
								for _, subordinate in ipairs(subordinates) do
									if subordinate.component then
										local group = GetComponentData(subordinate.component, "subordinategroup")
										if group and group > 0 then
											if groups[group] then
												table.insert(groups[group].subordinates, subordinate.component)
											else
												groups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(convertedRowComponent, group)), subordinates = { subordinate.component } }
											end
										end
									end
									-- LSR TODO?
								end

								if groups[rowdata[3]] then
									C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groups[rowdata[3]].subordinates[1]), true)
									menu.addSelectedComponents(groups[rowdata[3]].subordinates, modified ~= "shift")
								end
							elseif isplayerowned and isonlineobject then
								local assigneddock = ConvertIDTo64Bit(GetComponentData(convertedRowComponent, "assigneddock"))
								if assigneddock then
									local container = C.GetContextByClass(assigneddock, "container", false)
									if container then
										C.SetFocusMapComponent(menu.holomap, container, true)
									end
								end
							else
								C.SetFocusMapComponent(menu.holomap, convertedRowComponent, true)
							end
						end
					end
				end
			end
		elseif menu.infoTableMode == "plots" then
			if menu.plotDoNotUpdate then
				menu.plotDoNotUpdate = nil
			elseif menu.table_plotlist and (uitable == menu.table_plotlist.id) then
				if rowdata ~= "plots_new" then
					C.SetFocusMapComponent(menu.holomap, rowdata, true)
				end
				menu.updatePlotData(rowdata)
			end
		elseif (menu.infoTableMode == "missionoffer") or (menu.infoTableMode == "mission") then
			if uitable == menu.infoTable then
				if (menu.infoTableMode == "missionoffer") and (menu.missionOfferMode == "operation") then
					Helper.callExtensionFunction("multiverse", "onSelectRow", menu, "ventureoperation", uitable, modified, row, isdblclick, input)
				else
					if type(rowdata) == "table" then
						menu.missionModeCurrent = rowdata[1]
						local missionid = ConvertStringTo64Bit(rowdata[1])
						if menu.contextMenuData and menu.contextMenuData.missionid and (menu.contextMenuData.missionid == missionid) then
							menu.closeContextMenu()
							menu.missionModeContext = nil
						else
							menu.closeContextMenu()
							menu.showMissionContext(missionid)
							menu.missionModeContext = true
						end
					elseif type(rowdata) == "string" then
						menu.missionModeCurrent = rowdata
						if menu.missionDoNotUpdate then
							menu.missionDoNotUpdate = nil
						else
							menu.closeContextMenu()
							menu.missionModeContext = nil
						end
					end
				end
			end
		elseif (menu.infoTableMode == "info") then
			if (isdblclick or (input ~= "mouse")) then
				if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
					C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
				end
				if (menu.infoMode.left == "orderqueue") or (menu.infoMode.left == "orderqueue_advanced") then
					if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
						C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
					end
				end
			end
		end
	end

	if (menu.searchTableMode == "info") then
		if (isdblclick or (input ~= "mouse")) then
			if (rowdata == "info_focus") or ((type(rowdata) == "table") and (rowdata[1] == "info_focus")) then
				C.SetFocusMapComponent(menu.holomap, menu.infoSubmenuObject, true)
			end
			if (menu.infoMode.right == "orderqueue") or (menu.infoMode.right == "orderqueue_advanced") then
				if (type(rowdata) == "table") and (type(rowdata[1]) == "number") then
					C.SetFocusMapOrder(menu.holomap, menu.infoSubmenuObject, rowdata[1], true)
				end
			end
		end
	end
end

-- rendertarget selections
function menu.onRenderTargetSelect(modified)
	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.5 seconds and the mouse was moved more than a distance of 5px
	if (not menu.leftdown) or ((menu.leftdown.time + 0.5 > getElapsedTime()) and not Helper.comparePositions(menu.leftdown.position, offset, 5)) then
		if menu.showMultiverse then
			local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
			-- TODO
		elseif menu.mode == "selectbuildlocation" then
			local station = 0
			if menu.plotData.active then
				local offset = ffi.new("UIPosRot")
				local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
				if offsetsector ~= 0 then
					if C.IsCurrentBuildMapPlotValid(menu.holomap) then
						AddUITriggeredEvent(menu.name, "plotplaced")
						menu.plotData.sector = offsetsector
						station = C.ReserveBuildPlot(offsetsector, "player", menu.plotData.set, offset, menu.plotData.size.x * 1000, menu.plotData.size.y * 1000, menu.plotData.size.z * 1000)
						if GetComponentData(ConvertStringTo64Bit(tostring(offsetsector)), "isplayerowned") then
							local size = { x = menu.plotData.size.x * 1000, y = menu.plotData.size.y * 1000, z = menu.plotData.size.z * 1000 }
							local plotcenter = { x = offset.x, y = offset.y, z = offset.z }
							C.PayBuildPlotSize(station, size, plotcenter)
						end
						C.ClearMapBuildPlot(menu.holomap)
						menu.plotData.active = nil
						SetMouseOverOverride(menu.map, nil)
					else
						PlaySound("ui_target_set_fail")
					end
				end
			else
				local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
				local pickedcomponentclass = ffi.string(C.GetRealComponentClass(pickedcomponent))
				if (pickedcomponentclass == "station") and GetComponentData(ConvertStringToLuaID(tostring(pickedcomponent)), "isplayerowned") then
					station = pickedcomponent
				end
			end

			if station ~= 0 then
				for _, row in ipairs(menu.table_plotlist.rows) do
					if row.rowdata == station then
						menu.setplotrow = row.index
						menu.setplottoprow = (row.index - config.plots.maxPlotRows + 1) > 1 and (row.index - config.plots.maxPlotRows + 1) or 1
						break
					end
				end

				menu.updatePlotData(station, true)
				menu.refreshInfoFrame()
			end
		elseif menu.mode == "orderparam_position" then
			local offset = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local offsetcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, offset, false, 0, eclipticoffset)
			if offsetcomponent ~= 0 then
				local class = ffi.string(C.GetComponentClass(offsetcomponent))
				if (not menu.modeparam[2].inputparams.class) or (class == menu.modeparam[2].inputparams.class) then
					AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(offsetcomponent)))
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				elseif (menu.modeparam[2].inputparams.class == "zone") and (class == "sector") then
					offsetcomponent = C.GetZoneAt(offsetcomponent, offset)
					AddUITriggeredEvent(menu.name, menu.mode, ConvertStringToLuaID(tostring(offsetcomponent)))
					menu.modeparam[1]({ConvertStringToLuaID(tostring(offsetcomponent)), {offset.x, offset.y, offset.z}})
				end
			end
		elseif menu.mode == "orderparam_sector" then
			menu.mode = nil
		elseif (menu.mode == "orderparam_selectenemies") or (menu.mode == "orderparam_selectplayerdeployables") then
			menu.mode = nil
			menu.modeparam = {}
			SetMouseCursorOverride("default")
			menu.removeMouseCursorOverride(3)
		elseif menu.mode == "boardingcontext" then

		else
			if menu.searchField then
				Helper.confirmEditBoxInput(menu.searchField, 1, 7)
			end
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
			local ispickedcomponentship = C.IsComponentClass(pickedcomponent, "ship") and not C.IsUnit(pickedcomponent)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			if pickedordercomponent ~= 0 then
				local sectorcontext = C.GetContextByClass(pickedordercomponent, "sector", false)
				if sectorcontext ~= menu.currentsector then
					menu.currentsector = sectorcontext
				end

				menu.createInfoFrame()
			elseif pickedtradeoffer ~= 0 then
				local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
				local tradedata = GetTradeData(tradeid)
				if tradedata.ware then
					local setting, rawwarelist = menu.getTradeWareFilter(true)
					local found = false
					for i, ware in ipairs(rawwarelist) do
						if ware == tradedata.ware then
							found = i
							break
						end
					end
					AddUITriggeredEvent(menu.name, "filterwareselected", tradedata.isbuyoffer and "buyoffer" or "selloffer")
					if found then
						menu.removeFilterOption(setting, setting.id, found)
					else
						menu.setFilterOption("layer_trade", setting, setting.id, tradedata.ware)
					end
				end
			elseif pickedcomponent ~= 0 then
				local pickedcomponent64 = ConvertStringTo64Bit(tostring(pickedcomponent))
				if (not menu.sound_selectedelement) or (menu.sound_selectedelement ~= pickedcomponent) or (modified == "ctrl") or (modified == "shift") then
					local isselected = menu.isSelectedComponent(pickedcomponent)
					if (not isselected) and (modified == "shift") then
						PlaySound("ui_positive_multiselect")
					elseif modified == "ctrl" then
						if isselected then
							PlaySound("ui_positive_deselect")
						else
							PlaySound("ui_positive_multiselect")
						end
					elseif (pickedcomponentclass == "sector") then
						PlaySound("ui_positive_deselect")
					else
						PlaySound("ui_positive_select")
					end
				end
				menu.sound_selectedelement = pickedcomponent
				if menu.mode ~= "orderparam_object" then
					if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
						return
					end

					menu.setInfoSubmenuObjectAndRefresh(pickedcomponent64)
				end

				if pickedcomponentclass == "sector" then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
					if pickedcomponent ~= menu.currentsector then
						menu.currentsector = pickedcomponent
						menu.updateMapAndInfoFrame()
					end
				elseif (#menu.searchtext == 0) or Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.FilterComponentByText(pickedcomponent, numtexts, texts, true) end, "text") then
					local isconstruction = IsComponentConstruction(pickedcomponent64)
					if (C.IsComponentOperational(pickedcomponent) and (pickedcomponentclass ~= "player") and (not menu.createInfoFrameRunning)) or
						(pickedcomponentclass == "gate") or (pickedcomponentclass == "asteroid") or isconstruction
					then
						local sectorcontext = C.GetContextByClass(pickedcomponent, "sector", false)
						if sectorcontext ~= menu.currentsector then
							menu.currentsector = sectorcontext
						end

						if modified == "ctrl" then
							menu.toggleSelectedComponent(pickedcomponent)
						else
							if pickedcomponentclass == "station" then
								AddUITriggeredEvent(menu.name, "selection_station", pickedcomponent64)
							end
							if (pickedcomponentclass == "ship_s") or (pickedcomponentclass == "ship_m") or (pickedcomponentclass == "ship_l") or (pickedcomponentclass == "ship_xl") then
								AddUITriggeredEvent(menu.name, "selection_ship", pickedcomponent64)
							end
							if (pickedcomponentclass == "resourceprobe") then
								AddUITriggeredEvent(menu.name, "selection_resourceprobe", pickedcomponent64)
							end

							local newmode
							if (menu.mode ~= "selectComponent") or (menu.modeparam[3] ~= "deployables") then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									local isdeployable = GetComponentData(pickedcomponent64, "isdeployable")
									if isdeployable or (pickedcomponentclass == "lockbox") or (pickedcomponentclass == "collectablewares") then
										newmode = "deployables"
									elseif menu.objectMode ~= "objectall" then
										if C.IsRealComponentClass(pickedcomponent, "station") then
											newmode = "stations"
										elseif ispickedcomponentship then
											local found = false
											local commanderlist = GetAllCommanders(pickedcomponent64)
											for i, entry in ipairs(commanderlist) do
												if IsComponentClass(entry, "station") then
													found = true
													break
												end
											end
											if found then
												newmode = "stations"
											else
												newmode = "ships"
											end
										end
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									local isplayerowned, isdeployable = GetComponentData(pickedcomponent64, "isplayerowned", "isdeployable")
									if isplayerowned then
										if isdeployable or (pickedcomponentclass == "lockbox") or (pickedcomponentclass == "collectablewares") then
											newmode = "deployables"
										elseif menu.propertyMode ~= "propertyall" then
											if C.IsRealComponentClass(pickedcomponent, "station") then
												newmode = "stations"
											elseif ispickedcomponentship then
												local found = false
												local commanderlist = GetAllCommanders(pickedcomponent64)
												for i, entry in ipairs(commanderlist) do
													if IsComponentClass(entry, "station") then
														found = true
														break
													end
												end
												local subordinates = GetSubordinates(pickedcomponent64)
												if found then
													newmode = "stations"
												else
													if (#commanderlist > 0) or (#subordinates > 0) then
														newmode = "fleets"
													else
														newmode = "unassignedships"
													end
												end
											end
										end
									end

									-- start: mycu call-back
									if menu.uix_callbacks ["onRenderTargetSelect_on_propertyowned_newmode"] then
										for uix_id, uix_callback in pairs (menu.uix_callbacks ["onRenderTargetSelect_on_propertyowned_newmode"]) do
											result = uix_callback (pickedcomponent64, newmode)
											if result then
												newmode = result.newmode
											end
										end
									end
									-- end: mycu call-back

								end
							end
							menu.addSelectedComponent(pickedcomponent, not modified)
							if newmode then

								-- kuertee start:
								-- if menu.infoTableMode == "objectlist" then
								if string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
									-- kuertee end:

									if newmode ~= menu.objectMode then
										menu.objectMode = newmode
										menu.refreshInfoFrame()
									end

									-- kuertee start:
									-- elseif menu.infoTableMode == "propertyowned" then
								elseif string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
									-- kuertee end:

									if newmode ~= menu.propertyMode then
										menu.propertyMode = newmode
										menu.refreshInfoFrame()
									end
								end
							end
						end
					end
				end
			else
				if (menu.mode ~= "info") or (not menu.infoMode.left) or (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") or (menu.infoMode.left == "objectloadout") or (menu.infoMode.left == "objectlogbook") then
					AddUITriggeredEvent(menu.name, "selection_reset")
					menu.clearSelectedComponents()
				end
			end
		end
	end
	menu.leftdown = nil
end

-- rendertarget doubleclick
function menu.onRenderTargetDoubleClick(modified)
	local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
	if pickedcomponent ~= 0 then
		if not C.IsComponentClass(pickedcomponent, "sector") then
			if modified == "shift" then
				C.AddSimilarMapComponentsToSelection(menu.holomap, pickedcomponent)
			elseif modified ~= "ctrl" then
				C.SetFocusMapComponent(menu.holomap, pickedcomponent, true)
			end

			local components = {}
			Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
			if #components > 0 then
				menu.addSelectedComponents(components)
			else
				menu.clearSelectedComponents()
			end
		end
	end
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown(modified)
	menu.leftdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }

	local pickedorder = ffi.new("Order")
	local buf = ffi.new("bool[1]", 0)
	local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
	local isintermediate = buf[0]
	local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)
	if pickedordercomponent ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if not modified then
				if not menu.handlePlannedDefaultOrderRendertargetSelect(false) then
					return
				end

				menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(pickedordercomponent)))
			end

			menu.addSelectedComponent(pickedordercomponent, true)

			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				local orderdef = ffi.new("OrderDefinition")
				if C.GetOrderDefinition(orderdef, pickedorder.orderdef) then
					local orderdefid = ffi.string(orderdef.id)
					if isintermediate or config.orderDragSupport[orderdefid] then
						menu.orderdrag = { component = pickedordercomponent, order = pickedorder, orderdefid = isintermediate and "MoveWait" or orderdefid, isintermediate = isintermediate, isclick = true }
					end
				end
			end
		end
	elseif pickedintersectordefense.controllableid ~= 0 then
		if (menu.mode ~= "orderparam_object") and (menu.mode ~= "orderparam_position") then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedintersectordefense.controllableid)), "isplayerowned") then
				menu.intersectordrag = { component = pickedintersectordefense.controllableid, group = pickedintersectordefense.group, isclick = true }
			end
		end
	else
		if modified == "shift" then
			C.StartMapBoxSelect(menu.holomap, menu.mode == "orderparam_selectenemies")
		else
			C.StartPanMap(menu.holomap)
			menu.panningmap = { isclick = true }
			menu.noupdate = true
		end
	end

	-- kuertee start: distance tool
	distanceTool_from_posRot = ffi.new("UIPosRot")
	local eclipticoffset = ffi.new("UIPosRot")
	distanceTool_from_component = C.GetMapPositionOnEcliptic2(menu.holomap, distanceTool_from_posRot, false, 0, eclipticoffset)
    -- kuertee end
end

function menu.onRenderTargetMouseUp(modified)
	if menu.orderdrag then
		if not menu.orderdrag.isclick then
			if (menu.orderdrag.component ~= C.GetPlayerOccupiedShipID()) and GetComponentData(ConvertStringTo64Bit(tostring(menu.orderdrag.component)), "assignedpilot") then
				local posrot = ffi.new("UIPosRot")

				local paramidx = config.orderDragSupport[ffi.string(menu.orderdrag.orderdefid)]
				local orderidx = (tonumber(menu.orderdrag.order.queueidx) == 0) and "default" or tonumber(menu.orderdrag.order.queueidx)
				local orderparams = GetOrderParams(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx)
				if next(orderparams) then
					if (orderparams[paramidx].type == "position") and (type(orderparams[paramidx].value[2]) == "table") then
						local eclipticoffset = ffi.new("UIPosRot", orderparams[paramidx].value[2])

						local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, ConvertIDTo64Bit(orderparams[paramidx].value[1]), eclipticoffset)
						if posrotcomponent ~= 0 then
							SetOrderParam(ConvertStringToLuaID(tostring(menu.orderdrag.component)), orderidx, paramidx, nil, { ConvertStringToLuaID(tostring(posrotcomponent)), {posrot.x, posrot.y, posrot.z} })
						end
					else
						DebugError("menu.onRenderTargetMouseUp(): Invalid order parameter used for orderdrag: " .. menu.orderdrag.orderdefid .. ", param '" .. paramidx .. "' of type '" .. orderparams[paramidx].type .. "'")
					end
				end
			end
		end
		menu.orderdrag = nil
	elseif menu.intersectordrag then
		if not menu.intersectordrag.isclick then
			local posrot = ffi.new("UIPosRot")
			local currentsector = C.GetSubordinateGroupProtectedSector(menu.intersectordrag.component, menu.intersectordrag.group)
			local eclipticoffset = C.GetSubordinateGroupProtectedPosition(menu.intersectordrag.component, menu.intersectordrag.group)

			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, true, currentsector, eclipticoffset)
			if posrotcomponent ~= 0 then
				C.SetSubordinateGroupProtectedLocation(menu.intersectordrag.component, menu.intersectordrag.group, posrotcomponent, posrot)
			end
		end
		menu.intersectordrag = nil
	elseif menu.panningmap then
		C.StopPanMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_panmap then
			StopPlayingSound(menu.sound_panmap)
			menu.sound_panmap = nil
		end
		if menu.infoTableMode == "objectlist" then
			if not menu.panningmap.isclick then
				menu.refreshInfoFrame()
			end
		elseif menu.infoTableMode == "plots" and menu.plotData.component then
			if not menu.panningmap.isclick then
				-- update plot position and price
				menu.updatePlotData()
			end
		end
		menu.panningmap = nil
	else
		C.StopMapBoxSelect(menu.holomap)
		local components = {}
		Helper.ffiVLA(components, "UniverseID", C.GetNumMapSelectedComponents, C.GetMapSelectedComponents, menu.holomap)
		if #components > 0 then
			menu.setInfoSubmenuObjectAndRefresh(ConvertStringTo64Bit(tostring(components[1])))
			menu.sound_selectedelement = components[i]
			PlaySound("ui_positive_multiselect")
		end
		if menu.mode == "orderparam_selectenemies" then
			for i = #components, 1, -1 do
				local component = components[i]
				if component == menu.modeparam[1] then
					table.remove(components, i)
				elseif (not C.IsComponentClass(component, "ship")) and (not C.IsComponentClass(component, "station")) then
					table.remove(components, i)
				end
			end
			for id, _ in pairs(menu.selectedcomponents) do
				local selectedcomponent = ConvertStringTo64Bit(id)
				local hasloop = ffi.new("bool[1]", 0)
				C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
				if (selectedcomponent ~= C.GetPlayerOccupiedShipID()) and GetComponentData(selectedcomponent, "assignedpilot") and ((not hasloop[0]) or menu.orderdefbyid["Attack"].loopable) then
					if GetComponentData(selectedcomponent, "isplayerowned") then
						menu.orderAttackMultiple(selectedcomponent, menu.modeparam[1], components, menu.modeparam[2])
					end
				end
			end
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		elseif menu.mode == "orderparam_selectplayerdeployables" then
			for i = #components, 1, -1 do
				local component = ConvertStringTo64Bit(tostring(components[i]))
				if not GetComponentData(component, "isdeployable") then
					table.remove(components, i)
				end
			end
			menu.orderCollectDeployables(menu.modeparam[1], components, menu.modeparam[2])
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
			menu.refreshInfoFrame()
		else
			if #components > 0 then
				menu.addSelectedComponents(components, false)
			end
		end
	end
end

--[[
-- NOTE: When these functions are defined, regular MMB handling in the input system will be blocked
function menu.onRenderTargetMiddleMouseDown()
end

function menu.onRenderTargetMiddleMouseUp()
end
]]

function menu.onRenderTargetRightMouseDown()
	if (menu.mode ~= "boardingcontext") and (menu.contextMenuMode ~= "onlinemode") and (menu.contextMenuMode ~= "onlinereward") then
		menu.closeContextMenu()
	end
	menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }

	if menu.mode ~= "selectbuildlocation" then
		C.StartRotateMap(menu.holomap)
	end
	menu.rotatingmap = true
	menu.noupdate = true
end

function menu.onRenderTargetRightMouseUp(modified)
	local offset = table.pack(GetLocalMousePosition())

	-- Check if the mouse was moved more than a distance of 5px
	if menu.rightdown and (not Helper.comparePositions(menu.rightdown.position, offset, 5)) and (not menu.rightdown.wasmoved) and (menu.mode ~= "boardingcontext") then
		if (menu.mode == "orderparam_position") then
			menu.resetOrderParamMode()
		elseif (menu.mode == "selectbuildlocation") and menu.plotData.active then
			if menu.plotData.active then
				C.ClearMapBuildPlot(menu.holomap)
				menu.plotData.active = nil
				SetMouseOverOverride(menu.map, nil)
			end
		elseif menu.mode == "orderparam_selectenemies" then
			menu.mode = nil
			menu.modeparam = {}
			menu.removeMouseCursorOverride(3)
		else
			local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
			local pickedorder = ffi.new("Order")
			local isintermediate = ffi.new("bool[1]", 0)
			local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, isintermediate)
			local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
			local pickedmissionoffer = C.GetPickedMapMissionOffer(menu.holomap)
			local pickedmission = C.GetPickedMapMission(menu.holomap)
			local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
			local pickedsyncpointorder = ffi.new("Order")
			local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)
			local pickedintersectordefense = C.GetPickedMapInterSectorDefence(menu.holomap)

			local posrot = ffi.new("UIPosRot")
			local eclipticoffset = ffi.new("UIPosRot")
			local posrotcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, posrot, false, 0, eclipticoffset)

			-- kuertee start: distance tool
			distanceTool_to_posRot = posrot
			distanceTool_to_component = posrotcomponent
    
    			Helper.distanceTool_distance = nil
			if distanceTool_from_component and distanceTool_from_posRot then
				local posFrom, sectorFrom, posTo, sectorTo
				if C.IsComponentClass (distanceTool_from_component, "sector") then
					posFrom = distanceTool_from_posRot
					sectorFrom = distanceTool_from_component
				else
					posFrom = C.GetObjectPositionInSector (distanceTool_from_component)
					sectorFrom = ConvertIDTo64Bit(GetComponentData(distanceTool_from_component, "sectorid"))
				end
				if C.IsComponentClass (distanceTool_to_component, "sector") then
					posTo = distanceTool_to_posRot
					sectorTo = distanceTool_to_component
				else
					posTo = C.GetObjectPositionInSector (distanceTool_to_component)
					sectorTo = ConvertIDTo64Bit(GetComponentData(distanceTool_to_component, "sectorid"))
				end
				if sectorFrom == sectorTo then
					local x_delta = math.abs (posTo.x - posFrom.x)
					local y_delta = math.abs (posTo.y - posFrom.y)
					local z_delta = math.abs (posTo.z - posFrom.z)
					Helper.distanceTool_distance = math.pow (math.pow (x_delta, 2) + math.pow (y_delta, 2) + math.pow (z_delta, 2), 0.5)
				end
			end
			distanceTool_from_posRot = distanceTool_to_posRot
			distanceTool_from_component = distanceTool_to_component
		    -- kuertee end

			local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
			if pickedordercomponent ~= 0 then
				if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
					if menu.mode ~= nil then
						PlaySound("ui_menu_interact_btn_selectinvalid_core")
					else
						Helper.openInteractMenu(menu, { component = pickedordercomponent, order = pickedorder, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
					end
				end
			elseif pickedsyncpoint ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { syncpoint = pickedsyncpoint, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
				end
			elseif pickedsyncpointordercomponent ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedsyncpointordercomponent, syncpointorder = pickedsyncpointorder, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
				end
			elseif pickedintersectordefense.controllableid ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { component = pickedintersectordefense.controllableid, intersectordefencegroup = pickedintersectordefense.group, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
				end
			elseif pickedmission ~= 0 then
				if menu.mode ~= nil then
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				else
					Helper.openInteractMenu(menu, { mission = ConvertStringTo64Bit(tostring(pickedmission)), playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
				end
			elseif pickedtradeoffer ~= 0 then
				if menu.mode == nil then
					local tradeid = ConvertStringToLuaID(tostring(pickedtradeoffer))
					local tradedata = GetTradeData(tradeid)

					local issingleloopship, selectedcomponent
					if menu.getNumSelectedComponents() == 1 then
						local component = next(menu.selectedcomponents)
						selectedcomponent = ConvertStringTo64Bit(component)
						local hasloop = ffi.new("bool[1]", 0)
						C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
						issingleloopship = hasloop[0]
					end

					if issingleloopship then
						menu.contextMenuMode = "tradeloop"
						menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), currentShip = selectedcomponent, orders = {}, loop = tradedata.isbuyoffer and "SingleSell" or "SingleBuy", ware = tradedata.ware, reservecargo = true }

						local offsetx = offset[1] + Helper.viewWidth / 2
						local offsety = Helper.viewHeight / 2 - offset[2]

						menu.createContextFrame(Helper.scaleX(config.tradeLoopWidth), nil, offsetx, offsety)
					else
						local tradesubscription = GetComponentData(tradedata.station, "tradesubscription")
						if tradesubscription and (tradedata.amount > 0) then
							menu.contextMenuMode = "trade"
							menu.contextMenuData = { component = ConvertIDTo64Bit(tradedata.station), orders = {}, tradeid = tradeid }

							local numwarerows, numinforows = menu.initTradeContextData()
							menu.updateTradeContextDimensions(numwarerows, numinforows)
							AddUITriggeredEvent(menu.name, "pickedtradeoffer", tradedata.isbuyoffer and "buyoffer" or "selloffer")

							local width = menu.tradeContext.width
							local height = menu.tradeContext.shipheight + menu.tradeContext.buttonheight + 1 * Helper.borderSize

							local offsetx = offset[1] + Helper.viewWidth / 2
							if offsetx + width > Helper.viewWidth - Helper.frameBorder then
								offsetx = Helper.viewWidth - width - Helper.frameBorder
							end
							local offsety = Helper.viewHeight / 2 - offset[2]
							if offsety + height > Helper.viewHeight - Helper.frameBorder then
								offsety = Helper.viewHeight - height - Helper.frameBorder
							end

							menu.createContextFrame(width, height, offsetx, offsety)
						else
							local missions = {}
							Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, ConvertIDTo64Bit(tradedata.station))

							Helper.openInteractMenu(menu, { component = tradedata.station, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent })
						end
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedmissionoffer ~= 0 then
				if menu.mode == nil then
					menu.contextMenuMode = "mission"
					local width = Helper.scaleX(config.missionContextWidth)
					local height = menu.prepareMissionContextData(nil, tostring(pickedmissionoffer), width)

					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					if offsetx + width > Helper.viewWidth then
						offsetx = Helper.viewWidth - width - config.contextBorder
					end
					if offsety + height > Helper.viewHeight then
						offsety = Helper.viewHeight - height - config.contextBorder
					end

					menu.createContextFrame(width, height, offsetx, offsety)
					if menu.holomap ~= 0 then
						C.SetMapRenderMissionGuidance(menu.holomap, pickedmissionoffer)
					end
				else
					PlaySound("ui_menu_interact_btn_selectinvalid_core")
				end
			elseif pickedcomponent ~= 0 then
				local convertedComponent = ConvertStringTo64Bit(tostring(pickedcomponent))
				if modified ~= "ctrl" then
					if menu.mode == "hire" then
						if C.IsComponentClass(convertedComponent, "controllable") and (not C.IsComponentClass(convertedComponent, "spacesuit")) then
							local isplayerowned, isdock, isonlineobject = GetComponentData(convertedComponent, "isplayerowned", "isdock", "isonlineobject")
							if (isplayerowned or (isdock and C.IsComponentClass(convertedComponent, "station"))) and (not isonlineobject) then
								menu.contextMenuMode = "hire"
								menu.contextMenuData = { hireObject = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }

								local width = Helper.scaleX(config.hireContextWidth)
								if menu.contextMenuData.xoffset + width > Helper.viewWidth then
									menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
								end

								menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
							end
						end
					elseif menu.mode == "selectCV" then
						if C.IsComponentClass(pickedcomponent, "ship") and GetComponentData(convertedComponent, "primarypurpose") == "build" then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "orderparam_object" then
						if menu.checkForOrderParamObject(convertedComponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2]  }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					elseif menu.mode == "selectComponent" then
						if menu.checkForSelectComponent(pickedcomponent) then
							menu.contextMenuData = { component = convertedComponent, xoffset = offset[1] + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - offset[2] }
							menu.contextMenuMode = "select"
							menu.createContextFrame(menu.selectWidth)
						end
					else
						local missions = {}
						Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, pickedcomponent)

						Helper.openInteractMenu(menu, { component = pickedcomponent, offsetcomponent = posrotcomponent, offset = posrot, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent, buildStationMode = menu.mode == "selectbuildlocation" })
					end
				else
					local offsetx = offset[1] + Helper.viewWidth / 2
					local offsety = Helper.viewHeight / 2 - offset[2]

					menu.defaultInteraction(pickedcomponent, posrot, posrotcomponent ~= 0, offsetx, offsety)
				end
			end
		end
	end
	menu.rightdown = nil
	if menu.rotatingmap then
		C.StopRotateMap(menu.holomap)
		menu.noupdate = false
		if menu.sound_rotatemap and menu.sound_rotatemap.sound then
			StopPlayingSound(menu.sound_rotatemap.sound)
			menu.sound_rotatemap = nil
		end
		menu.rotatingmap = nil
		if menu.infoTableMode == "objectlist" then
			menu.refreshInfoFrame()
		end
	end
end

function menu.prepareMissionContextData(missionid, missionofferid, width)
	if missionid then
		local missionid64 = ConvertStringTo64Bit(missionid)
		local missiondetails = C.GetMissionIDDetails(missionid64)
		local onlineinfo = C.GetMissionOnlineInfo(missionid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		local missionGroup = C.GetMissionGroupDetails(missionid64)
		local groupID = ffi.string(missionGroup.id)
		menu.contextMenuData = {
			isoffer = false,
			missionid = missionid64,
			name = ffi.string(missiondetails.missionName),
			rawdescription = ffi.string(missiondetails.missionDescription),
			difficulty = missiondetails.difficulty,
			rewardmoney = tonumber(missiondetails.reward) / 100,
			rewardtext = ffi.string(missiondetails.rewardText),
			activebriefingstep = missiondetails.activeBriefingStep,
			briefingmissions = {},
			timeout = (missiondetails.timeLeft and missiondetails.timeLeft > -1) and missiondetails.timeLeft or (missiondetails.duration or -1),
			abortable = missiondetails.abortable,
			offeractor = nil,
			expired = false,
			threadtype = ffi.string(missiondetails.threadType),
			threadMissionID = ConvertStringTo64Bit(tostring(missiondetails.threadMissionID)),
			type = ffi.string(missiondetails.mainType),
			subtype = ffi.string(missiondetails.subType),
			onlinechapter = onlinechapter,
			onlineID = onlineid,
			groupID = groupID,
		}
		if menu.contextMenuData.threadtype == "" then
			local objectivedata = C.GetMissionIDObjective2(missionid64)
			menu.contextMenuData.objectiveText = ffi.string(objectivedata.objectiveText)
			menu.contextMenuData.progressname = ffi.string(objectivedata.progressname)
			menu.contextMenuData.curProgress = objectivedata.curProgress
			menu.contextMenuData.maxProgress = objectivedata.maxProgress
		end

		local briefingicon = C.GetMissionBriefingIcon(missionid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.briefingbuttontext = ffi.string(C.GetMissionBriefingButton(missionid64))

		menu.contextMenuData.briefingobjectives = {}
		for i = 1, tonumber(missiondetails.numBriefingObjectives) do
			local objective = C.GetMissionObjectiveStep3(missionid64, i)
			table.insert(menu.contextMenuData.briefingobjectives, { step = objective.step, text = ffi.string(objective.text), failed = objective.failed, completedoutofsequence = objective.completedoutofsequence })
		end
		menu.contextMenuData.subMissions = {}
		local buf = {}
		Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, missionid64)
		for _, submission in ipairs(buf) do
			local submissionEntry = menu.getMissionIDInfoHelper(submission)
			table.insert(menu.contextMenuData.subMissions, submissionEntry)
		end

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		local faction = ffi.string(missiondetails.faction)
		if faction ~= "" then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
		local oppfaction = ffi.string(missiondetails.opposingFaction)
		if oppfaction ~= "" then
			local factionDetails = C.GetFactionDetails(ffi.string(oppfaction))
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.oppFactionName = factionName
			end
		end
	elseif missionofferid then
		local missionofferid64 = ConvertStringTo64Bit(missionofferid)
		local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, rewardmoney, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, abortable, guidancedisabled, associatedcomponent, alertLevel, offeractor, offercomponent = GetMissionOfferDetails(ConvertStringToLuaID(missionofferid))
		local onlineinfo = C.GetMissionOnlineInfo(missionofferid64)
		local onlinechapter, onlineid = ffi.string(onlineinfo.chapter), ffi.string(onlineinfo.onlineid)
		local missionGroup = C.GetMissionGroupDetails(missionofferid64)
		local groupID = ffi.string(missionGroup.id)
		menu.contextMenuData = {
			isoffer = true,
			missionid = missionofferid64,
			name = name,
			rawdescription = description,
			difficulty = difficulty,
			rewardmoney = rewardmoney,
			rewardtext = rewardtext,
			briefingobjectives = briefingobjectives,
			activebriefingstep = activebriefingstep,
			briefingmissions = briefingmissions,
			timeout = duration or -1,
			abortable = nil,
			offeractor = offeractor,
			expired = false,
			threadtype = threadtype,
			subMissions = {},
			type = maintype,
			subtype = subtype,
			onlinechapter = onlinechapter,
			onlineID = onlineid,
			groupID = groupID,
		}
		local briefingicon = C.GetMissionBriefingIcon(missionofferid64)
		if ffi.string(briefingicon.icon) ~= "" then
			menu.contextMenuData.briefingicon = ffi.string(briefingicon.icon)
			menu.contextMenuData.briefingiconcaption = ffi.string(briefingicon.caption)
			menu.contextMenuData.briefingiconwidth = math.floor(config.missionContextIconWidthFactor * width)
		end

		menu.contextMenuData.briefingbuttontext = ffi.string(C.GetMissionBriefingButton(missionofferid64))

		menu.contextMenuData.deliveryWares = {}
		local n = C.GetNumMissionDeliveryWares(missionofferid64)
		if n > 0 then
			local buf = ffi.new("MissionWareDeliveryInfo[1]")
			buf[0].numwares = n
			buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", n)
			C.GetMissionDeliveryWares(buf, missionofferid64)
			menu.contextMenuData.deliveryWares.target = buf[0].target
			for i = 0, buf[0].numwares - 1 do
				table.insert(menu.contextMenuData.deliveryWares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
			end
		end

		local descriptionwidth = width
		if menu.contextMenuData.briefingicon then
			descriptionwidth = descriptionwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
		end
		descriptionwidth = descriptionwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionwidth)
		menu.contextMenuData.descriptionWidth = descriptionwidth

		if faction then
			local factionDetails = C.GetFactionDetails(faction)
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.factionName = factionName
			end
		end
		if oppfaction then
			local factionDetails = C.GetFactionDetails(ffi.string(oppfaction))
			local factionName = ffi.string(factionDetails.factionName)
			if factionName ~= "" then
				menu.contextMenuData.oppFactionName = factionName
			end
		end
	end
	if menu.contextMenuData and menu.contextMenuData.briefingobjectives then
		for i, entry in ipairs(menu.contextMenuData.briefingobjectives) do
			local mode, object
			local library, item, item2 = GetMissionObjectiveEncyclopediaReference(menu.contextMenuData.missionid, i)
			local known = true
			if library then
				if library == "Galaxy" then
					mode = library
					object = item
					known = C.IsKnownToPlayer(ConvertIDTo64Bit(object))
				elseif library == "Blueprints" then
					mode = library
					library = item
					item = item2

					local macro = GetWareData(item2, "component")
					local macrolibrary = GetMacroData(macro, "infolibrary")
					AddKnownItem(macrolibrary, macro)
				else
					AddKnownItem(library, item)
				end
				entry.encyclopedia = { mode = mode, library = library, id = item, object = object, known = known }
			end
		end
	end

	local textHeight = math.ceil(C.GetTextHeight(" ", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), 0))

	local descriptionminwidth = width - Helper.scrollbarWidth
	if menu.contextMenuData.briefingicon then
		descriptionminwidth = descriptionminwidth - menu.contextMenuData.briefingiconwidth - Helper.borderSize
	end
	descriptionminwidth = descriptionminwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)

	-- restrict number of visible lines for both description table and objectives table - if there are more lines, we need a scrollbar
	menu.contextMenuData.descriptionLines = #menu.contextMenuData.description
	local maxdescriptionlines = 10
	local briefingiconheight = 0
	if menu.contextMenuData.briefingicon then
		local iconwidth = menu.contextMenuData.briefingiconwidth
		local captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		-- cap the captionheight at 5 lines
		if captionheight > 5 * (textHeight + Helper.borderSize) then
			local lines = GetTextLines(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx))
			menu.contextMenuData.briefingiconcaption = ""
			for i = 1, 5 do
				if i > 1 then
					menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. " "
				end
				menu.contextMenuData.briefingiconcaption = menu.contextMenuData.briefingiconcaption .. lines[i]
			end
			menu.contextMenuData.briefingiconcaption = utf8.sub(menu.contextMenuData.briefingiconcaption, 1, -3) .. "..."
			captionheight = math.ceil(C.GetTextHeight(menu.contextMenuData.briefingiconcaption, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), iconwidth - 2 * Helper.scaleX(Helper.standardTextOffsetx)))
		end

		briefingiconheight = iconwidth + captionheight + Helper.borderSize
		maxdescriptionlines = math.ceil(1.5 * briefingiconheight / (textHeight + Helper.borderSize))
	end
	if menu.contextMenuData.descriptionLines > maxdescriptionlines then
		menu.contextMenuData.description = GetTextLines(menu.contextMenuData.rawdescription, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), descriptionminwidth)
		menu.contextMenuData.descriptionLines = maxdescriptionlines
		menu.contextMenuData.descriptionWidth = descriptionminwidth
	end

	if menu.contextMenuData.threadtype ~= "" then
		if menu.contextMenuData.isoffer then
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingmissions, 1)
		else
			menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.subMissions, 1)
		end
	else
		menu.contextMenuData.objectiveLines = math.max(#menu.contextMenuData.briefingobjectives, 1)
	end

	local minwidth = width - Helper.scrollbarWidth
	menu.contextMenuData.objectiveWidth = width
	if menu.contextMenuData.objectiveLines > 10 then
		menu.contextMenuData.objectiveLines = 10
		menu.contextMenuData.objectiveWidth = minwidth
	end
	menu.contextMenuData.bottomLines = 3 + (menu.contextMenuData.factionName and 1 or 0) + (menu.contextMenuData.oppFactionName and 1 or 0) + ((menu.contextMenuData.difficulty ~= 0) and 1 or 0) + (menu.contextMenuData.isoffer and 0 or 1)

	local tablespacing = Helper.standardTextHeight
	local headerHeight = Helper.scaleY(Helper.headerRow1Offsety) + Helper.scaleY(Helper.headerRow1Height - Helper.headerRow1Offsety)
	menu.contextMenuData.descriptionYOffset = Helper.borderSize
	menu.contextMenuData.descriptionHeight = headerHeight + math.max(menu.contextMenuData.descriptionLines * (textHeight + Helper.borderSize), briefingiconheight)
	menu.contextMenuData.objectiveYOffset = menu.contextMenuData.descriptionYOffset + menu.contextMenuData.descriptionHeight + tablespacing
	menu.contextMenuData.objectiveHeight = headerHeight + menu.contextMenuData.objectiveLines * (textHeight + Helper.borderSize)
	menu.contextMenuData.bottomYOffset = menu.contextMenuData.objectiveYOffset + menu.contextMenuData.objectiveHeight + tablespacing
	menu.contextMenuData.bottomHeight = menu.contextMenuData.bottomLines * (textHeight + Helper.borderSize)

	return menu.contextMenuData.bottomYOffset + menu.contextMenuData.bottomHeight + Helper.borderSize
end

function menu.showMissionContext(missionid, isoffer)
	menu.contextMenuMode = "mission"
	local width = Helper.scaleX(config.missionContextWidth)
	local height
	if ((not menu.showMultiverse) and (menu.infoTableMode == "mission")) or (isoffer == false) then
		height = menu.prepareMissionContextData(missionid, nil, width)
	else
		height = menu.prepareMissionContextData(nil, missionid, width)
	end

	local offsetx = menu.infoTableOffsetX + menu.infoTableWidth + Helper.borderSize + config.contextBorder
	local offsety = menu.infoTableOffsetY

	menu.createContextFrame(width, height, offsetx, offsety)
	if menu.holomap ~= 0 then
		C.SetMapRenderMissionGuidance(menu.holomap, ConvertStringTo64Bit(missionid))
	end
end

function menu.getSelectedComponentCategories()
	local playerships, otherobjects, playerdeployables = {}, {}, {}, {}

	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		local isplayerowned, isdeployable = GetComponentData(selectedcomponent, "isplayerowned", "isdeployable")
		if isdeployable then
			if isplayerowned then
				table.insert(playerdeployables, selectedcomponent)
			end
		elseif C.IsComponentClass(selectedcomponent, "ship") then
			if isplayerowned then
				table.insert(playerships, selectedcomponent)
			else
				table.insert(otherobjects, selectedcomponent)
			end
		elseif C.IsRealComponentClass(selectedcomponent, "station") or C.IsRealComponentClass(selectedcomponent, "ship") then
			table.insert(otherobjects, selectedcomponent)
		end
	end

	return playerships, otherobjects, playerdeployables
end

function menu.onRenderTargetCombinedScrollDown(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "out" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "out" }
	end
end

function menu.onRenderTargetCombinedScrollUp(step)
	local curtime = getElapsedTime()
	C.ZoomMap(menu.holomap, -step)
	if not menu.lastzoom or menu.lastzoom.dir ~= "in" or menu.lastzoom.time + 1.0 < curtime then
		menu.lastzoom = { time = curtime, dir = "in" }
	end
end

-- button mouse helper

function menu.onButtonOverSound(uitable, row, col, button, input)
	if not menu.sound_selectedelement or button ~= menu.sound_selectedelement then
		if input == "mouse" then
			if (not menu.sound_buttonOverLock) then
				PlaySound((uitable == menu.sideBar) and "ui_positive_hover_side" or "ui_positive_hover_normal")
				menu.sound_buttonOverLock = true
			end
		end
	end
	menu.sound_selectedelement = button
end

function menu.onButtonDown()
	menu.noupdate = true
	PlaySound("ui_positive_click")
end

function menu.onButtonUp()
	menu.noupdate = false
	--PlaySound("ui_positive_click")
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableScrollBarDown()
	menu.noupdate = true
	PlaySound("ui_sbar_table_down")
end

function menu.onTableScrollBarUp()
	menu.noupdate = false
end

function menu.onEditboxRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	-- start Forleyor_infoCenter Callback:
	if menu.uix_callbacks ["ic_onTableRightMouseClick"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["ic_onTableRightMouseClick"]) do
			uix_callback (uitable, row, posx, posy)
		end
	end
	-- end Forleyor_infoCenter:

	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	else
		if row > (menu.numFixedRows or 0) then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if not menu.showMultiverse then

				-- kuertee start:
				-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
				if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
					-- kuertee end:

					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							local x, y = GetLocalMousePosition()
							if x == nil then
								-- gamepad case
								if posx ~= nil then
									x = posx + Helper.viewWidth / 2
									y = posy + Helper.viewHeight / 2
								end
							else
								x = x + Helper.viewWidth / 2
								y = Helper.viewHeight / 2 - y
							end

							local convertedRowComponent = ConvertIDTo64Bit(rowdata[2])
							local fleetunit
							if rowdata[1] == "fleetunit" then
								fleetunit = rowdata[3].fleetunit
							elseif string.find(rowdata[1], "fleetunit") then
								fleetunit = rowdata[4]
							end

							if fleetunit then
								local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
								if rowdata[1] == "fleetunit" then
									Helper.openInteractMenu(menu, { fleetunit = fleetunit, replacingcontrollable = menu.infoTableData.left.fleetUnitReplacements["fleetunit:" .. tostring(fleetunit)], playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, selectedfleetunit = menu.prevselectedfleetunit, selectedreplacingcontrollable = menu.infoTableData.left.fleetUnitReplacements["fleetunit:" .. tostring(menu.prevselectedfleetunit)], mouseX = posx, mouseY = posy, componentmissions = {}, behaviourInspectionComponent = menu.behaviourInspectionComponent })
								else
									Helper.openInteractMenu(menu, { fleetunit = fleetunit, replacingcontrollable = menu.infoTableData.left.fleetUnitReplacements["fleetunit:" .. tostring(fleetunit)], playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, selectedfleetunit = menu.prevselectedfleetunit, selectedreplacingcontrollable = menu.infoTableData.left.fleetUnitReplacements["fleetunit:" .. tostring(menu.prevselectedfleetunit)], mouseX = posx, mouseY = posy, subordinategroup = rowdata[3], componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent })
								end
							elseif convertedRowComponent and (convertedRowComponent ~= 0) then

								if menu.mode == "hire" then
									local isplayerowned, isonlineobject = GetComponentData(convertedRowComponent, "isplayerowned", "isonlineobject")
									if isplayerowned and C.IsComponentClass(convertedRowComponent, "controllable") and (not C.IsComponentClass(convertedRowComponent, "spacesuit")) and (not isonlineobject) then
										menu.contextMenuMode = "hire"
										menu.contextMenuData = { hireObject = convertedRowComponent, xoffset = x, yoffset = y }

										local width = Helper.scaleX(config.hireContextWidth)
										if menu.contextMenuData.xoffset + width > Helper.viewWidth then
											menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
										end

										menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
									end
								elseif menu.mode == "selectCV" then
									menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
									menu.contextMenuMode = "select"
									menu.createContextFrame(menu.selectWidth)
								elseif menu.mode == "orderparam_object" then
									if menu.checkForOrderParamObject(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								elseif menu.mode == "selectComponent" then
									if menu.checkForSelectComponent(convertedRowComponent) then
										menu.contextMenuData = { component = convertedRowComponent, xoffset = x, yoffset = y }
										menu.contextMenuMode = "select"
										menu.createContextFrame(menu.selectWidth)
									end
								else
									local missions = {}
									Helper.ffiVLA(missions, "MissionID", C.GetNumMapComponentMissions, C.GetMapComponentMissions, menu.holomap, convertedRowComponent)

									local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
									if rowdata[1] == "construction" then
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, construction = rowdata[3], componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent })
									elseif string.find(rowdata[1], "subordinates") then
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, mouseX = posx, mouseY = posy, subordinategroup = rowdata[3], componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent })
									else
										Helper.openInteractMenu(menu, { component = convertedRowComponent, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, selectedfleetunit = menu.prevselectedfleetunit, selectedreplacingcontrollable = menu.infoTableData.left.fleetUnitReplacements["fleetunit:" .. tostring(menu.prevselectedfleetunit)], mouseX = posx, mouseY = posy, componentmissions = missions, behaviourInspectionComponent = menu.behaviourInspectionComponent })
									end
								end
							end
						end
					end
				elseif menu.infoTableMode == "info" then
					if uitable == menu.infoTable then
						menu.prepareInfoContext(rowdata, "left")
					end
				elseif menu.infoTableMode == "missionoffer" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { missionoffer = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
						end
					end
				elseif menu.infoTableMode == "mission" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local missionid = ConvertStringTo64Bit(rowdata[1])
							local playerships, otherobjects, playerdeployables = menu.getSelectedComponentCategories()
							Helper.openInteractMenu(menu, { mission = missionid, playerships = playerships, otherobjects = otherobjects, playerdeployables = playerdeployables, behaviourInspectionComponent = menu.behaviourInspectionComponent })
						end
					end
				end

			else
				if menu.ventureMode == "ventureseason" then
					if menu.seasonMode.left == "ventureteam" then
						if uitable == menu.infoTable then
							if type(rowdata) == "table" then
								if not rowdata.isplayer then
									menu.closeContextMenu()

									local x, y = GetLocalMousePosition()

									menu.contextMenuMode = "ventureteammembercontext"
									menu.contextMenuData = { teammember = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

									local width = Helper.scaleX(config.ventureTeamContextWidth)
									if menu.contextMenuData.xoffset + width > Helper.viewWidth then
										menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
									end

									menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
								end
							end
						end
					end
				elseif menu.ventureMode == "venturecontacts" then
					if uitable == menu.infoTable then
						if type(rowdata) == "table" then
							menu.closeContextMenu()

							local x, y = GetLocalMousePosition()

							menu.contextMenuMode = "venturecontactcontext"
							menu.contextMenuData = { contact = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }

							local width = Helper.scaleX(config.ventureContactContextWidth)
							if menu.contextMenuData.xoffset + width > Helper.viewWidth then
								menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
							end

							menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
						end
					end
				end
			end

			if menu.searchTableMode == "info" then
				if uitable == menu.infoTableRight then
					menu.prepareInfoContext(rowdata, "right")
				end
			end
		else
			menu.closeContextMenu()
		end
	end
end

function menu.prepareInfoContext(rowdata, instance)
	-- controllable: rowdata[3], actor: rowdata[2]
	-- actor may be a member of a ship's crew (person) or a ship's pilot, depending on rowdata[1]. actor should never be the player.
	if (type(rowdata) == "table") and (type(rowdata[3]) == "number") and C.IsComponentClass(rowdata[3], "controllable") then
		local controllable = rowdata[3]
		local person, entity, inv_ware, weaponmacro, equipmentmacro, software
		local isplayerowned, assignedpilot, assignedaipilot, tradenpc, shiptrader, individualtrainee = GetComponentData(rowdata[3], "isplayerowned", "assignedpilot", "assignedaipilot", "tradenpc", "shiptrader", "individualtrainee")
		if rowdata[1] == "info_crewperson" then
			if isplayerowned and C.IsPerson(rowdata[2], controllable) then
				person = rowdata[2]
			end
		elseif rowdata[1] == "info_crewnpc" then
			if GetComponentData(rowdata[2], "isplayerowned") then
				entity = rowdata[2]
			end
		elseif (rowdata[1] == "info_manager") or (rowdata[1] == "info_pilot") or (rowdata[1] == "info_shiptrader") or (rowdata[1] == "info_individualtrainee") then
			if isplayerowned or C.CanPlayerCommTarget(rowdata[2]) then
				-- ship captain
				if C.IsComponentClass(controllable, "ship") and ((ConvertStringTo64Bit(tostring(assignedpilot)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(assignedaipilot)) == rowdata[2])) then
					entity = rowdata[2]
				-- station manager or shiptrader
				elseif C.IsComponentClass(controllable, "station") and ((ConvertStringTo64Bit(tostring(tradenpc)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(shiptrader)) == rowdata[2]) or (ConvertStringTo64Bit(tostring(individualtrainee)) == rowdata[2])) then
					entity = rowdata[2]
				end
			end
		elseif rowdata[1] == "info_inventory" then
			inv_ware = rowdata[2]
		elseif rowdata[1] == "info_weapon" then
			weaponmacro = rowdata[2]
		elseif (rowdata[1] == "info_equipment") or (rowdata[1] == "info_deploy") then
			equipmentmacro = rowdata[2]
		elseif rowdata[1] == "info_software" then
			software = rowdata[2]
		end

		if person or entity or inv_ware or weaponmacro or equipmentmacro or software then
			--print("person: " .. ffi.string(C.GetPersonName(rowdata[2], rowdata[3])) .. ", combinedskill: " .. C.GetPersonCombinedSkill(rowdata[3], rowdata[2], nil, nil))
			local x, y = GetLocalMousePosition()
			menu.contextMenuData = { component = controllable, person = person, entity = entity, inv_ware = inv_ware, weaponmacro = weaponmacro, equipmentmacro = equipmentmacro, software = software, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y, instance = instance }
			menu.contextMenuMode = "info_context"
			menu.createContextFrame(menu.selectWidth)
		end
	end
end

function menu.onButtonRightMouseClick()
	if (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
	end
end

function menu.onInteractiveElementChanged(element)
	menu.lastactivetable = element
end

-- close menu handler
function menu.onCloseElement(dueToClose, layer)
	PlaySound("ui_negative_back")
	if (menu.contextMenuMode == "onlinemode") or ((menu.contextMenuMode == "onlinereward") and (not menu.contextMenuData.allowClose)) then
		Helper.closeMenu(menu, dueToClose)
		menu.cleanup()
		return
	end

	if menu.closeContextMenu(dueToClose) and (dueToClose == "back") then
		return
	end

	if (menu.mode == "orderparam_object") or (menu.mode == "orderparam_position") then
		menu.resetOrderParamMode()
		return
	end

	if (menu.mode ~= "hire") and (not menu.minimized) and (dueToClose == "back") then
		if menu.showMultiverse then
			if menu.ventureMode then
				menu.deactivateObjectList()
				return
			end
		else
			if menu.infoTableMode then
				menu.deactivateObjectList()
				return
			end
		end
	end

	if (layer == nil) or (layer == config.mainFrameLayer) or (layer == config.infoFrameLayer) or (layer == config.infoFrameLayer2) then
		if dueToClose == "minimize" then
			if not menu.minimized then
				menu.closeContextMenu()
				Helper.minimizeMenu(menu, ReadText(1001, 3245))
			else
				Helper.restoreMenu(menu)
			end
		else
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
	elseif layer == config.contextFrameLayer then
		Helper.clearFrame(menu, layer)
	end
end

-- helper functions

function menu.initPlotList()
	if not menu.plots then
		menu.plots = {}
	end

	local playerobjects = GetContainedStationsByOwner("player", nil, true)
	for _, object in ipairs(playerobjects) do
		--print(GetComponentData(object, "name") .. " " .. tostring(object) .. " has " .. tostring(numstationmodules) .. " modules.")
		local object64 = ConvertIDTo64Bit(object)
		local sector64 = ConvertIDTo64Bit(GetComponentData(object, "sectorid"))
		local owner = GetComponentData(sector64, "owner")
		local inownedspace = (owner ~= "ownerless") and (owner ~= "xenon")
		local size = C.GetBuildPlotSize(object64)
		local boughtrawsize = C.GetPaidBuildPlotSize(object64)
		local paid = (not inownedspace) or (boughtrawsize.x > 0) or (boughtrawsize.y > 0) or (boughtrawsize.z > 0)
		local fullprice = tonumber(C.GetBuildPlotPrice(sector64, C.GetObjectPositionInSector(object64), size.x, size.y, size.z, "player"))
		local buf = ffi.new("bool[1]", 0)
		local plotpayment = tonumber(C.GetBuildPlotPayment(object64, buf))
		local haspositionchanged = buf[0]
		local fullypaid = ((not inownedspace) or ((boughtrawsize.x >= size.x) and (boughtrawsize.y >= size.y) and (boughtrawsize.z >= size.z))) and ((not haspositionchanged) or (plotpayment >= fullprice))

		local found = false
		for j, plot in ipairs(menu.plots) do
			if plot.station == object64 then
				found = true
				if plot.removed then
					table.remove(menu.plots, j)
				else
					plot.paid = paid
					plot.fullypaid = fullypaid
					plot.permanent = C.GetNumStationModules(object64, true, true) > 0
					-- plot.boughtrawcenteroffset is set at menu.buttonBuyPlot() when a plot is bought.
				end
				break
			end
		end
		if not found then
			table.insert(menu.plots, { station = object64, paid = paid, fullypaid = fullypaid, permanent = C.GetNumStationModules(object64, true, true) > 0, boughtrawcenteroffset = C.GetPaidBuildPlotCenterOffset(object64), removed = nil })
		end
	end
end

function menu.isInfoModeValidFor(object, mode)
	if object == nil or object == 0 then
		print(TraceBack())
	end
	local isonlineobject, isplayerowned, macro = GetComponentData(object, "isonlineobject", "isplayerowned", "macro")
	if isplayerowned and isonlineobject then
		return false
	end

	if (mode == "objectinfo") or (mode == "objectlogbook") then
		local isdatavault, islandmark = GetComponentData(object, "isdatavault", "islandmark")
		if	C.IsComponentClass(object, "ship") or
			C.IsRealComponentClass(object, "station") or
			C.IsComponentClass(object, "buildstorage") or
			C.IsComponentClass(object, "sector") or
			C.IsComponentClass(object, "gate") or
			C.IsComponentClass(object, "mine") or
			C.IsComponentClass(object, "navbeacon") or
			C.IsComponentClass(object, "resourceprobe") or
			C.IsComponentClass(object, "satellite") or
			C.IsComponentClass(object, "asteroid") or
			(C.IsComponentClass(object, "object") and (isdatavault or islandmark))
		then
			return true
		end
	elseif (mode == "objectcrew") or (mode == "objectloadout") then
		if C.IsRealComponentClass(object, "ship_xs") then
			return false
		elseif GetMacroData(macro, "islasertower") then
			return false
		elseif C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station") then
			return true
		end
	elseif mode == "orderqueue" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "standingorders" then
		if isplayerowned and (C.IsComponentClass(object, "ship") or C.IsComponentClass(object, "station")) and (not C.IsUnit(object)) then
			return true
		end
	elseif mode == "orderqueue_advanced" then
		if isplayerowned and C.IsComponentClass(object, "ship") and (not C.IsUnit(object)) then
			return true
		end
	else
		local text = ""
		for i, entry in ipairs(config.infoCategories) do
			if not entry.empty then
				if i == #config.infoCategories then
					text = text .. " and "
				elseif i > 1 then
					text = text .. ", "
				end
				text = text .. "'" .. entry.category .. "'"
			end
		end
		DebugError("menu.isInfoModeValidFor called with invalid mode: " .. tostring(mode) .. ". valid modes are " .. text)
	end

	return false
end

function menu.getNumDefendingCrew(objectid)
	local numdefendingcrew = 0
	local numpeople = C.GetNumAllRoles()
	local peopledata = ffi.new("PeopleInfo[?]", numpeople)
	numpeople = C.GetPeople2(peopledata, numpeople, objectid, true)
	local loccounter = 0
	for i = 0, numpeople - 1 do
		if ffi.string(peopledata[i].id) == "marine" or ffi.string(peopledata[i].id) == "service" then
			numdefendingcrew = numdefendingcrew + peopledata[i].amount
			loccounter = loccounter + 1
			if loccounter == 2 then
				loccounter = nil
				break
			end
		end
	end
	return numdefendingcrew
end

function menu.getNumOperationalTurrets(objectid, numtotalturrets)
	numoperationalturrets = 0
	for i = 1, numtotalturrets do
		local currentcomponent = ConvertStringTo64Bit(tostring(C.GetUpgradeSlotCurrentComponent(objectid, "turret", i)))
		if currentcomponent and currentcomponent ~= 0 and IsComponentOperational(currentcomponent) then
			numoperationalturrets = numoperationalturrets + 1
		end
	end
	return numoperationalturrets
end

function menu.infoChangeObjectName(objectid, text, textchanged)
	if textchanged then
		SetComponentName(objectid, text)
	end

	-- [UniTrader's Advanced Renaming] Forleyor start: callback
	if menu.uix_callbacks ["utRenaming_infoChangeObjectName"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["utRenaming_infoChangeObjectName"]) do
			uix_callback (objectid, text, textchanged)
		end
	end
	-- [UniTrader's Advanced Renaming] Forleyor end: callback

	menu.noupdate = false
	menu.refreshInfoFrame()
end

function menu.infoCombineLoadoutComponents(components)
	local locmacros = {}
	for _, val in ipairs(components) do
		local val64 = ConvertStringTo64Bit(tostring(val))
		local locmacro, hullpercent, shieldpercent, hull, shield = GetComponentData(val64, "macro", "hullpercent", "shieldpercent")
		local isoperational = IsComponentOperational(val64)
		local isconstruction = IsComponentConstruction(val64)
		if not locmacros[locmacro] then
			if isoperational then
				locmacros[locmacro] = { count = 1, hullpercent = hullpercent, shieldpercent = shieldpercent, construction = 0, wreck = 0 }
			elseif isconstruction then
				locmacros[locmacro] = { count = 0, hullpercent = 0, shieldpercent = 0, construction = 1, wreck = 0 }
			else
				locmacros[locmacro] = { count = 0, hullpercent = 0, shieldpercent = 0, construction = 0, wreck = 1 }
			end
		else
			if isoperational then
				locmacros[locmacro].count = locmacros[locmacro].count + 1
				locmacros[locmacro].hullpercent = locmacros[locmacro].hullpercent + hullpercent
				locmacros[locmacro].shieldpercent = locmacros[locmacro].shieldpercent + shieldpercent
			elseif isconstruction then
				locmacros[locmacro].construction = locmacros[locmacro].construction + 1
			else
				locmacros[locmacro].wreck = locmacros[locmacro].wreck + 1
			end
		end
	end
	return locmacros
end

function menu.infoSetWeaponGroup(objectid, weaponid, primary, group, active)
	--print("setting weapon " .. ffi.string(C.GetComponentName(weaponid)) .. " of object " .. ffi.string(C.GetComponentName(objectid)) .. " for group " .. tostring(group) .. " of set primary? " .. tostring(primary) .. " to " .. tostring(active))
	C.SetWeaponGroup(objectid, weaponid, primary, group, active)
	menu.refreshInfoFrame()
end

function menu.infoWeaponGroupCheckBoxColor(objectid, groupidx, primary)
	return (C.GetDefensibleActiveWeaponGroup(objectid, primary) == groupidx) and Color["weapon_group_highlight"] or Color["checkbox_background_default"]
end

function menu.infoUpdatePeople()
	menu.updatePeopleInfo = menu.updatePeopleInfo or getElapsedTime()
end

function menu.refreshCrewInfo()
	local refreshinfoframe, refreshinfoframe2 = false, false
	if (menu.infoMode.left == "objectinfo") or (menu.infoMode.left == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("left")
		end
		refreshinfoframe = true
	end
	if (menu.infoMode.right == "objectinfo") or (menu.infoMode.right == "objectcrew") then
		if menu.infoSubmenuObject and C.IsComponentClass(menu.infoSubmenuObject, "ship") then
			menu.infoSubmenuPrepareCrewInfo("right")
		end
		refreshinfoframe2 = true
	end

	if refreshinfoframe then
		menu.refreshInfoFrame()
		-- menu.refreshInfoFrame() already triggers menu.refreshInfoFrame2()
	elseif refreshinfoframe2 then
		menu.refreshInfoFrame2()
	end
end

function menu.isModuleTypeExtended(station, type)
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			return entry.moduletypes[type]
		end
	end
	return false
end

function menu.isSubordinateExtended(name, group)
	return menu.extendedsubordinates[name .. group] ~= false
end

function menu.isDockedShipsExtended(name, isstation)
	if isstation then
		return menu.extendeddockedships[name] ~= nil
	else
		return menu.extendeddockedships[name] ~= false
	end
end

function menu.isConstructionExtended(name)
	return menu.extendedconstruction[name] ~= nil
end

function menu.isPropertyExtended(name)
	return menu.extendedproperty[name] ~= nil
end

function menu.isOrderExtended(controllable, orderidx, instance, default)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			return entry.orders[orderidx .. instance]
		end
	end
	if default ~= nil then
		table.insert(menu.extendedorders, { id = controllable, orders = { [orderidx .. instance] = default } })
		return default
	end
	return false
end

function menu.isCommander(component, fleetunit, group)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if C.IsComponentClass(selectedcomponent, "controllable") then
			local n = C.GetNumAllCommanders(selectedcomponent, 0)
			if n > 0 then
				local buf = ffi.new("CommanderInfo[?]", n)
				n = C.GetAllCommanders(buf, n, selectedcomponent, 0)
				for i = 0, n - 1 do
					if ((component ~= 0) and (buf[i].controllableid == component)) or ((fleetunit ~= 0) and (buf[i].fleetunitid == fleetunit)) then
						if group then
							if i > 0 then
								-- This is a commander in the chain, get the previous commander's group and check if it matches
								return group == buf[i - 1].groupindex
							else
								-- This is the direct commander, check if the group matches
								return group == GetComponentData(selectedcomponent, "subordinategroup")
							end
						else
							return true
						end
					end
				end
			end
		end
	end
	return false
end

function menu.isDockContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isdocked") then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.isConstructionContext(component)
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsComponentConstruction(selectedcomponent) then
			local containercontext = C.GetContextByClass(selectedcomponent, "container", false)
			while containercontext ~= 0 do
				if containercontext == component then
					return true
				end
				containercontext = C.GetContextByClass(containercontext, "container", false)
			end
		end
	end
	return false
end

function menu.extendModuleType(station, type, notoggle)
	local found = false
	for i, entry in ipairs(menu.extendedmoduletypes) do
		if IsSameComponent(entry.id, station) then
			found = true
			if (not notoggle) and entry.moduletypes[type] then
				entry.moduletypes[type] = nil
				menu.clearSelectedComponents()
				menu.highlightedbordercomponent = station
				menu.highlightedbordermoduletype = type
			else
				entry.moduletypes[type] = true
			end
		end
	end
	if not found then
		table.insert(menu.extendedmoduletypes, {id = station, moduletypes = { [type] = true } })
	end
end

function menu.extendOrder(controllable, orderidx, instance)
	local found = false
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			found = true
			if entry.orders[orderidx .. instance] then
				entry.orders[orderidx .. instance] = nil
			else
				entry.orders[orderidx .. instance] = true
			end
			break
		end
	end
	if not found then
		table.insert(menu.extendedorders, {id = controllable, orders = { [orderidx .. instance] = true } })
	end
end

function menu.swapExtendedOrder(controllable, oldorderidx, neworderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			local temp = entry.orders[neworderidx .. instance]
			entry.orders[neworderidx .. instance] = entry.orders[oldorderidx .. instance]
			entry.orders[oldorderidx .. instance] = temp
			break
		end
	end
end

function menu.setOrderParamFromMode(controllable, order, param, index, value, instance)
	SetOrderParam(controllable, order, param, index, value)

	menu.resetOrderParamMode()
end

function menu.resetOrderParamMode()
	if menu.currentInfoMode then
		menu.infoTableMode = menu.currentInfoMode[1]
		menu.infoMode.left = menu.currentInfoMode[2]
		menu.currentInfoMode = nil
	end
	menu.settoprow = menu.modeparam[3]
	menu.mode = nil
	menu.modeparam = {}

	C.ClearMapOrderParamObjectFilter(menu.holomap)
	C.ClearMapObjectFilter(menu.holomap)

	menu.removeMouseCursorOverride(3)

	menu.refreshMainFrame = true
	menu.refreshInfoFrame(0, 0)
end

function menu.onEditBoxActivated(widget)
	menu.noupdate = true
end

function menu.searchTextChanged(_, text, textchanged)
	menu.searchFieldContextText = utf8.lower(text)
	if menu.contextMenuMode ~= "searchfield" then
		menu.contextMenuMode = "searchfield"
		menu.contextMenuData = {}
		menu.createContextFrame(menu.searchEditBoxData.width, nil, menu.searchEditBoxData.x, menu.searchEditBoxData.y, true)
	else
		menu.refreshContextFrame()
	end
end

function menu.searchTextConfirmed(_, text, textchanged)
	if textchanged then
		AddUITriggeredEvent(menu.name, "searchconfirmed")

		local ware = menu.economyWares[utf8.lower(text)]
		local sector = menu.knownSectors[utf8.lower(text)]
		if ware then
			local setting, list = menu.getTradeWareFilter(true)
			local found = false
			for _, filterware in ipairs(list) do
				if filterware == ware then
					found = true
				end
			end

			if not found then
				menu.setFilterOption("layer_trade", setting, setting.id, ware)
			else
				if not __CORE_DETAILMONITOR_MAPFILTER["layer_trade"] then
					__CORE_DETAILMONITOR_MAPFILTER["layer_trade"] = true
					menu.applyFilterSettings()
				end
			end
		elseif sector then
			__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
			local sectorfilter = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
			local found = false
			for _, sectorentry in ipairs(sectorfilter) do
				if tostring(sector) == sectorentry then
					found = true
					break
				end
			end
			if not found then
				table.insert(sectorfilter, tostring(sector))
			end

			menu.setSectorFilter()
		else
			table.insert(menu.searchtext, { text = text })
			menu.setTextFilter()
		end
		menu.refreshMainFrame = true
	end
	menu.noupdate = false

	if menu.contextMenuMode == "searchfield" then
		menu.closeContextMenu()
	end

	menu.refreshInfoFrame()
end

function menu.setTextFilter()
	if menu.mode == "behaviourinspection" then
		Helper.textArrayHelper({}, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	else
		Helper.textArrayHelper(menu.searchtext, function (numtexts, texts) return C.SetMapFilterString(menu.holomap, numtexts, texts) end, "text")
	end
end

function menu.setSectorFilter()
	if menu.mode == "behaviourinspection" then
		local components = ffi.new("UniverseID[?]", 0)
		C.SetMapFilterSectors(menu.holomap, 0, components)
	else
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] = __CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"] or {}
		local numsectors = #__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]
		local components = ffi.new("UniverseID[?]", numsectors)
		for i, sector in ipairs(__CORE_DETAILMONITOR_MAPFILTER_SAVE["searchsectors"]) do
			components[i - 1] = C.ConvertStringTo64Bit(sector)
		end

		C.SetMapFilterSectors(menu.holomap, numsectors, components)
	end
end

function menu.getTradeWareFilter(force)
	local setting = config.layersettings["layer_trade"][1]
	local list = {}
	-- only return the values if the filter is active
	if force or menu.getFilterOption("layer_trade", false) then
		list = menu.getFilterOption(setting.id, setting.savegame) or {}
	end
	return setting, list
end

function menu.removeExtendedOrder(controllable, orderidx, instance)
	for i, entry in ipairs(menu.extendedorders) do
		if entry.id == controllable then
			entry.orders[orderidx .. instance] = nil
			for i = orderidx + 1, #menu.infoTableData[instance].orders do
				entry.orders[(i - 1) .. instance] = entry.orders[i]
			end
			entry.orders[#menu.infoTableData[instance].orders .. instance] = nil
			break
		end
	end
end

function menu.addShipToBoardingOperation(shipid, shipdata)
	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. ", actionid: " .. tostring(shipdata.action))
	-- NB: actionid also applies to subordinates. explicitly assigned ships that are all subordinates should be in menu.boardingData.shipdata and not in subordinates. assignedmarines are distributed among shipid and all subordinates. assignedmarines starts from shipid, overflow among subordinates in no particular order.
	local actionid = shipdata.action
	local assignedmarines = {}
	local remainingmarines = {}
	local subordinates = shipdata.subordinates

	--print("ship: " .. ffi.string(C.GetComponentName(shipid)) .. ", actionid: " .. tostring(actionid) .. ", num subordinates: " .. tostring(#subordinates))
	for _, leveldata in ipairs(menu.boardingData.marinelevels) do
		if not menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel] then
			table.insert(assignedmarines, 0)
		else
			table.insert(assignedmarines, menu.boardingData.shipdata[shipid].assignedgroupmarines[leveldata.skilllevel])
		end
	end

	-- get number of marines per tier on shipid
	local numtiers = #menu.boardingData.marinelevels
	local tierdata = ffi.new("RoleTierData[?]", numtiers)
	numtiers = C.GetRoleTiers2(tierdata, numtiers, shipid, "marine", false)

	-- add each ship and subordinate to the boarding operation.
	local marinelist = ffi.new("uint32_t[?]", numtiers)
	local marineskilllevellist = ffi.new("uint32_t[?]", numtiers)
	for i = 0, numtiers - 1 do
		marinelist[i] = math.min(assignedmarines[i+1], tierdata[i].amount)
		marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
		table.insert(remainingmarines, assignedmarines[i+1] - marinelist[i])
		--print("primary attacker. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
	end

	if menu.isShipAlreadyBoarding(shipid) then
		if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid))
		end
	else
		if not C.AddAttackerToBoardingOperation(menu.boardingData.target, shipid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
			DebugError("Failed adding " .. ffi.string(C.GetComponentName(shipid)) .. " " .. tostring(shipid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
		end
	end

	for _, subordinateid in ipairs(subordinates) do
		if not menu.boardingData.shipdata[subordinateid].isprimaryboarder then
			-- get number of marines per tier in subordinateid
			numtiers = C.GetRoleTiers2(tierdata, numtiers, subordinateid, "marine", false)
			for i = 0, numtiers - 1 do
				marinelist[i] = math.min(remainingmarines[i+1], tierdata[i].amount)
				marineskilllevellist[i] = menu.boardingData.marinelevels[i+1].skilllevel
				remainingmarines[i+1] = remainingmarines[i+1] - marinelist[i]
				--print("subordinate. index: " .. tostring(i) .. ", num marines: " .. tostring(marinelist[i]) .. ", skill level: " .. tostring(marineskilllevellist[i]))
			end

			if menu.isShipAlreadyBoarding(subordinateid) then
				if not C.UpdateAttackerOfBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed updating boarding ship " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid))
				end
			else
				--print("adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " to boarding operation")
				if not C.AddAttackerToBoardingOperation(menu.boardingData.target, subordinateid, "player", actionid, marinelist, marineskilllevellist, numtiers) then
					DebugError("Failed adding " .. ffi.string(C.GetComponentName(subordinateid)) .. " " .. tostring(subordinateid) .. " to boarding operation attacking " .. ffi.string(C.GetComponentName(menu.boardingData.target)) .. " " .. tostring(menu.boardingData.target))
				end
			end
		end
	end
end

function menu.isShipAlreadyBoarding(shipid)
	local numattackers = C.GetNumAttackersOfBoardingOperation(menu.boardingData.target, "player")
	local attackers = ffi.new("UniverseID[?]", numattackers)
	numattackers = C.GetAttackersOfBoardingOperation(attackers, numattackers, menu.boardingData.target, "player")
	local alreadyboarding = false
	for i = 0, numattackers do
		if shipid == ConvertStringTo64Bit(tostring(attackers[i])) then
			alreadyboarding = true
			break
		end
	end

	return alreadyboarding
end

function menu.updateHolomap()
	if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or (menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") then
		return
	elseif (menu.infoMode.left == "objectlogbook") or (menu.infoMode.right == "objectlogbook")  then
		return
	end

	if not menu.lastUpdateHolomapTime then
		menu.lastUpdateHolomapTime = 0
	end
	local curTime = getElapsedTime()
	if menu.lastUpdateHolomapTime < curTime - 5 and not menu.noupdate then
		menu.lastUpdateHolomapTime = curTime
		menu.refreshInfoFrame()
	end
end

function menu.syncMapFilterWithConfig()
	__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = C.GetConfigSetting("highlightvisitors") ~= 0
end

function menu.importMenuParameters()
	menu.showzone = menu.param[3] ~= 0

	menu.focuscomponent = ConvertIDTo64Bit(menu.param[4])
	menu.selectfocuscomponent = true
	if not menu.focuscomponent then
		local softtargetinfo = C.GetSofttarget2()
		if softtargetinfo.softtargetID ~= 0 then
			if C.IsComponentClass(softtargetinfo.softtargetID, "space") or C.IsComponentClass(softtargetinfo.softtargetID, "object") then
				menu.focuscomponent = softtargetinfo.softtargetID
				if C.IsComponentClass(menu.focuscomponent, "zone") and (ffi.string(softtargetinfo.softtargetConnectionName) == "") then
					menu.focuscomponent = C.GetContextByClass(menu.focuscomponent, "sector", false)
					menu.focusoffset = C.GetPlayerTargetOffset()
				end
			else
				menu.focuscomponent = C.GetPlayerObjectID()
				menu.selectfocuscomponent = nil
			end
		else
			menu.focuscomponent = C.GetPlayerObjectID()
			menu.selectfocuscomponent = nil
		end
	end

	if C.IsComponentClass(menu.focuscomponent, "highway") then
		menu.currentsector = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.focuscomponent)), "sourcesector")) or 0
	else
		menu.currentsector = C.GetContextByClass(menu.focuscomponent, "sector", true)
	end
	menu.mode = menu.param[6]
	menu.modeparam = menu.param[7] or {}
	menu.initMultiverse = menu.param[8]
	menu.focusoffset = menu.param[9]
end

function menu.prepareEconomyWares()
	if not menu.economyWares then
		menu.economyWares = {}
		local n = C.GetNumWares("economy", false, "", "")
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, "economy", false, "", "")
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			local name = GetWareData(ware, "name")

			-- strip color code from temp strings
			if utf8.find(name, "^\027M") then
				name = utf8.sub(name, 3)
			end
			if utf8.find(name, "\027X$") then
				name = utf8.sub(name, 1, -3)
			end

			menu.economyWares[utf8.lower(name)] = ware
		end
	end
end

function menu.prepareKnownSectors()
	menu.knownSectors = {}
	local clusters = GetClusters(true)
	for _, cluster in ipairs(clusters) do
		sectors = GetSectors(cluster)
		for i, sector in ipairs(sectors) do
			local name = GetComponentData(sector, "name")

			-- strip color code from temp strings
			if utf8.find(name, "^\027M") then
				name = utf8.sub(name, 3)
			end
			if utf8.find(name, "\027X$") then
				name = utf8.sub(name, 1, -3)
			end

			menu.knownSectors[utf8.lower(name)] = sector
		end
	end
end

function menu.checkForOrderParamObject(component)
	if type(menu.modeparam[5]) == "string" then
		return C.FilterComponentForDefaultOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5] == "planneddefault", menu.modeparam[6])
	else
		return C.FilterComponentForOrderParamObjectMode(ConvertStringTo64Bit(tostring(component)), ConvertStringTo64Bit(tostring(menu.modeparam[4])), menu.modeparam[5], menu.modeparam[6])
	end
end

function menu.checkForSelectComponent(component)
	local numclasses = menu.modeparam[2] and #menu.modeparam[2] or 0
	local classes = ffi.new("const char*[?]", numclasses)
	if numclasses > 0 then
		for i, class in ipairs(menu.modeparam[2]) do
			classes[i - 1] = Helper.ffiNewString(class)
		end
	end
	local result = C.FilterComponentForMapMode(component, classes, numclasses, menu.modeparam[4] or -1, false)
	Helper.ffiClearNewHelper()

	return result
end

function menu.plotCourse(object, offset)
	local convertedObject = ConvertStringToLuaID(tostring(object))
	if menu.mode or (object == C.GetPlayerControlledShipID()) then
		PlaySound("ui_target_set_fail")
		return -- no plot course to playership or when menu.mode is set
	end

	if IsSameComponent(GetActiveGuidanceMissionComponent(), convertedObject) then
		C.EndGuidance()
	else
		if offset == nil then
			offset = ffi.new("UIPosRot", 0)
		elseif C.IsComponentClass(object, "sector") then
			object = C.GetZoneAt(object, offset)
		end
		C.SetGuidance(object, offset)
	end

	menu.settoprow = GetTopRow(menu.selecttable)
	menu.setrow = Helper.currentTableRow[menu.selecttable]
	if not menu.createInfoFrameRunning then
		menu.createInfoFrame()
	end
end

function menu.getParamValue(type, value, inputparams)
	local result

	if type == "bool" then
		result = (value ~= 0) and ReadText(1001, 2617) or ReadText(1001, 2618)
	elseif type == "length" then
		if inputparams and inputparams.step and (inputparams.step >= 1000) then
			result = tostring(math.floor(value / 1000)) .. " " .. ReadText(1001, 107)
		else
			result = tostring(value) .. " " .. ReadText(1001, 107)
		end
	elseif type == "time" then
		result = tostring(value) .. " " .. ReadText(1001, 100)
	elseif type == "money" then
		result = ConvertMoneyString(value, false, true, 0, true) .. " " .. ReadText(1001, 101)
	elseif type == "object" then
		if IsComponentClass(value, "space") then
			local name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
			result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
		else
			result = GetComponentData(value, "name")
		end
	elseif type == "sector" then
		local name, sector, cluster = "", "", ""
		if value then
			name, sector, cluster = GetComponentData(value, "name", "sector", "cluster")
		end
		result = ((cluster ~= "") and (cluster .. " / ") or "") .. ((sector ~= "") and (sector .. " / ") or "") .. name
	elseif type == "ware" then
		result = GetWareData(value, "name")
	elseif type == "macro" then
		result = GetMacroData(value, "name")
	elseif type == "trade_ware" then
		result = (value[1] and ReadText(1001, 2917) or ReadText(1001, 2916)) .. " " .. GetWareData(value[2], "name")
	elseif type == "trade_amount" then
		result = value[1] and (tostring(value[1]) .. " (" .. string.format(ReadText(1001, 3246), tostring(value[2])) .. ")") or ""
	elseif type == "position" then
		local name, sectorid, clusterid = GetComponentData(value[1], "name", "sectorid", "clusterid")
		result = ""
		if clusterid then
			local sectors = GetSectors(clusterid)
			local clustername, systemid = GetComponentData(clusterid, "name", "systemid")
			if (#sectors > 1) or (systemid ~= 0) then
				result = clustername .. "\n"
			end
		end
		result = result .. (sectorid and (GetComponentData(sectorid, "name") .. "\n") or "") .. name
	else
		result = tostring(value)
	end

	return result
end

function menu.closeContextMenu(dueToClose)
	AddUITriggeredEvent(menu.name, "contextmenu_close")

	if Helper.closeInteractMenu() then
		return true
	end
	if menu.contextMenuMode then
		if menu.contextMenuMode == "trade" then
			if C.IsComponentOperational(menu.contextMenuData.currentShip) then
				SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.currentShip)), false)
			end
			if menu.contextMenuData.wareexchange then
				if C.IsComponentOperational(menu.contextMenuData.component) then
					SetVirtualCargoMode(ConvertStringToLuaID(tostring(menu.contextMenuData.component)), false)
				end
			end
			menu.selectedTradeWare = nil
		elseif menu.contextMenuMode == "mission" then
			if menu.holomap ~= 0 then
				C.SetMapRenderMissionGuidance(menu.holomap, 0)
			end
			if menu.contextMenuData.isoffer then
				UnregisterEvent("missionofferremoved", menu.onMissionOfferRemoved)
			else
				UnregisterEvent("missionremoved", menu.onMissionRemoved)
			end
		elseif menu.contextMenuMode == "boardingcontext" then
			-- restore old mode and old info table mode
			menu.mode = menu.oldmode
			menu.oldmode = nil
			menu.infoTableMode = menu.oldInfoTableMode
			menu.refreshMainFrame = true
			menu.oldInfoTableMode = nil
			menu.boardingData = {}
			menu.contexttoprow = nil
			menu.contextselectedrow = nil
		elseif (menu.contextMenuMode == "onlinemode") then
			if dueToClose == "back" then
				return false
			end
		elseif (menu.contextMenuMode == "onlinereward") then
			OnlineClearLogbookRewards()
		elseif (menu.contextMenuMode == "ventureconfig") or (menu.contextMenuMode == "venturecreateparty") or (menu.contextMenuMode == "ventureoutcome") or (menu.contextMenuMode == "venturefriendlist") then
			if not Helper.callExtensionFunction("multiverse", "closeContextMenu", menu, menu.contextMenuMode, dueToClose) then
				return true
			end
		elseif menu.contextMenuMode == "changelogo" then
			if menu.contextMenuData.origlogo ~= nil then
				C.SetFleetLogo(menu.contextMenuData.component, menu.contextMenuData.origlogo)
			end
		elseif menu.contextMenuMode == "venturereport" then
			Helper.sendChatWindowCallback("unlock")
		elseif menu.contextMenuMode == "set_orderparam_sector" then
			if menu.picking then
				local offset = ffi.new("UIPosRot")
				local eclipticoffset = ffi.new("UIPosRot")
				local offsetcomponent = C.GetMapPositionOnEcliptic2(menu.holomap, offset, false, 0, eclipticoffset)
				if offsetcomponent ~= 0 then
					if C.IsComponentClass(offsetcomponent, "sector") then
						menu.mode = "orderparam_sector"
						local luaoffsetcomponent = ConvertStringToLuaID(tostring(offsetcomponent))
						SetOrderParam(ConvertStringTo64Bit(tostring(menu.infoSubmenuObject)), menu.contextMenuData.order, menu.contextMenuData.param, menu.contextMenuData.index, luaoffsetcomponent)
						AddUITriggeredEvent(menu.name, menu.contextMenuMode, luaoffsetcomponent)
						menu.refreshInfoFrame()
					end
				end
			end
		end
		-- REMOVE this block once the mouse out/over event order is correct -> This should be unnessecary due to the global tablemouseout event reseting the picking
		if menu.currentMouseOverTable and (
			(menu.currentMouseOverTable == menu.contexttable)
			or (menu.currentMouseOverTable == menu.contextshiptable)
			or (menu.currentMouseOverTable == menu.contextbuttontable)
			or (menu.currentMouseOverTable == menu.contextdesctable)
			or (menu.currentMouseOverTable == menu.contextobjectivetable)
			or (menu.currentMouseOverTable == menu.contextbottomtable)
			or (menu.currentMouseOverTable == contextobjectivetable)
			or (menu.contextMenuMode == "boardingcontext")
			or (menu.contextMenuMode == "dropwares")
			or (menu.contextMenuMode == "crewtransfer")
			or (menu.contextMenuMode == "rename")
			or (menu.contextMenuMode == "changelogo")
			or (menu.contextMenuMode == "userquestion")
			or (menu.contextMenuMode == "venturepatron")
			or (menu.contextMenuMode == "venturereport")
			or (menu.contextMenuMode == "ventureteammembercontext")
			or (menu.contextMenuMode == "venturecontactcontext")
			or (menu.contextMenuMode == "filter_multiselectlist")
			or (menu.contextMenuMode == "hire")
		) then
			menu.picking = true
			menu.currentMouseOverTable = nil
		end
		-- END
		menu.contextFrame = nil
		Helper.clearFrame(menu, config.contextFrameLayer)
		menu.contextMenuData = {}
		menu.contextMenuMode = nil
		if (menu.mode == "tradecontext") or (menu.mode == "dropwarescontext") or (menu.mode == "renamecontext") or (menu.mode == "changelogocontext") or (menu.mode == "crewtransfercontext") or(menu.mode == "venturepatroninfo") or (menu.mode == "venturereport") or menu.closemapwithmenu then
			Helper.closeMenu(menu, dueToClose)
			menu.cleanup()
		end
		return true
	end
	return false
end

function menu.onInteractMenuCallback(type, param)
	if type == "attackmultiple" then
		menu.mode = "orderparam_selectenemies"
		menu.modeparam = param
		menu.setMouseCursorOverride("targetred", 3)
	elseif type == "collectdeployables" then
		menu.mode = "orderparam_selectplayerdeployables"
		menu.modeparam = param
		menu.setMouseCursorOverride("target", 3)
	elseif type == "boardingcontext" then
		-- accessing boarding menu from within the map
		local width = Helper.viewWidth * 0.6
		local height = Helper.viewHeight * 0.7
		local xoffset = Helper.viewWidth * 0.2
		local yoffset = Helper.viewHeight * 0.15
		menu.contextMenuMode = "boardingcontext"
		menu.contextMenuData = { target = param[1], boarders = param[2] }
		menu.createContextFrame(width, height, xoffset, yoffset)
	elseif type == "comm" then
		menu.openComm(param)
	elseif type == "close" then
		menu.onCloseElement("close")
	elseif type == "info" then
		if param[2] then
			menu.extendedinfo = {}
			for _, loccategory in ipairs(param[2]) do
				menu.extendedinfo[loccategory] = true
			end
		end
		menu.openDetails(param[1])
	elseif type == "mission" then
		menu.infoTableMode = "mission"
		menu.missionMode = param[1]
		menu.missionModeCurrent = tostring(param[2])
		if param[3] then
			menu.expandedMissionGroups[param[2]] = true
		end
		menu.refreshMainFrame = true
		menu.refreshInfoFrame()
		if not param[3] then
			menu.showMissionContext(param[2])
			menu.missionModeContext = true
		end
	elseif type == "missionaccepted" then
		if menu.missionOfferList then
			local found = false
			for i, entry in ipairs(menu.missionOfferList["plot"] or {}) do
				if ConvertStringTo64Bit(entry.ID) == param[1] then
					found = true
					entry.accepted = true
					menu.highlightLeftBar["mission"] = true
					menu.refreshMainFrame = true
					break
				end
			end
			if not found then
				for _, data in ipairs(menu.missionOfferList["guild"] or {}) do
					for _, entry in ipairs(data.missions) do
						if ConvertStringTo64Bit(entry.ID) == param[1] then
							found = true
							entry.accepted = true
							menu.highlightLeftBar["mission"] = true
							menu.refreshMainFrame = true
							break
						end
					end
					if found then
						break
					end
				end
			end
			if not found then
				for i, entry in ipairs(menu.missionOfferList["other"] or {}) do
					if ConvertStringTo64Bit(entry.ID) == param[1] then
						found = true
						entry.accepted = true
						menu.highlightLeftBar["mission"] = true
						menu.refreshMainFrame = true
						break
					end
				end
			end
		end
		menu.refreshIF = getElapsedTime()
	elseif type == "newconversation" then
		Helper.closeMenuForNewConversation(menu, param[1], param[2], param[3])
		menu.cleanup()
	elseif type == "newmenu" then
		Helper.closeMenuAndOpenNewMenu(menu, param[1], param[2])
		menu.cleanup()
	elseif type == "refresh" then
		menu.refreshInfoFrame()
	elseif type == "sellships" then
		menu.contextMenuData = { shipyard = param[1], ships = param[2], xoffset = param[3], yoffset = param[4] }
		menu.contextMenuMode = "sellships"
		menu.createContextFrame(menu.sellShipsWidth)
	elseif type == "tradecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuData = { component = param[1], currentShip = param[5], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, loop = param[4] }
		if menu.contextMenuData.loop then
			menu.buttonContextTradeLoop()
		else
			menu.buttonContextTrade(param[3])
		end
	elseif type == "dropwarescontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "dropwares"
		menu.contextMenuData = { mode = param[1], entity = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2, wares = {} }

		if menu.contextMenuData.mode == "inventory" then
			local inventory = GetInventory(menu.contextMenuData.entity)
			local onlineitems = OnlineGetUserItems()

			-- kuertee start:
			if not onlineitems then
				onlineitems = {}
			end
			-- kuertee end

			for ware, entry in pairs(inventory) do
				local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
				if (not ispersonalupgrade) and (not onlineitems[ware]) then
					table.insert(menu.contextMenuData.wares, { ware = ware, name = entry.name, amount = entry.amount })
				end
			end
			table.sort(menu.contextMenuData.wares, Helper.sortName)
		end

		local height = (#menu.contextMenuData.wares + 5) * (Helper.scaleY(config.mapRowHeight) + Helper.borderSize)
		if menu.contextMenuData.yoffset + height > Helper.viewHeight then
			menu.contextMenuData.yoffset = Helper.viewHeight - height - Helper.frameBorder
		end
		if menu.contextMenuData.xoffset + config.dropInventoryWidth > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - config.dropInventoryWidth - Helper.frameBorder
		end

		menu.createContextFrame(config.dropInventoryWidth, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "crewtransfercontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "crewtransfer"
		menu.contextMenuData = { leftShip = param[1], rightShip = param[2], extendedTier = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.crewTransferWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "renamecontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "rename"

		-- kuertee start: multi-rename
		-- menu.contextMenuData = { component = param[1], fleetrename = param[2], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }
		menu.contextMenuData = {
			component = param[1],
			fleetrename = param[2],
			uix_multiRename_objects = param[3],
			xoffset = mousepos.x + Helper.viewWidth / 2,
			yoffset = mousepos.y + Helper.viewHeight / 2
		}
		-- kuertee end: multi-rename

		local width = Helper.scaleX(config.renameWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "changelogocontext" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "changelogo"
		menu.contextMenuData = { component = param[1], origlogo = {}, currentlogo = {}, xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local buf = C.GetCurrentFleetLogo(menu.contextMenuData.component)
		menu.contextMenuData.origlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }
		menu.contextMenuData.currentlogo = menu.contextMenuData.origlogo

		local width = Helper.scaleX(config.changeLogoWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "selectsubordinates" then
		local groupShips = {}
		if param[3] and (param[3] ~= 0) then
			local num_subordinates = C.GetNumFleetUnitSubordinates(param[3], param[2])
			if num_subordinates > 0 then
				local buf_subordinates = ffi.new("UniverseID[?]", num_subordinates)
				num_subordinates = C.GetFleetUnitSubordinates(buf_subordinates, num_subordinates, param[3], param[2])
				for i = 0, num_subordinates - 1 do
					table.insert(groupShips, ConvertStringToLuaID(tostring(buf_subordinates[i])))
				end
			end
		else
			local subordinates = GetSubordinates(param[1])
			for _, subordinate in ipairs(subordinates) do
				local group = GetComponentData(subordinate, "subordinategroup")
				if group and group > 0 then
					if group == param[2] then
						table.insert(groupShips, subordinate)
					end
				end
			end
		end

		if #groupShips > 0 then
			C.SetFocusMapComponent(menu.holomap, ConvertIDTo64Bit(groupShips[1]), true)
			menu.addSelectedComponents(groupShips)
		end
	elseif type == "venturepatroninfo" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturepatron"
		menu.contextMenuData = { component = param[1], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "venturereport" then
		local mousepos = C.GetCenteredMousePos()
		menu.contextMenuMode = "venturereport"
		menu.contextMenuData = { mode = "venturereport", submode = param[1], reason = param[2], timestamp = param[3], author = param[4], transactionid = param[5], userid = param[6], xoffset = mousepos.x + Helper.viewWidth / 2, yoffset = mousepos.y + Helper.viewHeight / 2 }

		local width = Helper.scaleX(config.venturePatronWidth)
		if menu.contextMenuData.xoffset + width > Helper.viewWidth then
			menu.contextMenuData.xoffset = Helper.viewWidth - width - Helper.frameBorder
		end

		menu.createContextFrame(width, nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	elseif type == "markashostile" then
		menu.contextMenuMode = "userquestion"
		menu.contextMenuData = { mode = "markashostile", controllable = param[1], xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2, saveOption = false }

		if __CORE_DETAILMONITOR_USERQUESTION[menu.contextMenuData.mode] then
			-- continue immediately
			menu.buttonConfirmUserQuestion()
		else
			menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
		end
	elseif type == "refreshcrew" then
		if menu.infoTableMode == "info" then
			if menu.infoMode.left == "objectcrew" then
				menu.infoTablePersistentData["left"].resetcrew = true
			end
		end
		if menu.searchTableMode == "info" then
			if menu.infoMode.right == "objectcrew" then
				menu.infoTablePersistentData["right"].resetcrew = true
			end
		end
		menu.refreshInfoFrame()
	elseif type == "behaviourinspection" then
		menu.behaviourInspectionComponent = param[1]
		C.SetMapBehaviourInspectionComponent(menu.holomap, menu.behaviourInspectionComponent)

		menu.mode = "behaviourinspection"
		menu.refreshMainFrame = true
		menu.setTextFilter()
		menu.applyFilterSettings()
	elseif type == "stopbehaviourinspection" then
		menu.behaviourInspectionComponent = nil
		C.SetMapBehaviourInspectionComponent(menu.holomap, 0)

		menu.mode = nil
		menu.refreshMainFrame = true
		menu.setTextFilter()
		menu.applyFilterSettings()
	elseif type == "removebuildstorage" then
		menu.contextMenuMode = "userquestion"
		menu.contextMenuData = { mode = "removebuildstorage", buildstorage = param[1], xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

		menu.createContextFrame(Helper.scaleX(400), nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset)
	end
end

function menu.updateSelectedComponents(modified, keepselection, changedComponent, changedrow)
	local components = {}
	local rows, highlightedborderrow = GetSelectedRows(menu.infoTable)

	-- determine whether the component we are changing is now selected or unselected
	local ischangedselected = false
	for _, row in ipairs(rows) do
		if row == changedrow then
			ischangedselected = true
			break
		end
	end

	menu.prevselectedfleetunit = nil
	for _, row in ipairs(rows) do
		local rowdata = menu.rowDataMap[menu.infoTable][row]
		if type(rowdata) == "table" then
			if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") then
				-- for docked ships in the PO the ship can be listed twice in the menu, do not keep the component due to the selection in the other line if the changed line is now unselected
				if rowdata[1] == "construction" then
					if rowdata[3].component ~= 0 then
						if ischangedselected or (rowdata[3].component ~= changedComponent) then
							table.insert(components, ConvertStringTo64Bit(tostring(rowdata[3].component)))
						end
					end
				elseif rowdata[1] == "fleetunit" then
					menu.prevselectedfleetunit = rowdata[3].fleetunit
					if rowdata[2] and (rowdata[2] ~= 0) then
						if ischangedselected or (rowdata[2] ~= changedComponent) then
							table.insert(components, ConvertStringTo64Bit(tostring(rowdata[2])))
						end
					end
				elseif ischangedselected or (C.ConvertStringTo64Bit(tostring(rowdata[2])) ~= changedComponent) then
					table.insert(components, rowdata[2])
				end
			end
		end
	end

	if modified or keepselection then
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- keep gates, satellites, etc. selected even if they don't have their own list entries
			if C.IsComponentClass(component, "gate") or C.IsComponentClass(component, "asteroid") or C.IsComponentClass(component, "buildstorage") or C.IsComponentClass(component, "highwayentrygate") or C.IsComponentClass(component, "highway") then
				table.insert(components, component)
			end

			-- kuertee start:
			-- if menu.infoTableMode == "propertyowned" then
			if string.find ("" .. tostring (menu.infoTableMode), "propertyowned") then
				-- kuertee end:

				local isplayerowned, isdeployable = GetComponentData(component, "isplayerowned", "isdeployable")
				if not isplayerowned then
					-- keep npc ships selected
					table.insert(components, component)
				elseif menu.propertyMode ~= "propertyall" then
					-- keep other property selected that is currently not displayed
					if (menu.propertyMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.propertyMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox") or C.IsComponentClass(component, "collectablewares")) then
					table.insert(components, component)
				end

				-- kuertee start:
				-- elseif menu.infoTableMode == "objectlist" then
			elseif string.find ("" .. tostring (menu.infoTableMode), "objectlist") then
				-- kuertee end:

				local isdeployable = GetComponentData(component, "isdeployable")
				if menu.objectMode ~= "objectall" then
					-- keep other property selected that is currently not displayed
					if (menu.objectMode ~= "stations") and C.IsRealComponentClass(component, "station") then
						table.insert(components, component)
					end
					if (modified ~= "ctrl") or (component ~= changedComponent) then
						if C.IsComponentClass(component, "ship") then
							table.insert(components, component)
						end
					end
				end
				if (menu.objectMode ~= "deployables") and (isdeployable or C.IsComponentClass(component, "lockbox") or C.IsComponentClass(component, "collectablewares")) then
					table.insert(components, component)
				end
			end
		end
	end

	local rowdata = menu.rowDataMap[menu.infoTable][highlightedborderrow]
	if type(rowdata) == "table" then
		menu.highlightedbordercomponent = rowdata[2]
		if rowdata[1] == "construction" then
			if rowdata[3].component ~= 0 then
				menu.highlightedbordercomponent = ConvertStringTo64Bit(tostring(rowdata[3].component))
			end
		elseif rowdata[1] == "fleetunit" then
			if rowdata[2] ~= 0 then
				menu.highlightedbordercomponent = ConvertStringTo64Bit(tostring(rowdata[2]))
			else
				menu.highlightedbordercomponent = nil
			end
		end
		local oldselectedstationcategory = menu.selectedstationcategory
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedplannedmodule = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		menu.highlightedfleetunit = nil
		menu.selectedfleetunit = nil
		if rowdata[1] == "moduletype" then
			menu.highlightedbordermoduletype = rowdata[3]
		elseif rowdata[1] == "module" then
			menu.highlightedbordermoduletype = rowdata[3]
			if rowdata[6] then
				menu.highlightedbordercomponent = rowdata[5]
				menu.highlightedplannedmodule = rowdata[6]
			end
		elseif string.find(rowdata[1], "subordinates") then
			menu.highlightedborderstationcategory = rowdata[1]
			if (keepselection and (oldselectedstationcategory == rowdata[1])) or (modified ~= "ctrl") then
				menu.selectedstationcategory = rowdata[1]
			end
			if rowdata[2] ~= 0 then
				menu.selectedfleetcommander = ConvertIDTo64Bit(rowdata[2])
			end
		elseif rowdata[1] == "dockedships" then
			menu.highlightedborderstationcategory = "dockedships"
		elseif rowdata[1] == "constructions" then
			menu.highlightedborderstationcategory = "constructions"
		elseif rowdata[1] == "construction" then
			menu.highlightedconstruction = rowdata[3]
			if (modified ~= "ctrl") then
				menu.selectedconstruction = rowdata[3]
			end
		elseif rowdata[1] == "fleetunit" then
			menu.highlightedfleetunit = rowdata[3].fleetunit
			if (modified ~= "ctrl") then
				menu.selectedfleetunit = rowdata[3].fleetunit
			end
		end
		menu.highlightedbordersection = nil
	elseif type(rowdata) == "string" then
		menu.highlightedbordercomponent = nil
		menu.highlightedbordermoduletype = nil
		menu.highlightedborderstationcategory = nil
		menu.selectedstationcategory = nil
		menu.highlightedconstruction = nil
		menu.selectedconstruction = nil
		menu.selectedfleetcommander = nil
		menu.highlightedfleetunit = nil
		menu.selectedfleetunit = nil
		menu.highlightedbordersection = rowdata
	end

	C.SetMapSelectedFleetCommander(menu.holomap, menu.selectedfleetcommander or 0)
	menu.addSelectedComponents(components, modified)
end

function menu.updateTableSelection(lastcomponent)
	menu.refreshMainFrame = true

	-- if (menu.infoTableMode == "objectlist") or (menu.infoTableMode == "propertyowned") then
	-- kuertee start:
	if (string.find ("" .. tostring (menu.infoTableMode), "objectlist")) or (string.find ("" .. tostring (menu.infoTableMode), "propertyowned")) then
		-- kuertee end:

		-- check if sections need to be extended - if so we need a refresh
		local refresh = false
		for id in pairs(menu.selectedcomponents) do
			local component = ConvertStringTo64Bit(id)
			-- build queues contain components that are not connected to the universe yet
			if IsValidComponent(component) then
				local commanderlist = C.IsComponentClass(component, "controllable") and GetAllCommanders(component) or {}
				for i, entry in ipairs(commanderlist) do
					if (not menu.isPropertyExtended(tostring(entry))) then
						menu.extendedproperty[tostring(entry)] = true
						refresh = true
					end
				end
			end
		end
		if refresh then
			menu.refreshInfoFrame()
			return
		end

		if menu.rowDataMap[menu.infoTable] then
			local rows = {}
			local curRow
			for row, rowdata in pairs(menu.rowDataMap[menu.infoTable]) do
				if type(rowdata) == "table" then
					if rowdata[1] == nil then
						print(TraceBack())
					end
					if (rowdata[1] ~= "moduletype") and (not string.find(rowdata[1], "subordinates")) and (rowdata[1] ~= "dockedships") and (rowdata[1] ~= "constructions") and (rowdata[1] ~= "construction") and (rowdata[1] ~= "fleetunit") and menu.isSelectedComponent(rowdata[2]) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and (rowdata[3].component ~= 0) and menu.isSelectedComponent(rowdata[3].component) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[3].component)) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "construction") and rowdata[2] and menu.selectedconstruction and (menu.selectedconstruction.id == rowdata[3].id) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "fleetunit") and (rowdata[2] ~= 0) and menu.isSelectedComponent(rowdata[2]) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif (rowdata[1] == "fleetunit") and menu.selectedfleetunit and (menu.selectedfleetunit == rowdata[3].fleetunit) then
						table.insert(rows, row)
						if ConvertStringTo64Bit(tostring(rowdata[2])) == lastcomponent then
							curRow = row
						end
					elseif string.find(rowdata[1], "subordinates") and (rowdata[1] == menu.selectedstationcategory) then
						table.insert(rows, row)
					end
				end
			end
			SetSelectedRows(menu.infoTable, rows, curRow or (Helper.currentTableRow[menu.infoTable] or 0))
		end
	end
	menu.setSelectedMapComponents()
end

function menu.addSelectedComponent(component, clear, noupdate)
	component = ConvertStringTo64Bit(tostring(component))
	if clear ~= false then
		menu.selectedcomponents = {}
	end

	local add = true
	local hasonlynpcs = true
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if GetComponentData(selectedcomponent, "isplayerowned") then
			hasonlynpcs = false
			break
		end
	end
	-- build queues contain components that are not connected to the universe yet
	if (not IsValidComponent(component)) or (not GetComponentData(component, "isplayerowned")) then
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- don't add
			add = false
		end
	else
		if hasonlynpcs then
			-- replace
			menu.selectedcomponents = {}
		else
			-- add -> nothing to do
		end
	end

	if add then
		menu.selectedcomponents[tostring(component)] = {}
	end
	if not noupdate then
		menu.updateTableSelection(component)
	end
end

function menu.addSelectedComponents(components, clear)
	if clear ~= false then
		menu.selectedcomponents = {}
	end
	for _, component in ipairs(components) do
		menu.addSelectedComponent(component, false, true)
	end
	menu.updateTableSelection()
end

function menu.removeSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	menu.selectedcomponents[tostring(component)] = nil
	menu.updateTableSelection()
end

function menu.toggleSelectedComponent(component)
	if menu.isSelectedComponent(component) then
		menu.removeSelectedComponent(component)
	else
		menu.addSelectedComponent(component, false)
	end
end

function menu.isSelectedComponent(component)
	component = ConvertStringTo64Bit(tostring(component))
	return menu.selectedcomponents[tostring(component)] ~= nil
end

function menu.clearSelectedComponents()
	menu.selectedcomponents = {}
	menu.updateTableSelection()
end

function menu.getNumSelectedComponents()
	local count = 0
	for _, _ in pairs(menu.selectedcomponents) do
		count = count + 1
	end
	return count
end

function menu.getShipList(includePlayerOccupiedShip, includeShipsWithOrderLoops)
	local ships = GetTradeShipList()
	local playeroccupiedship = ConvertStringToLuaID(tostring(C.GetPlayerOccupiedShipID()))
	for i = #ships, 1, -1 do
		local ship = ships[i]
		local commander = GetCommander(ship.shipid)
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ConvertIDTo64Bit(ship.shipid), hasloop)
		local isplayeroccupiedship = IsSameComponent(ship.shipid, playeroccupiedship)

		if commander and not IsSameComponent(commander, playeroccupiedship) then
			table.remove(ships, i)
		elseif GetComponentData(ship.shipid, "isdeployable") then
			table.remove(ships, i)
		elseif #GetTransportUnitMacros(GetComponentData(ship.shipid, "macro")) == 0 then
			table.remove(ships, i)
		elseif (not includePlayerOccupiedShip) and isplayeroccupiedship then
			-- remove the player occupied ship
			table.remove(ships, i)
		elseif (not includeShipsWithOrderLoops) and hasloop[0] and ((not includePlayerOccupiedShip) or (not isplayeroccupiedship)) then
			-- remove loop ship unless it is the player occupied ship and we keep the player occupied ship
			table.remove(ships, i)
		end
	end

	return ships
end

function menu.updateTradeContextDimensions(numwarerows, numinforows)
	local warescrollwindowsize = 10
	local numwarningrows = 2

	local textheight = math.ceil(C.GetTextHeight("", Helper.standardFont, math.floor(Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)), 0))
	local rowHeight = math.max(Helper.slidercellMinHeight, textheight)

	menu.tradeContext = {
		width = config.tradeContextMenuWidth,			-- ca 800 px in 1920x1080
		warescrollwindowsize = warescrollwindowsize,
		numwarerows = numwarerows,
		shipheight = Helper.scaleY(Helper.headerRow1Height) + Helper.borderSize + 1 + (math.min(warescrollwindowsize, numwarerows) + 1) * (Helper.borderSize + rowHeight),
		numinforows = numinforows,
		numwarningrows = numwarningrows,
		buttonheight = 1 + (numinforows + numwarningrows + 2) * (Helper.borderSize + rowHeight),
	}
end

function menu.getFilterTradeWaresOptions()
	local result = {}
	for name, ware in pairs(menu.economyWares) do
		table.insert(result, ware)
	end
	return result
end

function menu.getFilterTradeVolumeOptions()
	local params = C.GetMapTradeVolumeParameter()
	local icon = "\27[" .. ffi.string(params.icon) .."]"
	local color = { r = params.color.red, g = params.color.green, b = params.color.blue, a = params.color.alpha }

	local result = {
		{ id = 0,				text = ReadText(1001, 8359), text2 = "",														icon = "", displayremoveoption = false }, -- None
		{ id = params.volume_s,	text = ReadText(1001, 2853), text2 = Helper.convertColorToText(color) .. icon,					icon = "", displayremoveoption = false }, -- Small
		{ id = params.volume_m,	text = ReadText(1001, 2854), text2 = Helper.convertColorToText(color) .. icon .. icon,			icon = "", displayremoveoption = false }, -- Medium
		{ id = params.volume_l,	text = ReadText(1001, 2855), text2 = Helper.convertColorToText(color) .. icon .. icon .. icon,	icon = "", displayremoveoption = false }, -- Large
	}
	return result
end

function menu.getFilterTradePlayerOfferOptions(buysellswitch)
	local result = {
		{ id = 0,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11206),	icon = "", displayremoveoption = false }, -- All
		{ id = 1,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11207),	icon = "", displayremoveoption = false }, -- Player only
		{ id = 2,	text = (buysellswitch and ReadText(1001, 8309) or ReadText(1001, 8308)) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11208),	icon = "", displayremoveoption = false }, -- Non-Player only
	}
	return result
end

function menu.getFilterThinkAlertOptions()
	local result = {
		{ id = 0, text = ReadText(1001, 4054), icon = "", displayremoveoption = false }, -- none
		{ id = 3, text = ReadText(1001, 4053), icon = "", displayremoveoption = false }, -- high
		{ id = 2, text = ReadText(1001, 4052), icon = "", displayremoveoption = false }, -- medium
		{ id = 1, text = ReadText(1001, 4051), icon = "", displayremoveoption = false }, -- low
	}
	return result
end

function menu.getFilterOption(id, savegame)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if savegame then

		-- kuertee start: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui
		if not __CORE_DETAILMONITOR_MAPFILTER_SAVE then
			__CORE_DETAILMONITOR_MAPFILTER_SAVE = {}
		end
		-- kuertee end: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui

		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	return settings[id]
end

function menu.setFilterOption(mode, setting, id, value, index)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if setting.savegame then
		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	if setting.type == "multiselectlist" then
		settings[id] = settings[id] or {}
		if value then
			if index then
				settings[id][index] = value
			else
				if type(value) == "table" then
					local sorted = {}
					for ware in pairs(value) do
						table.insert(sorted, ware)
					end
					table.sort(sorted, Helper.sortWareName)
					settings[id] = {}
					for _, ware in ipairs(sorted) do
						table.insert(settings[id], ware)
					end
					menu.closeContextMenu()
				else
					table.insert(settings[id], value)
				end
			end
		else
			if menu.contextMenuMode == "filter_multiselectlist" then
				menu.setFilterOption(menu.displayedFilterLayer, menu.contextMenuData.setting, menu.contextMenuData.setting.id, menu.contextMenuData.selectedWares)
			else
				menu.contextMenuMode = "filter_multiselectlist"
				menu.contextMenuData = { setting = setting, id = id, value = value }
				menu.createContextFrame(280, Helper.viewHeight - 100, Helper.viewWidth - menu.infoTableOffsetX - menu.infoTableWidth - config.contextBorder - 280, 100)
			end
		end
	elseif setting.type == "checkbox" then
		settings[id] = not settings[id]
	elseif setting.type == "slidercell" then
		settings[id] = value
	elseif setting.type == "dropdown" then
		settings[id] = tonumber(value)
	end

	if not settings[mode] then
		settings[mode] = true
		menu.applyFilterSettings()
	else
		setting.callback(setting)
	end
end

function menu.removeFilterOption(setting, id, index)
	local settings = __CORE_DETAILMONITOR_MAPFILTER
	if setting.savegame then
		settings = __CORE_DETAILMONITOR_MAPFILTER_SAVE
	end

	if setting.type == "multiselectlist" then
		settings[id] = settings[id] or {}
		table.remove(settings[id], index)
		setting.callback(setting)
	end
end

function menu.upgradeMapFilterVersion()
	local oldversion = __CORE_DETAILMONITOR_MAPFILTER.version

	if oldversion < 3 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_ecliptic"] = true
	end
	if oldversion < 5 then
		__CORE_DETAILMONITOR_MAPFILTER["layer_think"] = true
	end
	if oldversion < 6 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_storage_container"] = true
	end
	if oldversion < 7 then
		__CORE_DETAILMONITOR_MAPFILTER["think_alert"] = 3
	end
	if oldversion < 8 then
		__CORE_DETAILMONITOR_MAPFILTER["mining_resource_display"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_civilian"] = true
	end
	if oldversion < 9 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_offer_number"] = 3
	end
	if oldversion < 10 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_volume"] = 0
	end
	if oldversion < 11 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_allyorderqueue"] = true
	end
	if oldversion < 12 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_wrecks"] = true
	end
	if oldversion < 13 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_factioncolor"] = false
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_buy"] = 0
		__CORE_DETAILMONITOR_MAPFILTER["trade_playeroffer_sell"] = 0
	end
	if oldversion < 14 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_selection_lines"] = true
	end
	if oldversion < 15 then
		__CORE_DETAILMONITOR_MAPFILTER["think_diplomacy_highlightvisitor"] = true
	end
	if oldversion < 16 then
		__CORE_DETAILMONITOR_MAPFILTER["trade_relation_enemy"] = true
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_opacity"] = false
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_gate_connections"] = true
	end
	if oldversion < 17 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 5000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 10000
		end
	end
	if oldversion < 18 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_coveroverride"] = false
	end
	if oldversion < 19 then
		if __CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] == 10000 then
			__CORE_DETAILMONITOR_MAPFILTER["trade_price_maxprice"] = 0
		end
	end
	if oldversion < 20 then
		__CORE_DETAILMONITOR_MAPFILTER["other_misc_rendersatelliteradarrange"] = true
	end

	__CORE_DETAILMONITOR_MAPFILTER.version = config.mapfilterversion
end

function menu.upgradeMapFilterSaveVersion()
	-- kuertee start: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui
	if not __CORE_DETAILMONITOR_MAPFILTER_SAVE then
		__CORE_DETAILMONITOR_MAPFILTER_SAVE = {}
	end
	-- kuertee end: __CORE_DETAILMONITOR_MAPFILTER_SAVE is reset on /reloadui

	local oldversion = __CORE_DETAILMONITOR_MAPFILTER_SAVE.version

	if oldversion < 1 then
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_wares"]				= Helper.tableCopy(__CORE_DETAILMONITOR_MAPFILTER["trade_wares"])
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_container"]	= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_container"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_solid"]		= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_solid"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_liquid"]		= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_liquid"]
		__CORE_DETAILMONITOR_MAPFILTER_SAVE["trade_storage_condensate"]	= __CORE_DETAILMONITOR_MAPFILTER["trade_storage_condensate"]
	end

	__CORE_DETAILMONITOR_MAPFILTER_SAVE.version = config.mapfiltersaveversion
end

function menu.applyFilterSettings()
	for mode, settings in pairs(config.layersettings) do
		local active = menu.getFilterOption(mode, false) or false
		if settings.callback then
			settings.callback(active)
		end
		if active then
			for _, setting in ipairs(settings) do
				setting.callback(setting)
			end
		end
	end

	menu.setSectorFilter()
end

function menu.setMouseCursorOverride(cursor, priority)
	menu.mouseCursorOverrides[priority] = cursor
	menu.setMouseCursor()
end

function menu.removeMouseCursorOverride(priority)
	menu.mouseCursorOverrides[priority] = nil
	menu.setMouseCursor()
end

function menu.clearMouseCursorOverrides()
	menu.mouseCursorOverrides = { [1] = "default" }
	menu.setMouseCursor()
end

function menu.setMouseCursor()
	local highestPriority = table.maxn(menu.mouseCursorOverrides)
	if menu.mouseCursorOverrides[highestPriority] ~= menu.currentMouseCursor then
		menu.currentMouseCursor = menu.mouseCursorOverrides[highestPriority]
		SetMouseCursorOverride(menu.currentMouseCursor)
	end
end

function menu.updateMouseCursor()
	local occupiedship = C.GetPlayerOccupiedShipID()

	local hasplayerselectedship = false
	for id, _ in pairs(menu.selectedcomponents) do
		local selectedcomponent = ConvertStringTo64Bit(id)
		if IsValidComponent(selectedcomponent) then
			if C.IsComponentClass(selectedcomponent, "ship") and GetComponentData(selectedcomponent, "isplayerowned") then
				if selectedcomponent ~= occupiedship then
					hasplayerselectedship = true
				end
			end
		else
			menu.removeSelectedComponent(selectedcomponent)
		end
	end

	local cursor
	if menu.showMultiverse then
		local pickedplayer = C.GetPickedMultiverseMapPlayer(menu.holomap)
		if pickedplayer.id ~= 0 then
			cursor = "cursor"
		elseif menu.picking then
			cursor = "crossarrows"
		end
	elseif menu.plotData and menu.plotData.active then
		-- plot mode
		local offset = ffi.new("UIPosRot")
		local offsetsector = C.GetBuildMapStationLocation2(menu.holomap, offset)
		if offsetsector ~= 0 then
			cursor = "cursorplus"
		else
			cursor = "unavailable"
		end
	else
		local shiftpressed = C.IsShiftPressed()
		local controlpressed = C.IsControlPressed()
		local pickedcomponent = C.GetPickedMapComponent(menu.holomap)
		local pickedcomponentclass = ffi.string(C.GetComponentClass(pickedcomponent))
		local pickedorder = ffi.new("Order")
		local buf = ffi.new("bool[1]", 0)
		local pickedordercomponent = C.GetPickedMapOrder(menu.holomap, pickedorder, buf)
		local isintermediate = buf[0]
		local pickedtradeoffer = C.GetPickedMapTradeOffer(menu.holomap)
		local pickedmission = C.GetPickedMapMission(menu.holomap)
		local pickedsyncpoint = C.GetPickedMapSyncPoint(menu.holomap)
		local pickedsyncpointorder = ffi.new("Order")
		local pickedsyncpointordercomponent = C.GetPickedMapSyncPointOwningOrder(menu.holomap, pickedsyncpointorder)

		if pickedordercomponent ~= 0 then
			if GetComponentData(ConvertStringTo64Bit(tostring(pickedordercomponent)), "isplayerowned") then
				-- orders
				if pickedordercomponent ~= occupiedship then
					if isintermediate then
						cursor = "cursorplus"
					else
						cursor = "cursormove"
					end
				else
					cursor = "cursor"
				end
			end
		elseif pickedmission ~= 0 then
			-- guidance
			cursor = "cursor"
		elseif pickedsyncpoint ~= 0 then
			-- sync point
			cursor = "cursor"
		elseif pickedsyncpointordercomponent ~= 0 then
			-- order sync point
			cursor = "cursor"
		elseif pickedtradeoffer ~= 0 then
			-- trade offers
			cursor = "trade"
		elseif pickedcomponent ~= 0 then
			if menu.picking then
				if shiftpressed then
					-- changing selection
					if (pickedcomponentclass ~= "player") and (pickedcomponentclass ~= "ship_xs") and (pickedcomponentclass ~= "highwayentrygate") and (pickedcomponentclass ~= "collectablewares") and (pickedcomponentclass ~= "gate") and (pickedcomponentclass ~= "asteroid") and (pickedcomponentclass ~= "sector") then
						if C.IsComponentOperational(pickedcomponent) and GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isplayerowned") then
							cursor = "cursorplus"
						end
					end
				elseif controlpressed then
					-- default interactions
					if C.IsComponentClass(pickedcomponent, "sector") then
						if hasplayerselectedship then
							cursor = "movehere"
						end
					elseif GetComponentData(ConvertStringTo64Bit(tostring(pickedcomponent)), "isenemy") then
						if hasplayerselectedship then
							cursor = "targetred"
						end
					elseif C.IsComponentClass(pickedcomponent, "station") then
						local issingleloopship
						if menu.getNumSelectedComponents() == 1 then
							local component = next(menu.selectedcomponents)
							local selectedcomponent = ConvertStringTo64Bit(component)
							local hasloop = ffi.new("bool[1]", 0)
							C.GetOrderQueueFirstLoopIdx(selectedcomponent, hasloop)
							issingleloopship = hasloop[0]
						end

						if not issingleloopship then
							cursor = "trade"
						end
					end
				elseif pickedcomponentclass ~= "player" then
					local playerships = menu.getSelectedComponentCategories()
					for i = #playerships, 1, -1 do
						local ship = playerships[i]
						if ship == pickedcomponent then
							table.remove(playerships, i)
						end
					end
					if #playerships > 0 then
						if C.IsComponentClass(pickedcomponent, "sector") then
							cursor = "crossarrowsorder"
						else
							cursor = "cursororder"
						end
					end
				end
			end
		end
		-- map pan & rot
		if menu.picking then
			if not cursor then
				if (pickedcomponent == 0) or (not C.IsComponentClass(pickedcomponent, "object")) then
					if shiftpressed then
						cursor = "boxselect"
					else
						cursor = "crossarrows"
					end
				end
			end
		end
	end
	if cursor then
		menu.setMouseCursorOverride(cursor, 2)
	else
		menu.removeMouseCursorOverride(2)
	end
end

function menu.getDropDownTurretModeOption(defensibleorturret, context, path, group)
	if (context == nil) and (path == nil) and (group == nil) then
		return ffi.string(C.GetWeaponMode(defensibleorturret))
	elseif context == "all" then
		local allmode
		for i, turret in ipairs(menu.turrets) do
			if (path == nil) or (path == C.IsComponentClass(turret, "missileturret")) then
				local mode = ffi.string(C.GetWeaponMode(turret))
				if allmode == nil then
					allmode = mode
				elseif allmode ~= mode then
					allmode = ""
					break
				end
			end
		end
		for i, group in ipairs(menu.turretgroups) do
			if group.operational > 0 then
				if (path == nil) or (path == IsMacroClass(group.currentmacro, "missileturret")) then
					local mode = ffi.string(C.GetTurretGroupMode2(defensibleorturret, group.context, group.path, group.group))
					if allmode == nil then
						allmode = mode
					elseif allmode ~= mode then
						allmode = ""
						break
					end
				end
			end
		end
		return allmode or ""
	end
	return ffi.string(C.GetTurretGroupMode2(defensibleorturret, context, path, group))
end

function menu.areTurretsArmed(defensibleorturret, ismissile)
	local alldisarmed = true
	for i, turret in ipairs(menu.turrets) do
		if (ismissile == nil) or (ismissile == C.IsComponentClass(turret, "missileturret")) then
			if C.IsWeaponArmed(turret) then
				alldisarmed = false
				break
			end
		end
	end
	for i, group in ipairs(menu.turretgroups) do
		if group.operational > 0 then
			if (ismissile == nil) or (ismissile == IsMacroClass(group.currentmacro, "missileturret")) then
				if C.IsTurretGroupArmed(defensibleorturret, group.context, group.path, group.group) then
					alldisarmed = false
					break
				end
			end
		end
	end
	return not alldisarmed
end

function menu.updateSubordinateGroupInfo(controllable)
	local curtime = getElapsedTime()
	if (not menu.lastSubordinateGroupUpdate) or (curtime > menu.lastSubordinateGroupUpdate) then
		menu.lastSubordinateGroupUpdate = curtime
		local subordinates = GetSubordinates(controllable)
		menu.subordinategroups = {}
		for _, subordinate in ipairs(subordinates) do
			local subordinate64 = ConvertIDTo64Bit(subordinate)
			local group = GetComponentData(subordinate, "subordinategroup")
			if group and group > 0 then
				if menu.subordinategroups[group] then
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					if isdocked then
						menu.subordinategroups[group].numdockedatcommander = menu.subordinategroups[group].numdockedatcommander + 1
					end
					table.insert(menu.subordinategroups[group].subordinates, subordinate)
				else
					local isdocked = C.GetContextByClass(subordinate64, "container", true) == controllable
					menu.subordinategroups[group] = { assignment = ffi.string(C.GetSubordinateGroupAssignment(controllable, group)), subordinates = { subordinate }, numdockedatcommander = isdocked and 1 or 0 }
				end
			end
		end
	end
end

function menu.buttonActiveSubordinateGroupLaunch(inputobject, i)
	menu.updateSubordinateGroupInfo(inputobject)
	if menu.subordinategroups[i] then
		return (menu.subordinategroups[i].assignment ~= "trade") and (menu.subordinategroups[i].assignment ~= "mining") and (menu.subordinategroups[i].assignment ~= "follow") and (menu.subordinategroups[i].assignment ~= "assist") and (menu.subordinategroups[i].assignment ~= "supplyfleet")
	end
	return false
end

function menu.etaSorter(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

-- sums up all ware reservation amounts and returns the total (single integer)
function menu.getReservationsAmountTotal(contextcomponent)
	local total = 0
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if buyflag == "buyoffer" then
				total = total + reservations[i].amount
			else
				total = total - reservations[i].amount
			end
		end
	end

	return total
end

-- sums up all ware reservation amounts sorted by transport type and returns the result as a list
function menu.getReservationsVolumeByTransportType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local storagetype, volume = GetWareData(ffi.string(reservations[i].ware), "transport", "volume")
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[storagetype] then
				amounts[storagetype] = 0
			end

			if buyflag == "buyoffer" then
				amounts[storagetype] = amounts[storagetype] + reservations[i].amount * volume
			else
				amounts[storagetype] = amounts[storagetype] - reservations[i].amount * volume
			end
		end
	end

	return amounts
end

-- sums up all ware reservation amounts sorted by ware type and returns the result as a list
function menu.getReservationsAmountByWareType(contextcomponent)
	local amounts = {}
	local n = C.GetNumContainerWareReservations2(contextcomponent, false, false, true)
	local reservations = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(reservations, n, contextcomponent, false, false, true)
	for i = 0, n - 1 do
		local ware = ffi.string(reservations[i].ware)
		local buyflag = reservations[i].isbuyreservation and "selloffer" or "buyoffer"
		if not Helper.dirtyreservations[tostring(reservations[i].tradedealid)] then
			if not amounts[ware] then
				amounts[ware] = 0
			end

			if buyflag == "buyoffer" then
				amounts[ware] = amounts[ware] + reservations[i].amount
			else
				amounts[ware] = amounts[ware] - reservations[i].amount
			end
		end
	end

	return amounts
end

-- Returns the color and function needed to initiate a ware button for the ObjectInfoTab and the SelectedObjectInfo
-- NOTE: this function is designed to run in a loop, therefore filteroptionlist and setting is not part of the function
--
-- filteroptionlist needs to be the return of menu.getFilterOption
-- setting needs to be the return of config.layersettings["layer_trade"][1]
-- contextware is the ware to do all the checks against
--
-- returns color white if the contextware can be found in filteroptionlist or if filteroptionlist is empty, returns grey otherwise
-- returns function to remove the ware from the tradefilter if the contextware can be found in filteroptionlist, returns function to add the ware otherwise
function menu.getWareButtonColorAndScript(filteroptionlist, setting, contextware)
	local index
	for i, entry in ipairs(filteroptionlist) do
		if (entry == contextware) then
			index = i
			break
		end
	end

	local color = Color["text_normal"]
	local script

	if menu.getFilterOption("layer_trade", false) then
		if (menu.mode ~= "behaviourinspection") and (#filteroptionlist ~= 0) and (not index) then
			color = Color["text_inactive"]
		end
		if index then
			script = function () menu.removeFilterOption(setting, setting.id, index) end
		else
			script = function () menu.setFilterOption("layer_trade", setting, setting.id, contextware) end
		end
	end

	return color, script
end

-- Takes in storage level, capacity and reservation amount and returns a formatted string like "4,928 k (+5,184) / 5,000 k m3"
-- NOTE: maxcapacity is optional in which case the return is like: "1,295 k (+425)"
function menu.formatWareAmount(currentamount, futureamount, maxcapacity)
	local formattedstring = ConvertIntegerString(math.max(0, futureamount), true, 2, true) .. ((futureamount ~= currentamount) and (" (" .. string.format("%s%s", ((futureamount - currentamount) > 0) and "+" or "", ConvertIntegerString(math.max(-currentamount, futureamount - currentamount), true, 2, true)) .. ")") or "")
	if maxcapacity ~= nil then
		formattedstring = formattedstring  .. " / " .. ConvertIntegerString(maxcapacity, true, 2, true) .. " " .. ReadText(1001, 110)
	end
	return formattedstring
end

function menu.getAmountTextWidth(amounttext)
	return math.ceil(C.GetTextWidth(amounttext, Helper.standardFont, menu.selectedShipsTableData.fontsize)) + 2 * Helper.standardTextOffsetx
end

-- Adds a row into a table that shows the name of a transporttype and its fillinglevel expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	textcolumn: the column the text should exist in
--	textcolspan: the column span of the text
--	currentamount: storage's current filling level
--	futureamount: storage's filling level after all reserved ware exchanges have happened
--	maxcapacity: storage's maximum capacity
--	transporttypename: the displayed text
function menu.addCapacityRow(data)
	row = data.inputtable:addRow(true, { interactive = false })
	row[data.textcolumn]:setColSpan(data.textcolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount, data.maxcapacity)
	local text = ReadText(1001, 1402) .. " (" .. data.transporttypename .. ")" .. ReadText(1001, 120)
	local truncatedtext = TruncateText(text, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.textcolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= text then
		mouseovertext = text .. " " .. amounttext
	end

	local textxoffset = 1 + Helper.borderSize
	local barxoffset = textxoffset + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.textcolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
	row[data.textcolumn]:createIcon("solid", { color = Color["icon_transparent"], height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext, scaling = false })
	row[data.textcolumn]:setText(truncatedtext, { x = textxoffset, scaling = true })
	row[data.textcolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx, scaling = true })
end

-- Adds a row into a table that shows a button labled with the ware's name and its amount expressed with a bar and in numbers
-- Function takes in a table with the following attributes
--	inputtable: the table to add the row to
--	barcolumn: the column the bar should exist in
--	buttoncolumn: the column the button should exist in
--	buttoncolspan: the column span of the button
--	currentamount: ware's current amount
--	futureamount: ware's amount after all reserved exchanges have happened
--	maxcapacity: ware's maximum capacity
--	warename: name of the ware
--	textcolor: the color to display the text in
--	buttonscript: the function to execute when clicking the button
function menu.addWareInfoButtonRow(data)
	row = data.inputtable:addRow(true)
	row[data.buttoncolumn]:setColSpan(data.buttoncolspan)

	local mouseovertext
	local amounttext = menu.formatWareAmount(data.currentamount, data.futureamount)
	local truncatedtext = TruncateText(data.warename, Helper.standardFont, menu.selectedShipsTableData.fontsize, row[data.buttoncolumn]:getWidth() - menu.getAmountTextWidth(amounttext))
	if truncatedtext ~= data.warename then
		mouseovertext = data.warename .. " " .. amounttext
	end

	local barxoffset = 1 + Helper.borderSize + row[data.barcolumn]:getColSpanWidth()
	local width = row[data.buttoncolumn]:getColSpanWidth()
	row[data.barcolumn]:createStatusBar({ current = data.futureamount, start = data.currentamount, max = data.maxcapacity, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["flowchart_slider_diff2"], negChangeColor = Color["flowchart_slider_diff1"], markerColor = Color["statusbar_marker_hidden"], width = width, x = barxoffset, scaling = false })
	row[data.buttoncolumn]:createButton({ highlightColor = (menu.mode == "behaviourinspection") and Color["button_highlight_hidden"] or nil, height = menu.selectedShipsTableData.textHeight, mouseOverText = mouseovertext, scaling = false })
	row[data.buttoncolumn]:setText(truncatedtext, { color = data.textcolor, x = Helper.standardIndentStep, scaling = true })
	row[data.buttoncolumn]:setText2(amounttext, { halign = "right", x = Helper.standardTextOffsetx, color = data.textcolor, scaling = true })
	if menu.mode ~= "behaviourinspection" then
		row[data.buttoncolumn].handlers.onClick = data.buttonscript
	end
end

function menu.setInfoSubmenuObjectAndRefresh(component)
	menu.infoSubmenuObject = component
	if menu.infoTableMode == "info" then
		menu.refreshInfoFrame(nil, 0)
	elseif menu.searchTableMode == "info" then
		menu.refreshInfoFrame2(nil, 0)
	end
end

-- kuertee start:
function menu.setSelectComponentMode (returnsection, classlist, category, playerowned, customheading, screenname)
	menu.old_mode = menu.mode
	menu.old_modeparam = menu.modeparam
	menu.old_infoTableMode = menu.infoTableMode

	menu.mode = "selectComponent"
	menu.modeparam = {
		returnsection,
		classlist,
		category,
		playerowned,
		customheading,
		screenname
	}
	menu.infoTableMode = "propertyowned"
	menu.closeContextMenu()
	menu.refreshMainFrame = true
	menu.refreshInfoFrame()
end

function menu.sortDistanceFromPlayer (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (C.GetPlayerID ())))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end

function menu.sortDistanceFromObject (a, b, invert)
	local distance_a = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (a.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	local distance_b = C.GetDistanceBetween (ConvertStringTo64Bit (tostring (b.id)), ConvertStringTo64Bit (tostring (menu.infoSubmenuObject)))
	if invert then
		return distance_a > distance_b
	else
		return distance_a < distance_b
	end
end

function menu.sortDanger (a, b, invert)
	-- danger = menu.object.dps * purpose.fighter * 100
	-- uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	-- local activedpstable = ffi.new("DPSData[?]", 6)
	-- local numtotalquadrants = C.GetDefensibleDPS(activedpstable, ship, true, true, true, false, false, false, false)
	-- hasactiveguns = activedpstable[0].dps > 0
	-- local inactivedpstable = ffi.new("DPSData[?]", 6)
	-- local numtotalquadrants = C.GetDefensibleDPS(inactivedpstable, ship, true, true, true, false, false, false, true)
	-- hasinactiveguns = inactivedpstable[0].dps > 0
	local purpose_a = GetComponentData(a, "primarypurpose")
	local dpsTable_a = ffi.new("DPSData[?]", 6)
	C.GetDefensibleDPS(dpsTable_a, a, true, true, true, false, true, false, false)
	local danger_a = dpsTable_a[0].dps + dpsTable_a[1].dps + dpsTable_a[2].dps + dpsTable_a[3].dps + dpsTable_a[4].dps + dpsTable_a[5].dps
	if purpose_a == "fighter" then
		danger_a = danger_a * 100
	end
	local purpose_b = GetComponentData(b, "primarypurpose")
	local dpsTable_b = ffi.new("DPSData[?]", 6)
	C.GetDefensibleDPS(dpsTable_b, b, true, true, true, false, true, false, false)
	local danger_b = dpsTable_b[0].dps + dpsTable_b[1].dps + dpsTable_b[2].dps + dpsTable_b[3].dps + dpsTable_b[4].dps + dpsTable_b[5].dps
	if purpose_b == "fighter" then
		danger_b = danger_b * 100
	end
	if danger_a == danger_b then
		return menu.sortCombinedSkill(a, b, invert)
	elseif invert then
		return danger_a > danger_b
	else
		return danger_a < danger_b
	end
end

function menu.sortCombinedSkill(a, b, invert)
	local name_a = GetComponentData(a, "name")
	local name_b = GetComponentData(b, "name")
	local idCode_a = ffi.string(C.GetObjectIDCode(a))
	local idCode_b = ffi.string(C.GetObjectIDCode(b))
	local skill_a, skill_b = 0, 0
	local isLaserTower_a = GetMacroData(GetComponentData(a, "macro"), "islasertower")
	if C.IsRealComponentClass(a, "ship") and (not isLaserTower_a) then
		skill_a = math.floor(C.GetShipCombinedSkill(a) * 15 / 100)
	end
	local isLaserTower_b = GetMacroData(GetComponentData(b, "macro"), "islasertower")
	if C.IsRealComponentClass(b, "ship") and (not isLaserTower_b) then
		skill_b = math.floor(C.GetShipCombinedSkill(b) * 15 / 100)
	end
	if invert then
		if skill_a == skill_b then
			-- name and idcode sorts are always ascending
			if name_a == name_b then
				return idCode_a < idCode_b
			else
				return name_a < name_b
			end
		else
			return skill_a > skill_b
		end
	else
		if skill_a == skill_b then
			-- name and idcode sorts are always ascending
			if name_a == name_b then
				return idCode_a < idCode_b
			else
				return name_a < name_b
			end
		else
			return skill_a < skill_b
		end
	end
end

menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿
-- param == { 0, 0, mode, modeparam }
-- modes: - "globalorders",		param: { "traderule|blacklist|fightrule", id }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef int32_t BlacklistID;
	typedef int32_t FightRuleID;
	typedef uint64_t MessageID;
	typedef uint64_t TickerCacheID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;
	typedef struct {
		const char* factionid;
		const char* civiliansetting;
		const char* militarysetting;
	} UIFightRuleSetting;

	typedef struct {
		uint32_t id;
		const char* type;
		const char* name;
		bool usemacrowhitelist;
		uint32_t nummacros;
		const char** macros;
		bool usefactionwhitelist;
		uint32_t numfactions;
		const char** factions;
		const char* relation;
		bool hazardous;
	} BlacklistInfo2;
	typedef struct {
		FightRuleID id;
		const char* name;
		uint32_t numfactions;
		UIFightRuleSetting* factions;
	} FightRuleInfo;
	typedef struct {
		MessageID id;
		double time;
		const char* category;
		const char* title;
		const char* text;
		const char* source;
		UniverseID sourcecomponent;
		const char* interaction;
		UniverseID interactioncomponent;
		const char* interactiontext;
		const char* interactionshorttext;
		const char* cutscenekey;
		const char* entityname;
		const char* factionname;
		int64_t money;
		int64_t bonus;
		bool highlighted;
		bool isread;
	} MessageInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		uint32_t numspaces;
	} PlayerAlertCounts;
	typedef struct {
		size_t index;
		double interval;
		bool repeats;
		bool muted;
		uint32_t numspaces;
		UniverseID* spaceids;
		const char* objectclass;
		const char* objectpurpose;
		const char* objectidcode;
		const char* objectowner;
		const char* name;
		const char* message;
		const char* soundid;
	} PlayerAlertInfo2;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
	} Skill2;
	typedef struct {
		const char* id;
		const char* name;
	} SoundInfo;
	typedef struct {
		TickerCacheID id;
		double time;
		const char* category;
		const char* title;
		const char* text;
	} TickerCacheEntry;
	typedef struct {
		uint32_t numfactions;
	} TradeRuleCounts;
	typedef struct {
		uint32_t id;
		const char* name;
		uint32_t numfactions;
		const char** factions;
		bool iswhitelist;
	} TradeRuleInfo;
	typedef struct {
		const char* ID;
		const char* Name;
		const char* RawName;
	} UIClothingTheme;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
	} UIEquipmentMod;
	typedef struct {
		const char* file;
		const char* icon;
		bool ispersonal;
	} UILogo;
	typedef struct {
		const char* macro;
		uint32_t amount;
	} UIMacroCount;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		const char* category;
		bool enabled;
		bool enabledByDefault;
	} UINotificationType2;
	typedef struct {
		const char* ID;
		const char* Name;
		const char* RawName;
		const char* Icon;
	} UIPaintTheme;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;
	void AddPlayerAlert2(PlayerAlertInfo2 alert);
	bool AreVenturesCompatible(void);
	BlacklistID CreateBlacklist2(BlacklistInfo2 info);
	FightRuleID CreateFightRule(FightRuleInfo info);
	UniverseID CreateNPCFromPerson(NPCSeed person, UniverseID controllableid);
	TradeRuleID CreateTradeRule(TradeRuleInfo info);
	bool DropInventory(UniverseID entityid, const char* lockboxid, UIWareAmount* wares, uint32_t numwares);
	const char* GenerateFactionRelationText(const char* factionid);
	uint32_t GetAllFactionShips(UniverseID* result, uint32_t resultlen, const char* factionid);
	uint32_t GetAllFactionStations(UniverseID* result, uint32_t resultlen, const char* factionid);
	uint32_t GetAllTradeRules(TradeRuleID* result, uint32_t resultlen);
	uint32_t GetAvailableClothingThemes(UIClothingTheme* result, uint32_t resultlen);
	uint32_t GetAvailableEquipmentMods(UIEquipmentMod* result, uint32_t resultlen);
	uint32_t GetAvailableLockboxes(const char** result, uint32_t resultlen, UniverseID entityid);
	uint32_t GetAvailablePaintThemes(UIPaintTheme* result, uint32_t resultlen);
	float GetAveragePlayerNPCSkill(void);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	double GetCurrentGameTime(void);
	UILogo GetCurrentPlayerLogo(void);
	const char* GetDefaultResponseToSignalForFaction2(const char* signalid, const char* factionid, const char* purposeid);
	const char* GetDefaultPlayerBuildMethod(void);
	int32_t GetEntityCombinedSkill(UniverseID entityid, const char* role, const char* postid);
	uint32_t GetEntitySkillsForAssignment(Skill2* result, UniverseID entityid, const char* role, const char* postid);
	const char* GetFactionDefaultWeaponMode(const char* factionid);
	UniverseID GetLastPlayerControlledShipID(void);
	UIPosRot GetMessageInteractPosition(MessageID messageid);
	uint32_t GetMessages(MessageInfo* result, uint32_t resultlen, size_t start, size_t count, const char* categoryname);
	uint32_t GetNotificationTypes2(UINotificationType2* result, uint32_t resultlen);
	uint32_t GetNumAllFactionShips(const char* factionid);
	uint32_t GetNumAllFactionStations(const char* factionid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllTradeRules(void);
	uint32_t GetNumAvailableClothingThemes();
	uint32_t GetNumAvailableEquipmentMods();
	uint32_t GetNumAvailableLockboxes(UniverseID entityid);
	uint32_t GetNumAvailablePaintThemes();
	uint32_t GetNumMessages(const char* categoryname, bool );
	uint32_t GetNumNotificationTypes(void);
	uint32_t GetNumPlayerAlerts(void);
	uint32_t GetNumPlayerAlertSounds2(const char* tags);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumPlayerLogos(bool includestandard, bool includecustom);
	uint32_t GetNumSkills(void);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumTickerCache(const char* categoryname);
	uint32_t GetNumTransactionLog(UniverseID componentid, double starttime, double endtime);
	int32_t GetPersonCombinedSkill(UniverseID controllableid, NPCSeed person, const char* role, const char* postid);
	const char* GetPersonName(NPCSeed person, UniverseID controllableid);
	const char* GetPersonRoleName(NPCSeed person, UniverseID controllableid);
	uint32_t GetPersonSkillsForAssignment(Skill2* result, NPCSeed person, UniverseID controllableid, const char* role, const char* postid);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPlayerAlertCounts(PlayerAlertCounts* result, uint32_t resultlen);
	uint32_t GetPlayerAlerts2(PlayerAlertInfo2* result, uint32_t resultlen);
	uint32_t GetPlayerAlertSounds2(SoundInfo* result, uint32_t resultlen, const char* tags);
	const char* GetPlayerBuildMethod(void);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	const char* GetPlayerClothingTheme(void);
	const char* GetPlayerFactionName(bool userawname);
	float GetPlayerGlobalLoadoutLevel(void);
	UniverseID GetPlayerID(void);
	uint32_t GetPlayerLogos(UILogo* result, uint32_t resultlen, bool includestandard, bool includecustom);
	const char* GetPlayerPaintTheme(void);
	const char* GetPlayerName(void);
	UniverseID GetPlayerOccupiedShipID(void);
	bool GetPlayerGlobalTradeLoopCargoReservationSetting(void);
	UniverseID GetPlayerZoneID(void);
	const char* GetPurposeName(const char* purposeid);
	int32_t GetRelationRangeUIMaxValue(const char* relationrangeid);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	int64_t GetSupplyBudget(UniverseID containerid);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	float GetTextHeight(const char*const text, const char*const fontname, const float fontsize, const float wordwrapwidth);
	uint32_t GetTickerCache(TickerCacheEntry* result, uint32_t resultlen, size_t start, size_t count, const char* categoryname);
	bool GetTradeRuleInfo(TradeRuleInfo* info, TradeRuleID id);
	TradeRuleCounts GetTradeRuleInfoCounts(TradeRuleID id);
	int64_t GetTradeWareBudget(UniverseID containerid);
	bool HasPersonArrived(UniverseID controllableid, NPCSeed person);
	bool HasDefaultResponseToSignalForFaction(const char* signalid, const char* factionid, const char* purposeid);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsComponentOperational(UniverseID componentid);
	bool IsMouseEmulationActive(void);
	bool IsPersonTransferScheduled(UniverseID controllableid, NPCSeed person);
	bool IsPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsUnit(UniverseID controllableid);
	void MutePlayerAlert(size_t index);
	void ReadAllInventoryWares(void);
	void ReadInventoryWare(const char* wareid);
	void ReleasePersonFromCrewTransfer(UniverseID controllableid, NPCSeed person);
	void RemoveBlacklist(BlacklistID id);
	void RemoveFightRule(FightRuleID id);
	void RemovePerson(UniverseID controllableid, NPCSeed person);
	void RemovePlayerAlert(size_t index);
	void RemoveTradeRule(TradeRuleID id);
	void ResetDefaultResponseToSignalForFaction(const char* signalid, const char* factionid, const char* purposeid);
	bool SetDefaultResponseToSignalForFaction2(const char* newresponse, bool ask, const char* signalid, const char* factionid, const char* purposeid);
	void SetEditBoxText(const int editboxid, const char* text);
	void SetFactionBuildMethod(const char* factionid, const char* buildmethodid);
	void SetFactionRelationToPlayerFaction(const char* factionid, const char* reasonid, float boostvalue);
	void SetFactionDefaultWeaponMode(const char* factionid, const char* weaponmode);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMessageRead(MessageID messageid, const char* categoryname);
	void SetNotificationTypeEnabled(const char* id, bool value);
	void SetPlayerBlacklistDefault(BlacklistID id, const char* listtype, const char* defaultgroup, bool value);
	void SetPlayerClothingTheme(const char* theme);
	void SetPlayerFactionName(const char* name);
	void SetPlayerFightRuleDefault(FightRuleID id, const char* listtype, bool value);
	void SetPlayerGlobalLoadoutLevel(float value);
	void SetPlayerIllegalWare(const char* wareid, bool illegal);
	void SetPlayerLogo(UILogo logo);
	void SetPlayerPaintTheme(const char* theme);
	void SetPlayerShipsWaitForPlayer(bool value);
	void SetPlayerTaxiWaitsForPlayer(bool value);
	void SetPlayerTradeLoopCargoReservationSetting(bool value);
	void SetPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype, bool value);
	bool ShouldPlayerShipsWaitForPlayer(void);
	bool ShouldPlayerTaxiWaitForPlayer(void);
	void SignalObjectWithNPCSeed(UniverseID objecttosignalid, const char* param, NPCSeed person, UniverseID controllableid);
	void UnmutePlayerAlert(size_t index, bool silent);
	void UpdateBlacklist2(BlacklistInfo2 info);
	void UpdateFightRule(FightRuleInfo info);
	void UpdatePlayerAlert2(PlayerAlertInfo2 uialert);
	void UpdateTradeRule(TradeRuleInfo info);
]]

local utf8 = require("utf8")

local menu = {
	name = "PlayerInfoMenu",
	inventoryData = {
		craftingHistory = {},
		selectedWares = {},
		curEntry = {},
		mode = "normal",
		clearRendertarget = true,
	},
	logbookData = {
		name = ReadText(1001, 2963),
		category = "all",
		curPage = 1,
		searchtext = "",
	},
	messageData = {
		name = ReadText(1001, 7741),
		category = "highprio",
		searchtext = "",
		curEntry = {},
	},
	equipmentModsData = {
		expandedProperties = {}
	},
	accountData = {
		transactions = {}
	},
	empireData = {
	},
	personnelData = {
		sort = "name",
		role = "current",
		curPage = 1,
		searchtext = "",
		expandedEntities = {},
		curEntry = {},
	},
	editedBlacklist = {},
	factionData = {
		curEntry = {},
	},
	editedFightRule = {},
}

local config = {
	mode = "empire",
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	rowHeight = 17,
	leftBar = {
		{ name = ReadText(1001, 7717),		icon = "pi_empire",					mode = "empire",			active = true, helpOverlayID = "playerinfo_sidebar_empire",			helpOverlayText = ReadText(1028, 7701) },
		{ name = ReadText(1001, 7703),		icon = "pi_diplomacy",				mode = "factions",			active = true, helpOverlayID = "playerinfo_sidebar_factions",		helpOverlayText = ReadText(1028, 7715) },
		{ name = ReadText(1001, 2500),		icon = "pi_statistics",				mode = "stats",				active = true, helpOverlayID = "playerinfo_sidebar_stats",			helpOverlayText = ReadText(1028, 7717) },
		{ spacing = true },
		{ name = ReadText(1001, 2202),		icon = "pi_inventory",				mode = "inventory",			active = true, helpOverlayID = "playerinfo_sidebar_inventory",		helpOverlayText = ReadText(1028, 7703) },
		--{ name = ReadText(1001, 7701),		icon = "pi_crafting",				mode = "crafting",			active = true },
		{ name = ReadText(1001, 8031),		icon = "pi_equipmentmods",			mode = "equipmentmods",		active = true, helpOverlayID = "playerinfo_sidebar_equipmentmods",	helpOverlayText = ReadText(1028, 7705) },
		{ name = ReadText(1001, 7716),		icon = "pi_spacesuit",				mode = "spacesuit",			active = true, helpOverlayID = "playerinfo_sidebar_spacesuit",		helpOverlayText = ReadText(1028, 7707) },
		{ spacing = true },
		{ name = ReadText(1001, 9171),		icon = "mapst_ao_default_global",	mode = "globalorders",		active = true, helpOverlayID = "playerinfo_sidebar_globalorders",	helpOverlayText = ReadText(1028, 7709) },
		{ name = ReadText(1001, 7708),		icon = "pi_accountmanagement",		mode = "accounts",			active = true, helpOverlayID = "playerinfo_sidebar_accounts",		helpOverlayText = ReadText(1028, 7713) },
		{ name = ReadText(1001, 11034),		icon = "pi_personnelmanagement",	mode = "personnel",			active = true, helpOverlayID = "playerinfo_sidebar_personnel",		helpOverlayText = ReadText(1028, 7718) },
		{ spacing = true },
		{ name = ReadText(1001, 7730),		icon = function () return menu.messageSidebarIcon() end,		mode = "messages",			active = true, helpOverlayID = "playerinfo_sidebar_messages",		helpOverlayText = ReadText(1028, 7712),		iconcolor = function () return menu.messageSidebarIconColor() end },
		{ name = ReadText(1001, 7702),		icon = "pi_transactionlog",			mode = "transactionlog",	active = true, helpOverlayID = "playerinfo_sidebar_transactions",	helpOverlayText = ReadText(1028, 7719) },
		{ name = ReadText(1001, 5700),		icon = "pi_logbook",				mode = "logbook",			active = true, helpOverlayID = "playerinfo_sidebar_logbook",		helpOverlayText = ReadText(1028, 7711) },
		{ spacing = true,	condition = function () return OnlineHasSession() end },
		{ name = ReadText(1001, 11386),		icon = "vt_contactlist",			mode = "venturecontacts",	active = true, helpOverlayID = "playerinfo_sidebar_contacts",		helpOverlayText = ReadText(1028, 3275),	condition = function () return OnlineHasSession() end },
	},
	rightAlignTextProperties = {
		halign = "right"
	},
	rightAlignBoldTextProperties = {
		font = Helper.standardFontBold,
		halign = "right"
	},
	logbookCategories = {
		{ name = ReadText(1001, 2963),	icon = "pi_logbook",			mode = "all" },
		{ empty = true },
		{ name = ReadText(1001, 5701),	icon = "logbook_general",		mode = "general" },
		{ name = ReadText(1001, 5702),	icon = "logbook_missions",		mode = "missions" },
		{ name = ReadText(1001, 5721),	icon = "logbook_news",			mode = "news" },
		{ name = ReadText(1001, 5714),	icon = "logbook_alerts",		mode = "alerts" },
		{ name = ReadText(1001, 5704),	icon = "logbook_upkeep",		mode = "upkeep" },
		{ name = ReadText(1001, 5708),	icon = "logbook_tips",			mode = "tips" },
		{ name = ReadText(1001, 5727),	icon = "logbook_notifications",	mode = "ticker" },
	},
	logbookPage = 100,
	logbookQueryLimit = 1000,
	messageCategories = {
		{ name = ReadText(1001, 7741),	icon = "pi_message_read_high",	icon_unread = "pi_message_unread_high",	mode = "highprio" },
		{ name = ReadText(1001, 7742),	icon = "pi_message_read_low",	icon_unread = "pi_message_unread_low",	mode = "lowprio" },
	},
	messageCutscenes = {
		["OrbitIndefinitely"] = true,
		["terraforming_scaleplate_green"] = true,
		["terraforming_black_hole_sun"] = true,
		["terraforming_getsu_fune"] = true,
		["terraforming_frontier_edge"] = true,
		["terraforming_atiyas_misfortune"] = true,
		["terraforming_18billion"] = true,
		["terraforming_memory_of_profit"] = true,
		["terraforming_tharkas_cascade"] = true,
		["terraforming_ocean_of_fantasy"] = true
	},
	mouseOutRange = 100,
	modCountColumnWidth = 60,
	equipmentModClasses = {
		{ name = ReadText(1001, 8008), modclass = "ship" },
		{ name = ReadText(1001, 1301), modclass = "weapon" },
		{ name = ReadText(1001, 1317), modclass = "shield" },
		{ name = ReadText(1001, 1103), modclass = "engine" },
	},
	inventoryCategories = {
		{ id = "crafting",		name = ReadText(1001, 2827) },
		{ id = "upgrade",		name = ReadText(1001, 7716) },
		{ id = "paintmod",		name = ReadText(1001, 8510) },
		{ id = "useful",		name = ReadText(1001, 2828) },
		{ id = "tradeonly",		name = ReadText(1001, 2829) },
	},
	inventoryTabs = {
		{ category = "normal",	name = ReadText(1001, 2202),	icon = "pi_inventory",			helpOverlayID = "playerinfo_inventory_normal",		helpOverlayText = ReadText(1028, 7703) },
	},
	blacklistTypes = {
		[1] = { id = "sectortravel",	text = ReadText(1001, 9165), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9101), shorttext = ReadText(1001, 9162) },
		[2] = { id = "sectoractivity",	text = ReadText(1001, 9166), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9102), shorttext = ReadText(1001, 9163) },
		[3] = { id = "objectactivity",	text = ReadText(1001, 9167), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 9103), shorttext = ReadText(1001, 9164) },
	},
	classDefinitions = {
		["object"]	= ReadText(1001, 9198),
		["station"]	= ReadText(1001, 3),
		["ship_xl"]	= ReadText(1001, 11003),
		["ship_l"]	= ReadText(1001, 11002),
		["ship_m"]	= ReadText(1001, 11001),
		["ship_s"]	= ReadText(1001, 11000),
	},
	personnelPage = 100,
}

if C.AreVenturesCompatible() then
	table.insert(config.inventoryTabs, { category = "online",	name = ReadText(1001, 7720),	icon = "vt_inventory_player",	helpOverlayID = "playerinfo_inventory_online",		helpOverlayText = ReadText(1028, 3269) })

	table.insert(config.logbookCategories, { empty = true,		online = true })
	table.insert(config.logbookCategories, { name = ReadText(1001, 11319),	icon = "vt_logbook",		mode = "online",	online = true })
end

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.infoTablePersistentData = {
		left = {
			venturecontacts = { curPage = 1, searchtext = "", forumsearch = "" },
		},
	}


	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.cleanup()
	unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)

	UnregisterAddonBindings("ego_detailmonitor")

	menu.mainFrame = nil
	menu.infoFrame = nil
	menu.contextFrame = nil

	menu.mainTable = nil
	menu.topLevelTable = nil
	menu.infoTable = nil
	menu.buttonTable = nil

	menu.contextMenuMode = nil
	menu.mouseOutBox = nil

	menu.expandedTransactionEntry = nil
	menu.transactionSearchString = nil

	menu.inventoryData.selectedWares = {}
	menu.accountData.transactions = {}
	menu.personnelData.curEntry = {}
	menu.messageData.showFullscreen = nil

	menu.blacklists = {}
	menu.blacklist = {}
	menu.editedBlacklist = {}

	menu.fightrules = {}
	menu.fightrule = {}
	menu.editedFightRule = {}

	menu.settoprow = nil
	menu.setselectedrow = nil
	menu.setselectedrow2 = nil
	menu.setselectedcol2 = nil
	menu.logbookPageEditBox = nil
	menu.personnelPageEditBox = nil
	menu.transactionLogEditBox = nil
	menu.noupdate = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	menu.cleanupCutsceneRenderTarget()

	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		C.ReadAllInventoryWares()
	end
	menu.empireData = {}

	if Helper.hasExtension("multiverse") then
		Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
	end
	Helper.unregisterVentureContactCallbacks()
	menu.ventureContactCallbacksRegistered = nil

	C.SetUICoverOverride(false)

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

-- Menu member functions

function menu.refreshInfoFrame(toprow, selectedrow, mode, selectedrow2)
	menu.settoprow = toprow or GetTopRow(menu.infoTable)
	menu.setselectedrow = selectedrow or Helper.currentTableRow[menu.infoTable]
	if mode == "accounts" then
		menu.setselectedrow2 = selectedrow2 or Helper.currentTableRow[menu.infoTable]
	end
	menu.logbookPageEditBox = nil
	menu.personnelPageEditBox = nil
	menu.transactionLogEditBox = nil
	if menu.inventoryHeaderTable and menu.lastactivetable == menu.inventoryHeaderTable.id then
		menu.selectedRows.inventoryHeaderTable = menu.selectedRows.inventoryHeaderTable or Helper.currentTableRow[menu.inventoryHeaderTable.id] or 1
		menu.selectedCols.inventoryHeaderTable = menu.selectedCols.inventoryHeaderTable or Helper.currentTableCol[menu.inventoryHeaderTable.id]
	end
	menu.createInfoFrame()
end

function menu.buttonSetPlayerLogo(logo, row, col)
	C.SetPlayerLogo(logo)
	menu.empireData.currentlogo = logo

	menu.setselectedrow2 = row
	menu.setselectedcol2 = col
	menu.over = true
	--print("row: " .. tostring(row) .. ", col: " .. tostring(col))
end

function menu.buttonSetDefaultTheme(mode, themeid, row, col)
	--print("mode: " .. tostring(mode) .. ". applying theme: " .. tostring(themeid))
	if mode == "painttheme" then
		C.SetPlayerPaintTheme(themeid)
	elseif mode == "uniform" then
		C.SetPlayerClothingTheme(themeid)
	end

	menu.setselectedrow2 = row
	menu.setselectedcol2 = col
	menu.over = true
	--print("row: " .. tostring(row) .. ", col: " .. tostring(col))
end

function menu.buttonTogglePlayerInfo(mode)
	-- kuertee start: callback
	if menu.uix_callbacks ["buttonTogglePlayerInfo_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonTogglePlayerInfo_on_start"]) do
			uix_callback (mode, config)
		end
	end
	-- kuertee end: callback

	local oldidx, newidx
	for i, entry in ipairs(config.leftBar) do
		if entry.mode then
			if entry.mode == menu.mode then
				oldidx = i
			end
			if entry.mode == mode then
				newidx = i
			end
		end
		if oldidx and newidx then
			break
		end
	end
	if newidx then
		Helper.updateButtonColor(menu.mainTable, newidx + 2, 1, Color["row_background_selected"])
	end
	if oldidx then
		Helper.updateButtonColor(menu.mainTable, oldidx + 2, 1, Color["button_background_default"])
	end

	-- Mark items as read when hiding them
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		menu.inventoryData.selectedWares = {}
		C.ReadAllInventoryWares()
		if menu.inventoryData.mode == "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureinventory", mode)
			end
		end
	elseif menu.mode == "messages" then
		if next(menu.messageData.curEntry) then
			C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
			AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		end
		menu.messageData.curEntry = {}
		menu.messageData.showFullscreen = nil
		menu.cleanupCutsceneRenderTarget()
	elseif menu.mode == "venturecontacts" then
		Helper.unregisterVentureContactCallbacks()
		menu.ventureContactCallbacksRegistered = nil
	end

	AddUITriggeredEvent(menu.name, mode, menu.mode == mode and "off" or "on")
	if mode == menu.mode then
		PlaySound("ui_negative_back")
		menu.mode = nil
		menu.personnelData.curEntry = {}
		if oldidx then
			SelectRow(menu.mainTable, oldidx + 2)
		end
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.mode = mode
		if mode == "personnel" then
			menu.empireData.init = true
		elseif mode == "inventory" then
			menu.inventoryData.clearRendertarget = true
		end
		if newidx then
			SelectRow(menu.mainTable, newidx + 2)
		end
	end

	menu.refreshInfoFrame(1, 1)
end

function menu.deactivatePlayerInfo()
	local oldidx
	for i, entry in ipairs(config.leftBar) do
		if entry.mode then
			if entry.mode == menu.mode then
				oldidx = i
			end
		end
		if oldidx then
			break
		end
	end

	if oldidx then
		Helper.updateButtonColor(menu.mainTable, oldidx + 2, 1, Color["button_background_default"])
	end

	-- Mark items as read when hiding them
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") or (menu.empireData.mode and (menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
		menu.inventoryData.selectedWares = {}
		C.ReadAllInventoryWares()
		if menu.inventoryData.mode == "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
				Helper.callExtensionFunction("multiverse", "onCloseMenuTab", menu, "ventureinventory", "ventureinventory")
			end
		end
	elseif menu.mode == "messages" then
		if next(menu.messageData.curEntry) then
			C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
			AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		end
		menu.messageData.curEntry = {}
		menu.messageData.showFullscreen = nil
		menu.cleanupCutsceneRenderTarget()
	elseif menu.mode == "venturecontacts" then
		Helper.unregisterVentureContactCallbacks()
		menu.ventureContactCallbacksRegistered = nil
	end
	menu.personnelData.curEntry = {}

	PlaySound("ui_negative_back")
	menu.mode = nil
	if oldidx then
		SelectRow(menu.mainTable, oldidx + 2)
	end

	menu.refreshInfoFrame(1, 1)
end

function menu.buttonInventoryDrop()
	if menu.inventoryData.mode == "drop" then
		local wares = ffi.new("UIWareAmount[?]", #menu.inventoryData.dropWares)

		for i, entry in ipairs(menu.inventoryData.dropWares) do
			wares[i - 1].wareid = Helper.ffiNewString(entry.ware)
			wares[i - 1].amount = entry.amount
		end

		local lockbox = menu.inventoryData.dropLockbox
		if lockbox == "none" then
			lockbox = nil
		end
		C.DropInventory(C.GetPlayerID(), lockbox, wares, #menu.inventoryData.dropWares)

		menu.inventoryData.mode = "normal"
		menu.inventoryData.dropWares = {}
	else
		local rowdata = Helper.getCurrentRowData(menu, menu.infoTable)
		if type(rowdata) == "table" then
			menu.inventoryData.mode = "drop"

			menu.inventoryData.dropWares = {}
			for ware in pairs(menu.inventoryData.selectedWares) do
				if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
					if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
						table.insert(menu.inventoryData.dropWares, { ware = ware, amount = menu.inventory[ware].amount })
					end
				end
			end
		end
	end
	menu.refreshInfoFrame()
end

function menu.buttonInventoryCraft()
	if menu.inventoryData.mode == "craft" then
		if menu.inventoryData.craftAmount and menu.inventoryData.craftAmount > 0 then
			for _, entry in ipairs(menu.craftable) do
				if entry.ware == menu.inventoryData.craftWare[1] then
					if HasAllResourcesToCraft(nil, menu.inventoryData.craftWare[1], menu.inventoryData.craftAmount) then
						local isunbundleammo, component = GetWareData(menu.inventoryData.craftWare[1], "isunbundleammo", "component")
						if isunbundleammo then
							local playership = C.GetPlayerOccupiedShipID()
							if playership ~= 0 then
								if AddAmmo(ConvertStringToLuaID(tostring(playership)), component, menu.inventoryData.craftAmount, true) ~= menu.inventoryData.craftAmount then
									-- We're out of ammo space abort
									break
								end
							end
						end
						for _, resource in ipairs(entry.resources) do
							RemoveInventory(nil, resource.ware, menu.inventoryData.craftAmount * resource.data.needed)
						end
						AddInventory(nil, menu.inventoryData.craftWare[1], menu.inventoryData.craftAmount, true)
						table.insert(menu.inventoryData.craftingHistory, 1, { ware = menu.inventoryData.craftWare, amount = menu.inventoryData.craftAmount, time = C.GetCurrentGameTime() })
						PlaySound("ui_crafting_success")
					end
					break
				end
			end
		end
		menu.inventoryData.mode = nil
		menu.inventoryData.craftWare = nil
		menu.inventoryData.craftAmount = nil
	else
		local rowdata = Helper.getCurrentRowData(menu, menu.defaulttable)
		if type(rowdata) == "table" then
			menu.inventoryData.mode = "craft"
			menu.inventoryData.craftWare = Helper.getCurrentRowData(menu, menu.defaulttable)
			menu.inventoryData.craftAmount = 1
		end
	end
	menu.refreshInfoFrame()
end

function menu.buttonInventoryCancel()
	menu.inventoryData.mode = "normal"
	menu.inventoryData.dropWares = {}
	menu.inventoryData.craftWare = nil
	menu.inventoryData.craftAmount = nil
	menu.refreshInfoFrame()
end

function menu.buttonInventoryEncyclopedia(ware)
	local ispaintmod = GetWareData(ware, "ispaintmod")
	if ispaintmod then
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "paintmods", ware })
	else
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Wares", "inventory_wares", ware })
	end
	menu.cleanup()
end

function menu.buttonInventoryDropAll(illegalonly)
	local count = 0
	for ware in pairs(illegalonly and menu.inventory or menu.inventoryData.selectedWares) do
		if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
			if (not illegalonly) or (menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction)) then
				if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
					count = count + 1
				end
			end
		end
	end

	local wares = ffi.new("UIWareAmount[?]", count)
	local i = 0
	for ware in pairs(illegalonly and menu.inventory or menu.inventoryData.selectedWares) do
		if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
			if (not illegalonly) or (menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction)) then
				if menu.inventory[ware] and menu.inventory[ware].amount > 0 then
					wares[i].wareid = Helper.ffiNewString(ware)
					wares[i].amount = menu.inventory[ware].amount
					i = i + 1
				end
			end
		end
	end

	C.DropInventory(C.GetPlayerID(), menu.inventoryData.defaultLockbox, wares, count)
	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonInventorySubMode(mode, col)
	if mode ~= menu.inventoryData.mode then
		menu.inventoryData.mode = mode
		if menu.inventoryData.mode ~= "online" then
			if Helper.hasExtension("multiverse") then
				Helper.callExtensionFunction("multiverse", "unregisterOnlineEvents", menu)
			end
		end
		menu.refreshInfoFrame()
	end
end

function menu.buttonLogbookCategory(name, category, col)
	menu.logbookData.name = name
	menu.logbookData.category = category
	menu.logbookData.curPage = 1
	menu.setselectedcol = col
	menu.refreshInfoFrame()
end

function menu.buttonLogbookClearQuestion()
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "clearlogbook", category = menu.logbookData.category, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.buttonLogbookClear(category)
	ClearLogbook(0, category)
	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonLogbookInteraction(entry)
	if IsValidComponent(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, entry.interactioncomponent })
			menu.cleanup()
		elseif entry.interaction == "showlocationonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, entry.interactioncomponent, nil, nil, nil, nil, entry.interactionposition })
			menu.cleanup()
		elseif entry.interaction == "guidance" then
			local convertedInteractionComponent = ConvertIDTo64Bit(entry.interactioncomponent)
			if convertedInteractionComponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(convertedInteractionComponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.editboxLogbookPage(_, text, textchanged)
	menu.noupdate = nil
	local newpage = tonumber(text)
	if newpage and (newpage ~= menu.logbookData.curPage) then
		menu.logbookData.curPage = math.max(1, math.min(newpage, menu.logbookData.numPages))
		menu.refreshInfoFrame()
	else
		C.SetEditBoxText(menu.logbookPageEditBox.id, menu.logbookData.curPage .. " / " .. menu.logbookData.numPages)
	end
end

function menu.editboxPersonnelPage(_, text, textchanged)
	menu.noupdate = nil
	local newpage = tonumber(text)
	if newpage and (newpage ~= menu.personnelData.curPage) then
		menu.personnelData.curPage = math.max(1, math.min(newpage, menu.personnelData.numPages))
		menu.personnelData.curEntry = {}
		menu.refreshInfoFrame(1, 1)
	else
		C.SetEditBoxText(menu.personnelPageEditBox.id, menu.personnelData.curPage .. " / " .. menu.personnelData.numPages)
	end
end

function menu.buttonMessageCategory(name, category, col)
	menu.messageData.name = name
	menu.messageData.category = category
	if next(menu.messageData.curEntry) then
		C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
	end
	menu.messageData.curEntry = {}
	menu.messageData.showFullscreen = nil
	menu.cleanupCutsceneRenderTarget()
	menu.setselectedcol = col
	menu.refreshInfoFrame()
end

function menu.buttonMessagesRead()
	for _, entry in ipairs(menu.messages) do
		C.SetMessageRead(entry.id, entry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(entry.id)))
	end
	menu.refreshInfoFrame()
end

function menu.buttonMessagesInteraction(entry)
	if (entry.interactioncomponent > 0) and C.IsComponentOperational(entry.interactioncomponent) then
		if entry.interaction == "showonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, ConvertStringToLuaID(tostring(entry.interactioncomponent)) })
			menu.cleanup()
		elseif entry.interaction == "showlocationonmap" then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, ConvertStringToLuaID(tostring(entry.interactioncomponent)), nil, nil, nil, nil, entry.interactionposition })
			menu.cleanup()
		elseif entry.interaction == "guidance" then
			if entry.interactioncomponent ~= C.GetPlayerControlledShipID() then
				local offset = ffi.new("UIPosRot", 0)
				C.SetGuidance(entry.interactioncomponent, offset)
			end
		end
	else
		menu.refreshInfoFrame()
	end
end

function menu.buttonMessagesToggleCutsceneFullscreen()
	menu.messageData.showFullscreen = not menu.messageData.showFullscreen
	if not menu.messageData.cutsceneStopped then
		menu.messageData.fullscreenToggled = true
	end
	menu.refreshInfoFrame()
end

function menu.buttonAccountCancel()
	menu.accountData.transactions = {}
	menu.refreshInfoFrame()
end

function menu.buttonAccountConfirm()
	for _, transaction in ipairs(menu.accountData.transactions) do
		if transaction.amount > 0 then
			local isplayerowned = GetComponentData(transaction.station, "isplayerowned")
			if isplayerowned then
				local newstationcash = (GetAccountData(transaction.station, "money") or 0) - transaction.amount
				SetMaxBudget(transaction.station, (newstationcash * 3) / 2)
				SetMinBudget(transaction.station, newstationcash)
				TransferMoneyToPlayer(transaction.amount, transaction.station)
			end
		end
	end
	for _, transaction in ipairs(menu.accountData.transactions) do
		if transaction.amount < 0 then
			local isplayerowned = GetComponentData(transaction.station, "isplayerowned")
			if isplayerowned then
				-- NB: transaction.amount is always with respect to the player's account! so transaction.amount in this case is negative since money is taken away from the player's account.
				local newstationcash = (GetAccountData(transaction.station, "money") or 0) - transaction.amount
				SetMaxBudget(transaction.station, (newstationcash * 3) / 2)
				SetMinBudget(transaction.station, newstationcash)
				TransferPlayerMoneyTo(-transaction.amount, transaction.station)
			end
		end
	end
	menu.accountData.transactions = {}
	menu.refreshInfoFrame()
end

function menu.accountSetEstimate(container, isbuildstorage)
	local container64 = ConvertIDTo64Bit(container)
	local containernmoney, productionmoney, wantedmoney, isplayerowned = GetComponentData(container, "money", "productionmoney", "wantedmoney", "isplayerowned")
	if isplayerowned then
		local estimate = 0
		if isbuildstorage then
			estimate = wantedmoney
		else
			local supplymoney = tonumber(C.GetSupplyBudget(container64)) / 100
			local tradewaremoney = tonumber(C.GetTradeWareBudget(container64)) / 100
			estimate = productionmoney + supplymoney + tradewaremoney
		end
		local amount = -estimate + containernmoney

		local _, index = menu.findAccountTransaction(container)
		if amount ~= 0 then
			if index then
				if menu.accountData.transactions[index].amount ~= amount then
					menu.accountData.transactions[index].amount = amount
				end
			else
				table.insert(menu.accountData.transactions, { station = container, amount = amount })
			end
		else
			if index then
				table.remove(menu.accountData.transactions, index)
			end
		end
	end
end

function menu.buttonAccountToEstimate(container, isbuildstorage)
	menu.accountSetEstimate(container, isbuildstorage)

	menu.refreshInfoFrame()
end

function menu.buttonAccountAllEstimates()
	for i, station in ipairs(menu.accountData.stations) do
		local productionmoney, buildstorage = GetComponentData(station, "money", "buildstorage")
		if productionmoney then
			menu.accountSetEstimate(station)
		end
		menu.accountSetEstimate(buildstorage, true)
	end
	for i, buildstorage in ipairs(menu.accountData.buildstorages) do
		menu.accountSetEstimate(buildstorage, true)
	end

	menu.refreshInfoFrame()
end

function menu.editboxChangePlayerName(_, text, textchanged)
	menu.noupdate = nil
	if textchanged and (text ~= "") then
		local player = ConvertStringTo64Bit(tostring(C.GetPlayerID()))
		SetComponentName(player, text)
		menu.empireData.name = text
	end

	menu.refreshInfoFrame()
end

function menu.editboxChangePlayerFactionName(_, text, textchanged)
	menu.noupdate = nil
	if textchanged then
		C.SetPlayerFactionName(text)
		menu.empireData.factionname = text
	end

	menu.refreshInfoFrame()
end

function menu.editboxUpdateTransactionSearchString(_, text, textchanged)
	if textchanged then
		menu.transactionSearchString = text
	end

	menu.refreshInfoFrame()
end

function menu.dropdownInventoryLockbox(_, id)
	menu.inventoryData.dropLockbox = id
end

function menu.slidercellInventoryDrop(ware, value)
	for _, entry in ipairs(menu.inventoryData.dropWares) do
		if entry.ware == ware then
			entry.amount = value
		end
	end
end

function menu.slidercellInventoryCraft(_, value)
	menu.inventoryData.craftAmount = value
end

function menu.slidercellAccountChanged(station, row, value, functable)
	if not functable then
		functable = menu.infoTable
	end

	local changed = false
	if value ~= 0 then
		local _, index = menu.findAccountTransaction(station)
		if index then
			if menu.accountData.transactions[index].amount ~= value then
				menu.accountData.transactions[index].amount = value
				changed = true
			end
		else
			table.insert(menu.accountData.transactions, { station = station, amount = value })
		end
	else
		local _, index = menu.findAccountTransaction(station)
		if index then
			table.remove(menu.accountData.transactions, index)
			changed = true
		end
	end

	if changed then
		local playermoney = ConvertMoneyString(menu.getAccountPlayerMoney(), false, true, nil, true) .. " " .. ReadText(1001, 101)

		local offset = 2
		for i, otherstation in ipairs(menu.accountData.stations) do
			if i ~= 1 then
				-- empty row
				offset = offset + 1
			end
			-- title
			offset = offset + 1

			local stationmoney, buildstorage = GetComponentData(otherstation, "money", "buildstorage")

			if stationmoney then
				local stationsliderrow = offset + 1

				Helper.updateCellText(functable, stationsliderrow, 5, playermoney)
				if stationsliderrow == row then
					Helper.updateCellText(functable, stationsliderrow, 2, ConvertMoneyString(GetComponentData(station, "money") - value, false, true, nil, true) .. " " .. ReadText(1001, 101))
				end

				offset = offset + 3
			end

			if buildstorage then
				local buildstoragesliderrow = offset + 1

				Helper.updateCellText(functable, buildstoragesliderrow, 5, playermoney)
				if buildstoragesliderrow == row then
					Helper.updateCellText(functable, buildstoragesliderrow, 2, ConvertMoneyString(GetComponentData(station, "money") - value, false, true, nil, true) .. " " .. ReadText(1001, 101))
				end

				offset = offset + 2
			end
		end
		for i in ipairs(menu.accountData.buildstorages) do
			if (i ~= 1) or (#menu.accountData.stations > 0) then
				-- empty row
				offset = offset + 1
			end
			-- title
			offset = offset + 1

			local sliderrow = offset + 1

			Helper.updateCellText(functable, sliderrow, 5, playermoney)
			if sliderrow == row then
				Helper.updateCellText(functable, sliderrow, 2, ConvertMoneyString(GetComponentData(station, "money") - value, false, true, nil, true) .. " " .. ReadText(1001, 101))
			end

			offset = offset + 2
		end
	end
end

function menu.onSliderCellActivated()
	menu.refresh = nil
	menu.refreshdata = nil
end

-- mode: "factionresponses", "controllableresponses"
function menu.checkboxOrdersSetAsk(factionorcontrollable, signalid, mode, row)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.checkboxOrdersSetAsk called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.checkboxOrdersSetAsk called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.checkboxOrdersSetAsk called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	local ask
	local response
	if mode == "controllableresponses" then
		ask = not C.GetAskToSignalForControllable(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForControllable(signalid, factionorcontrollable)
		C.SetDefaultResponseToSignalForControllable(response, ask, signalid, factionorcontrollable)
	else
		ask = not C.GetAskToSignalForFaction(signalid, factionorcontrollable)
		response = C.GetDefaultResponseToSignalForFaction2(signalid, factionorcontrollable, "")
		C.SetDefaultResponseToSignalForFaction2(response, ask, signalid, factionorcontrollable, "")
	end
	menu.setselectedrow2 = row
	menu.refreshInfoFrame()
end

function menu.toggleAllNotificationSettings(notificationgroupdata, checked)
	for _, type in ipairs(notificationgroupdata.types) do
		menu.checkboxNotification(notificationgroupdata, type.id, checked)
	end
end

function menu.checkboxNotification(notificationgroupdata, id, checked)
	C.SetNotificationTypeEnabled(id, checked)
	notificationgroupdata.checkedcounts = 0
	for _, type in ipairs(notificationgroupdata.types) do
		if type.id == id then
			type.enabled = checked
		end
		if type.enabled then
			notificationgroupdata.checkedcounts = notificationgroupdata.checkedcounts + 1
		end
	end
end

-- mode: "factionresponses", "controllableresponses"
function menu.dropdownOrdersSetResponse(newresponseid, factionorcontrollable, signalid, mode, purposetype)
	if mode ~= "factionresponses" and mode ~= "controllableresponses" then
		DebugError("menu.dropdownOrdersSetResponse called with invalid mode set. only 'factionresponses' and 'controllableresponses' are supported at this time. mode: " .. tostring(mode))
		return
	elseif not factionorcontrollable then
		DebugError("menu.dropdownOrdersSetResponse called with invalid faction or controllable set. factionorcontrollable: " .. tostring(factionorcontrollable))
		return
	elseif not signalid then
		DebugError("menu.dropdownOrdersSetResponse called with invalid signal id set. signalid: " .. tostring(signalid))
		return
	end

	if newresponseid == "reset" then
		if mode == "controllableresponses" then
			if not C.ResetResponseToSignalForControllable(signalid, factionorcontrollable) then
				DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(factionorcontrollable)) .. " " .. tostring(factionorcontrollable))
			end
		else
			local factionobjects = GetContainedObjectsByOwner(factionorcontrollable)
			for _, object in ipairs(factionobjects) do
				local object64 = ConvertIDTo64Bit(object)
				if C.IsComponentClass(object64, "controllable") then
					if not C.ResetResponseToSignalForControllable(signalid, object64) then
						DebugError("Failed resetting response to signal " .. tostring(signalid) .. " for controllable " .. ffi.string(C.GetComponentName(object64)) .. " " .. tostring(object64))
					end
				end
			end
		end
	elseif newresponseid == "default" then
		if mode == "factionresponses" then
			if purposetype == "military" then
				C.ResetDefaultResponseToSignalForFaction(signalid, factionorcontrollable, "fight")
				C.ResetDefaultResponseToSignalForFaction(signalid, factionorcontrollable, "auxiliary")
			else
				C.ResetDefaultResponseToSignalForFaction(signalid, factionorcontrollable, "")
			end
		end
	else
		local ask
		if mode == "controllableresponses" then
			ask = C.GetAskToSignalForControllable(signalid, factionorcontrollable)
			C.SetDefaultResponseToSignalForControllable(newresponseid, ask, signalid, factionorcontrollable)
		else
			ask = C.GetAskToSignalForFaction(signalid, factionorcontrollable)
			if purposetype == "military" then
				C.SetDefaultResponseToSignalForFaction2(newresponseid, ask, signalid, factionorcontrollable, "fight")
				C.SetDefaultResponseToSignalForFaction2(newresponseid, ask, signalid, factionorcontrollable, "auxiliary")
			else
				C.SetDefaultResponseToSignalForFaction2(newresponseid, ask, signalid, factionorcontrollable, "")
			end
		end
	end
end

function menu.dropdownOrdersResupply(_, id)
	C.SetPlayerGlobalLoadoutLevel(tonumber(id))
end

function menu.dropdownOrdersCargoReservations(_, id)
	C.SetPlayerTradeLoopCargoReservationSetting(id == "on")
end

function menu.dropdownOrdersBuildRule(_, id)
	C.SetFactionBuildMethod("player", id)
end

function menu.hotkey(action)
	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_CLOSE_PLAYERINFO" then
		menu.closeMenu("close")
	end
end

function menu.onShowMenu(state)
	-- reset settings
	C.SetUICoverOverride(false)
	menu.noupdate = nil
	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.messageData.curEntry = {}

	-- Register bindings
	Helper.setKeyBinding(menu, menu.hotkey)
	RegisterAddonBindings("ego_detailmonitor", "playerinfo")

	-- Init
	menu.playerInfoFullWidth = Helper.viewWidth - (Helper.playerInfoConfig.offsetX + Helper.frameBorder + Helper.borderSize)

	menu.sideBarWidth = Helper.scaleX(Helper.sidebarWidth)
	local availableLeftBarHeight = Helper.viewHeight - (Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + Helper.borderSize + menu.sideBarWidth + Helper.scaleY(Helper.titleTextProperties.height) + 3 * Helper.borderSize)
	local count, bordercount = 0, 0
	for _, entry in ipairs(config.leftBar) do
		if not entry.condition or entry.condition() then
			if entry.spacing then
				count = count + 0.25
				bordercount = bordercount + 1
			else
				count = count + 1
				bordercount = bordercount + 1
			end
		end
	end
	if (count * menu.sideBarWidth + bordercount * Helper.borderSize) > availableLeftBarHeight then
		menu.sideBarWidth = math.floor((availableLeftBarHeight - bordercount * Helper.borderSize) / count)
	end

	menu.contextMenuWidth = Helper.scaleX(200)

	menu.mode = menu.param[3] or menu.mode or config.mode
	-- cleanup parameter, so we are not returned automatically to the original mode when opening another menu/conversation from this menu (but a different mode)
	menu.param[3] = nil

	menu.expandedTransactionEntry = {}
	menu.transactionSearchString = ""

	menu.initEmpireData()
	if menu.mode == "globalorders" then
		if menu.param[4] then
			if menu.param[4][1] == "traderule" then
				local id = menu.param[4][2]

				if id then
					local counts = C.GetTradeRuleInfoCounts(id)
					local buf = ffi.new("TradeRuleInfo")
					buf.numfactions = counts.numfactions
					buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
					if C.GetTradeRuleInfo(buf, id) then
						local factions = {}
						for j = 0, buf.numfactions - 1 do
							table.insert(factions, ffi.string(buf.factions[j]))
						end

						local defaults = {
							["trade"] = C.IsPlayerTradeRuleDefault(id, "buy") and C.IsPlayerTradeRuleDefault(id, "sell"),
							["supply"] = C.IsPlayerTradeRuleDefault(id, "supply"),
							["build"] = C.IsPlayerTradeRuleDefault(id, "build"),
						}

						menu.empireData.mode = { "empire_list", "traderule", { id = id, name = ffi.string(buf.name), factions = factions, iswhitelist = buf.iswhitelist, defaults = defaults } }
					end
				else
					menu.empireData.mode = { "empire_list", "traderule", {} }
				end
			elseif menu.param[4][1] == "blacklist" then
				local id = menu.param[4][2]

				if id then
					local counts = C.GetBlacklistInfoCounts(id)
					local buf = ffi.new("BlacklistInfo2")
					buf.nummacros = counts.nummacros
					buf.macros = Helper.ffiNewHelper("const char*[?]", counts.nummacros)
					buf.numfactions = counts.numfactions
					buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
					if C.GetBlacklistInfo2(buf, id) then
						local type = ffi.string(buf.type)

						local spaces = {}
						for j = 0, buf.nummacros - 1 do
							table.insert(spaces, ConvertIDTo64Bit(GetMacroData(ffi.string(buf.macros[j]), "sectorcomponent")))
						end

						local factions = {}
						for j = 0, buf.numfactions - 1 do
							table.insert(factions, ffi.string(buf.factions[j]))
						end

						local defaults = {
							["civilian"] = C.IsPlayerBlacklistDefault(id, type, "civilian"),
							["military"] = C.IsPlayerBlacklistDefault(id, type, "military"),
						}

						menu.empireData.mode = { "empire_list", "blacklist", { id = id, type = type, name = ffi.string(buf.name), spaces = spaces, factions = factions, relation = ffi.string(buf.relation), hazardous = buf.hazardous, defaults = defaults, usemacrowhitelist = buf.usemacrowhitelist, usefactionwhitelist = buf.usefactionwhitelist } }
					end
				else
					menu.empireData.mode = { "empire_list", "blacklist", {} }
				end
			elseif menu.param[4][1] == "fightrule" then
				local id = menu.param[4][2]

				if id then
					local counts = C.GetFightRuleInfoCounts(id)
					local buf = ffi.new("FightRuleInfo")
					buf.numfactions = counts.numfactions
					buf.factions = Helper.ffiNewHelper("UIFightRuleSetting[?]", counts.numfactions)
					if C.GetFightRuleInfo(buf, id) then
						local settings = {}
						for j = 0, buf.numfactions - 1 do
							local faction = ffi.string(buf.factions[j].factionid)
							local civilian = ffi.string(buf.factions[j].civiliansetting)
							if civilian == "" then
								civilian = "default"
							end
							local military = ffi.string(buf.factions[j].militarysetting)
							if military == "" then
								military = "default"
							end
							settings[faction] = { civilian = civilian, military = military }
						end

						local defaults = {
							["attack"] = C.IsPlayerFightRuleDefault(id, "attack"),
						}

						menu.empireData.mode = { "empire_list", "fightrule", { id = id, name = ffi.string(buf.name), settings = settings, defaults = defaults } }
					end
				else
					menu.empireData.mode = { "empire_list", "fightrule", {} }
				end
			end
		end
	end

	Helper.setTabScrollCallback(menu, menu.onTabScroll)
	registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
	registerForEvent("cutsceneStopped", getElement("Scene.UIContract"), menu.onCutsceneStopped)

	if state then
		menu.onRestoreState(state)
	end

	menu.holomapcolor = Helper.getHoloMapColors()

	-- display main frame
	menu.createMainFrame()

	AddUITriggeredEvent(menu.name, menu.mode)

	-- display info
	menu.createInfoFrame()
end

function menu.onSaveState()
	local state = {}

	state.settoprow = GetTopRow(menu.infoTable)
	state.setselectedrow = Helper.currentTableRow[menu.infoTable]

	return state
end

function menu.onRestoreState(state)
	menu.settoprow = state.settoprow
	menu.setselectedrow = state.setselectedrow
end

function menu.createMainFrame()
	local frameProperties = {
		standardButtons = { back = true, close = true },
		standardButtonX = Helper.playerInfoConfig.offsetX,
		standardButtonY = Helper.playerInfoConfig.offsetY,
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		layer = config.mainLayer,
		standardButtons = { back = true, close = true, help = true  },
	}

	menu.mainFrame = Helper.createFrameHandle(menu, frameProperties)
	menu.mainFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.createPlayerInfo(menu.mainFrame, Helper.playerInfoConfig.width, Helper.playerInfoConfig.height, Helper.playerInfoConfig.offsetX, Helper.playerInfoConfig.offsetY)

	menu.mainFrame:display()
end

function menu.createPlayerInfo(frame, width, height, offsetx, offsety)
	-- kuertee start: callback
	if menu.uix_callbacks ["createPlayerInfo_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createPlayerInfo_on_start"]) do
			uix_callback (config)
		end
	end
	-- kuertee end: callback

	local ftable = frame:addTable(2, { tabOrder = 3, scaling = false, borderEnabled = false, x = offsetx, y = offsety, reserveScrollBar = false })
	ftable:setColWidth(1, menu.sideBarWidth, false)
	ftable:setColWidth(2, width - menu.sideBarWidth - Helper.borderSize, false)

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["player_info_background"] })
	local icon = row[1]:setColSpan(2):createIcon(function () local logo = C.GetCurrentPlayerLogo(); return ffi.string(logo.icon) end, { width = height, height = height, color = Helper.getPlayerLogoColor })

	local textheight = math.ceil(C.GetTextHeight(Helper.playerInfoConfigTextLeft(), Helper.standardFont, Helper.playerInfoConfig.fontsize, width - height - Helper.borderSize))
	icon:setText(Helper.playerInfoConfigTextLeft,		{ fontsize = Helper.playerInfoConfig.fontsize, halign = "left",  x = height + Helper.borderSize, y = (height - textheight) / 2 })
	icon:setText2(Helper.playerInfoConfigTextRight,		{ fontsize = Helper.playerInfoConfig.fontsize, halign = "right", x = Helper.borderSize,          y = (height - textheight) / 2 })

	local spacingHeight = menu.sideBarWidth / 4
	row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createText(" ", { minRowHeight = menu.sideBarWidth + Helper.scaleY(Helper.titleTextProperties.height) + 2 * Helper.borderSize })
	for _, entry in ipairs(config.leftBar) do
		if not entry.condition or entry.condition() then
			if entry.spacing then
				row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createIcon("mapst_seperator_line", { width = menu.sideBarWidth, height = spacingHeight })
			else
				row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
				row[1]:createButton({ active = entry.active, height = menu.sideBarWidth, bgColor = (menu.mode == entry.mode) and Color["row_background_selected"] or Color["row_title_background"], mouseOverText = entry.name, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = entry.iconcolor })
				row[1].handlers.onClick = function () return menu.buttonTogglePlayerInfo(entry.mode) end
			end
		end
	end

	ftable:addConnection(1, 1, true)
end

function menu.createTopLevel(frame)
	menu.topLevelHeight = Helper.createTopLevelTab(menu, "playerinfo", frame, "", nil, true)
end

function menu.onTabScroll(direction)
	if direction == "right" then
		Helper.scrollTopLevel(menu, "playerinfo", 1)
	elseif direction == "left" then
		Helper.scrollTopLevel(menu, "playerinfo", -1)
	end
end

function menu.onInputModeChanged(_, mode)
	if not menu.noupdate then
		menu.refreshInfoFrame()
	else
		menu.inputModeHasChanged = true
	end
end

function menu.onCutsceneStopped(_, cutsceneID)
	if cutsceneID == menu.cutsceneid then
		if next(menu.messageData.curEntry) then
			if menu.messageData.showFullscreen then
				menu.buttonMessagesToggleCutsceneFullscreen()
			end
			menu.messageData.cutsceneStopped = true
		end
	end
end

function menu.createInfoFrame()
	-- kuertee start: callback
	if menu.uix_callbacks ["createInfoFrame_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_on_start"]) do
			uix_callback (menu.infoFrame, tableProperties)
		end
	end
	-- kuertee end: callback

	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	local width = Helper.playerInfoConfig.width
	if (menu.mode == "empire") or (menu.mode == "globalorders") or (menu.mode == "messages") or (menu.mode == "factions") then
		width = menu.playerInfoFullWidth
	end

	local frameProperties = {
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		layer = config.infoLayer,
	}

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	if not menu.messageData.showFullscreen then
		menu.createTopLevel(menu.infoFrame)
	end

	local tableProperties = {
		width = width - menu.sideBarWidth - Helper.borderSize,
		x = Helper.playerInfoConfig.offsetX + menu.sideBarWidth + Helper.borderSize,
		y = math.max(Helper.playerInfoConfig.offsetY + Helper.playerInfoConfig.height + Helper.borderSize, menu.topLevelHeight),
	}
	tableProperties.height = Helper.viewHeight - tableProperties.y

	Helper.clearTableConnectionColumn(menu, 2)
	Helper.clearTableConnectionColumn(menu, 3)

	if menu.mode == "inventory" then
		menu.createInventory(menu.infoFrame, tableProperties)
	elseif menu.mode == "crafting" then
		menu.createCrafting(menu.infoFrame, tableProperties)
	elseif menu.mode == "equipmentmods" then
		menu.createEquipmentMods(menu.infoFrame, tableProperties)
	elseif menu.mode == "spacesuit" then
		menu.createInventory(menu.infoFrame, tableProperties, "personalupgrade")
	elseif menu.mode == "globalorders" then
		menu.createEmpire(menu.infoFrame, tableProperties)
	elseif menu.mode == "factions" then
		menu.createFactions(menu.infoFrame, tableProperties)
	elseif menu.mode == "transactionlog" then
		tableProperties.width = tableProperties.width * 5 / 4
		tableProperties.x2 = Helper.frameBorder
		Helper.createTransactionLog(menu.infoFrame, C.GetPlayerID(), tableProperties, menu.refreshInfoFrame, { toprow = menu.settoprow, selectedrow = menu.setselectedrow })
		menu.lastTransactionLogRefreshTime = getElapsedTime()
	elseif menu.mode == "empire" then
		menu.createEmpire(menu.infoFrame, tableProperties)
	elseif menu.mode == "accounts" then
		tableProperties.width = tableProperties.width * 3 / 2
		menu.createAccounts(menu.infoFrame, tableProperties)
	elseif menu.mode == "stats" then
		menu.createStats(menu.infoFrame, tableProperties)
	elseif menu.mode == "logbook" then
		tableProperties.width = tableProperties.width * 5 / 4
		menu.createLogbook(menu.infoFrame, tableProperties)
	elseif menu.mode == "messages" then
		menu.createMessages(menu.infoFrame, tableProperties)
	elseif menu.mode == "personnel" then
		menu.createPersonnelInfo(menu.infoFrame, tableProperties)
	elseif menu.mode == "venturecontacts" then
		if not menu.ventureContactCallbacksRegistered then
			menu.ventureContactCallbacksRegistered = true
			Helper.registerVentureContactCallbacks(menu)
		end
		Helper.createVentureContacts(menu, menu.infoFrame, "left", tableProperties.width, tableProperties.x, tableProperties.y, tableProperties.x, tableProperties.y)
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["createInfoFrame_on_info_frame_mode"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_on_info_frame_mode"]) do
			uix_callback (menu.infoFrame, tableProperties)
		end
	end
	-- kuertee end: callback

	menu.infoFrame:display()
end

function menu.createInventory(frame, tableProperties, mode, tabOrderOffset)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	if not tabOrderOffset then
		tabOrderOffset = 0
	end
	menu.skipread = true

	local isonline = Helper.isOnlineGame()
	-- show venture inventory partially if we have permanent online items

	local onlineitems = OnlineGetUserItems()

	-- kuertee start:
	if not onlineitems then
		onlineitems = {}
	end
	-- kuertee end

	for ware, waredata in pairs(onlineitems) do
		local isoperationvolatile, isseasonvolatile = GetWareData(ware, "isoperationvolatile", "isseasonvolatile")
		if (not isoperationvolatile) and (not isseasonvolatile) then
			isonline = true
			break
		end
	end

	if menu.inventoryData.mode == "online" then
		if not isonline then
			menu.inventoryData.mode = "normal"
		end
	end

	if (menu.inventoryData.mode == "normal") or (menu.inventoryData.mode == "drop") or (mode == "personalupgrade") then
		local infotable = frame:addTable(4, { tabOrder = 1 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, maxVisibleHeight = tableProperties.height, multiSelect = true, x = tableProperties.x, y = tableProperties.y })
		menu.inventoryInfoTable = infotable
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(2, tableProperties.width / 8, false)
		infotable:setColWidth(3, tableProperties.width / 5, false)
		infotable:setColWidth(4, tableProperties.width / 5, false)
		infotable:setDefaultBackgroundColSpan(1, 4)

		-- title
		local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText((mode == "personalupgrade") and ReadText(1001, 7716) or ReadText(1001, 2202), Helper.titleTextProperties)

		local wareCategories = {}
		local wareCategoryIdx = {}
		for i, entry in ipairs(config.inventoryCategories) do
			wareCategoryIdx[entry.id] = i
			table.insert(wareCategories, { id = entry.id, name = entry.name, data = {} })
		end

		menu.inventory = GetPlayerInventory()
		menu.onlineitems = OnlineGetUserItems()

		-- kuertee start:
		if not menu.onlineitems then
			menu.onlineitems = {}
		end
		-- kuertee end

		for ware, waredata in Helper.orderedPairs(menu.inventory) do
			local iscraftingresource, ismodpart, isprimarymodpart, ispersonalupgrade, tradeonly, ispaintmod, isbraneitem = GetWareData(ware, "iscraftingresource", "ismodpart", "isprimarymodpart", "ispersonalupgrade", "tradeonly", "ispaintmod", "isbraneitem")
			if iscraftingresource or ismodpart or isprimarymodpart then
				table.insert(wareCategories[wareCategoryIdx["crafting"]].data, ware)
			elseif ispersonalupgrade then
				table.insert(wareCategories[wareCategoryIdx["upgrade"]].data, ware)
			elseif tradeonly then
				table.insert(wareCategories[wareCategoryIdx["tradeonly"]].data, ware)
			elseif ispaintmod then
				table.insert(wareCategories[wareCategoryIdx["paintmod"]].data, ware)
			elseif (not menu.onlineitems[ware]) and (not isbraneitem) then
				table.insert(wareCategories[wareCategoryIdx["useful"]].data, ware)
			end
		end
		for i, entry in ipairs(config.inventoryCategories) do
			table.sort(wareCategories[i].data, Helper.sortWareName)
		end

		menu.inventoryData.policefaction = GetComponentData(ConvertStringToLuaID(tostring(C.GetPlayerZoneID())), "policefaction")

		menu.inventoryData.lockboxes = {}
		local player = C.GetPlayerID()
		local n = C.GetNumAvailableLockboxes(player)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetAvailableLockboxes(buf, n, player)
		for i = 0, n - 1 do
			table.insert(menu.inventoryData.lockboxes, GetWareData(ffi.string(buf[i]), "component"))
		end

		local totalprice = 0
		local totalonlineprice = 0
		local found = false
		if next(menu.inventory) then
			-- header
			row = infotable:addRow(ware, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(4):createText(ReadText(1001, 95), { font = Helper.standardFontBold })
			row[2]:createText(ReadText(1001, 1202), config.rightAlignBoldTextProperties)
			row[3]:createText(ReadText(1001, 2413), config.rightAlignBoldTextProperties)
			row[4]:createText(ReadText(1001, 2927), config.rightAlignBoldTextProperties)

			row = infotable:addRow(false, { fixed = true, bgColor = Color["row_separator"] })
			row[1]:setColSpan(4):createText("", {height = 1})

			-- entries
			for _, entry in ipairs(wareCategories) do
				if #entry.data > 0 then
					if (mode == "personalupgrade") == (entry.id == "upgrade") then
						found = true
						if mode ~= "personalupgrade" then
							row = infotable:addRow(nil, {  })
							row[1]:setColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
							row[1].properties.halign = "center"

							row[1].properties.helpOverlayID = "playerinfo_inventory_" .. entry.id
							row[1].properties.helpOverlayText = " "
							row[1].properties.helpOverlayHeight = row:getHeight()
							row[1].properties.helpOverlayHighlightOnly = true
							row[1].properties.helpOverlayScaling = false
						end
						for _, ware in ipairs(entry.data) do
							local waredata = menu.inventory[ware]
							local isequipment, avgprice = GetWareData(ware, "isequipment", "avgprice")
							if not next(menu.inventoryData.selectedWares) then
								menu.inventoryData.selectedWares[ware] = true
							end
							menu.addInventoryWareEntry(infotable, ware, waredata, nil, nil, isequipment, entry.id == "online")
							totalprice = totalprice + avgprice * waredata.amount
							row[1].properties.helpOverlayHeight = row[1].properties.helpOverlayHeight + row:getHeight() + Helper.borderSize
						end
					end
				end
			end

		end
		if not found then
			row = infotable:addRow(true, { interactive = false })
			row[1]:setColSpan(4):createText("-- " .. ReadText(1001, 32) .. " --", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		if not menu.setselectedrow2 then
			infotable:setSelectedRow(menu.setselectedrow)
		else
			infotable:setSelectedRow(menu.setselectedrow2)
		end
		menu.settoprow = nil
		menu.setselectedrow = nil
		menu.setselectedrow2 = nil

		-- buttons
		local buttontable = frame:addTable(3, { tabOrder = 2 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
		menu.inventoryButtonTable = buttontable

		local row = buttontable:addRow(false, { fixed = true })
		row[1]:setColSpan(3):createText("")

		if mode ~= "personalupgrade" then
			local row = buttontable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText(" ", { titleColor = Color["row_title"] })
			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(3):setColSpan(2):createText(ReadText(1001, 2442), {  })
			row[3]:createText(ConvertMoneyString(totalprice, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)

			buttontable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = buttontable:addRow(nil, { fixed = true })
		row[1]:setColSpan(3):createText(ReadText(1001, 7735), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"

		local curOption = menu.inventoryData.dropLockbox or "none"
		local options = {
			{ id = "none", text = ReadText(1001, 7731), icon = "", displayremoveoption = false }
		}
		for _, box in ipairs(menu.inventoryData.lockboxes) do
			if (menu.inventoryData.dropLockbox == nil) and (curOption == "none") then
				menu.inventoryData.dropLockbox = box
				menu.inventoryData.defaultLockbox = box
				curOption = box
			end
			table.insert(options, { id = box, text = GetMacroData(box, "name"), icon = "", displayremoveoption = false })
		end

		local row
		if menu.inventoryData.mode == "drop" then
			for _, entry in ipairs(menu.inventoryData.dropWares) do
				local slidermax = entry.amount
				row = buttontable:addRow(true, { fixed = true })
				row[1]:setColSpan(3):createSliderCell({ height = Helper.standardButtonHeight, valueColor = Color["slider_value"], min = 0, minSelect = 1, max = slidermax, start = slidermax }):setText(GetWareData(entry.ware, "name"))
				row[1].handlers.onSliderCellChanged = function (_, value) return menu.slidercellInventoryDrop(entry.ware, value) end
			end

			row = buttontable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText("")

			row = buttontable:addRow(true, { fixed = true })
			row[1]:createText(ReadText(1001, 7732))
			row[2]:setColSpan(2):createDropDown(options, { startOption = curOption })
			row[2].handlers.onDropDownConfirmed = menu.dropdownInventoryLockbox

			row = buttontable:addRow(true, { fixed = true })
			-- cancel button
			row[3]:createButton():setText(ReadText(1001, 64), { halign = "center" })
			row[3].handlers.onClick = menu.buttonInventoryCancel
		else
			row = buttontable:addRow(true, { fixed = true })
		end
		-- drop item button
		row[1]:createButton({ active = menu.inventoryData.mode == "drop", helpOverlayID = "playerinfo_inventory_drop", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText((menu.inventoryData.dropWares and (#menu.inventoryData.dropWares > 1)) and ReadText(1001, 7733) or ReadText(1001, 7705), { halign = "center" })
		row[1].handlers.onClick = menu.buttonInventoryDrop

		if menu.inventoryData.mode ~= "drop" then
			local hasillegalwares = false
			for ware in pairs(menu.inventory) do
				if menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction) then
					hasillegalwares = true
					break
				end
			end

			row = buttontable:addRow(true, { fixed = true })
			row[1]:createButton({ active = hasillegalwares, helpOverlayID = "playerinfo_inventory_dropallillegal", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 7734), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonInventoryDropAll(true) end
		end

		if isonline and (mode ~= "personalupgrade") then
			local headertable = menu.createInventoryHeader(frame, tableProperties)

			local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - headertable:getFullHeight() - Helper.borderSize - Helper.frameBorder
			infotable.properties.y = headertable.properties.y + headertable:getFullHeight() + Helper.borderSize
			buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
			infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

			headertable:addConnection(1, 2, true)
			infotable:addConnection(2, 2)
			buttontable:addConnection(3, 2)
		else
			local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
			buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
			infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

			infotable:addConnection(1, 2, true)
			buttontable:addConnection(2, 2)
		end

		-- media & description
		if menu.inventoryData.curEntry and next(menu.inventoryData.curEntry) then
			local width = narrowtablewidth
			local height = width
			if height > Helper.viewHeight / 2 then
				height = Helper.viewHeight / 2
				width = height
			end
			local mediaProperties = { width = width, x = Helper.viewWidth - width - Helper.frameBorder, height = height, y = tableProperties.y, clear = menu.inventoryData.clearRendertarget }
			menu.inventoryData.clearRendertarget = false

			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			menu.inventoryData.activatecutscene = true

			local descriptiontable = frame:addTable(1, { tabOrder = 0, width = width, x = Helper.viewWidth - width - Helper.frameBorder, y = tableProperties.y + height + Helper.borderSize })
			local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:createText(ReadText(1001, 2404), Helper.titleTextProperties)

			local row = descriptiontable:addRow(nil, { fixed = true })
			row[1]:createText(GetWareData(menu.inventoryData.curEntry[1], "description"), { wordwrap = true })
		end
	elseif menu.inventoryData.mode == "online" then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "registerOnlineEvents", menu)
			Helper.callExtensionFunction("multiverse", "createVenturePlayerInventory", menu, menu.infoFrame, "left", "playerinfo", tableProperties)
		end
	end
end

function menu.createInventoryHeader(frame, tableProperties)
	local categories = config.inventoryTabs

	menu.inventoryHeaderTable = frame:addTable(#categories + 1, { tabOrder = 1, x = tableProperties.x, y = tableProperties.y, width = tableProperties.width })
	local ftable = menu.inventoryHeaderTable

	local count = 1
	for i, entry in ipairs(categories) do
		if entry.showtab ~= false then
			if entry.empty then
				ftable:setColWidth(count, menu.sideBarWidth / 2, false)
			else
				ftable:setColWidth(count, menu.sideBarWidth, false)
			end
			count = count + 1
		end
	end

	local row = ftable:addRow("tabs", { fixed = true })
	local count = 1
	for _, entry in ipairs(categories) do
		if not entry.empty then
			local bgcolor = Color["row_title_background"]
			local color = Color["text_normal"]
			if entry.category == menu.inventoryData.mode then
				bgcolor = Color["row_background_selected"]
			end

			local loccount = count
			row[loccount]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false, helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText }):setIcon(entry.icon, { color = color})
			row[loccount].handlers.onClick = function () return menu.buttonInventorySubMode(entry.category, loccount) end
			count = count + 1
		end
	end

	if menu.selectedRows["inventoryHeaderTable"] then
		ftable.properties.defaultInteractiveObject = true
		ftable:setSelectedRow(menu.selectedRows["inventoryHeaderTable"])
		ftable:setSelectedCol(menu.selectedCols["inventoryHeaderTable"] or 0)
		menu.selectedRows["inventoryHeaderTable"] = nil
		menu.selectedCols["inventoryHeaderTable"] = nil
	end

	return ftable
end

function menu.createCrafting(frame, tableProperties)
	local infotable = frame:addTable(4, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(2, tableProperties.width / 8, false)
	infotable:setColWidth(3, tableProperties.width / 5, false)
	infotable:setColWidth(4, tableProperties.width / 5, false)
	infotable:setDefaultBackgroundColSpan(1, 4)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(4):createText(ReadText(1001, 7701), Helper.titleTextProperties)

	menu.inventory = GetPlayerInventory()
	menu.inventoryData.policefaction = GetComponentData(ConvertStringToLuaID(tostring(C.GetPlayerZoneID())), "policefaction")

	menu.craftable = {}
	if next(menu.inventory) then
		for ware, waredata in pairs(menu.inventory) do
			local ismodpart, isequipment = GetWareData(ware, "ismodpart", "isequipment")
			if (not ismodpart) and (not isequipment) then
				local hasproduction, products, issinglecraft, iscrafting = GetWareData(ware, "hasproductionmethod", "products", "issinglecraft", "iscrafting")
				if (not issinglecraft) or (waredata.amount < 1) then
					if iscrafting and hasproduction then
						menu.createCraftableEntry(ware)
					elseif next(products) then
						for _, product in ipairs(products) do
							menu.createCraftableEntry(product)
						end
					end
				end
			end
		end

		table.sort(menu.craftable, function (a, b) return a.data.name < b.data.name end)
	end

	if next(menu.craftable) then
		-- header
		row = infotable:addRow(ware, {  })
		row[1]:createText(ReadText(1001, 45))
		row[2]:createText(ReadText(1001, 1202), config.rightAlignTextProperties)
		row[3]:createText(ReadText(1001, 2413), config.rightAlignTextProperties)
		row[4]:createText(ReadText(1001, 2927), config.rightAlignTextProperties)

		-- entries
		for i, product in ipairs(menu.craftable) do
			AddKnownItem("productionmethods", GetWareData(product.ware, "productionmethod"))
			if product.resources.count > 0 then
				menu.addInventoryWareEntry(infotable, product.ware, product.data, true)
				for _, resource in ipairs(product.resources) do
					menu.addInventoryWareEntry(infotable, resource.ware, resource.data, true, true)
				end
			end
		end
	else
		row = infotable:addRow(true, {  })
		row[1]:setColSpan(4):createText("-- " .. ReadText(1001, 32) .. " --", { halign = "center" })
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- history & buttons
	local buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
	local row
	if menu.inventoryData.craftingHistory[1] then
		row = buttontable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 7707), Helper.titleTextProperties)

		for i = 1, math.min(3, #menu.inventoryData.craftingHistory) do
			local entry = menu.inventoryData.craftingHistory[i]

			row = buttontable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(entry.amount .. ReadText(1001, 42) .. " " .. entry.ware[2].name)
			row[3]:createText(Helper.convertGameTimeToXTimeString(entry.time), config.rightAlignTextProperties)
		end

		row = buttontable:addRow(nil, { fixed = true })
		row[1]:setColSpan(3):createText("")
	end
	if menu.inventoryData.mode == "craft" then
		row = buttontable:addRow(true, { fixed = true })

		local slidermax = menu.inventoryData.craftWare[2].craftable
		row[1]:setColSpan(3):createSliderCell({ height = Helper.standardButtonHeight, valueColor = Color["slider_value"], min = 0, minSelect = 1, max = slidermax, start = 1 }):setText(menu.inventoryData.craftWare[2].name)
		row[1].handlers.onSliderCellChanged = menu.slidercellInventoryCraft

		row = buttontable:addRow(true, { fixed = true })
		-- cancel button
		row[3]:createButton():setText(ReadText(1001, 64), { halign = "center" })
		row[3].handlers.onClick = menu.buttonInventoryCancel
	else
		row = buttontable:addRow(true, { fixed = true })
	end
	-- craft item button
	row[1]:createButton({ active = true }):setText(ReadText(1001, 7706), { halign = "center" })
	row[1].handlers.onClick = menu.buttonInventoryCraft

	infotable.properties.maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + infotable:getMaxVisibleHeight()

	infotable:addConnection(1, 2, true)
	buttontable:addConnection(2, 2)
end

function menu.createEquipmentMods(frame, tableProperties)
	-- STATUS
	local statustable = frame:addTable(1, { tabOrder = 0, width = tableProperties.width, x = tableProperties.x, y = 0 })

	local row = statustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText(ReadText(1001, 2427), Helper.titleTextProperties)

	local row = statustable:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 7715), { wordwrap = true })

	statustable.properties.maxVisibleHeight = statustable:getFullHeight()
	statustable.properties.y = tableProperties.y + tableProperties.height - statustable:getVisibleHeight() - Helper.frameBorder

	-- MOD LIST
	local infotable = frame:addTable(6, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = statustable.properties.y - tableProperties.y - Helper.borderSize })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, config.rowHeight, true)
	infotable:setColWidth(2, config.rowHeight, true)
	infotable:setColWidth(4, config.modCountColumnWidth)
	infotable:setColWidth(5, config.modCountColumnWidth)
	infotable:setColWidth(6, config.modCountColumnWidth)
	infotable:setDefaultBackgroundColSpan(2, 5)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(6):createText(ReadText(1001, 8031), Helper.titleTextProperties)

	menu.inventory = GetPlayerInventory()
	menu.modwares = {}
	local n = C.GetNumAvailableEquipmentMods()
	local buf = ffi.new("UIEquipmentMod[?]", n)
	n = C.GetAvailableEquipmentMods(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.ware = ffi.string(buf[i].Ware)

		local modclass, modquality, rawresources = GetWareData(entry.ware, "modclass", "modquality", "resources")
		entry.quality = modquality

		entry.resources = {}
		for _, resource in ipairs(rawresources or {}) do
			local resourcedata = menu.inventory[resource.ware]
			if resourcedata then
				local isprimarymodpart = GetWareData(resource.ware, "isprimarymodpart")
				local maxcraftable = math.floor(resourcedata.amount / resource.amount)
				entry.craftableamount = entry.craftableamount and math.min(maxcraftable, entry.craftableamount) or maxcraftable
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
			else
				local resourcename, resourcebuyprice, isprimarymodpart = GetWareData(resource.ware, "name", "buyprice", "isprimarymodpart")
				entry.craftableamount = 0
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
			end
		end

		if menu.modwares[modclass] then
			table.insert(menu.modwares[modclass], entry)
		else
			menu.modwares[modclass] = { entry }
		end
	end

	for _, entry in ipairs(config.equipmentModClasses) do
		local isclassexpanded = menu.isEquipmentModExpanded(entry.modclass, "")

		local qualitycounts = {
			[0] = 0, -- default value in ModDB, handle but don't use
			[1] = 0,
			[2] = 0,
			[3] = 0,
		}
		for _, modware in ipairs(menu.modwares[entry.modclass] or {}) do
			if modware.craftableamount > 0 then
				expandable = true
				qualitycounts[modware.quality] = qualitycounts[modware.quality] + 1
			end
		end

		local row = infotable:addRow(true, { bgColor = Color["row_background_blue"] })
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(isclassexpanded and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.expandWeaponMod(entry.modclass, "", row.index) end
		row[2]:setColSpan(2):createText(entry.name)
		for quality, entry2 in ipairs(Helper.modQualities) do
			row[quality + 3]:createText(qualitycounts[quality] .. " \27[" .. entry2.icon2 .. "]", config.rightAlignTextProperties)
		end

		if isclassexpanded then
			for _, property in ipairs(Helper.modProperties[entry.modclass]) do
				menu.createEquipmentPropertyEntry(infotable, entry.modclass, property)
			end
		end
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	infotable:addConnection(1, 2, true)
end

function menu.createEquipmentPropertyEntry(ftable, modclass, property)
	local isexpanded = menu.isEquipmentModExpanded(modclass, property.key)

	local expandable = false
	local modwares = {
		[0] = {}, -- default value in ModDB, handle but don't use
		[1] = {},
		[2] = {},
		[3] = {},
	}
	for _, modware in ipairs(menu.modwares[modclass] or {}) do
		local moddef = C.GetEquipmentModInfo(modware.ware)
		local propertytype = ffi.string(moddef.PropertyType)
		if propertytype == property.key then
			expandable = true
			table.insert(modwares[modware.quality], modware)
			if modware.craftableamount > 0 then
				modwares[modware.quality].iscraftable = true
			end
		end
	end
	table.sort(modwares[1], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	table.sort(modwares[2], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	table.sort(modwares[3], function (a, b) return GetWareData(a.ware, "name") < GetWareData(b.ware, "name") end)
	local color = Color["text_normal"]
	if not expandable then
		color = Color["text_inactive"]
	end

	local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
	row[1].properties.cellBGColor = Color["row_background"]
	row[2]:setBackgroundColSpan(1):createButton({ active = expandable, height = Helper.standardTextHeight }):setText(isexpanded and "-" or "+", { halign = "center" })
	row[2].handlers.onClick = function () return menu.expandWeaponMod(modclass, property.key, row.index) end
	row[3]:setBackgroundColSpan(4):createText(property.text, { color = color })
	local minusedcol = 7
	for quality, entry2 in ipairs(Helper.modQualities) do
		if modwares[quality].iscraftable then
			minusedcol = math.min(minusedcol, quality + 3)
			row[quality + 3]:createText("\27[" .. entry2.icon2 .. "]", { halign = "right", color = color })
		end
	end
	row[3]:setColSpan(minusedcol - 3)

	if isexpanded then
		local first = true
		for quality, entry2 in ipairs(Helper.modQualities) do
			if not first then
				ftable:addEmptyRow(config.rowHeight / 2)
			end
			first = false
			for i, modware in ipairs(modwares[quality]) do
				if i ~= 1 then
					ftable:addEmptyRow(config.rowHeight / 2)
				end
				menu.createEquipmentModEntry(ftable, modclass, modware)
			end
		end
	end
end

function menu.createEquipmentModEntry(ftable, modclass, moddata)
	-- mod name
	local row = ftable:addRow(true, { bgColor = Color["row_title_background"], interactive = false })
	row[1].properties.cellBGColor = Color["row_background"]
	row[2].properties.cellBGColor = Color["row_background"]
	row[3]:setColSpan(4):createText("    " .. "\27[" .. Helper.modQualities[moddata.quality].icon2 .. "]" .. GetWareData(moddata.ware, "shortname"), { color = Helper.modQualities[moddata.quality].color })
	-- Resources
	for _, resource in ipairs(moddata.resources) do
		local row = ftable:addRow(true, { interactive = false })
		local color = (resource.data.amount < resource.data.needed) and Color["text_inactive"] or Color["text_normal"]
		-- name
		row[3]:setColSpan(2):createText("       " .. resource.data.name, { color = color })
		-- amount
		row[5]:setColSpan(2):createText(resource.data.amount .. " / " .. resource.data.needed, { halign = "right", color = color })
	end
	-- Effects
	local row = ftable:addRow(true, { interactive = false })
	row[3]:setColSpan(4):createText("     " .. ReadText(1001, 8034) .. ReadText(1001, 120))
	-- Property
	local moddef = C.GetEquipmentModInfo(moddata.ware)
	local propertytype = ffi.string(moddef.PropertyType)
	for i, property in ipairs(Helper.modProperties[modclass]) do
		if property.key == propertytype then
			local minvalue = moddef["MinValue" .. property.type]
			local mineffectcolor = Color["text_normal"]
			if minvalue > property.basevalue then
				mineffectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
			elseif minvalue < property.basevalue then
				mineffectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
			end

			local maxvalue = moddef["MaxValue" .. property.type]
			local maxeffectcolor = Color["text_normal"]
			if maxvalue > property.basevalue then
				maxeffectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
			elseif maxvalue < property.basevalue then
				maxeffectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
			end

			local row = ftable:addRow(true, { interactive = false })
			row[3]:createText("       " .. property.text, { font = Helper.standardFontBold })
			if property.pos_effect and (minvalue < maxvalue) or (minvalue > maxvalue) then
				row[5]:setColSpan(2):createText(property.eval2(minvalue, mineffectcolor, maxvalue, maxeffectcolor), { font = Helper.standardFontBold, halign = "right" })
			else
				row[5]:setColSpan(2):createText(property.eval2(maxvalue, maxeffectcolor, minvalue, mineffectcolor), { font = Helper.standardFontBold, halign = "right" })
			end
			break
		end
	end
	-- Bonus properties
	if moddef.BonusMax > 0 then
		local mouseovertext = ReadText(1026, 8005) .. ReadText(1001, 120)
		for n = 1, moddef.BonusMax do
			-- n < n_max:
			-- p_n = p^n * (1-p)
			-- n == n_max:
			-- p_n_max = p^n_max
			local probability = ((moddef.BonusChance ^ n) * ((n ~= moddef.BonusMax) and (1 - moddef.BonusChance) or 1))
			mouseovertext = mouseovertext .. "\n" .. string.format("%+d %s%s %4.1f%%", n, ReadText(1001, 6602), ReadText(1001, 120), probability * 100)
		end

		local row = ftable:addRow(true, { interactive = false })
		row[3]:setColSpan(2):createText("       " .. ((moddef.BonusMax == 1) and ReadText(1001, 8039) or string.format(ReadText(1001, 8040), moddef.BonusMax)), { mouseOverText = mouseovertext })
		row[5]:setColSpan(2):createText("???", { halign = "right" })
	end
end

function menu.isEquipmentModExpanded(class, property)
	return menu.equipmentModsData.expandedProperties[class .. property]
end

function menu.expandWeaponMod(class, property, row)
	if menu.equipmentModsData.expandedProperties[class .. property] then
		menu.equipmentModsData.expandedProperties[class .. property] = nil
	else
		menu.equipmentModsData.expandedProperties[class .. property] = true
	end

	menu.refreshInfoFrame(nil, row)
end

function menu.isPersonnelExpanded(id)
	return menu.equipmentModsData.expandedProperties[tostring(id)]
end

function menu.expandPersonnel(id, row)
	if menu.equipmentModsData.expandedProperties[tostring(id)] then
		menu.equipmentModsData.expandedProperties[tostring(id)] = nil
	else
		menu.equipmentModsData.expandedProperties[tostring(id)] = true
	end

	if tostring(menu.personnelData.curEntry.id) ~= tostring(id) then
		menu.personnelData.curEntry = {}
	end
	menu.refreshInfoFrame(nil, row)
end

function menu.createFactions(frame, tableProperties)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize
	local iconheight = math.ceil(config.rowHeight * 1.5)
	local iconoffset = 2

	local infotable = frame:addTable(3, { tabOrder = 1, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })

	-- kuertee start: callback
	infotable:setDefaultCellProperties("text", {minRowHeight = config.rowHeight, fontsize = Helper.standardFontSize})
	infotable:setDefaultCellProperties("button", {height = config.rowHeight})
	-- kuertee end: callback

	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, Helper.scaleX(iconheight) + 2 * iconoffset, false)
	infotable:setColWidthPercent(3, 33)
	infotable:setDefaultBackgroundColSpan(1, 3)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 7703), Helper.titleTextProperties)
	row[1].properties.height = row[1].properties.height + Helper.borderSize

	-- cover override
	if Helper.isPlayerCovered() then
		local row = infotable:addRow(true, { fixed = true })
		row[1]:createCheckBox(C.IsUICoverOverridden(), { width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = ReadText(1026, 7713) })
		row[1].handlers.onClick = function(_, checked) C.SetUICoverOverride(checked); menu.refreshInfoFrame() end
		row[2]:setColSpan(2):createText(ReadText(1001, 11604), { mouseOverText = ReadText(1026, 7713) })
	end

	menu.relations = GetLibrary("factions")
	for i, relation in ipairs(menu.relations) do
		if relation.id == "player" then
			table.remove(menu.relations, i)
			break
		end
	end
	table.sort(menu.relations, Helper.sortName)
	menu.licences = {}
	for i, relation in ipairs(menu.relations) do
		menu.licences[relation.id] = GetOwnLicences(relation.id)
		table.sort(menu.licences[relation.id], menu.sortLicences)
	end

	if #menu.relations == 0 then
		row = infotable:addRow(true, {  })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 38) .. " ---", { halign = "center" })
	else
		for i, relation in ipairs(menu.relations) do
			local shortname = GetFactionData(relation.id, "shortname")
			row = infotable:addRow({ "faction", relation }, {  })
			row[1]:setBackgroundColSpan(3):createIcon((relation.icon ~= "") and relation.icon or "solid", {
				height = iconheight,
				x = iconoffset,
				color = function () return menu.relationColor(relation.id) end,
				mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end,
				helpOverlayID = "playerinfo_faction_" .. relation.id,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				helpOverlayUseBackgroundSpan = true,
			})
			row[2]:createText("[" .. shortname .. "] " .. relation.name, { fontsize = 14, color = function () return menu.relationColor(relation.id) end, y = 2 * iconoffset, minRowHeight = iconheight + 2 * iconoffset, mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end })
			row[3]:createText(
				function () return string.format("%+d", GetUIRelation(relation.id)) end,
				{ font = Helper.standardFontMono, color = function () return menu.relationColor(relation.id) end, fontsize = 14, halign = "right", y = 2 * iconoffset, mouseOverText = function () local prioritizedrelationrangename = GetFactionData(relation.id, "prioritizedrelationrangename"); return prioritizedrelationrangename end })
		end
	end
	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- faction details
	local detailtable = frame:addTable(3, { tabOrder = 2, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = infotable.properties.y, highlightMode = "grey" })
	detailtable:setColWidth(1, 2 * Helper.titleHeight)

	local relation = menu.factionData.curEntry

	AddUITriggeredEvent(menu.name, menu.mode, menu.factionData.curEntry.id)

	local row = detailtable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setBackgroundColSpan(3):createText(next(relation) and ("\27[" .. relation.icon .. "]") or "", Helper.titleTextProperties)
	local name
	if next(relation) then
		local shortname = GetFactionData(relation.id, "shortname")
		name = "[" .. shortname .. "] " .. relation.name
	end
	row[2]:setColSpan(2):createText(name, Helper.titleTextProperties)
	row[2].properties.height = row[2].properties.height + Helper.borderSize

	if next(relation) then
		local isrelationlocked, relationlockreason, willclaimspace = GetFactionData(relation.id, "isrelationlocked", "relationlockreason", "willclaimspace")
		-- sector ownership
		if not willclaimspace then
			local row = detailtable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7784))

			detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		-- kuertee start: callback
		if menu.uix_callbacks ["createFactions_on_before_render_licences"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createFactions_on_before_render_licences"]) do
				uix_callback (frame, tableProperties, relation.id, detailtable)
			end
		end
		-- kuertee end: callback

		-- licences
		if menu.licences[relation.id] and #menu.licences[relation.id] > 0 then
			local row = detailtable:addRow(nil, {  })
			row[1]:setBackgroundColSpan(3):setColSpan(2):createText(ReadText(1001, 62), Helper.subHeaderTextProperties)
			row[3]:createText(ReadText(1001, 7748), Helper.subHeaderTextProperties)
			row[3].properties.halign = "right"

			for i, licence in ipairs(menu.licences[relation.id]) do
				local row = detailtable:addRow({ "licence", licence.id }, {  })
				local color = Color["text_inactive"]
				if HasLicence("player", licence.type, relation.id) then
					color = Color["text_normal"]
				end
				local name = licence.name
				if licence.precursor then
					name = "    " .. name
				end
				local info
				if licence.price > 0 then
					info = ConvertMoneyString(licence.price, false, true, 0, true) .. " " .. ReadText(1001, 101)
				elseif not licence.precursor then
					info = string.format("%+d", licence.minrelation)
				end
				row[2]:setBackgroundColSpan(2):createText(name, {
					color = color,
					mouseOverText = licence.desc,
					helpOverlayID = "playerinfo_factionlicense_" .. licence.id,
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
					helpOverlayUseBackgroundSpan = true,
				})
				row[3]:createText(info, { halign = "right", color = color })
				AddKnownItem("licences", licence.id)
			end

			detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		end
		-- relation
		local row = detailtable:addRow(nil, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 7749), Helper.subHeaderTextProperties)

		local row = detailtable:addRow(true, {  })
		row[2]:setColSpan(2):createText(ffi.string(C.GenerateFactionRelationText(relation.id)), {
			helpOverlayID = "playerinfo_faction_relation",
			helpOverlayText = " ",
			helpOverlayHighlightOnly = true,
		})

		detailtable:addEmptyRow(Helper.standardTextHeight / 2)
		-- war declaration
		local row = detailtable:addRow(true, {  })
		local active = true
		local mouseovertext
		if GetUIRelation(relation.id) <= -25 then
			active = false
			mouseovertext = ReadText(1026, 7702)
		elseif isrelationlocked then
			active = false
			mouseovertext = (relationlockreason ~= "") and relationlockreason or ReadText(20229, 100)
		end
		row[3]:createButton({ active = active, mouseOverText = mouseovertext }):setText(ReadText(1001, 7750), { halign = "center" })
		row[3].handlers.onClick = function () return menu.buttonWarDeclarationConfirm(relation.id) end

		-- kuertee start: callback
		if menu.uix_callbacks ["createFactions_on_after_declare_war_button"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createFactions_on_after_declare_war_button"]) do
				uix_callback (frame, tableProperties, relation.id, detailtable)
			end
		end
		-- kuertee end: callback
	end

	infotable:addConnection(1, 2, true)
	detailtable:addConnection(1, 3, true)
end

function menu.sortLicences(a, b)
	if a.minrelation == b.minrelation then
		if a.precursor == b.precursor then
			if a.price == b.price then
				return a.name < b.name
			end
			return a.price < b.price
		end
		return (not a.precursor) and b.precursor
	end
	return a.minrelation < b.minrelation
end

function menu.relationColor(faction)
	if GetFactionData(faction, "ishostile") then
		return Color["text_hostile"]
	elseif GetFactionData(faction, "isenemy") then
		return Color["text_enemy"]
	else
		return Color["text_normal"]
	end
end

function menu.createStats(frame, tableProperties)
	local infotable = frame:addTable(2, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, highlightMode = "grey" })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, 2 * tableProperties.width / 3, false)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(2):createText(ReadText(1001, 2500), Helper.titleTextProperties)

	local stats = GetAllStatIDs()
	for i = 1, #stats do
		local hidden, displayname = GetStatData(stats[i], "hidden", "displayname")
		if not hidden then
			row = infotable:addRow(stats[i], {})
			row[1]:createText(displayname)
			row[2]:createText(function () return GetStatData(stats[i], "displayvalue") end, { halign = "right", font = Helper.standardFontMono })
		end
	end
	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	infotable:addConnection(1, 2, true)
end

function menu.findAccountTransaction(station)
	for i, transaction in ipairs(menu.accountData.transactions) do
		if IsSameComponent(transaction.station, station) then
			return transaction.amount, i
		end
	end

	return 0
end

function menu.getAccountPlayerMoney()
	local playermoney = GetPlayerMoney()
	for _, transaction in ipairs(menu.accountData.transactions) do
		playermoney = playermoney + transaction.amount
	end
	return playermoney
end

function menu.createAccounts(frame, tableProperties, tabOrderOffset)
	if not tabOrderOffset then
		tabOrderOffset = 0
	end
	local infotable = frame:addTable(5, { tabOrder = 1 + tabOrderOffset, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidthPercent(1, 25)

	-- title
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(5):createText(ReadText(1001, 7708), Helper.titleTextProperties)

	row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setBackgroundColSpan(5)
	row[2]:createText(ReadText(1001, 7773), { font = Helper.standardFontBold })
	row[5]:createText(ReadText(1001, 6509), { font = Helper.standardFontBold })

	local playermoney = menu.getAccountPlayerMoney()

	menu.accountData.stations = GetContainedStationsByOwner("player", nil, true)
	table.sort(menu.accountData.stations, Helper.sortComponentName)

	menu.accountData.buildstorages = GetContainedBuildStoragesByOwner("player")
	for i = #menu.accountData.buildstorages, 1, -1 do
		if GetComponentData(menu.accountData.buildstorages[i], "basestation") then
			table.remove(menu.accountData.buildstorages, i)
		end
	end
	table.sort(menu.accountData.buildstorages, Helper.sortComponentName)

	if (#menu.accountData.stations > 0) or (#menu.accountData.buildstorages > 0) then
		for i, station in ipairs(menu.accountData.stations) do
			if i ~= 1 then
				infotable:addEmptyRow()
			end

			local name, sector, stationmoney, productionmoney, buildstorage = GetComponentData(station, "name", "sector", "money", "productionmoney", "buildstorage")
			local station64 = ConvertIDTo64Bit(station)
			-- station name
			local mouseovertext = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. sector
			local row = infotable:addRow(false, { bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(5):createText(name .. " (" .. ffi.string(C.GetObjectIDCode(station64)) .. ")", Helper.subHeaderTextProperties)
			row[1].properties.color = menu.holomapcolor.playercolor
			row[1].properties.mouseOverText = mouseovertext

			if stationmoney then
				-- station account
				local transaction = menu.findAccountTransaction(station)
				local row = infotable:addRow(true, {  })
				row[1]:createText(ReadText(1001, 7710) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				row[2]:createText(ConvertMoneyString(stationmoney - transaction, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				row[3]:setColSpan(2):createSliderCell({ min = math.min((-playermoney + transaction), transaction), max = math.max(stationmoney, transaction), start = transaction, fromCenter = true, suffix = ReadText(1001, 101), height = config.rowHeight })
				row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellAccountChanged(station, row.index, value, infotable.id) end
				row[3].handlers.onSliderCellConfirm = function () menu.refreshdata = { nil, nil, "accounts", row.index } menu.refresh = getElapsedTime() + 0.1 end
				row[5]:createText(ConvertMoneyString(playermoney, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "left" })

				-- station estimated budget
				local supplymoney = tonumber(C.GetSupplyBudget(station64)) / 100
				local tradewaremoney = tonumber(C.GetTradeWareBudget(station64)) / 100
				local row = infotable:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9434) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				local mouseovertext =	ReadText(1001, 8420) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(productionmoney, false, true, 0, true)	.. " " .. ReadText(1001, 101) .. "\n" ..
										ReadText(1001, 8423) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(supplymoney, false, true, 0, true)		.. " " .. ReadText(1001, 101) .. "\n" ..
										ReadText(1001, 8447) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tradewaremoney, false, true, 0, true)	.. " " .. ReadText(1001, 101)
				row[2]:createText(ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })
				row[5]:createButton({ active = function () local money, estimate = GetComponentData(station64, "money", "productionmoney"); estimate = estimate + tonumber(C.GetSupplyBudget(station64)) / 100 + tonumber(C.GetTradeWareBudget(station64)) / 100; return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })
				row[5].handlers.onClick = function () return menu.buttonAccountToEstimate(station) end

				infotable:addEmptyRow(Helper.standardTextHeight / 2)
			end

			-- buildstorage account
			if buildstorage then
				local buildstorage64 = ConvertIDTo64Bit(buildstorage)
				local buildstoragemoney, wantedmoney = GetComponentData(buildstorage64, "money", "wantedmoney")

				local transaction = menu.findAccountTransaction(buildstorage)
				local row = infotable:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9429) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				row[2]:createText(ConvertMoneyString(buildstoragemoney - transaction, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				row[3]:setColSpan(2):createSliderCell({ min = math.min((-playermoney + transaction), transaction), max = math.max(buildstoragemoney, transaction), start = transaction, fromCenter = true, suffix = ReadText(1001, 101), height = config.rowHeight })
				row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellAccountChanged(buildstorage, row.index, value, infotable.id) end
				row[3].handlers.onSliderCellConfirm = function () menu.refreshdata = { nil, nil, "accounts", row.index } menu.refresh = getElapsedTime() + 0.1 end
				row[5]:createText(ConvertMoneyString(playermoney, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "left" })

				-- buildstorage estimated budget
				local row = infotable:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9436) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
				row[2]:createText(ConvertMoneyString(wantedmoney, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				row[5]:createButton({ active = function () local money, estimate = GetComponentData(buildstorage64, "money", "wantedmoney"); return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })
				row[5].handlers.onClick = function () return menu.buttonAccountToEstimate(buildstorage, true) end
			end
		end
		for i, buildstorage in ipairs(menu.accountData.buildstorages) do
			if (i ~= 1) or (#menu.accountData.stations > 0) then
				infotable:addEmptyRow()
			end

			local name, sector, buildstoragemoney, wantedmoney = GetComponentData(buildstorage, "name", "sector", "money", "wantedmoney")

			-- station name
			local mouseovertext = ReadText(20001, 201) .. ReadText(1001, 120) .. " " .. sector
			local row = infotable:addRow(false, { bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(5):createText(name .. " (" .. ffi.string(C.GetObjectIDCode(ConvertIDTo64Bit(buildstorage))) .. ")", Helper.subHeaderTextProperties)
			row[1].properties.color = menu.holomapcolor.playercolor
			row[1].properties.mouseOverText = mouseovertext

			local transaction = menu.findAccountTransaction(buildstorage)
			local row = infotable:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9429) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
			row[2]:createText(ConvertMoneyString(buildstoragemoney - transaction, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "right" })
			row[3]:setColSpan(2):createSliderCell({ min = math.min((-playermoney + transaction), transaction), max = math.max(buildstoragemoney, transaction), start = transaction, fromCenter = true, suffix = ReadText(1001, 101), height = config.rowHeight })
			row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellAccountChanged(buildstorage, row.index, value, infotable.id) end
			row[3].handlers.onSliderCellConfirm = function () menu.refreshdata = { nil, nil, "accounts", row.index } menu.refresh = getElapsedTime() + 0.1 end
			row[5]:createText(ConvertMoneyString(playermoney, false, true, nil, true) .. " " .. ReadText(1001, 101), { halign = "left" })

			-- buildstorage estimated budget
			local row = infotable:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9436) .. ReadText(1001, 120), { x = Helper.standardTextHeight })
			row[2]:createText(ConvertMoneyString(wantedmoney, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
			row[5]:createButton({ active = function () local money, estimate = GetComponentData(buildstorage, "money", "wantedmoney"); return (money + GetPlayerMoney()) > estimate end }):setText(ReadText(1001, 7965), { halign = "center", fontsize = config.mapFontSize })
			row[5].handlers.onClick = function () return menu.buttonAccountToEstimate(buildstorage, true) end
		end
	else
		local row = infotable:addRow(true, {  })
		row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 33) .. " ---", { halign = "center" })
	end

	infotable:setTopRow(menu.settoprow)
	if not menu.setselectedrow2 then
		infotable:setSelectedRow(menu.setselectedrow)
	else
		infotable:setSelectedRow(menu.setselectedrow2)
	end
	menu.settoprow = nil
	menu.setselectedrow = nil
	menu.setselectedrow2 = nil

	local buttontable = frame:addTable(3, { tabOrder = 2 + tabOrderOffset, borderEnabled = false, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })

	local row = buttontable:addRow(false, { fixed = true })
	row[1]:setColSpan(3):createText("")

	local row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createButton({ active = #menu.accountData.transactions > 0 }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonAccountConfirm
	row[2]:createButton():setText(ReadText(1001, 3318), { halign = "center" })
	row[2].handlers.onClick = menu.buttonAccountCancel
	row[3]:createButton():setText(ReadText(1001, 7779), { halign = "center" })
	row[3].handlers.onClick = menu.buttonAccountAllEstimates

	local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
	infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

	infotable:addConnection(1, 2, true)
	buttontable:addConnection(2, 2)

	return infotable, buttontable
end

function menu.logbookSearchHelper(entry, text)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.title), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.text), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.entityname), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.factionname), text, 1, true) then
		return true
	end

	return false
end

function menu.createLogbookHeader(frame, tableProperties)
	local isonline = C.AreVenturesCompatible()

	local count = 0
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			count = count + 1
		end
	end

	local numcols = count + 1
	local titletable = frame:addTable(numcols, { tabOrder = 2, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			if entry.empty then
				titletable:setColWidth(i, menu.sideBarWidth / 2, false)
			else
				titletable:setColWidth(i, menu.sideBarWidth, false)
			end
		end
	end

	-- title
	local row = titletable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numcols):createText(ReadText(1001, 5700), Helper.titleTextProperties)
	-- categories
	local row = titletable:addRow(true, { fixed = true })
	for i, entry in ipairs(config.logbookCategories) do
		if (entry.online == nil) or (entry.online == isonline) then
			if not entry.empty then
				local bgcolor = Color["row_title_background"]
				local color = Color["text_normal"]
				if entry.mode == menu.logbookData.category then
					bgcolor = Color["row_background_selected"]
				end

				row[i]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false }):setIcon(entry.icon, { color = color})
				row[i].handlers.onClick = function () return menu.buttonLogbookCategory(entry.name, entry.mode, i) end
			end
		end
	end

	if menu.setselectedcol then
		titletable:setSelectedCol(menu.setselectedcol)
		menu.setselectedcol = nil
	end

	return titletable
end

function menu.createLogbook(frame, tableProperties)
	local isonline = Helper.isOnlineGame()
	if not isonline then
		if menu.logbookData.category == "online" then
			menu.logbookData.hasExtension = "all"
		end
	end

	if menu.logbookData.category == "online" then
		if Helper.hasExtension("multiverse") then
			Helper.callExtensionFunction("multiverse", "createVentureLogbook", menu, menu.infoFrame, "left", "playerinfo", tableProperties)
		end
	else
		local titletable = menu.createLogbookHeader(frame, tableProperties)

		-- entries
		local buttonsize = Helper.scaleY(config.rowHeight)
		local infotable = frame:addTable(10, { tabOrder = 1, width = tableProperties.width, x = tableProperties.x, y = titletable.properties.y + titletable:getFullHeight() + 2 * Helper.borderSize, maxVisibleHeight = tableProperties.height - titletable:getFullHeight() - Helper.borderSize })
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(1, tableProperties.width / 3, false)
		infotable:setColWidth(4, config.rowHeight)
		infotable:setColWidth(5, config.rowHeight)
		infotable:setColWidth(6, config.rowHeight)
		infotable:setColWidth(7, config.rowHeight)
		infotable:setColWidth(8, tableProperties.width / 3 - 4 * (buttonsize + Helper.borderSize), false)
		infotable:setColWidth(9, config.rowHeight)
		infotable:setColWidth(10, config.rowHeight)

		-- entries
		menu.logbookData.numEntries = 0
		if menu.logbookData.category == "ticker" then
			menu.logbookData.numEntries = C.GetNumTickerCache("")
		else
			menu.logbookData.numEntries = GetNumLogbook(menu.logbookData.category)
		end
		if menu.logbookData.searchtext ~= "" then
			menu.logbook = {}
			for i = 1, math.ceil(menu.logbookData.numEntries / config.logbookQueryLimit) do
				local numQuery = math.min(config.logbookQueryLimit, menu.logbookData.numEntries - (i - 1) * config.logbookQueryLimit)
				if menu.logbookData.category == "ticker" then
					local buf = ffi.new("TickerCacheEntry[?]", numQuery)
					local n = C.GetTickerCache(buf, numQuery, (i - 1) * config.logbookQueryLimit + 1, numQuery, "");
					for j = 0, n - 1 do
						local entry = {
							time = buf[j].time,
							category = ffi.string(buf[j].category),
							title = ffi.string(buf[j].title),
							text = ffi.string(buf[j].text),
							factionname = "",
							entityname = "",
							money = 0,
							bonus = 0,
						}

						if menu.logbookSearchHelper(entry, menu.logbookData.searchtext) then
							table.insert(menu.logbook, entry)
						end
					end
				else
					local logbook = GetLogbook((i - 1) * config.logbookQueryLimit + 1, numQuery, menu.logbookData.category) or {}
					if #logbook > 0 then
						for _, entry in ipairs(logbook) do
							if menu.logbookSearchHelper(entry, menu.logbookData.searchtext) then
								table.insert(menu.logbook, entry)
							end
						end
					end
				end
			end

			menu.logbookData.numEntries = #menu.logbook
			if menu.logbookData.numEntries <= config.logbookPage then
				menu.logbookData.curPage = 1
			else
				local startIndex = menu.logbookData.numEntries - config.logbookPage * menu.logbookData.curPage + 1
				local endIndex = config.logbookPage + startIndex - 1
				if startIndex < 1 then
					startIndex = 1
				end
				menu.logbook = { table.unpack(menu.logbook, startIndex, endIndex) }
			end
		else
			local startIndex = 1
			local numQuery = math.min(config.logbookPage, menu.logbookData.numEntries)
			if menu.logbookData.numEntries <= config.logbookPage then
				menu.logbookData.curPage = 1
			else
				startIndex = menu.logbookData.numEntries - config.logbookPage * menu.logbookData.curPage + 1
				if startIndex < 1 then
					numQuery = config.logbookPage + startIndex - 1
					startIndex = 1
				end
			end
			if menu.logbookData.category == "ticker" then
				menu.logbook = {}
				local buf = ffi.new("TickerCacheEntry[?]", numQuery)
				local n = C.GetTickerCache(buf, numQuery, startIndex, numQuery, "");
				for j = 0, n - 1 do
					local entry = {
						time = buf[j].time,
						category = ffi.string(buf[j].category),
						title = ffi.string(buf[j].title),
						text = ffi.string(buf[j].text),
						factionname = "",
						entityname = "",
						money = 0,
						bonus = 0,
					}

					table.insert(menu.logbook, entry)
				end
			else
				menu.logbook = GetLogbook(startIndex, numQuery, menu.logbookData.category) or {}
			end
		end
		menu.logbookData.numPages = math.max(1, math.ceil(menu.logbookData.numEntries / config.logbookPage))

		-- category title / pages
		local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(10):createText(menu.logbookData.name, {
			scaling = false,
			font = Helper.titleFont,
			fontsize = Helper.scaleFont(Helper.titleFont, Helper.standardFontSize),
			height = Helper.scaleY(Helper.subHeaderHeight),
			cellBGColor = Color["row_background"],
			titleColor = Color["row_title"],
		})
		row[1].properties.x = (tableProperties.width - math.ceil(C.GetTextWidth(menu.logbookData.name, Helper.titleFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))) / 2
		row = infotable:addRow(true, { fixed = true })
		row[1]:setColSpan(3):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250) }):setText(menu.logbookData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.logbookData.searchtext then menu.logbookData.searchtext = text; menu.noupdate = nil; menu.refreshInfoFrame() end end

		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[4]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[4].handlers.onClick = function () menu.logbookData.searchtext = ""; menu.refreshInfoFrame() end

		row[5]:createButton({ scaling = false, active = menu.logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[5].handlers.onClick = function () menu.logbookData.curPage = 1; menu.refreshInfoFrame() end
		row[6]:createButton({ scaling = false, active = menu.logbookData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[6].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.curPage - 1; menu.refreshInfoFrame() end
		menu.logbookPageEditBox = row[7]:setColSpan(2):createEditBox({ description = ReadText(1001, 7739) }):setText(menu.logbookData.curPage .. " / " .. menu.logbookData.numPages, { halign = "center" })
		row[7].handlers.onEditBoxDeactivated = menu.editboxLogbookPage
		row[9]:createButton({ scaling = false, active = menu.logbookData.curPage < menu.logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[9].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.curPage + 1; menu.refreshInfoFrame() end
		row[10]:createButton({ scaling = false, active = menu.logbookData.curPage < menu.logbookData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
		row[10].handlers.onClick = function () menu.logbookData.curPage = menu.logbookData.numPages; menu.refreshInfoFrame() end

		infotable:addEmptyRow(Helper.standardTextHeight / 2)

		if #menu.logbook > 0 then
			for i = #menu.logbook, 1, -1 do
				local entry = menu.logbook[i]
				local textcolor = entry.highlighted and Color["text_logbook_highlight"] or Color["text_normal"]
				row = infotable:addRow(true, { borderBelow = false })
				if entry.interaction and IsValidComponent(entry.interactioncomponent) then
					local mouseoverobject = entry.interactioncomponent
					if IsComponentClass(mouseoverobject, "zone") and not IsComponentClass(mouseoverobject, "highway") then
						mouseoverobject = GetContextByClass(mouseoverobject, "sector")
					end
					row[1]:setColSpan(9):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
					row[10]:createButton({ scaling = false, bgColor = Color["button_background_hidden"], mouseOverText = string.format(entry.interactiontext, GetComponentData(mouseoverobject, "name")), height = buttonsize }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize })
					row[10].handlers.onClick = function () return menu.buttonLogbookInteraction(entry) end
				else
					row[1]:setColSpan(10):createText(entry.title, { font = Helper.standardFontBold, color = textcolor, wordwrap = true })
				end

				if (entry.entityname ~= "") or (entry.factionname ~= "") then
					row = infotable:addRow(false, { borderBelow = false })
					if entry.entityname ~= "" then
						row[1]:setColSpan(2):createText(ReadText(1001, 5711) .. " " .. entry.entityname, { x = config.rowHeight })
					end
					row[3]:setColSpan(8):createText(entry.factionname, config.rightAlignTextProperties)
				end

				if entry.text ~= "" then
					row = infotable:addRow(false, { borderBelow = false })
					row[1]:setColSpan(10):createText(entry.text, { x = config.rowHeight, color = textcolor, wordwrap = true })
				end

				row = infotable:addRow(false, {  })
				row[1]:setColSpan(2):createText(Helper.getPassedTime(entry.time), { mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.rowHeight })
				local moneystring = ""
				if entry.money ~= 0 then
					local moneycolor = (entry.money >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. Helper.convertColorToText(moneycolor) .. ((entry.bonus >= 0) and "+" or "-") .. ConvertMoneyString(entry.money, false, true, nil, true) .. " " .. ReadText(1001, 101)
				end
				if entry.bonus ~= 0 then
					local bonuscolor = (entry.bonus >= 0) and Color["text_positive"] or Color["text_negative"]
					moneystring = moneystring .. " " .. Helper.convertColorToText(bonuscolor) .. "(" .. ((entry.bonus >= 0) and "+" or "-") .. " " .. ReadText(1001, 5712) .. " " .. ConvertMoneyString(entry.bonus, false, true, nil, true) .. " " .. ReadText(1001, 101) .. ")"
				end
				row[3]:setColSpan(8):createText(moneystring, config.rightAlignTextProperties)

				if i ~= 1 then
					row = infotable:addRow(false, { bgColor = Color["row_title"] })
					row[1]:setColSpan(10):createText("", { fontsize = 1, minRowHeight = 1 })
				end
			end
		else
			row = infotable:addRow(false, {  })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		infotable:setSelectedRow(menu.setselectedrow)
		menu.settoprow = nil
		menu.setselectedrow = nil

		local buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = false, width = tableProperties.width, x = tableProperties.x, y = infotable.properties.y })

		local row = buttontable:addRow(false, { fixed = true })
		row[1]:setColSpan(3):createText("")

		local row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createButton():setText(ReadText(1001, 5722), { halign = "center" })
		row[1].handlers.onClick = menu.buttonLogbookClearQuestion

		local maxVisibleHeight = infotable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
		buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
		infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

		titletable:addConnection(1, 2, true)
		infotable:addConnection(2, 2)
		buttontable:addConnection(3, 2)

		local width = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize
		local descriptiontable = frame:addTable(1, { tabOrder = 0, width = width, x = Helper.viewWidth - width - Helper.frameBorder, y = Helper.viewHeight * 4 / 5 })
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:createText(ReadText(1001, 2427), Helper.titleTextProperties)

		local row = descriptiontable:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 5726), { wordwrap = true })
	end
end

function menu.messageHelper(numQuery, startIdx, category)
	local buf = ffi.new("MessageInfo[?]", numQuery)
	numQuery = C.GetMessages(buf, numQuery, startIdx, numQuery, category)
	returnvalue = {}
	for i = 0, numQuery - 1 do
		local entry = {}

		entry.id					= buf[i].id
		entry.time					= buf[i].time
		entry.category				= ffi.string(buf[i].category)
		entry.title					= ffi.string(buf[i].title)
		entry.text					= ffi.string(buf[i].text)
		entry.source				= ffi.string(buf[i].source)
		entry.sourcecomponent		= buf[i].sourcecomponent
		entry.interaction			= ffi.string(buf[i].interaction)
		entry.interactioncomponent	= buf[i].interactioncomponent
		entry.interactiontext		= ffi.string(buf[i].interactiontext)
		entry.interactionshorttext	= ffi.string(buf[i].interactionshorttext)
		local posrot = C.GetMessageInteractPosition(entry.id)
		entry.interactionposition	= { x = posrot.x, y = posrot.y, z = posrot.z }
		entry.cutscenekey			= ffi.string(buf[i].cutscenekey)
		entry.entityname			= ffi.string(buf[i].entityname)
		entry.factionname			= ffi.string(buf[i].factionname)
		entry.money					= buf[i].money
		entry.bonus					= buf[i].bonus
		entry.highlighted			= buf[i].highlighted
		entry.isread				= buf[i].isread

		table.insert(returnvalue, entry)
	end

	return returnvalue
end

function menu.messageCategoryIcon(entry)
	local numentries = C.GetNumMessages(entry.mode, true)
	return (numentries > 0) and entry.icon_unread or entry.icon
end

function menu.messageSidebarIcon()
	for i, entry in ipairs(config.messageCategories) do
		local numentries = C.GetNumMessages(entry.mode, true)
		if numentries > 0 then
			return entry.icon_unread
		end
	end
	-- if there are no unread messages, use the normal icon of the last category
	return config.messageCategories[#config.messageCategories].icon
end

function menu.messageSidebarIconColor()
	for i, entry in ipairs(config.messageCategories) do
		local numentries = C.GetNumMessages(entry.mode, true)
		if numentries > 0 then
			local period = 10
			local effectduration = 2
			local effectrepeat = 2

			-- number between 0 and period
			local x = getElapsedTime() % period

			if x <= effectduration then
				-- number between 0 and 1
				x = (x * effectrepeat / effectduration) % 1

				normalcolor = Color["text_normal"]
				overridecolor = Color["text_mission"]
				local color = {
					r = (1 - x) * overridecolor.r + x * normalcolor.r,
					g = (1 - x) * overridecolor.g + x * normalcolor.g,
					b = (1 - x) * overridecolor.b + x * normalcolor.b,
					a = (1 - x) * overridecolor.a + x * normalcolor.a,
				}
				return color
			end
		end
	end
	-- if there are no unread messages, use the normal icon color
	return Color["text_normal"]
end

function menu.createMessages(frame, tableProperties)
	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	local infotable, buttontable, titletable, detailtable, interacttable
	if not menu.messageData.showFullscreen then
		-- entries
		local buttonsize = Helper.scaleY(config.rowHeight)
		infotable = frame:addTable(10, { tabOrder = 1, width = narrowtablewidth, x = tableProperties.x, y = 0, maxVisibleHeight = tableProperties.height })
		if menu.setdefaulttable then
			infotable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		infotable:setColWidth(1, narrowtablewidth / 3, false)
		infotable:setColWidth(4, config.rowHeight)
		infotable:setColWidth(5, config.rowHeight)
		infotable:setColWidth(6, config.rowHeight)
		infotable:setColWidth(7, config.rowHeight)
		infotable:setColWidth(8, narrowtablewidth / 3 - 4 * (buttonsize + Helper.borderSize), false)
		infotable:setColWidth(9, config.rowHeight)
		infotable:setColWidth(10, config.rowHeight)

		-- entries
		menu.messageData.numEntries = C.GetNumMessages(menu.messageData.category, false)
		if menu.messageData.searchtext ~= "" then
			menu.messages = {}
			for i = 1, math.ceil(menu.messageData.numEntries / config.logbookQueryLimit) do
				local numQuery = math.min(config.logbookQueryLimit, menu.messageData.numEntries - (i - 1) * config.logbookQueryLimit)
				local startIdx = (i - 1) * config.logbookQueryLimit + 1
				local messages = menu.messageHelper(numQuery, startIdx, menu.messageData.category)

				if #messages > 0 then
					for _, entry in ipairs(messages) do
						if menu.logbookSearchHelper(entry, menu.messageData.searchtext) then
							table.insert(menu.messages, entry)
						end
					end
				end
			end

			menu.messageData.numEntries = #menu.messages
		else
			local numQuery = math.min(config.logbookQueryLimit, menu.messageData.numEntries)
			local startIdx = menu.messageData.numEntries - numQuery + 1
			menu.messages = menu.messageHelper(numQuery, startIdx, menu.messageData.category)
		end

		-- category title / pages
		local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(10):createText(menu.messageData.name, {
			font = Helper.titleFont,
			fontsize = Helper.standardFontSize,
			height = Helper.subHeaderHeight,
			cellBGColor = Color["row_background"],
			titleColor = Color["row_title"],
			halign = "center",
		})

		local row = infotable:addRow(true, { fixed = true })
		row[1]:setColSpan(9):createEditBox({ description = ReadText(1001, 7740), defaultText = ReadText(1001, 3250) }):setText(menu.messageData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.messageData.searchtext then menu.messageData.searchtext = text; menu.noupdate = nil; menu.refreshInfoFrame() end end
		local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
		row[10]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setText("X", { halign = "center", font = Helper.standardFontBold })
		row[10].handlers.onClick = function () menu.messageData.searchtext = ""; menu.refreshInfoFrame() end

		infotable:addEmptyRow(Helper.standardTextHeight / 2)

		local numunread = 0
		if #menu.messages > 0 then
			for i = #menu.messages, 1, -1 do
				local entry = menu.messages[i]
				if not entry.isread then
					numunread = numunread + 1
				end
				local font = entry.isread and Helper.standardFont or Helper.standardFontBold
				local textcolor = entry.highlighted and Color["text_logbook_highlight"] or Color["text_normal"]
				row = infotable:addRow(entry, { borderBelow = false })
				if entry.id == menu.messageData.curEntry.id then
					infotable:setSelectedRow(row.index)
				end

				row[1]:setColSpan(6):createText(entry.title, { font = font, color = textcolor, wordwrap = true })
				row[7]:setColSpan(4):createText(Helper.getPassedTime(entry.time), { font = font, mouseOverText = Helper.convertGameTimeToXTimeString(entry.time), x = config.rowHeight, halign = "right" })
			end
		else
			row = infotable:addRow(false, {  })
			row[1]:setColSpan(10):createText("--- " .. ReadText(1001, 5705) .. " ---", { halign = "center" })
		end

		infotable:setTopRow(menu.settoprow)
		menu.settoprow = nil

		-- buttons
		buttontable = frame:addTable(3, { tabOrder = 2, borderEnabled = false, width = narrowtablewidth, x = tableProperties.x, y = infotable.properties.y })

		local row = buttontable:addRow(false, { fixed = true })
		row[1]:setColSpan(3):createText("")

		local row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		row[3]:createButton({ active = numunread > 0 }):setText(ReadText(1001, 7744), { halign = "center" })
		row[3].handlers.onClick = menu.buttonMessagesRead

		local numcols = #config.messageCategories + 1
		titletable = frame:addTable(numcols, { tabOrder = 2, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })
		for i, entry in ipairs(config.messageCategories) do
			if entry.empty then
				titletable:setColWidth(i, menu.sideBarWidth / 2, false)
			else
				titletable:setColWidth(i, menu.sideBarWidth, false)
			end
		end

		-- title
		local row = titletable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(numcols):createText(ReadText(1001, 7730), Helper.titleTextProperties)
		-- categories
		local row = titletable:addRow(true, { fixed = true })
		for i, entry in ipairs(config.messageCategories) do
			if not entry.empty then
				local bgcolor = Color["row_title_background"]
				local color = Color["icon_normal"]
				if entry.mode == menu.messageData.category then
					bgcolor = Color["row_background_selected"]
				end

				row[i]:createButton({ height = menu.sideBarWidth, bgColor = bgcolor, mouseOverText = entry.name, scaling = false }):setIcon(function () return menu.messageCategoryIcon(entry) end, { color = color})
				row[i].handlers.onClick = function () return menu.buttonMessageCategory(entry.name, entry.mode, i) end
			end
		end

		if menu.setselectedcol then
			titletable:setSelectedCol(menu.setselectedcol)
			menu.setselectedcol = nil
		end

		infotable.properties.y = titletable.properties.y + titletable:getFullHeight() + 2 * Helper.borderSize

		local maxVisibleHeight = Helper.viewHeight - infotable.properties.y - buttontable:getFullHeight() - Helper.frameBorder
		buttontable.properties.y = infotable.properties.y + math.min(maxVisibleHeight, infotable:getFullHeight())
		infotable.properties.maxVisibleHeight = buttontable.properties.y - infotable.properties.y

		titletable:addConnection(1, 2, true)
		infotable:addConnection(2, 2)
		buttontable:addConnection(3, 2)

		-- message details
		detailtable = frame:addTable(3, { tabOrder = 3, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = titletable.properties.y, highlightMode = "off" })
		local row = detailtable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(menu.messageData.curEntry.title, Helper.titleTextProperties)

		if next(menu.messageData.curEntry) then
			local row = detailtable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(2):setBackgroundColSpan(3):createText(ReadText(1001, 7745) .. ReadText(1001, 120) .. " " .. menu.messageData.curEntry.source, {
				font = Helper.titleFont,
				fontsize = Helper.standardFontSize,
				height = Helper.subHeaderHeight,
				cellBGColor = Color["row_background"],
				titleColor = Color["row_title"],
			})
			row[3]:createText(ReadText(1001, 2691) .. ReadText(1001, 120) .. " " .. Helper.convertGameTimeToXTimeString(menu.messageData.curEntry.time), {
				font = Helper.titleFont,
				fontsize = Helper.standardFontSize,
				height = Helper.subHeaderHeight,
				cellBGColor = Color["row_background"],
				titleColor = Color["row_title"],
				halign = "right",
			})

			local interacttableheight = 0
			if (menu.messageData.curEntry.interaction ~= "") and (menu.messageData.curEntry.interactioncomponent > 0) and C.IsComponentOperational(menu.messageData.curEntry.interactioncomponent) then
				interacttable = frame:addTable(3, { tabOrder = 4, width = tableProperties.width - 2 * (narrowtablewidth + Helper.borderSize), x = tableProperties.x + infotable.properties.width + Helper.borderSize, y = titletable.properties.y })
				interacttable:addEmptyRow(config.rowHeight)

				local interactioncomponent = menu.messageData.curEntry.interactioncomponent
				if C.IsComponentClass(interactioncomponent, "zone") and (not C.IsComponentClass(interactioncomponent, "highway")) then
					interactioncomponent = GetContextByClass(interactioncomponent, "sector")
				end
				local name = ffi.string(C.GetComponentName(interactioncomponent))

				local row = interacttable:addRow(nil, { fixed = true })
				row[1]:setColSpan(3):createText(name)
				local row = interacttable:addRow(true, { fixed = true })
				row[3]:createButton({ mouseOverText = string.format(menu.messageData.curEntry.interactiontext, name) }):setText(menu.messageData.curEntry.interactionshorttext, { halign = "center" })
				row[3].handlers.onClick = function () return menu.buttonMessagesInteraction(menu.messageData.curEntry) end

				interacttableheight = interacttable:getFullHeight() + Helper.frameBorder + Helper.borderSize
			end

			local maxnumlines = math.floor((Helper.viewHeight - interacttableheight - detailtable.properties.y) / (Helper.scaleY(Helper.standardTextHeight) + Helper.borderSize))
			local lines = GetTextLines(menu.messageData.curEntry.text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), detailtable.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx))
			if #lines > maxnumlines then
				-- scrollbar case
				lines = GetTextLines(menu.messageData.curEntry.text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), detailtable.properties.width - 2 * Helper.scaleX(Helper.standardTextOffsetx) - Helper.scrollbarWidth)
			end
			for linenum, line in ipairs(lines) do
				local row = detailtable:addRow(true, {  })
				row[1]:setColSpan(3):createText(line)
			end

			if interacttable then
				if #lines > maxnumlines then
					interacttable.properties.y = Helper.viewHeight - interacttable:getFullHeight() - Helper.frameBorder
					detailtable.properties.maxVisibleHeight = interacttable.properties.y - detailtable.properties.y
				else
					interacttable.properties.y = detailtable.properties.y + detailtable:getFullHeight() + Helper.borderSize
				end

				detailtable:addConnection(1, 3, true)
				interacttable:addConnection(2, 3)
			end
		end
	end

	-- media
	if next(menu.messageData.curEntry) and (menu.messageData.curEntry.cutscenekey ~= "") then
		if config.messageCutscenes[menu.messageData.curEntry.cutscenekey] then
			local mediaProperties
			if menu.messageData.showFullscreen then
				local width = Helper.viewWidth
				local height = Helper.round(width * 9 / 16)
				if height > Helper.viewHeight then
					height = Helper.viewHeight
					width = Helper.round(height * 16 / 9)
				end
				mediaProperties = { width = width, x = (Helper.viewWidth - width) / 2, height = height, y = (Helper.viewHeight - height) / 2 }
			else
				local width = narrowtablewidth
				local height = Helper.round(width * 9 / 16)
				if height > tableProperties.height then
					height = tableProperties.height
					width = Helper.round(height * 16 / 9)
				end
				mediaProperties = { width = width, x = tableProperties.x + infotable.properties.width + detailtable.properties.width + (2 * Helper.borderSize), height = height, y = tableProperties.y }
			end

			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			if not menu.messageData.fullscreenToggled then
				menu.messageData.activatecutscene = true
				menu.messageData.cutsceneStopped = nil

				if not menu.cutsceneStoppedNotification then
					menu.cutsceneStoppedNotification = true
					NotifyOnCutsceneStopped(getElement("Scene.UIContract"))
				end
			end
			menu.messageData.fullscreenToggled = nil

			local buttonsize = 2 * config.rowHeight
			local rendertargetbuttontable = frame:addTable(2, { tabOrder = 4, width = mediaProperties.width, x = mediaProperties.x, y = mediaProperties.y + mediaProperties.height - Helper.scaleX(buttonsize) })
			rendertargetbuttontable:setColWidth(2, buttonsize)
			local row = rendertargetbuttontable:addRow(true, { fixed = true })
			row[2]:createButton({ height = buttonsize, bgColor = Color["button_background_hidden"] }):setIcon(menu.messageData.showFullscreen and "menu_minimize_video" or "menu_maximize_video")
			row[2].handlers.onClick = menu.buttonMessagesToggleCutsceneFullscreen
		else
			print("Unsupported message cutscene key: '" .. menu.messageData.curEntry.cutscenekey .. "'")
		end
	end
end

function menu.createPersonnelInfo(frame, tableProperties)
	if not menu.empireData.initialized or menu.empireData.init then
		menu.initEmpireData()
		menu.empireData.init = nil
	else
		menu.getEmployeeList()
	end

	local infotablewidth = 2 * (Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize)
	local numCols = 11
	local buttonsize = Helper.scaleY(config.rowHeight)

	local infotable = frame:addTable(numCols, { tabOrder = 1, width = infotablewidth, x = tableProperties.x, y = tableProperties.y, maxVisibleHeight = tableProperties.height })
	if menu.setdefaulttable then
		infotable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	infotable:setColWidth(1, config.rowHeight)
	infotable:setColWidth(3, config.rowHeight)
	infotable:setColWidth(7, config.rowHeight)
	infotable:setColWidth(8, config.rowHeight)
	infotable:setColWidth(9, 6 * config.rowHeight)
	infotable:setColWidth(10, config.rowHeight)
	infotable:setColWidth(11, config.rowHeight)

	infotable:setDefaultBackgroundColSpan(1, numCols)
	infotable:setDefaultColSpan(2, 2)
	infotable:setDefaultColSpan(4, 2)
	infotable:setDefaultColSpan(6, 3)
	infotable:setDefaultColSpan(9, 3)

	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11034), Helper.titleTextProperties)

	-- overview
	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11035), Helper.headerRowCenteredProperties)

	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setColSpan(5):createText(ReadText(1001, 9113))	-- Number of hired personnel
	row[6]:setColSpan(6):createText((ConvertIntegerString(menu.empireData.numhiredpersonnel, true)), { halign = "right" })

	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setColSpan(5):createText(ReadText(1001, 9114))	-- Average personnel skill
	row[6]:setColSpan(6):createText(Helper.displaySkill(menu.empireData.averagepersonnelskill), { color = Color["text_skills"], halign = "right" })

	local row = infotable:addRow(nil, { fixed = true })
	row[1]:createText("")

	-- list
	local employees = menu.empireData.filteredemployees
	if menu.personnelData.sort == "name" then
		table.sort(employees, function (a, b) return Helper.sortName(a, b, false) end)
	elseif menu.personnelData.sort == "name_inv" then
		table.sort(employees, function (a, b) return Helper.sortName(a, b, true) end)
	elseif menu.personnelData.sort == "skill" then
		table.sort(employees, function (a, b) return menu.skillSorter(a, b, false) end)
	elseif menu.personnelData.sort == "skill_inv" then
		table.sort(employees, function (a, b) return menu.skillSorter(a, b, true) end)
	elseif menu.personnelData.sort == "role" then
		table.sort(employees, function (a, b) return menu.roleSorter(a, b, false) end)
	elseif menu.personnelData.sort == "role_inv" then
		table.sort(employees, function (a, b) return menu.roleSorter(a, b, true) end)
	elseif menu.personnelData.sort == "workplace" then
		table.sort(employees, function (a, b) return menu.workplaceSorter(a, b, false) end)
	elseif menu.personnelData.sort == "workplace_inv" then
		table.sort(employees, function (a, b) return menu.workplaceSorter(a, b, true) end)
	end

	menu.personnelData.numPages = math.ceil(#employees / config.personnelPage)
	if #employees <= config.personnelPage then
		menu.personnelData.curPage = 1
	else
		local startIndex = config.personnelPage * (menu.personnelData.curPage - 1) + 1
		local endIndex = config.personnelPage + startIndex - 1
		if startIndex < 1 then
			startIndex = 1
		end
		employees = { table.unpack(employees, startIndex, endIndex) }
	end

	local row = infotable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(numCols):createText(ReadText(1001, 11036), Helper.headerRowCenteredProperties)

	-- search & pages
	local roleOptions = {
		{ id = "post:aipilot",		text = ReadText(20208, 30101), icon = "", displayremoveoption = false },
		{ id = "post:manager",		text = ReadText(20208, 30301), icon = "", displayremoveoption = false },
		{ id = "post:shiptrader",	text = ReadText(20208, 30501), icon = "", displayremoveoption = false },
		{ id = "role:service",		text = ReadText(20208, 20103), icon = "", displayremoveoption = false },
		{ id = "role:marine",		text = ReadText(20208, 20203), icon = "", displayremoveoption = false },
	}
	table.sort(roleOptions, function (a, b) return a.text < b.text end)
	table.insert(roleOptions, 1, { id = "current", text = ReadText(1001, 8373), icon = "", displayremoveoption = false })
	local row = infotable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createEditBox({ description = ReadText(1001, 11038), defaultText = ReadText(1001, 3250), height = config.rowHeight }):setText(menu.personnelData.searchtext, { halign = "left", x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
	row[1].handlers.onEditBoxDeactivated = function (_, text) if text ~= menu.personnelData.searchtext then menu.personnelData.searchtext = text; menu.personnelData.curPage = 1; menu.noupdate = nil; menu.personnelData.curEntry = {}; menu.refreshInfoFrame() end end

	local buttonheight = math.max(Helper.editboxMinHeight, Helper.scaleY(Helper.subHeaderHeight))
	row[3]:createButton({ scaling = false, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setText("X", { halign = "center", font = Helper.standardFontBold })
	row[3].handlers.onClick = function () if menu.personnelData.searchtext ~= "" then menu.personnelData.searchtext = ""; menu.personnelData.curPage = 1; menu.refreshInfoFrame() end end
	row[4]:setColSpan(1):createText(ReadText(1001, 8399) .. ReadText(1001, 120), { halign = "right" })
	row[5]:createDropDown(roleOptions, { height = config.rowHeight, startOption = menu.personnelData.role })
	row[5].handlers.onDropDownConfirmed = function (_, newrole) if menu.personnelData.role ~= newrole then menu.personnelData.role = newrole; menu.personnelData.curPage = 1; menu.refreshInfoFrame() end end
	row[6]:setColSpan(1)
	row[7]:createButton({ scaling = false, active = menu.personnelData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[7].handlers.onClick = function () menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[8]:createButton({ scaling = false, active = menu.personnelData.curPage > 1, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_left_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[8].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.curPage - 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	menu.personnelPageEditBox = row[9]:setColSpan(1):createEditBox({ description = ReadText(1001, 7739) }):setText(menu.personnelData.curPage .. " / " .. menu.personnelData.numPages, { halign = "center" })
	row[9].handlers.onEditBoxDeactivated = menu.editboxPersonnelPage
	row[10]:createButton({ scaling = false, active = menu.personnelData.curPage < menu.personnelData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[10].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.curPage + 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[11]:createButton({ scaling = false, active = menu.personnelData.curPage < menu.personnelData.numPages, width = buttonsize, height = buttonheight, cellBGColor = Color["row_background"] }):setIcon("widget_arrow_skip_right_01", { width = buttonsize, height = buttonsize, y = (row:getHeight() - buttonsize) / 2 })
	row[11].handlers.onClick = function () menu.personnelData.curPage = menu.personnelData.numPages; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end

	-- sort
	local arrowWidth = Helper.scaleY(config.rowHeight)
	local row = infotable:addRow(true, { fixed = true })
	row[1]:setColSpan(3):createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 2809), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[1]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "name") or (menu.personnelData.sort == "name_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
	row[1].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "name") and "name_inv" or "name"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[4]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11037), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "workplace_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "workplace") or (menu.personnelData.sort == "workplace_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
	row[4].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "workplace") and "workplace_inv" or "workplace"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[6]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 11200), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "role_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[6]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "role") or (menu.personnelData.sort == "role_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
	row[6].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "role") and "role_inv" or "role"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end
	row[9]:createButton({ height = config.mapRowHeight }):setText(ReadText(1001, 9124), { x = Helper.standardTextOffsetx }):setIcon((menu.personnelData.sort == "skill_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[9]:getColSpanWidth() - arrowWidth, color = ((menu.personnelData.sort == "skill") or (menu.personnelData.sort == "skill_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
	row[9].handlers.onClick = function () menu.personnelData.sort = (menu.personnelData.sort == "skill") and "skill_inv" or "skill"; menu.personnelData.curPage = 1; menu.personnelData.curEntry = {}; menu.refreshInfoFrame(1, 1) end

	local found = false
	for i, employeedata in ipairs(employees) do
		if menu.personnelData.curEntry and next(menu.personnelData.curEntry) then
			if tostring(employeedata.id) == tostring(menu.personnelData.curEntry.id) then
				found = true
			end
		else
			menu.personnelData.curEntry = employeedata
			found = true
		end

		local name = employeedata.name
		local namemouseovertext = ""
		local namecolor
		if GetComponentData(employeedata.container, "isonlineobject") then
			namecolor = Color["text_inactive"]
			namemouseovertext = ReadText(1026, 9118)
		end
		if employeedata.type == "person" then
			if C.IsPersonTransferScheduled(C.ConvertStringTo64Bit(tostring(employeedata.container)), C.ConvertStringTo64Bit(tostring(employeedata.id))) then
				name = ColorText["crew_transfer"] .. "\027[warning]" .. name
				namemouseovertext = ReadText(1026, 3228)
			elseif not C.HasPersonArrived(C.ConvertStringTo64Bit(tostring(employeedata.container)), C.ConvertStringTo64Bit(tostring(employeedata.id))) then
				namecolor = Color["text_inactive"]
				namemouseovertext = ReadText(1026, 3247)
			end
		end
		local adjustedskill = math.floor(employeedata.skill * 15 / 100)
		local workplace = employeedata.containername
		local assignment = employeedata.rolename

		local role, post, rolename
		if menu.personnelData.role ~= "current" then
			local type, id = string.match(menu.personnelData.role, "(.+):(.+)")
			if type == "post" then
				post = id
			elseif type == "role" then
				role = id
			end
			for _, option in ipairs(roleOptions) do
				if option.id == menu.personnelData.role then
					rolename = option.text
					break
				end
			end
		end

		local roleColor, mouseovertext
		if (menu.personnelData.role ~= "current") and (role ~= employeedata.roleid) and (post ~= employeedata.roleid) then
			roleColor = Color["text_inactive"]
			mouseovertext = string.format(ReadText(1026, 3231), assignment)
		end

		local isexpanded = menu.isPersonnelExpanded(employeedata.id)
		local row = infotable:addRow({"personnel_employee", employeedata}, {  })
		row[1]:createButton({ height = config.mapRowHeight }):setText(function() return isexpanded and "-" or "+" end, { halign = "center" })
		row[1].handlers.onClick = function() return menu.expandPersonnel(employeedata.id, row.index) end
		row[2]:createText(name, { mouseOverText = namemouseovertext, color = namecolor })
		row[4]:createText(workplace)
		row[6]:createText(assignment, { color = roleColor, mouseOverText = mouseovertext })
		row[9]:createText(Helper.displaySkill(adjustedskill), { color = Color["text_skills"], halign = "right", mouseOverText = ReadText(1026, 2) })
		if isexpanded then
			local numskills = C.GetNumSkills()
			local skilltable = ffi.new("Skill2[?]", numskills + 1)
			if employeedata.type == "person" then
				numskills = C.GetPersonSkillsForAssignment(skilltable, C.ConvertStringTo64Bit(tostring(employeedata.id)), C.ConvertStringTo64Bit(tostring(employeedata.container)), role, post)
			else
				numskills = C.GetEntitySkillsForAssignment(skilltable, C.ConvertStringTo64Bit(tostring(employeedata.id)), role, post)
			end
			local sortedskilltable = {}
			for i = 1, numskills do
				table.insert(sortedskilltable, skilltable[i])
			end
			table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
			for i, skill in ipairs(sortedskilltable) do
				local skillname = ReadText(1013, skill.textid)
				local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
				local mouseovertext = ReadText(1013, skill.descriptionid)
				local row = infotable:addRow(nil, {  })
				row[2]:createText(skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
				row[4]:createText(printedskill, { halign = "left", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
			end
		end
	end

	if not found then
		menu.personnelData.curEntry = {}
	end

	infotable:setTopRow(menu.settoprow)
	infotable:setSelectedRow(menu.setselectedrow)
	menu.settoprow = nil
	menu.setselectedrow = nil

	-- media & description
	if menu.personnelData.curEntry and next(menu.personnelData.curEntry) then
		local width = math.floor(infotablewidth / 2)
		local height = width
		if height > Helper.viewHeight / 2 then
			height = math.floor(Helper.viewHeight / 2)
			width = height
		end
		local x = tableProperties.x + infotablewidth + Helper.borderSize
		local mediaProperties = { width = width, x = x, height = height, y = tableProperties.y }

		if menu.personnelData.curEntry.type == "entity" then
			menu.rendertarget = frame:addRenderTarget(mediaProperties)
			if tostring(menu.personnelData.curEntry.id) ~= tostring(menu.personnelData.renderobject) then
				menu.personnelData.activatecutscene = true
			end
		end

		local descriptiontable = frame:addTable(2, { tabOrder = 0, width = width, x = x, y = tableProperties.y + height + Helper.borderSize })
		descriptiontable:setColWidthPercent(1, 33)
		-- no video icon
		if menu.personnelData.curEntry.type ~= "entity" then
			descriptiontable.properties.y = tableProperties.y
			local row = descriptiontable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createIcon("briefing_no_video", { width = width, height = height, scaling = false })
		end
		-- details
		local row = descriptiontable:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(2):createText(ReadText(1001, 2961), Helper.titleTextProperties)
		-- name
		local row = descriptiontable:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.name, { halign = "right" })
		-- skills
		local numskills = C.GetNumSkills()
		local skilltable = ffi.new("Skill2[?]", numskills + 1)
		if menu.personnelData.curEntry.type == "person" then
			numskills = C.GetPersonSkillsForAssignment(skilltable, C.ConvertStringTo64Bit(tostring(menu.personnelData.curEntry.id)), C.ConvertStringTo64Bit(tostring(menu.personnelData.curEntry.container)), role, post)
		else
			numskills = C.GetEntitySkillsForAssignment(skilltable, C.ConvertStringTo64Bit(tostring(menu.personnelData.curEntry.id)), role, post)
		end
		local sortedskilltable = {}
		for i = 1, numskills do
			table.insert(sortedskilltable, skilltable[i])
		end
		table.sort(sortedskilltable, function(a, b) return a.relevance > b.relevance end)
		for i, skill in ipairs(sortedskilltable) do
			local skillname = ReadText(1013, skill.textid)
			local printedskill = Helper.displaySkill(skill.value, skill.relevance > 0)
			local mouseovertext = ReadText(1013, skill.descriptionid)
			local row = descriptiontable:addRow(nil, {  })
			row[1]:createText("   " .. skillname, { font = (skill.relevance > 0) and Helper.standardFontBold or nil, color = (skill.relevance > 0) and Color["text_normal"] or Color["text_inactive"], mouseOverText = mouseovertext })
			row[2]:createText(printedskill, { halign = "right", color = (skill.relevance > 0) and Color["text_skills"] or Color["text_skills_irrelevant"], mouseOverText = mouseovertext })
		end
		-- workplace
		local row = descriptiontable:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11037) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.containername, { halign = "right" })
		-- location
		local row = descriptiontable:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11039) .. ReadText(1001, 120))
		row[2]:createText(function () return GetComponentData(menu.personnelData.curEntry.container, "sector") end, { halign = "right" })
		-- role
		local row = descriptiontable:addRow(nil, { fixed = true })
		row[1]:createText(ReadText(1001, 11200) .. ReadText(1001, 120))
		row[2]:createText(menu.personnelData.curEntry.rolename, { halign = "right" })
		-- current command
		if (menu.personnelData.curEntry.type == "entity") and (menu.personnelData.curEntry.roleid == "aipilot") then
			local aicommandstack, aicommand, aicommandparam, aicommandaction, aicommandactionparam = GetComponentData(menu.personnelData.curEntry.id, "aicommandstack", "aicommand", "aicommandparam", "aicommandaction", "aicommandactionparam")
			local row = descriptiontable:addRow(nil, { fixed = true })
			row[1]:createText(ReadText(1001, 78) .. ReadText(1001, 120))
			if #aicommandstack > 0 then
				aicommand = aicommandstack[1].command
				aicommandparam = aicommandstack[1].param
			end
			row[2]:createText(string.format(aicommand, IsComponentClass(aicommandparam, "component") and GetComponentData(aicommandparam, "name") or nil), { halign = "right" })
			local row = descriptiontable:addRow(nil, { fixed = true })
			local numaicommands = #aicommandstack
			if numaicommands > 1 then
				aicommandaction = aicommandstack[numaicommands].command
				aicommandactionparam = aicommandstack[numaicommands].param
			end
			row[2]:createText(string.format(aicommandaction, IsComponentClass(aicommandactionparam, "component") and GetComponentData(aicommandactionparam, "name") or nil), { halign = "right" })
		end
	end

	infotable:addConnection(1, 2, true)
end

function menu.roleSorter(a, b, invert)
	if a.rolename == b.rolename then
		if a.skill == b.skill then
			return a.name < b.name
		end
		return a.combinedskill > b.combinedskill
	end
	if invert then
		return a.rolename > b.rolename
	else
		return a.rolename < b.rolename
	end
end

function menu.skillSorter(a, b, invert)
	if a.skill == b.skill then
		return a.name < b.name
	end
	if invert then
		return a.skill < b.skill
	else
		return a.skill > b.skill
	end
end

function menu.workplaceSorter(a, b, invert)
	if a.containername == b.containername then
		return a.name < b.name
	end
	if invert then
		return a.containername > b.containername
	else
		return a.containername < b.containername
	end
end

function menu.getEmployeeList()
	local role, post
	if menu.crewRole ~= "current" then
		local type, id = string.match(menu.personnelData.role, "(.+):(.+)")
		if type == "post" then
			post = id
		elseif type == "role" then
			role = id
		end
	end

	local numroles = C.GetNumAllRoles()
	local peopletable = ffi.new("PeopleInfo[?]", numroles)

	-- give the empire employee list an update to avoid referencing destroyed objects
	local numhiredpersonnel = 0
	local empireemployees = {}

	local numownedships = C.GetNumAllFactionShips("player")
	local allownedships = ffi.new("UniverseID[?]", numownedships)
	numownedships = C.GetAllFactionShips(allownedships, numownedships, "player")
	for i = 0, numownedships - 1 do
		local locship = ConvertStringTo64Bit(tostring(allownedships[i]))
		local shipmacro, isdeployable = GetComponentData(locship, "macro", "isdeployable")
		local islasertower, locshipware = GetMacroData(shipmacro, "islasertower", "ware")
		local isunit = C.IsUnit(locship)
		if locshipware and (not isunit) and (not islasertower) and (not isdeployable) then
			local shipname, pilot, isdeployable = GetComponentData(locship, "name", "assignedaipilot", "isdeployable")
			shipname = shipname .. " (" .. ffi.string(C.GetObjectIDCode(locship)) .. ")"
			if pilot and IsValidComponent(pilot) then
				local name, combinedskill, poststring, postname = GetComponentData(pilot, "name", "combinedskill", "poststring", "postname")
				table.insert(empireemployees, { id = ConvertIDTo64Bit(pilot), type = "entity", name = name, combinedskill = combinedskill, roleid = poststring, rolename = postname, container = locship, containername = shipname })
				numhiredpersonnel = numhiredpersonnel + 1
			end
			local locnumroles = C.GetPeople2(peopletable, numroles, locship, true)
			for i = 0, locnumroles - 1 do
				numhiredpersonnel = numhiredpersonnel + peopletable[i].amount
				local roleid = ffi.string(peopletable[i].id)
				local rolename = ffi.string(peopletable[i].name)
				local numtiers = peopletable[i].numtiers
				--print("role: " .. tostring(roleid) .. ", rolename: " .. tostring(rolename) .. ", numtiers: " .. tostring(numtiers))
				if numtiers > 0 then
					local tiertable = ffi.new("RoleTierData[?]", numtiers)
					numtiers = C.GetRoleTiers(tiertable, numtiers, locship, peopletable[i].id)
					for j = 0, numtiers - 1 do
						local numpersons = tiertable[j].amount
						if numpersons > 0 then
							local persontable = GetRoleTierNPCs(locship, roleid, tiertable[j].skilllevel)
							for k, person in ipairs(persontable) do
								table.insert(empireemployees, { id = person.seed, type = "person", name = person.name, combinedskill = person.combinedskill, roleid = roleid, rolename = rolename, container = locship, containername = shipname })
							end
						end
					end
				elseif roleid == "unassigned" then
					local persontable = GetRoleTierNPCs(locship, roleid, 0)
					--print("numpersons: " .. tostring(#persontable))
					for k, person in ipairs(persontable) do
						--print(k .. ": " .. person.name)
						table.insert(empireemployees, { id = person.seed, type = "person", name = person.name, combinedskill = person.combinedskill, roleid = roleid, rolename = rolename, container = locship, containername = shipname })
					end
				end
			end
		end
	end

	local numownedstations = C.GetNumAllFactionStations("player")
	local allownedstations = ffi.new("UniverseID[?]", numownedstations)
	numownedstations = C.GetAllFactionStations(allownedstations, numownedstations, "player")
	for i = 0, numownedstations - 1 do
		local locstation = ConvertStringTo64Bit(tostring(allownedstations[i]))
		local stationname, manager, shiptrader = GetComponentData(locstation, "name", "tradenpc", "shiptrader")
		stationname = stationname .. " (" .. ffi.string(C.GetObjectIDCode(locstation)) .. ")"
		if manager then
			local name, combinedskill, poststring, postname = GetComponentData(manager, "name", "combinedskill", "poststring", "postname")
			table.insert(empireemployees, { id = ConvertIDTo64Bit(manager), type = "entity", name = name, combinedskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
			numhiredpersonnel = numhiredpersonnel + 1
		end
		if shiptrader then
			local name, combinedskill, poststring, postname = GetComponentData(shiptrader, "name", "combinedskill", "poststring", "postname")
			table.insert(empireemployees, { id = ConvertIDTo64Bit(shiptrader), type = "entity", name = name, combinedskill = combinedskill, roleid = poststring, rolename = postname, container = locstation, containername = stationname })
			numhiredpersonnel = numhiredpersonnel + 1
		end
	end
	menu.empireData.employees = empireemployees
	menu.empireData.numhiredpersonnel = numhiredpersonnel

	local filteredemployees = {}
	for _, employeedata in ipairs(menu.empireData.employees) do
		if (menu.personnelData.searchtext == "") or menu.employeeSearchHelper(employeedata, menu.personnelData.searchtext) then
			if menu.personnelData.role == "current" then
				employeedata.skill = employeedata.combinedskill
			else
				if employeedata.type == "person" then
					employeedata.skill = C.GetPersonCombinedSkill(C.ConvertStringTo64Bit(tostring(employeedata.container)), C.ConvertStringTo64Bit(tostring(employeedata.id)), role, post)
				else
					employeedata.skill = C.GetEntityCombinedSkill(C.ConvertStringTo64Bit(tostring(employeedata.id)), role, post)
				end
			end
			table.insert(filteredemployees, employeedata)
		end
	end
	menu.empireData.filteredemployees = filteredemployees
end

function menu.employeeSearchHelper(entry, text)
	text = utf8.lower(text)

	if string.find(utf8.lower(entry.name), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.containername), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(entry.rolename), text, 1, true) then
		return true
	end

	return false
end

function menu.initEmpireData()
	menu.empireData.name = ffi.string(C.GetPlayerName())
	menu.empireData.factionname = ffi.string(C.GetPlayerFactionName(true))

	local shipworth = 0
	local stationworth = 0
	local inventoryworth = 0
	local cash = GetPlayerMoney()
	local onlineworth = 0
	local numonlineships = 0

	local ships = {}
	local stations = {}

	local numownedships = C.GetNumAllFactionShips("player")
	local allownedships = ffi.new("UniverseID[?]", numownedships)
	numownedships = C.GetAllFactionShips(allownedships, numownedships, "player")
	--print("num owned ships: " .. numownedships .. ", all owned ships:")
	for i = 0, numownedships - 1 do
		--print(ffi.string(C.GetComponentName(allownedships[i])))
		local locship = ConvertStringTo64Bit(tostring(allownedships[i]))
		local shipmacro, isdeployable = GetComponentData(locship, "macro", "isdeployable")
		local islasertower, locshipware = GetMacroData(shipmacro, "islasertower", "ware")
		local isunit = C.IsUnit(locship)
		if locshipware and (not isunit) and (not islasertower) and (not isdeployable) then
			local shipname, isonlineobject, shipsize = GetComponentData(locship, "name", "isonlineobject", "size")
			shipname = shipname .. " (" .. ffi.string(C.GetObjectIDCode(locship)) .. ")"
				local locshipworth = GetWareData(locshipware, "avgprice")
				shipworth = shipworth + locshipworth
			table.insert(ships, { ship = locship, size = shipsize })

				if isonlineobject then
					numonlineships = numonlineships + 1
				end
						end
					end
	table.sort(ships, function (a, b) return a.size > b.size end)

	local numownedstations = C.GetNumAllFactionStations("player")
	local allownedstations = ffi.new("UniverseID[?]", numownedstations)
	numownedstations = C.GetAllFactionStations(allownedstations, numownedstations, "player")
	local totalstationaccountcash = 0
	for i = 0, numownedstations - 1 do
		local locstation = ConvertStringTo64Bit(tostring(allownedstations[i]))
		local stationname, buildstorage, manager, shiptrader = GetComponentData(locstation, "name", "buildstorage", "tradenpc", "shiptrader")
		stationname = stationname .. " (" .. ffi.string(C.GetObjectIDCode(locstation)) .. ")"
		if C.IsComponentClass(locstation, "container") then
			totalstationaccountcash = totalstationaccountcash + (GetAccountData(locstation, "money") or 0)
		end
		table.insert(stations, { station = locstation, name = stationname })

		if buildstorage then
			totalstationaccountcash = totalstationaccountcash + (GetAccountData(buildstorage, "money") or 0)
		end

		local numstationmodules = C.GetNumStationModules(allownedstations[i], false, false)
		local allstationmodules = ffi.new("UniverseID[?]", numstationmodules)
		numstationmodules = C.GetStationModules(allstationmodules, numstationmodules, allownedstations[i], false, false)
		for j = 0, numstationmodules-1 do
			local macro = GetComponentData(ConvertStringTo64Bit(tostring(allstationmodules[j])), "macro")
			local ware = GetMacroData(macro, "ware")
			if ware then
				stationworth = stationworth + GetWareData(ware, "avgprice")
			end
		end
				end
	table.sort(stations, function (a, b) return a.name < b.name end)

	menu.getEmployeeList()

	local onlineitems = OnlineGetUserItems()

	-- kuertee start:
	if not onlineitems then
		onlineitems = {}
	end
	-- kuertee end

	local numinventoryitems = 0
	-- { [ware1] = { name = "", amount = 0, price = 0 }, [ware2] = {} }
	local playerinventory = GetPlayerInventory()
	for item, itemdata in pairs(playerinventory) do
		local isequipment = GetWareData(item, "isequipment")
		if (not isequipment) and (not onlineitems[item]) then
			numinventoryitems = numinventoryitems + 1
			inventoryworth = inventoryworth + itemdata.amount * itemdata.price
		end
	end

	local numplayerpolicesectors = 0
	local clusters = GetClusters(true)
	for _, cluster in ipairs(clusters) do
		local sectors = GetSectors(cluster)
		for _, sector in ipairs(sectors) do
			if GetComponentData(sector, "isplayerowned") then
				numplayerpolicesectors = numplayerpolicesectors + 1
			end
		end
	end

	menu.empireData.networth = shipworth + stationworth + totalstationaccountcash + inventoryworth + cash

	menu.empireData.shipworth = shipworth
	menu.empireData.stationworth = stationworth
	menu.empireData.totalstationaccountcash = totalstationaccountcash
	menu.empireData.inventoryworth = inventoryworth
	menu.empireData.cash = cash

	menu.empireData.numownedships = numownedships
	menu.empireData.numownedstations = numownedstations

	menu.empireData.ships = ships
	menu.empireData.stations = stations

	menu.empireData.numonlineships = numonlineships

	menu.empireData.averagepersonnelskill = C.GetAveragePlayerNPCSkill() * 15 / 100

	menu.empireData.numinventoryitems = numinventoryitems

	menu.empireData.numplayerpolicesectors = numplayerpolicesectors

	menu.empireData.initialized = true
end

function menu.createEmpire(frame, tableProperties)
	--print("menu.createEmpire")
	if not menu.empireData.initialized or menu.empireData.init then
		menu.initEmpireData()
		menu.empireData.init = nil
	end

	if not menu.empireData.mode then
		menu.empireData.mode = {"empire", "name"}
	end

	local narrowtablewidth = Helper.playerInfoConfig.width - menu.sideBarWidth - Helper.borderSize

	-- 4 tables: left, center, topright, bottomright
	-- left: static numrows. selecting rows changes content of center.
	local numCols = (menu.mode == "empire") and 3 or 4
	local table_left = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x, y = tableProperties.y })
	table_left:setColWidth(numCols, Helper.scaleY(config.rowHeight), false)
	table_left:setDefaultBackgroundColSpan(1, numCols)

	local tabOrderOffset = 1
	local properties_table_center = { tabOrder = 2, borderEnabled = true, width = tableProperties.width - (table_left.properties.width * 2) - (Helper.borderSize * 2), x = tableProperties.x + table_left.properties.width + Helper.borderSize, y = tableProperties.y }
	local table_center, table_topright, table_bottomright
	if menu.empireData.mode[1] ~= "empire_call" then
		-- center: content depends on left selection.
		table_center = frame:addTable(5, properties_table_center)
		tabOrderOffset = tabOrderOffset + 1
	end

	-- topright: rendertarget, depends on selection in center.
	local properties_table_topright = { width = narrowtablewidth, x = tableProperties.x + table_left.properties.width + properties_table_center.width + (2 * Helper.borderSize), height = tableProperties.height / 2, y = tableProperties.y }

	-- bottomright: description, depends on selection in center.
	table_bottomright = frame:addTable(1, { tabOrder = 0, borderEnabled = true, width = narrowtablewidth, x = tableProperties.x + table_left.properties.width + properties_table_center.width + (2 * Helper.borderSize), height = tableProperties.height / 2, y = tableProperties.y + properties_table_topright.height })

	--print("widths. left: " .. table_left.properties.width .. ", center: " .. properties_table_center.width .. ", right: " .. properties_table_topright.width)

	if menu.setdefaulttable then
		table_left.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end

	if menu.mode == "empire" then
		-- Empire Overview
		local row = table_left:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 9100), Helper.titleTextProperties)	-- Empire Overview

		-- global properties
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 9101), Helper.headerRowCenteredProperties)	-- Global Properties

		row = table_left:addRow({"empire", "name"}, {  })
		row[1]:createText(ReadText(1001, 9102))	-- Player Name
		row[2]:setColSpan(2):createEditBox({ description = ReadText(1001, 9102) }):setText(menu.empireData.name)
		row[2].handlers.onEditBoxDeactivated = menu.editboxChangePlayerName

		row = table_left:addRow({"empire", "name"}, {  })
		row[1]:createText(ReadText(1001, 11006))	-- Player Name
		row[2]:setColSpan(2):createEditBox({ description = ReadText(1001, 11006) }):setText(menu.empireData.factionname)
		row[2].handlers.onEditBoxDeactivated = menu.editboxChangePlayerFactionName

		row = table_left:addRow({"empire_grid", "logo"}, {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 9103))	-- Player Logo
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })

		if #menu.empireData.ships > 0 then
			row = table_left:addRow({"empire_grid", "painttheme"}, {  })
		else
			row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		end
		row[1]:setColSpan(2):createText(ReadText(1001, 9104))	-- Default Ship Skin
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })

		-- TODO: reenable when we get clothing themes
		--[[
		if (C.GetNumAvailableClothingThemes() > 0) then
			if #menu.empireData.employees > 0 then
				row = table_left:addRow({"empire_grid", "uniform"}, {  })
			else
				row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
			end
			row[1]:setColSpan(2):createText(ReadText(1001, 9105))	-- Default Uniform
			row[3]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		]]

		-- player wealth
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 9106), Helper.headerRowCenteredProperties)	-- Player Wealth

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		--row = table_left:addRow({"empire_call", "networth"}, {  })
		row[1]:createText(ReadText(1001, 9107))	-- Player net worth
		-- string = ConvertMoneyString(money [, showcents [, separators [, accuracy [, notrailingspaces [, colorprefix]]]]])
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.networth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 9108), { x = Helper.standardIndentStep })	-- Total value of ships
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.shipworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 9109), { x = Helper.standardIndentStep })	-- Total value of stations
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.stationworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 2202), { x = Helper.standardIndentStep })	-- Inventory
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.inventoryworth, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		--row = table_left:addRow({"empire_call", "cash"}, {  })
		row[1]:createText(ReadText(1001, 9110), { x = Helper.standardIndentStep })	-- Available cash
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.cash, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 9111), { x = Helper.standardIndentStep })	-- Total cash in station accounts
		row[2]:setColSpan(2):createText((ConvertMoneyString(menu.empireData.totalstationaccountcash, false, true) .. ReadText(1001, 101)), { halign = "right" })	-- Cr

		-- personnel
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 9400), Helper.headerRowCenteredProperties)	-- Personnel

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 9113))	-- Number of hired personnel
		row[2]:setColSpan(2):createText((ConvertIntegerString(menu.empireData.numhiredpersonnel, true)), { halign = "right" })

		row = table_left:addRow(nil, { bgColor = Color["row_background_unselectable"] })
		row[1]:createText(ReadText(1001, 9114))	-- Average personnel skill
		row[2]:setColSpan(2):createText(Helper.displaySkill(menu.empireData.averagepersonnelskill), { color = Color["text_skills"], halign = "right" })

		-- online items
		--[[
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1041, 10141), Helper.headerRowCenteredProperties)	-- Online items

		row = table_left:addRow({"empire_list", "onlineitems"}, {  })
		row[1]:createText(ReadText(1001, 9122))	-- Venture Ships
		row[2]:createText((ConvertIntegerString(menu.empireData.numonlineships, true)), { halign = "right" })
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight }) --]]

		-- sector ownership
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(3):createText(ReadText(1001, 9180), Helper.headerRowCenteredProperties)	-- Government

		row = table_left:addRow({"empire_list", "sectorownership"}, {  })
		row[1]:createText(ReadText(1001, 9601))	-- Police Authority
		row[2]:createText((ConvertIntegerString(menu.empireData.numplayerpolicesectors, true)), { halign = "right" })
		row[3]:createIcon("widget_arrow_right_01", { height = config.rowHeight, width = config.rowHeight })
	else
		local row = table_left:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 9171), Helper.titleTextProperties)

		row = table_left:addRow({ "empire_list", "standingorders" }, {  })
		row[1]:setColSpan(4):createText(ReadText(1001, 9301))	-- Global standing orders

		-- trade rules
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 11010), Helper.headerRowCenteredProperties)	-- Trade Rules

		menu.traderules = {}
		Helper.ffiVLA(menu.traderules, "TradeRuleID", C.GetNumAllTradeRules, C.GetAllTradeRules)
		for i = #menu.traderules, 1, -1 do
			local id = menu.traderules[i]

			local counts = C.GetTradeRuleInfoCounts(id)
			local buf = ffi.new("TradeRuleInfo")
			buf.numfactions = counts.numfactions
			buf.factions = Helper.ffiNewHelper("const char*[?]", counts.numfactions)
			if C.GetTradeRuleInfo(buf, id) then
				local factions = {}
				for j = 0, buf.numfactions - 1 do
					table.insert(factions, ffi.string(buf.factions[j]))
				end

				local defaults = {
					["trade"] = C.IsPlayerTradeRuleDefault(id, "buy") and C.IsPlayerTradeRuleDefault(id, "sell"),
					["supply"] = C.IsPlayerTradeRuleDefault(id, "supply"),
					["build"] = C.IsPlayerTradeRuleDefault(id, "build"),
				}

				menu.traderules[i] = { id = id, name = ffi.string(buf.name), factions = factions, iswhitelist = buf.iswhitelist, defaults = defaults }
			else
				table.remove(menu.traderules, i)
			end
		end
		table.sort(menu.traderules, Helper.sortID)

		for _, entry in ipairs(menu.traderules) do
			row = table_left:addRow({ "empire_list", "traderule", entry }, {  })
			if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "traderule") and (menu.empireData.mode[3].id == entry.id) then
				menu.setselectedrow = row.index
			end

			row[1]:createText(entry.name)
			local defaulttext = ""
			--print(entry.defaults.trade .. ", " .. entry.defaults.supply .. ", " .. entry.defaults.build)
			if entry.defaults.trade and entry.defaults.supply and entry.defaults.build then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 11023) .. "]"
			else
				if entry.defaults.trade then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11017)
				end
				if entry.defaults.supply then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11018)
				end
				if entry.defaults.build then
					if defaulttext == "" then
						defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " "
					else
						defaulttext = defaulttext .. ", "
					end
					defaulttext = defaulttext .. ReadText(1001, 11019)
				end
				if defaulttext ~= "" then
					defaulttext = defaulttext .. "]"
				end
			end
			row[2]:setColSpan(2):createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end

		row = table_left:addRow({ "empire_list", "traderule", {} }, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 11011))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "traderule") and (not next(menu.empireData.mode[3])) then
			menu.setselectedrow = row.index
		end

		-- blacklists
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 9143), Helper.headerRowCenteredProperties)	-- Blacklist

		menu.blacklists = Helper.getBlackLists()

		for _, entry in ipairs(menu.blacklists) do
			row = table_left:addRow({ "empire_list", "blacklist", entry }, {  })
			if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "blacklist") and (menu.empireData.mode[3].id == entry.id) then
				menu.setselectedrow = row.index
			end
			row[1]:createText(entry.name)
			local text = ""
			for _, option in ipairs(config.blacklistTypes) do
				if option.id == entry.type then
					text = option.shorttext
					break
				end
			end
			row[2]:createText(text)
			local defaulttext = ""
			if entry.defaults.civilian and entry.defaults.military then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9175) .. "]"
			elseif entry.defaults.civilian then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9173) .. "]"
			elseif entry.defaults.military then
				defaulttext = "[" .. ReadText(1001, 9172) .. ReadText(1001, 120) .. " " .. ReadText(1001, 9174) .. "]"
			end
			row[3]:createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "blacklist", {} }, {  })
		if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "blacklist") and (not next(menu.empireData.mode[3])) then
			menu.setselectedrow = row.index
		end
		row[1]:setColSpan(3):createText(ReadText(1001, 9144))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })

		-- Fire authorization
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 7753), Helper.headerRowCenteredProperties)

		menu.fightrules = Helper.getFightRules()

		for _, entry in ipairs(menu.fightrules) do
			row = table_left:addRow({ "empire_list", "fightrule", entry }, {  })
			if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "fightrule") and (menu.empireData.mode[3].id == entry.id) then
				menu.setselectedrow = row.index
			end
			row[1]:setColSpan(2):createText(entry.name)
			local defaulttext = ""
			if entry.defaults.attack then
				defaulttext = "[" .. ReadText(1001, 9172) .. "]"
			end
			row[3]:createText(defaulttext, { halign = "right" })
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "fightrule", {} }, {  })
		if (menu.empireData.mode[1] == "empire_list") and (menu.empireData.mode[2] == "fightrule") and (not next(menu.empireData.mode[3])) then
			menu.setselectedrow = row.index
		end
		row[1]:setColSpan(3):createText(ReadText(1001, 7754))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })

		-- player alerts
		row = table_left:addRow(nil, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 9183), Helper.headerRowCenteredProperties)	-- Alerts

		menu.playeralerts = {}
		local n = C.GetNumPlayerAlerts()
		local counts = ffi.new("PlayerAlertCounts[?]", n)
		n = C.GetPlayerAlertCounts(counts, n)
		local buf = ffi.new("PlayerAlertInfo2[?]", n)
		for i = 0, n - 1 do
			buf[i].numspaces = counts[i].numspaces
			buf[i].spaceids = Helper.ffiNewHelper("UniverseID[?]", counts[i].numspaces)
		end
		n = C.GetPlayerAlerts2(buf, n)
		for i = 0, n - 1 do
			local entry = {}

			entry.index				= buf[i].index
			entry.interval			= buf[i].interval
			entry.repeats			= buf[i].repeats
			entry.muted				= buf[i].muted
			entry.spaces = {}
			for j = 0, buf[i].numspaces - 1 do
				table.insert(entry.spaces, ConvertStringTo64Bit(tostring(buf[i].spaceids[j])))
			end
			entry.objectclasses		= {}
			for class in string.gmatch(ffi.string(buf[i].objectclass), "[%a_]+") do
				table.insert(entry.objectclasses, class)
			end
			table.sort(entry.objectclasses, menu.sortClasses)
			entry.objectpurpose		= ffi.string(buf[i].objectpurpose)
			entry.objectidcode		= ffi.string(buf[i].objectidcode)
			entry.objectowners		= {}
			for faction in string.gmatch(ffi.string(buf[i].objectowner), "[%a_]+") do
				table.insert(entry.objectowners, faction)
			end
			table.sort(entry.objectowners, Helper.sortFactionName)
			entry.name				= ffi.string(buf[i].name)
			entry.message			= ffi.string(buf[i].message)
			entry.soundid			= ffi.string(buf[i].soundid)

			table.insert(menu.playeralerts, entry)
		end
		Helper.ffiClearNewHelper()

		for _, entry in ipairs(menu.playeralerts) do
			row = table_left:addRow({ "empire_list", "playeralert", entry }, {  })
			row[1]:createText(entry.name)
			local height = Helper.scaleY(config.rowHeight)
			row[3]:createButton({ height = height, width = height, x = row[3]:getWidth() - height, scaling = false }):setIcon(entry.muted and "menu_sound_off" or "menu_sound_on")
			row[3].handlers.onClick = function () if entry.muted then C.UnmutePlayerAlert(entry.index, false) else C.MutePlayerAlert(entry.index) end menu.refreshInfoFrame() end
			row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
		end
		row = table_left:addRow({ "empire_list", "playeralert", {} }, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 9184))
		row[4]:createIcon("menu_edit", { height = config.rowHeight, width = config.rowHeight })
	end

	if menu.setselectedrow then
		table_left:setSelectedRow(menu.setselectedrow)
		menu.setselectedrow = nil
		if menu.settoprow then
			table_left:setTopRow(menu.settoprow)
			menu.settoprow = nil
		end
	end

	local table_called, table_called2 = menu.setupEmpireRows(menu.empireData.mode, properties_table_center, tabOrderOffset, table_center)

	if table_center then
		-- table_center is nil if menu.empireData.mode[1] == "empire_call"
		table_center:setTopRow(menu.setcentertoprow or GetTopRow(menu.buttonTable))
		menu.setcentertoprow = nil
		if menu.setselectedrow2 then
			--print("numvisiblerows: " .. tostring(numvisiblerows) .. ", total height: " .. tostring(tableProperties.height) .. ", row height: " .. tostring(table_center.properties.width / 5 + Helper.borderSize))
			--print("set row: " .. tostring(menu.setselectedrow2))
			table_center:setSelectedRow(menu.setselectedrow2)
			if (menu.empireData.mode[2] == "logo") then
				local numvisiblerows = math.floor(tableProperties.height / (table_center.properties.width / 5 + Helper.borderSize) - 1)
				if menu.setselectedrow2 > numvisiblerows then
					--print("setting top row to: " .. tostring(menu.setselectedrow2 - numvisiblerows + 2))
					table_center:setTopRow(menu.setselectedrow2 - numvisiblerows + 2)
				end
			end
			menu.setselectedrow2 = nil
			if menu.setselectedcol2 then
				--print("set col: " .. tostring(menu.setselectedcol2))
				table_center:setSelectedCol(menu.setselectedcol2)
				menu.setselectedcol2 = nil
			end
		end

		table_left:addConnection(1, 2, true)
		table_center:addConnection(1, 3, true)
	elseif table_called then
		table_left:addConnection(1, 2, true)
		table_called:addConnection(1, 3, true)
		if table_called2 then
			table_called:addConnection(2, 3)
		end
	end

	if menu.empireData.selectedobject then
		-- menu.setupEmpireRenderTarget called from menu.onUpdate
		--print("menu.setupEmpireRenderTarget. object: " .. ffi.string(C.GetComponentName(menu.empireData.selectedobject)))
		menu.activatecutscene = true
		menu.rendertarget = frame:addRenderTarget(properties_table_topright)
	end

	menu.setupEmpireDescription(table_bottomright)
end

function menu.setupEmpireDescription(table_bottomright)
	--print("menu.setupEmpireDescription. object: " .. tostring(menu.empireData.selectedobject))

	-- Description
	local row = table_bottomright:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:createText(ReadText(1001, 2404), Helper.titleTextProperties)	-- Description

	if menu.empireData.mode then
		local descrtext = ""

		if (menu.empireData.mode[2] == "logo") then
			descrtext = ReadText(1001, 9140)		-- Select a logo to be applied to all of your ships.\n\nTo add your own logo, insert an image file to your logos folder. Files in any of the following formats are supported: .bmp, .dds, .gif, .jpg, .png, .tga
		elseif (menu.empireData.mode[2] == "painttheme") then
			descrtext = ReadText(1001, 9141)		-- Select a ship skin to be applied to all of your ships.
		elseif (menu.empireData.mode[2] == "uniform") then
			descrtext = ReadText(1001, 9142)		-- Select a uniform to be used by all of your employees.
		elseif menu.empireData.selectedobject and menu.rendertarget then
			if (menu.empireData.objecttype ~= "ware") then
				descrtext = GetComponentData(menu.empireData.selectedobject, "description")
			else
				descrtext = GetWareData(menu.empireData.selectedobject, "description")
			end
			--print("menu.setupEmpireDescription. object: " .. ffi.string(C.GetComponentName(menu.empireData.selectedobject)))
		elseif menu.empireData.mode[2] == "traderule" then
			descrtext = ReadText(1001, 11012)
		elseif menu.empireData.mode[2] == "blacklist" then
			descrtext = ReadText(1001, 9158)
		elseif menu.empireData.mode[2] == "fightrule" then
			descrtext = ReadText(1001, 7755)
		elseif menu.empireData.mode[2] == "playeralert" then
			descrtext = ReadText(1001, 9185)
		elseif menu.empireData.mode[2] == "sectorownership" then
			descrtext = ReadText(1001, 9182)
		end

		row = table_bottomright:addRow(nil, {  })
		row[1]:createText(tostring(descrtext), { wordwrap = true })
	end
end

function menu.cleanupCutsceneRenderTarget()
	if menu.cutsceneid then
		--print("stopping cutscene " .. tostring(menu.cutsceneid))
		StopCutscene(menu.cutsceneid)
	end
	if menu.cutscenedesc then
		--print("releasing cutscene descriptor " .. tostring(menu.cutscenedesc))
		ReleaseCutsceneDescriptor(menu.cutscenedesc)
	end
	if menu.precluster then
		--print("destroying cluster " .. tostring(menu.precluster))
		menu.paintmodshowcaseobject = nil
		DestroyPresentationCluster(menu.precluster)
	end
	menu.precluster = nil
	menu.preobject = nil
	menu.personnelData.renderobject = nil
	menu.cutscenedesc = nil
	menu.cutsceneid = nil
	menu.currentrenderobject = nil
end

function menu.setupEmpireRenderTarget()
	--print("menu.setupEmpireRenderTarget. object: " .. tostring(menu.empireData.selectedobject))
	local renderobject = "encyclopedia_dummy_macro"
	local mode = nil
	if menu.empireData.selectedobject then
		if (menu.empireData.objecttype ~= "ware") and menu.empireCanShowObject(menu.empireData.selectedobject) then
			renderobject = menu.empireData.selectedobject
			mode = "object"
			if C.IsComponentClass(renderobject, "npc") then
				mode = "npc"
			end
		elseif (menu.empireData.objecttype == "ware") then
			local video = GetWareData(menu.empireData.selectedobject, "video")
			if video and (video ~= "") then
				renderobject = video
			end
			mode = "ware"
		end
	end
	--print("mode: " .. tostring(mode) .. ", renderobject: " .. tostring(renderobject))

	if not menu.currentrenderobject or not renderobject or (menu.currentrenderobject ~= renderobject) then
		if menu.cutsceneid then
			--print("calling menu.cleanupCutsceneRenderTarget")
			menu.cleanupCutsceneRenderTarget()
			return false
		end

		local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
		--print("rendertarget id: " .. tostring(menu.rendertarget.id) .. ", rendertarget texture: " .. tostring(rendertargetTexture))
		if rendertargetTexture then
			menu.currentrenderobject = renderobject
			if (mode == "object") then
				menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", {targetobject = renderobject})
			elseif (mode == "npc") then
				menu.cutscenedesc = CreateCutsceneDescriptor("ShowCharacter", {npcref = renderobject})
			elseif not mode or (mode == "ware") then
				menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
				if menu.preobject then
					menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitely", {targetobject = menu.preobject})
				end
			end

			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
				--print("started cutscene")
			end
		end
	end
	return true
end

function menu.setupMessageRenderTarget()
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
	if rendertargetTexture then
		local cutscenekey = menu.messageData.curEntry.cutscenekey
		local cutsceneparameter = GetMessageCutsceneParameter(ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)), menu.messageData.curEntry.category)

		local refobjects
		if cutscenekey == "OrbitIndefinitely" then
			refobjects = { targetobject = cutsceneparameter }
		end

		menu.cutscenedesc = CreateCutsceneDescriptor(cutscenekey, refobjects)
		if menu.cutscenedesc then
			menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
		end
	end
	return true
end

function menu.setupInventoryRenderTarget()
	local ware = menu.inventoryData.curEntry[1]
	local video, ispaintmod = GetWareData(ware, "video", "ispaintmod")
	if ispaintmod and menu.paintmodshowcaseobject then
		-- already showing a paintmod showcase -> just update the paintmod
		C.InstallPaintMod(menu.paintmodshowcaseobject, ware, false)
		return true
	end
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
	if rendertargetTexture then

		local renderobject
		if ispaintmod then
			local lastplayership = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
			if lastplayership and (lastplayership ~= 0) and (not C.IsComponentClass(lastplayership, "spacesuit")) then
				renderobject = GetComponentData(lastplayership, "macro")
			else
				local playerobjects = GetContainedObjectsByOwner("player")
				for _, object in ipairs(playerobjects) do
					if IsComponentClass(object, "ship") and (not IsComponentClass(object, "spacesuit")) then
						renderobject = GetComponentData(object, "macro")
						break
					end
				end
			end
		end
		if renderobject == nil then
			if video and (video ~= "") then
				renderobject = video
			end
		end
		if renderobject == nil then
			renderobject = "encyclopedia_dummy_macro"
		end

		menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
		if menu.preobject then
			if ispaintmod then
				menu.paintmodshowcaseobject = ConvertIDTo64Bit(menu.preobject)
				C.InstallPaintMod(menu.paintmodshowcaseobject, ware, false)
			end
			menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitely", { targetobject = menu.preobject })
			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
			end
		end
	end
	return true
end

function menu.setupPersonnelRenderTarget()
	if menu.cutsceneid then
		menu.cleanupCutsceneRenderTarget()
		return false
	end
	if menu.personnelData.curEntry.type == "entity" then
		local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
		if rendertargetTexture then
			menu.personnelData.renderobject = menu.personnelData.curEntry.id
			menu.cutscenedesc = CreateCutsceneDescriptor("ShowCharacter", { npcref = menu.personnelData.renderobject })
			if menu.cutscenedesc then
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
			end
		end
	end
	return true
end

function menu.setupEmpireRows(mode, properties_table_center, tabOrderOffset, table_center)
	local locmode = nil
	if type(mode) == "table" then
		locmode = mode[2]
	else
		DebugError("menu.setupEmpireRows called with invalid mode: " .. tostring(mode))
		return
	end

	if mode[1] == "empire_grid" then
		local buttonheight = table_center.properties.width / 5
		local rowcounter = 0
		local headertext = ""
		local nonetext = ""
		table_center.properties.highlightMode = "column"

		if locmode == "logo" then
			local logooptiondata = { {{}, ReadText(1001, 9126)}, {{}, ReadText(1001, 9127)} }	-- Standard Logos, Custom Logos
			headertext = ReadText(1001, 9125)		-- Logo Selection
			local buf = C.GetCurrentPlayerLogo()
			menu.empireData.currentlogo = { file = ffi.string(buf.file), icon = ffi.string(buf.icon), ispersonal = buf.ispersonal }

			local numlogos = C.GetNumPlayerLogos(true, false)
			local logos = ffi.new("UILogo[?]", numlogos)
			numlogos = C.GetPlayerLogos(logos, numlogos, true, false)
			for i = 0, numlogos-1 do
				--print("inserting logo: " .. ffi.string(logos[i].file))
				table.insert(logooptiondata[1][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
			end
			--print("num standard logos: " .. tostring(numlogos))

			numlogos = C.GetNumPlayerLogos(false, true)
			logos = ffi.new("UILogo[?]", numlogos)
			numlogos = C.GetPlayerLogos(logos, numlogos, false, true)
			for i = 0, numlogos-1 do
				--print("inserting logo: " .. ffi.string(logos[i].file))
				table.insert(logooptiondata[2][1], { file = ffi.string(logos[i].file), icon = ffi.string(logos[i].icon), ispersonal = logos[i].ispersonal })
			end

			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			for _, logodata in ipairs(logooptiondata) do
				row = table_center:addRow(nil, { bgColor = Color["player_info_background"] })
				row[1]:setColSpan(5):createText(logodata[2], Helper.headerRowCenteredProperties)

				local rowbuttoncounter = 6
				if #logodata[1] > 0 then
					for i, logo in ipairs(logodata[1]) do
						if rowbuttoncounter == 6 then
							rowbuttoncounter = 1
							rowcounter = rowcounter + 1
							row = table_center:addRow(("empire_standardlogoselect_" .. rowcounter), {  })
						end

						-- NB: icon more reliable than file name for comparison because file extensions vary.
						if logo.icon == menu.empireData.currentlogo.icon and logo.ispersonal == menu.empireData.currentlogo.ispersonal then
							--print("current logo found: " .. tostring(logo) .. ". row: " .. tostring(rowcounter) .. ", column: " .. tostring(rowbuttoncounter))
							menu.setselectedrow2 = row.index
							menu.setselectedcol2 = rowbuttoncounter
						end

						--print("adding button " .. tostring(rowbuttoncounter) .. " in row " .. tostring(rowcounter) .. " with icon: " .. tostring(logo.icon))
						local locrow = row.index
						local loccol = rowbuttoncounter
						row[rowbuttoncounter]:createButton({ height = buttonheight, scaling = false }):setIcon(logo.icon):setIcon2(function() return menu.logoButtonIcon2(logo) end, { color = function() return menu.logoButtonIcon2Color(logo) end })
						row[rowbuttoncounter].handlers.onClick = function() return menu.buttonSetPlayerLogo(logo, locrow, loccol) end

						rowbuttoncounter = rowbuttoncounter + 1
					end
				else
					row = table_center:addRow("empire_standardlogoselect_none", {  })
					row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 9132) .. " ---")
				end
			end
		else
			local currentthemeid = ""
			local themeoptions = {}

			if locmode == "painttheme" then
				headertext = ReadText(1001, 9119)	-- Ship Skin Selection
				nonetext = ReadText(1001, 9130)		-- (Paint Theme)None
				currentthemeid = ffi.string(C.GetPlayerPaintTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numpaintthemes = C.GetNumAvailablePaintThemes()
				local paintthemes = ffi.new("UIPaintTheme[?]", numpaintthemes)
				numpaintthemes = C.GetAvailablePaintThemes(paintthemes, numpaintthemes)
				for i = 0, numpaintthemes - 1 do
					local icon = ffi.string(paintthemes[i].Icon)
					table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = ffi.string(paintthemes[i].Icon) })
					--print("id: " .. tostring(ffi.string(paintthemes[i].ID)) .. ", name: " .. tostring(ffi.string(paintthemes[i].Name)) .. ", icon: " .. tostring(ffi.string(paintthemes[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			elseif locmode == "uniform" then
				headertext = ReadText(1001, 9120)	-- Uniform Selection
				nonetext = ReadText(1001, 9131)		-- (Uniform)None
				currentthemeid = ffi.string(C.GetPlayerClothingTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numuniforms = C.GetNumAvailableClothingThemes()
				local uniforms = ffi.new("UIClothingTheme[?]", numuniforms)
				numuniforms = C.GetAvailableClothingThemes(uniforms, numuniforms)
				for i = 0, numuniforms - 1 do
					table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(uniforms[i].ID)) .. ", name: " .. tostring(ffi.string(uniforms[i].Name)) .. ", icon: " .. tostring(ffi.string(uniforms[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			end

			table.sort(themeoptions, function (a, b) return a.text < b.text end)
			if locmode == "uniform" then
				table.insert(themeoptions, { id = "", text = nonetext, icon = "" })
			end

			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			local rowbuttoncounter = 6
			for i, theme in ipairs(themeoptions) do

				if rowbuttoncounter == 6 then
					rowbuttoncounter = 1
					rowcounter = rowcounter + 1
					row = table_center:addRow(("empire_themeselect_" .. rowcounter), {  })
				end

				local icon2
				if theme.id == currentthemeid then
					--print("current theme found: " .. tostring(theme.id) .. ". row: " .. tostring(rowcounter) .. ", column: " .. tostring(rowbuttoncounter))
					table_center:setSelectedRow(row.index)
					table_center:setSelectedCol(rowbuttoncounter)
					icon2 = "be_upgrade_installed"
				end

				--print("adding button " .. tostring(rowbuttoncounter) .. " in row " .. tostring(rowcounter))
				local locrow = row.index
				local loccol = rowbuttoncounter
				local button = row[rowbuttoncounter]:createButton({ height = buttonheight, scaling = false, mouseOverText = theme.text })
				if theme.icon ~= "" then
					button:setIcon(theme.icon)
				end
				if icon2 then
					button:setIcon2(icon2)
				end
				row[rowbuttoncounter].handlers.onClick = function() return menu.buttonSetDefaultTheme(locmode, theme.id, locrow, loccol) end

				rowbuttoncounter = rowbuttoncounter + 1
			end
		end
	elseif mode[1] == "empire_list" then
		if (locmode == "painttheme") or (locmode == "uniform") then
			local currentthemeid = ""
			local headertext = ""
			local nonetext = ""
			local themeoptions = {}

			if (locmode == "painttheme") then
				headertext = ReadText(1001, 9119)	-- Ship Skin Selection
				nonetext = ReadText(1001, 9130)		-- (Paint Theme)None
				currentthemeid = ffi.string(C.GetPlayerPaintTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numpaintthemes = C.GetNumAvailablePaintThemes()
				local paintthemes = ffi.new("UIPaintTheme[?]", numpaintthemes)
				numpaintthemes = C.GetAvailablePaintThemes(paintthemes, numpaintthemes)
				for i = 0, numpaintthemes-1 do
					--table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = ffi.string(paintthemes[i].Icon) })
					table.insert(themeoptions, { id = ffi.string(paintthemes[i].ID), text = ffi.string(paintthemes[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(paintthemes[i].ID)) .. ", name: " .. tostring(ffi.string(paintthemes[i].Name)) .. ", icon: " .. tostring(ffi.string(paintthemes[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			elseif (locmode == "uniform") then
				headertext = ReadText(1001, 9120)	-- Uniform Selection
				nonetext = ReadText(1001, 9131)		-- (Uniform)None
				currentthemeid = ffi.string(C.GetPlayerClothingTheme())
				--print("current theme: " .. tostring(currentthemeid))

				local numuniforms = C.GetNumAvailableClothingThemes()
				local uniforms = ffi.new("UIClothingTheme[?]", numuniforms)
				numuniforms = C.GetAvailableClothingThemes(uniforms, numuniforms)
				for i = 0, numuniforms-1 do
					--table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = ffi.string(uniforms[i].Icon) })
					table.insert(themeoptions, { id = ffi.string(uniforms[i].ID), text = ffi.string(uniforms[i].Name), icon = "" })
					--print("id: " .. tostring(ffi.string(uniforms[i].ID)) .. ", name: " .. tostring(ffi.string(uniforms[i].Name)) .. ", icon: " .. tostring(ffi.string(uniforms[i].Icon)))
				end
				--print("num paint options: " .. tostring(#themeoptions))
			end

			table.sort(themeoptions, function (a, b) return a.text < b.text end)
			table.insert(themeoptions, { id = "", text = nonetext, icon = "" })

			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(headertext, Helper.titleTextProperties)

			for i, theme in ipairs(themeoptions) do
				--print("adding " .. tostring(locmode) .. " theme: " .. tostring(theme.id))
				row = table_center:addRow({locmode, theme.id}, {  })
				row[1]:setColSpan(5):createText(theme.text)

				--print("current theme: " .. tostring(currentthemeid) .. ", this theme: " .. tostring(theme.id))
				if theme.id == currentthemeid then
					menu.setselectedrow2 = row.index
				end
			end
		elseif locmode == "ships" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 6), Helper.titleTextProperties)	-- Ships

			row = table_center:addRow(nil, { fixed = true })
			row[1]:setColSpan(3):createText(ReadText(1001, 2809))	-- Name
			row[4]:createText(ReadText(1001, 9051))	-- Ship Type
			row[5]:createText(ReadText(1001, 2943))	-- Location
			for i, ship in ipairs(menu.empireData.ships) do
				local name, shiptype, location, isonlineobject = GetComponentData(ship.ship, "name", "shiptypename", "sector", "isonlineobject")
				if isonlineobject then
					location = ReadText(1001, 9121)	-- On venture
				end
				row = table_center:addRow({ "empire_ship", ship.ship }, {  })
				row[1]:setColSpan(3):createText(name)
				row[4]:createText(shiptype)
				row[5]:createText(location)
			end
		elseif locmode == "stations" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 4), Helper.titleTextProperties)	-- Stations

			row = table_center:addRow(nil, { fixed = true })
			row[1]:setColSpan(4):createText(ReadText(1001, 2809))	-- Name
			row[5]:createText(ReadText(1001, 2943))	-- Location

			for i, station in ipairs(menu.empireData.stations) do
				local name, sector = GetComponentData(station.station, "name", "sector")
				row = table_center:addRow({"empire_station", station.station}, {  })
				row[1]:setColSpan(4):createText(name)
				row[5]:createText(sector)
			end
		elseif locmode == "standingorders" then
			table_center:setColWidth(1, Helper.standardTextHeight)
			table_center:setColWidthPercent(2, 45)
			table_center:setColWidthPercent(4, 20)
			table_center:setColWidthPercent(5, 20)

			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9301), Helper.titleTextProperties)	-- Global Standing Orders

			local faction = "player"
			menu.signals = {}
			local numsignals = C.GetNumAllSignals()
			local allsignals = ffi.new("SignalInfo[?]", numsignals)
			numsignals = C.GetAllSignals(allsignals, numsignals)
			for i = 0, numsignals - 1 do
				local signalid = ffi.string(allsignals[i].id)
				table.insert( menu.signals, {id = signalid, name = ffi.string(allsignals[i].name), description = ffi.string(allsignals[i].description), defaultresponse = ffi.string(allsignals[i].defaultresponse), ask = allsignals[i].ask, responses = {} })

				local numresponses = C.GetNumAllResponsesToSignal(signalid)
				local allresponses = ffi.new("ResponseInfo[?]", numresponses)
				numresponses = C.GetAllResponsesToSignal(allresponses, numresponses, signalid)
				for j = 0, numresponses - 1 do
					table.insert(menu.signals[#menu.signals].responses, { id = ffi.string(allresponses[j].id), name = ffi.string(allresponses[j].name), description = ffi.string(allresponses[j].description) })
				end
			end

			for _, signalentry in ipairs(menu.signals) do
				local signalid = signalentry.id
				local defask = C.GetAskToSignalForFaction(signalid, faction)
				local defresponse = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, ""))
				local defresponse_military = ffi.string(C.GetDefaultResponseToSignalForFaction2(signalid, faction, "fight"))
				if not C.HasDefaultResponseToSignalForFaction(signalid, faction, "fight") then
					defresponse_military = "default"
				end
				local locresponses = {}
				local locresponses_military = {
					{ id = "default", text = ReadText(1001, 7789), icon = "", displayremoveoption = false },
				}
				for _, responseentry in ipairs(signalentry.responses) do
					table.insert(locresponses, { id = responseentry.id, text = responseentry.name, icon = "", displayremoveoption = false })
					table.insert(locresponses_military, { id = responseentry.id, text = responseentry.name, icon = "", displayremoveoption = false })
				end

				local row = table_center:addRow("orders_" .. tostring(signalid) .. "_response")
				row[1]:setColSpan(2):createText(ReadText(1001, 9320) .. " " .. tostring(signalentry.name) .. ReadText(1001, 120), textproperties)	-- Default global response to, :
				row[3]:setColSpan(3):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = defresponse }):setTextProperties({ fontsize = config.mapFontSize })
				row[3].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(newresponseid, faction, signalid, "factionresponses", "all") end

				local row = table_center:addRow("orders_" .. tostring(signalid) .. "_response_military")
				row[2]:createText(ReadText(1001, 9150) .. ReadText(1001, 120))
				row[3]:setColSpan(3):createDropDown(locresponses_military, { height = Helper.standardTextHeight, startOption = defresponse_military, active = hasmilitaryoverride }):setTextProperties({ fontsize = config.mapFontSize })
				row[3].handlers.onDropDownConfirmed = function(_, newresponseid) return menu.dropdownOrdersSetResponse(newresponseid, faction, signalid, "factionresponses", "military") end

				local row = table_center:addRow("orders_" .. tostring(signalid) .. "_ask")
				row[1]:createCheckBox(defask, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[1].handlers.onClick = function() return menu.checkboxOrdersSetAsk(faction, signalid, "factionresponses", row.index) end
				row[2]:setColSpan(2):createText(ReadText(1001, 9330), textproperties)	-- Notify me if incident occurs
				row[4]:setColSpan(2):createButton({ height = Helper.standardTextHeight, mouseOverText = ReadText(1026, 7714) }):setText(ReadText(1001, 7788), { halign = "center" })
				row[4].handlers.onClick = function () return menu.dropdownOrdersSetResponse("reset", faction, signalid, "factionresponses") end

				table_center:addEmptyRow()
			end

			-- preferred build method
			local row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7775) .. ReadText(1001, 120), textproperties)

			local cursetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the cursetting (which can be the method of the player's race) is in the list of options
					if id == cursetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				cursetting = "default"
			end

			local row = table_center:addRow("orders_buildmethod", {  })
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = cursetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersBuildRule

			table_center:addEmptyRow()

			-- resupply
			local row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7721) .. ReadText(1001, 120), textproperties)

			local locresponses = {
				{ id = 0,   text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
				{ id = 0.1, text = ReadText(1001, 7736), icon = "", displayremoveoption = false },
				{ id = 0.5, text = ReadText(1001, 7737), icon = "", displayremoveoption = false },
				{ id = 1.0, text = ReadText(1001, 7738), icon = "", displayremoveoption = false },
			}
			local row = table_center:addRow("orders_resupply", {})
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = Helper.round(C.GetPlayerGlobalLoadoutLevel(), 1) }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersResupply

			table_center:addEmptyRow()

			-- trade loop
			local row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7785) .. ReadText(1001, 120), textproperties)

			local locresponses = {
				{ id = "off",   text = ReadText(1001, 7726),  icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 3276) },
				{ id = "on",    text = ReadText(1001, 11643), icon = "", displayremoveoption = false },
			}
			local row = table_center:addRow("orders_cargoreservations", {  })
			row[1]:setColSpan(5):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = C.GetPlayerGlobalTradeLoopCargoReservationSetting() and "on" or "off" }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = menu.dropdownOrdersCargoReservations

			table_center:addEmptyRow()

			-- default weapon mode
			local row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7774) .. ReadText(1001, 120), textproperties)

			local weaponmodes = {
				[1] = { id = "defend",			text = ReadText(1001, 8613),	icon = "",	displayremoveoption = false },
				[2] = { id = "attackenemies",	text = ReadText(1001, 8614),	icon = "",	displayremoveoption = false },
				[3] = { id = "attackcapital",	text = ReadText(1001, 8634),	icon = "",	displayremoveoption = false },
				[4] = { id = "prefercapital",	text = ReadText(1001, 8637),	icon = "",	displayremoveoption = false },
				[5] = { id = "attackfighters",	text = ReadText(1001, 8635),	icon = "",	displayremoveoption = false },
				[6] = { id = "preferfighters",	text = ReadText(1001, 8638),	icon = "",	displayremoveoption = false },
				[7] = { id = "missiledefence",	text = ReadText(1001, 8636),	icon = "",	displayremoveoption = false },
				[8] = { id = "prefermissiles",	text = ReadText(1001, 8639),	icon = "",	displayremoveoption = false },
			}
			local row = table_center:addRow("orders_weaponmode", {})
			row[1]:setColSpan(5):createDropDown(weaponmodes, { height = Helper.standardTextHeight, startOption = ffi.string(C.GetFactionDefaultWeaponMode("player")) }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return C.SetFactionDefaultWeaponMode("player", id) end

			table_center:addEmptyRow()

			-- wait for undock/signal
			local row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9331) .. ReadText(1001, 120), textproperties)

			local row = table_center:addRow("playershipswait", {})
			local waiting = C.ShouldPlayerShipsWaitForPlayer()
			row[1]:createCheckBox(waiting, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[1].handlers.onClick = function(_, checked) C.SetPlayerShipsWaitForPlayer(checked) end
			row[1].properties.uiTriggerID = "playershipswait"
			row[2]:setColSpan(4):createText(ReadText(1001, 9332), textproperties)

			local row = table_center:addRow("playertaxiwait", {})
			local waiting = C.ShouldPlayerTaxiWaitForPlayer()
			row[1]:createCheckBox(waiting, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[1].handlers.onClick = function(_, checked) C.SetPlayerTaxiWaitsForPlayer(checked) end
			row[1].properties.uiTriggerID = "playertaxiwait"
			row[2]:setColSpan(4):createText(ReadText(1001, 9333), textproperties)

			local row = table_center:addRow("global_standing_orders_reset", {  })
			row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 7786), { halign = "center" })
			row[4].handlers.onClick = menu.buttonResetGlobalStandingOrders

			table_center:addEmptyRow()

			-- notifications
			local row = table_center:addRow(nil, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7727), Helper.titleTextProperties)	-- Notification Settings

			menu.typecategories = {
				[1] = { category = "npc_interactive",	name = ReadText(1001, 7728),	types = {} },
				[2] = { category = "npc_info",			name = ReadText(1001, 7729),	types = {} },
				[3] = { category = "ticker",			name = ReadText(1001, 7743),	types = {} },
			}
			local n = C.GetNumNotificationTypes()
			local buf = ffi.new("UINotificationType2[?]", n)
			n = C.GetNotificationTypes2(buf, n)
			for i = 0, n - 1 do
				local category = ffi.string(buf[i].category)
				for _, entry in ipairs(menu.typecategories) do
					if entry.category == category then
						table.insert(entry.types, { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), enabled = buf[i].enabled, enabledByDefault = buf[i].enabledByDefault })
						if entry.checkedcounts == nil then
							entry.checkedcounts = 0
						end
						if buf[i].enabled then
							entry.checkedcounts = entry.checkedcounts + 1
						end
						break
					end
				end
			end

			local hasrows = false
			for i, entry in ipairs(menu.typecategories) do
				if #entry.types ~= 0 then
					if hasrows then
						table_center:addEmptyRow()
					end

					local row = table_center:addRow(true, { bgColor = Color["row_background_unselectable"] })
					row[1]:createCheckBox(function () return entry.checkedcounts == #entry.types end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[1].handlers.onClick = function (_, checked) return menu.toggleAllNotificationSettings(entry, checked) end
					row[2]:setColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
					row[2].properties.font = Helper.standardFontBold
					hasrows = true

					for _, type in ipairs(entry.types) do
						local row = table_center:addRow(true, {  })
						row[1]:createCheckBox(function () return type.enabled end, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
						row[1].handlers.onClick = function (_, checked) return menu.checkboxNotification(entry, type.id, checked) end
						row[2]:setColSpan(4):createText(type.name, textproperties)
						row[2].properties.mouseOverText = type.desc
					end
				end
			end

			local row = table_center:addRow("notification_settings_reset", {  })
			row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 7787), { halign = "center" })
			row[4].handlers.onClick = menu.buttonResetNotificationSettings
		elseif locmode == "onlineitems" then
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9122), Helper.titleTextProperties)	-- Venture Ships

			row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(4):createText(ReadText(1001, 2809), { font = Helper.standardFontBold })	-- Name
			row[5]:createText(ReadText(1001, 9051), { font = Helper.standardFontBold })	-- Ship Type

			for i, ship in ipairs(menu.empireData.ships) do
				local name, shiptype, isonlineobject = GetComponentData(ship.ship, "name", "shiptypename", "isonlineobject")
				if isonlineobject then
					row = table_center:addRow({ "empire_onlineship", ship.ship }, { interative = false })
					row[1]:setColSpan(4):createText(name)
					row[5]:createText(shiptype)
				end
			end
		elseif locmode == "traderule" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.traderule = Helper.tableCopy(mode[3])
			else
				menu.traderule = {
					name = ReadText(1001, 11013) .. " #" .. (#menu.traderules + 1),
					iswhitelist = false,
					factions = {},
					defaults = { trade = false, supply = false, build = false },
				}
			end
			menu.editedTradeRule = mode[4] or Helper.tableCopy(menu.traderule)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 11010), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedTradeRule.name)
			row[2].handlers.onTextChanged = menu.editboxTradeRuleNameChanged

			if menu.traderule.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ active = menu.buttonTradeRuleCheckChanges, mouseOverText = ReadText(1026, 9116) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonTradeRuleConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonTradeRuleCheckChanges, mouseOverText = ReadText(1026, 9117) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonTradeRuleReset
				-- delete
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9115) }):setText(ReadText(1001, 11014), { halign = "center" })
				row[2].handlers.onClick = menu.buttonTradeRuleRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 11015), { halign = "center" })
				row[4].handlers.onClick = menu.buttonTradeRuleConfirm

				row = table_center:addRow(false, { fixed = true })
				row[2]:createText("")
			end

			-- defaults
			row = table_center:addRow(false, {  })
			row[2]:createText("")
			-- trade
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 11016) .. ReadText(1001, 120))
			row[2]:setColSpan(3):createText(ReadText(1001, 11017))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.trade, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("trade", checked) end
			-- supply
			row = table_center:addRow(true, {  })
			row[2]:setColSpan(3):createText(ReadText(1001, 11018))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.supply, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("supply", checked) end
			-- build
			row = table_center:addRow(true, {  })
			row[2]:setColSpan(3):createText(ReadText(1001, 11019))
			row[5]:createCheckBox(menu.editedTradeRule.defaults.build, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxTradeRuleDefault("build", checked) end

			-- data
			row = table_center:addRow(false, {  })
			row[2]:createText("")
			-- use whitelist
			row = table_center:addRow(true, {  })
			row[2]:setColSpan(3):createText(ReadText(1001, 11020))
			row[5]:createCheckBox(menu.editedTradeRule.iswhitelist, {  })
			row[5].handlers.onClick = menu.checkboxTradeRuleUseWhitelist
			row = table_center:addRow(false, {  })
			row[2]:createText("")
			-- factions
			row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1].properties.cellBGColor = Color["row_background"]
			row[2]:setColSpan(4):createText((menu.editedTradeRule.iswhitelist and ReadText(1001, 11022) or ReadText(1001, 11021)) .. ReadText(1001, 120))
			for _, faction in ipairs(menu.editedTradeRule.factions) do
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"), { color = (faction == "player") and Color["text_player"] or nil })
				row[5]:createButton({  }):setText("x", { halign = "center" })
				row[5].handlers.onClick = function () return menu.buttonTradeRuleRemoveFaction(faction) end
			end
			row = table_center:addRow(true, {  })
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonTradeRuleAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end

		elseif locmode == "blacklist" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.blacklist = Helper.tableCopy(mode[3])
			else
				menu.blacklist = {
					name = ReadText(1001, 9159) .. " #" .. (#menu.blacklists + 1),
					spaces = {},
					factions = {},
					defaults = { civilian = false, military = false },
				}
			end
			menu.editedBlacklist = mode[4] or Helper.tableCopy(menu.blacklist)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9143), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedBlacklist.name)
			row[2].handlers.onTextChanged = menu.editboxBlacklistNameChanged

			if menu.blacklist.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ active = menu.buttonBlacklistCheckChanges, mouseOverText = ReadText(1026, 9107) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonBlacklistConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonBlacklistCheckChanges, mouseOverText = ReadText(1026, 9108) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonBlacklistReset
				-- delete
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9106) }):setText(ReadText(1001, 9148), { halign = "center" })
				row[2].handlers.onClick = menu.buttonBlacklistRemove
				-- type
				row = table_center:addRow(false, {  })
				row[1]:createText(ReadText(1001, 9161) .. ReadText(1001, 120))
				local text, mouseovertext = "", ""
				for _, option in ipairs(config.blacklistTypes) do
					if option.id == menu.editedBlacklist.type then
						text = option.text
						mouseovertext = option.mouseovertext .. "\n\n" .. ReadText(1026, 9104)
						break
					end
				end
				row[2]:setColSpan(4):createText(text, { mouseOverText = mouseovertext })
			else
				-- save
				row = table_center:addRow(true, { fixed = true })
				row[4]:setColSpan(2):createButton({ active = menu.editedBlacklist.type ~= nil, mouseOverText = (menu.editedBlacklist.type == nil) and ReadText(1026, 9109) or ReadText(1026, 9105) }):setText(ReadText(1001, 9160), { halign = "center" })
				row[4].handlers.onClick = menu.buttonBlacklistConfirm

				row = table_center:addRow(false, { fixed = true })
				row[2]:createText("")
				-- type
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9161) .. ReadText(1001, 120))
				row[2]:setColSpan(4):createDropDown(config.blacklistTypes, { height = Helper.standardTextHeight, startOption = menu.editedBlacklist.type })
				row[2].handlers.onDropDownConfirmed = menu.dropdownBlacklistType
			end

			if menu.editedBlacklist.type ~= nil then
				row = table_center:addRow(false, {  })
				row[2]:createText("")
				-- military
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9149) .. ReadText(1001, 120))
				row[2]:setColSpan(3):createText(ReadText(1001, 9150))
				row[5]:createCheckBox(menu.editedBlacklist.defaults.military, {  })
				row[5].handlers.onClick = function (_, checked) return menu.checkboxBlacklistDefault("military", checked) end
				-- civilian
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(3):createText(ReadText(1001, 9151))
				row[5]:createCheckBox(menu.editedBlacklist.defaults.civilian, {  })
				row[5].handlers.onClick = function (_, checked) return menu.checkboxBlacklistDefault("civilian", checked) end
			end

			row = table_center:addRow(false, {  })
			row[2]:createText("")

			if menu.editedBlacklist.type == "sectortravel" then
				-- hazardous
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9168) .. ReadText(1001, 120))
				row[2]:setColSpan(3):createText(ReadText(1001, 9152))
				row[5]:createCheckBox(menu.editedBlacklist.hazardous, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistHazard
			end
			if (menu.editedBlacklist.type == "sectortravel") or (menu.editedBlacklist.type == "sectoractivity") then
				-- relation
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(3):createText(ReadText(1001, 9153))
				row[5]:createCheckBox(menu.editedBlacklist.relation == "enemy", {  })
				row[5].handlers.onClick = menu.checkboxBlacklistRelation
			end
			if menu.editedBlacklist.type ~= nil then
				table_center:addEmptyRow()
				-- factions
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(3):createText(ReadText(1001, 11020))
				row[5]:createCheckBox(menu.editedBlacklist.usefactionwhitelist, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistUseFactionWhitelist
				row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[1].properties.cellBGColor = Color["row_background"]
				row[2]:setColSpan(4):createText(((menu.editedBlacklist.type == "objectactivity") and (menu.editedBlacklist.usefactionwhitelist and ReadText(1001, 11041) or ReadText(1001, 9179)) or (menu.editedBlacklist.usefactionwhitelist and ReadText(1001, 11040) or ReadText(1001, 9154))) .. ReadText(1001, 120))
				for _, faction in ipairs(menu.editedBlacklist.factions) do
					row = table_center:addRow(true, {  })
					row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"), { color = (faction == "player") and Color["text_player"] or nil })
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonBlacklistRemoveFaction(faction) end
				end
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
				row[2].handlers.onClick = function () return menu.buttonBlacklistAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			end
			if (menu.editedBlacklist.type == "sectortravel") or (menu.editedBlacklist.type == "sectoractivity") then
				table_center:addEmptyRow()
				-- macros
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(3):createText(ReadText(1001, 11043))
				row[5]:createCheckBox(menu.editedBlacklist.usemacrowhitelist, {  })
				row[5].handlers.onClick = menu.checkboxBlacklistUseMacroWhitelist
				row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
				row[1].properties.cellBGColor = Color["row_background"]
				row[2]:setColSpan(4):createText((menu.editedBlacklist.usemacrowhitelist and ReadText(1001, 11042) or ReadText(1001, 9155)) .. ReadText(1001, 120))
				for _, spaceid in ipairs(menu.editedBlacklist.spaces) do
					row = table_center:addRow(true, {  })
					row[2]:setColSpan(3):createText("    " .. ffi.string(C.GetComponentName(spaceid)))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonBlacklistRemoveMacro(spaceid) end
				end
				row = table_center:addRow(true, {  })
				row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9157), { halign = "center" })
				row[2].handlers.onClick = function () return menu.buttonBlacklistAddMacro(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			end

		elseif locmode == "fightrule" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(3, 10)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.fightrule = Helper.tableCopy(mode[3], 3)
			else
				menu.fightrule = {
					name = ReadText(1001, 7756) .. " #" .. (#menu.fightrules + 1),
					settings = {},
					defaults = { attack = false },
				}
			end
			menu.editedFightRule = mode[4] or Helper.tableCopy(menu.fightrule, 3)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7753), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(nil, { fixed = true })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedFightRule.name)
			row[2].handlers.onTextChanged = menu.editboxFightRuleNameChanged

			if menu.fightrule.id then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ active = menu.buttonFightRuleCheckChanges, mouseOverText = ReadText(1026, 7703) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonFightRuleConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonFightRuleCheckChanges, mouseOverText = ReadText(1026, 7704) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonFightRuleReset
				-- delete
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ mouseOverText = ReadText(1026, 7705) }):setText(ReadText(1001, 7757), { halign = "center" })
				row[2].handlers.onClick = menu.buttonFightRuleRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 7758), { halign = "center" })
				row[4].handlers.onClick = menu.buttonFightRuleConfirm

				row = table_center:addRow(false, { fixed = true })
				row[2]:createText("")
			end

			row = table_center:addRow(false, {  })
			row[2]:createText("")
			-- default
			row = table_center:addRow(true, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 7766) .. ReadText(1001, 120))
			row[5]:createCheckBox(menu.editedFightRule.defaults.attack, {  })
			row[5].handlers.onClick = function (_, checked) return menu.checkboxFightRuleDefault("attack", checked) end

			row = table_center:addRow(false, {  })
			row[2]:createText("")

			row = table_center:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(5):createText(ReadText(1001, 44), { font = Helper.standardFontBold })
			row[2]:createText(ReadText(1001, 2809), { font = Helper.standardFontBold })
			row[3]:createText(ReadText(1001, 7749), { font = Helper.standardFontBold, halign = "center" })
			row[4]:setColSpan(2):createText(ReadText(1001, 7767), { font = Helper.standardFontBold, halign = "center" })

			local factions = {}
			local relations = GetLibrary("factions")
			for i, relation in ipairs(relations) do
				if relation.id ~= "player" then
					table.insert(factions, relation.id)
				end
			end
			table.sort(factions, Helper.sortFactionName)

			local overrideoptions = {
				{ id ="engage/default",		text = ReadText(1001, 7759), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7706) },
				{ id ="default/engage",		text = ReadText(1001, 7760), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7707), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/engage",		text = ReadText(1001, 7761), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7708) },
				{ id ="default/default",	text = ReadText(1001, 7762), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7709), C.GetRelationRangeUIMaxValue("killmilitary"), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/default",		text = ReadText(1001, 7763), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7710), C.GetRelationRangeUIMaxValue("killmilitary")) },
				{ id ="default/hold",		text = ReadText(1001, 7764), icon = "", displayremoveoption = false, mouseovertext = string.format(ReadText(1026, 7711), C.GetRelationRangeUIMaxValue("kill")) },
				{ id ="hold/hold",			text = ReadText(1001, 7765), icon = "", displayremoveoption = false, mouseovertext = ReadText(1026, 7712) },
			}

			for i, faction in ipairs(factions) do
				local name, shortname = GetFactionData(faction, "name", "shortname")
				local startoption = "default/default"
				if menu.editedFightRule.settings[faction] then
					startoption = menu.editedFightRule.settings[faction].civilian .. "/" .. menu.editedFightRule.settings[faction].military
				end

				local row = table_center:addRow(true, {  })
				row[2]:setColSpan(1):createText("[" .. shortname .. "] " .. name)
				row[3]:createText(function () return string.format("%+d", GetUIRelation(faction)) end, { halign = "right", font = Helper.standardFontMono, color = function () return menu.relationColor(faction) end })
				row[4]:setColSpan(2):createDropDown(overrideoptions, { height = Helper.standardTextHeight, startOption = startoption }):setTextProperties({ halign = "center" })
				row[4].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownFightRuleFactionSetting(faction, id) end
			end

		elseif locmode == "playeralert" then
			table_center:setColWidthPercent(1, 25)
			table_center:setColWidthPercent(2, 25)
			table_center:setColWidth(4, table_center.properties.width / 4 - Helper.standardTextHeight, false)
			table_center:setColWidth(5, Helper.standardTextHeight)

			if next(mode[3]) then
				menu.playeralert = Helper.tableCopy(mode[3])
			else
				menu.playeralert = {
					name = ReadText(1001, 9186) .. " #" .. (#menu.playeralerts + 1),
					interval = 300,
					objectclasses = { "object" },
					objectpurpose = "",
					objectidcode = "",
					objectowners = {},
					spaces = {},
					message = "",
					soundid = "",
				}
			end
			menu.editedPlayerAlert = mode[4] or Helper.tableCopy(menu.playeralert)
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9183), Helper.titleTextProperties)
			-- name
			row = table_center:addRow(true, { fixed = true })
			row[1]:createText(ReadText(1001, 2809) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 2809) }):setText(menu.editedPlayerAlert.name)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertNameChanged

			if menu.playeralert.index then
				-- confirm, cancel
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ active = menu.buttonPlayerAlertCheckChanges, mouseOverText = ReadText(1026, 9111) }):setText(ReadText(1001, 9146), { halign = "center" })
				row[2].handlers.onClick = menu.buttonPlayerAlertConfirm
				row[4]:setColSpan(2):createButton({ active = menu.buttonPlayerAlertCheckChanges, mouseOverText = ReadText(1026, 9112) }):setText(ReadText(1001, 9147), { halign = "center" })
				row[4].handlers.onClick = menu.buttonPlayerAlertReset
				-- delete
				row = table_center:addRow(true, { fixed = true })
				row[2]:createButton({ mouseOverText = ReadText(1026, 9110) }):setText(ReadText(1001, 9187), { halign = "center" })
				row[2].handlers.onClick = menu.buttonPlayerAlertRemove
			else
				-- save
				row = table_center:addRow(true, { fixed = true })
				row[4]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9188), { halign = "center" })
				row[4].handlers.onClick = menu.buttonPlayerAlertConfirm

				row = table_center:addRow(false, { fixed = true })
				row[2]:createText("")
			end

			row = table_center:addRow(false, {  })
			row[2]:createText("")

			-- notification text
			row = table_center:addRow(true, { fixed = true })
			row[1]:createText(ReadText(1001, 11009) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 11009) }):setText(menu.editedPlayerAlert.message)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertMessageChanged
			-- sound
			local n = C.GetNumPlayerAlertSounds2("general subtle hostile")
			local buf = ffi.new("SoundInfo[?]", n)
			n = C.GetPlayerAlertSounds2(buf, n, "general subtle hostile")
			local options = {}
			for i = 0, n - 1 do
				table.insert(options, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
			end
			table.sort(options, function (a, b) return a.text < b.text end)

			if (menu.editedPlayerAlert.soundid == "") and options[1] then
				menu.editedPlayerAlert.soundid = options[1].id
			end
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9192) .. ReadText(1001, 120))
			row[2]:setColSpan(3):createDropDown(options, { height = Helper.standardTextHeight, startOption = menu.editedPlayerAlert.soundid })
			row[2].handlers.onDropDownConfirmed = menu.dropdownPlayerAlertSound
			row[5]:createButton({ height = Helper.standardTextHeight }):setIcon("menu_sound_on")
			row[5].handlers.onClick = menu.buttonPlayerAlertSoundTest

			row = table_center:addRow(false, {  })
			row[2]:createText("")

			-- interval
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9193) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 9113) })
			row[2]:setColSpan(4):createSliderCell({ min = 1, max = 60, start = menu.editedPlayerAlert.interval / 60, suffix = ReadText(1001, 103), hideMaxValue = true, exceedMaxValue = true, height = Helper.standardTextHeight })
			row[2].handlers.onSliderCellChanged = menu.slidercellPlayerAlertInterval
			-- repeats
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9194) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 9114) })
			row[2]:setColSpan(4):createCheckBox(menu.editedPlayerAlert.repeats, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
			row[2].handlers.onClick = menu.checkboxPlayerAlertRepeat

			row = table_center:addRow(false, {  })
			row[2]:createText("")

			-- spaces
			if #menu.editedPlayerAlert.spaces > 0 then
				for i, spaceid in ipairs(menu.editedPlayerAlert.spaces) do
					row = table_center:addRow(true, {  })
						if i == 1 then
							row[1]:createText(ReadText(1001, 9190).. ReadText(1001, 120))
						end
					row[2]:setColSpan(3):createText("    " .. ffi.string(C.GetComponentName(spaceid)))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveSpace(spaceid) end
				end
				row = table_center:addRow(true, {  })
			else
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9190).. ReadText(1001, 120))
				row[2]:createText("    " .. ReadText(1001, 9191))
			end
			row = table_center:addRow(true, {  })
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9157), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddSpace(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end

			-- owner
			if #menu.editedPlayerAlert.objectowners > 0 then
				for i, faction in ipairs(menu.editedPlayerAlert.objectowners) do
					row = table_center:addRow(true, {  })
					if i == 1 then
						row[1]:createText(ReadText(1001, 9195).. ReadText(1001, 120))
					end
					row[2]:setColSpan(3):createText("    " .. GetFactionData(faction, "name"))
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveFaction(faction) end
				end
				row = table_center:addRow(true, {  })
			else
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9195).. ReadText(1001, 120))
			end
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9156), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddFaction(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			-- class
			if #menu.editedPlayerAlert.objectclasses > 0 then
				for i, class in ipairs(menu.editedPlayerAlert.objectclasses) do
					row = table_center:addRow(true, {  })
					if i == 1 then
						row[1]:createText(ReadText(1001, 9197).. ReadText(1001, 120))
					end
					row[2]:setColSpan(3):createText("    " .. config.classDefinitions[class])
					row[5]:createButton({  }):setText("x", { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonPlayerAlertRemoveClass(class) end
				end
				row = table_center:addRow(true, {  })
			else
				row = table_center:addRow(true, {  })
				row[1]:createText(ReadText(1001, 9197).. ReadText(1001, 120))
			end
			row[2]:setColSpan(4):createButton({  }):setText(ReadText(1001, 11008), { halign = "center" })
			row[2].handlers.onClick = function () return menu.buttonPlayerAlertAddClass(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
			-- purpose
			local purposes = { "trade", "fight", "build", "mine", "auxiliary" }
			local options = {
				{ id = "default", text = ReadText(1001, 11004), icon = "", displayremoveoption = false }
			}
			for _, purpose in ipairs(purposes) do
				table.insert(options, { id = purpose, text = ffi.string(C.GetPurposeName(purpose)), icon = "", displayremoveoption = false })
			end
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 9199) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createDropDown(options, { height = Helper.standardTextHeight, startOption = (menu.editedPlayerAlert.objectpurpose ~= "") and menu.editedPlayerAlert.objectpurpose or "default" })
			row[2].handlers.onDropDownConfirmed = menu.dropdownPlayerAlertPurpose
			-- idcode
			row = table_center:addRow(true, {  })
			row[1]:createText(ReadText(1001, 11005) .. ReadText(1001, 120))
			row[2]:setColSpan(4):createEditBox({ description = ReadText(1001, 11005) }):setText(menu.editedPlayerAlert.objectidcode)
			row[2].handlers.onTextChanged = menu.editboxPlayerAlertIDCodeChanged
		elseif locmode == "sectorownership" then
			-- title
			local row = table_center:addRow(nil, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 9601), Helper.titleTextProperties)
			-- owned sectors
			local row = table_center:addRow(true, { interactive = false })
			row[1]:setBackgroundColSpan(5):createText(ReadText(1001, 9181))

			local skiprow = true
			local clusters = GetClusters(true)
			for _, cluster in ipairs(clusters) do
				local sectors = GetSectors(cluster)
				for _, sector in ipairs(sectors) do
					if GetComponentData(sector, "isplayerowned") then
						if not skiprow then
							row = table_center:addRow(true, { interactive = false })
							row[1]:setBackgroundColSpan(5)
						end
						skiprow = false
						row[2]:setColSpan(4):createText(ffi.string(C.GetComponentName(ConvertIDTo64Bit(sector))), { halign = "right" })
					end
				end
			end

			local row = table_center:addRow(nil, { bgColor = Color["player_info_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 2435), Helper.headerRowCenteredProperties)
			-- illegal wares
			local illegalWares = {}
			local n = C.GetNumWares("economy", false, "", "")
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWares(buf, n, "economy", false, "", "")
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				local name, playerillegal = GetWareData(ware, "name", "playerillegal")
				if playerillegal then
					table.insert(illegalWares, { ware = ware, name = name })
				end
			end
			table.sort(illegalWares, Helper.sortName)

			if #illegalWares > 0 then
				for _, entry in ipairs(illegalWares) do
					local row = table_center:addRow(true, { interactive = false })
					row[1]:createText(entry.name)
				end
			else
				local row = table_center:addRow(true, { interactive = false })
				row[1]:createText("--- " .. ReadText(1001, 32) .. " ---")
			end
			-- button
			local row = table_center:addRow(true, {  })
			row[1]:setColSpan(2):createButton({}):setText(ReadText(1001, 8378), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonIllegalWares(table_center.properties.x + table_center.properties.width + Helper.borderSize, table_center.properties.y) end
		end
	elseif mode[1] == "empire_call" then

		local tableProperties = properties_table_center
		tableProperties.height = Helper.viewHeight - tableProperties.y

		if locmode == "stationcash" then
			return menu.createAccounts(menu.infoFrame, tableProperties, tabOrderOffset)
		elseif locmode == "inventory" then
			return menu.createInventory(menu.infoFrame, tableProperties, nil, tabOrderOffset)
		end
	end
end

function menu.logoButtonIcon2(logo)
	if (logo.icon == menu.empireData.currentlogo.icon) and (logo.ispersonal == menu.empireData.currentlogo.ispersonal) then
		return "be_upgrade_installed"
	end
	return "solid"
end

function menu.logoButtonIcon2Color(logo)
	if (logo.icon == menu.empireData.currentlogo.icon) and (logo.ispersonal == menu.empireData.currentlogo.ispersonal) then
		return Color["text_positive"]
	end
	return Color["icon_hidden"]
end

function menu.buttonTradeRuleConfirm()
	local traderule = ffi.new("TradeRuleInfo")
	traderule.name = Helper.ffiNewString(menu.editedTradeRule.name)

	traderule.iswhitelist = menu.editedTradeRule.iswhitelist
	traderule.numfactions = #menu.editedTradeRule.factions
	traderule.factions = Helper.ffiNewHelper("const char*[?]", traderule.numfactions)
	for i, faction in ipairs(menu.editedTradeRule.factions) do
		traderule.factions[i - 1] = Helper.ffiNewString(faction)
	end

	if menu.editedTradeRule.id then
		traderule.id = menu.editedTradeRule.id
		C.UpdateTradeRule(traderule)
	else
		menu.editedTradeRule.id = C.CreateTradeRule(traderule)
	end

	if menu.editedTradeRule.id ~= 0 then
		if menu.editedTradeRule.defaults.trade or menu.traderule.defaults.trade then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "buy", menu.editedTradeRule.defaults.trade)
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "sell", menu.editedTradeRule.defaults.trade)
		end
		if menu.editedTradeRule.defaults.supply or menu.traderule.defaults.supply then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "supply", menu.editedTradeRule.defaults.supply)
		end
		if menu.editedTradeRule.defaults.build or menu.traderule.defaults.build then
			C.SetPlayerTradeRuleDefault(menu.editedTradeRule.id, "build", menu.editedTradeRule.defaults.build)
		end
	end

	menu.empireData.mode[3] = menu.editedTradeRule
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleRemove()
	C.RemoveTradeRule(menu.editedTradeRule.id)
	menu.editedTradeRule = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleCheckChanges()
	for k, v in pairs(menu.traderule) do
		if type(v) == "table" then
			if #menu.editedTradeRule[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedTradeRule[k][k2] ~= v2 then
					return true
				end
			end
		else
			if menu.editedTradeRule[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.buttonTradeRuleAddFaction(x, y)
	menu.contextMenuMode = "traderulefaction"
	menu.createContext(x, y)
end

function menu.buttonBlacklistConfirm()
	local blacklist = ffi.new("BlacklistInfo2")
	blacklist.type = Helper.ffiNewString(menu.editedBlacklist.type)
	blacklist.name = Helper.ffiNewString(menu.editedBlacklist.name)
	blacklist.relation = Helper.ffiNewString(menu.editedBlacklist.relation or "")
	blacklist.hazardous = menu.editedBlacklist.hazardous or false

	blacklist.nummacros = #menu.editedBlacklist.spaces
	blacklist.macros = Helper.ffiNewHelper("const char*[?]", blacklist.nummacros)
	for i, spaceid in ipairs(menu.editedBlacklist.spaces) do
		blacklist.macros[i - 1] = Helper.ffiNewString(GetComponentData(spaceid, "macro"))
	end
	blacklist.usemacrowhitelist = menu.editedBlacklist.usemacrowhitelist or false

	blacklist.numfactions = #menu.editedBlacklist.factions
	blacklist.factions = Helper.ffiNewHelper("const char*[?]", blacklist.numfactions)
	for i, faction in ipairs(menu.editedBlacklist.factions) do
		blacklist.factions[i - 1] = Helper.ffiNewString(faction)
	end
	blacklist.usefactionwhitelist = menu.editedBlacklist.usefactionwhitelist or false

	if menu.editedBlacklist.id then
		blacklist.id = menu.editedBlacklist.id
		C.UpdateBlacklist2(blacklist)
	else
		menu.editedBlacklist.id = C.CreateBlacklist2(blacklist)
	end

	if menu.editedBlacklist.id ~= 0 then
		if menu.editedBlacklist.defaults.civilian or menu.blacklist.defaults.civilian then
			C.SetPlayerBlacklistDefault(menu.editedBlacklist.id, menu.editedBlacklist.type, "civilian", menu.editedBlacklist.defaults.civilian)
		end
		if menu.editedBlacklist.defaults.military or menu.blacklist.defaults.military then
			C.SetPlayerBlacklistDefault(menu.editedBlacklist.id, menu.editedBlacklist.type, "military", menu.editedBlacklist.defaults.military)
		end
	end

	menu.empireData.mode[3] = menu.editedBlacklist
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistReset()
	--menu.editedBlacklist = Helper.tableCopy(menu.blacklist)
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemove()
	C.RemoveBlacklist(menu.editedBlacklist.id)
	menu.editedBlacklist = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistCheckChanges()
	for k, v in pairs(menu.blacklist) do
		if type(v) == "table" then
			if #menu.editedBlacklist[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedBlacklist[k][k2] ~= v2 then
					return true
				end
			end
		else
			if menu.editedBlacklist[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.buttonBlacklistAddFaction(x, y)
	menu.contextMenuMode = "blacklistfaction"
	menu.createContext(x, y)
end

function menu.buttonBlacklistAddMacro(x, y)
	menu.contextMenuMode = "blacklistsector"
	menu.createContext(x, y)
end

function menu.buttonIllegalWares(x, y)
	menu.contextMenuMode = "illegalwares"
	menu.createContext(x, y)
end

function menu.buttonSelectContextSetList(data)
	if menu.contextMenuMode == "blacklistfaction" then
		menu.editedBlacklist.factions = {}
		local hasplayer = false
		for faction in pairs(data) do
			if faction == "player" then
				hasplayer = true
			else
				table.insert(menu.editedBlacklist.factions, faction)
			end
		end
		table.sort(menu.editedBlacklist.factions, Helper.sortFactionName)
		if hasplayer then
			table.insert(menu.editedBlacklist.factions, 1, "player")
		end
		menu.empireData.mode[4] = menu.editedBlacklist
	elseif menu.contextMenuMode == "blacklistsector" then
		menu.editedBlacklist.spaces = {}
		for spaceid in pairs(data) do
			table.insert(menu.editedBlacklist.spaces, spaceid)
		end
		table.sort(menu.editedBlacklist.spaces, Helper.sortUniverseIDName)
		menu.empireData.mode[4] = menu.editedBlacklist
	elseif menu.contextMenuMode == "illegalwares" then
		for _, entry in ipairs(menu.contextMenuData.data) do
			C.SetPlayerIllegalWare(entry, data[entry] or false)
		end
	elseif menu.contextMenuMode == "playeralertclass" then
		menu.editedPlayerAlert.objectclasses = {}
		for class in pairs(data) do
			table.insert(menu.editedPlayerAlert.objectclasses, class)
		end
		table.sort(menu.editedPlayerAlert.objectclasses, menu.sortClasses)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "playeralertfaction" then
		menu.editedPlayerAlert.objectowners = {}
		for faction in pairs(data) do
			table.insert(menu.editedPlayerAlert.objectowners, faction)
		end
		table.sort(menu.editedPlayerAlert.objectowners, Helper.sortFactionName)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "playeralertsector" then
		menu.editedPlayerAlert.spaces = {}
		for spaceid in pairs(data) do
			table.insert(menu.editedPlayerAlert.spaces, spaceid)
		end
		table.sort(menu.editedPlayerAlert.spaces, Helper.sortUniverseIDName)
		menu.empireData.mode[4] = menu.editedPlayerAlert
	elseif menu.contextMenuMode == "traderulefaction" then
		menu.editedTradeRule.factions = {}
		local hasplayer = false
		for faction in pairs(data) do
			if faction == "player" then
				hasplayer = true
			else
				table.insert(menu.editedTradeRule.factions, faction)
			end
		end
		table.sort(menu.editedTradeRule.factions, Helper.sortFactionName)
		if hasplayer then
			table.insert(menu.editedTradeRule.factions, 1, "player")
		end
		menu.empireData.mode[4] = menu.editedTradeRule
	end

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.sortClasses(a, b)
	local aname = config.classDefinitions[a] or ""
	local bname = config.classDefinitions[b] or ""

	return aname > bname
end

function menu.editboxTradeRuleNameChanged(_, text)
	menu.noupdate = nil
	menu.editedTradeRule.name = text
end

function menu.checkboxTradeRuleDefault(group, checked)
	menu.editedTradeRule.defaults[group] = checked
end

function menu.checkboxTradeRuleUseWhitelist(_, checked)
	menu.editedTradeRule.iswhitelist = checked
	if checked then
		menu.editedTradeRule.factions = { "player" }
	else
		menu.editedTradeRule.factions = {}
	end

	menu.empireData.mode[4] = menu.editedTradeRule
	menu.refreshInfoFrame()
end

function menu.buttonTradeRuleRemoveFaction(faction)
	for i, entry in ipairs(menu.editedTradeRule.factions) do
		if entry == faction then
			table.remove(menu.editedTradeRule.factions, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedTradeRule
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemoveFaction(faction)
	for i, entry in ipairs(menu.editedBlacklist.factions) do
		if entry == faction then
			table.remove(menu.editedBlacklist.factions, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.buttonBlacklistRemoveMacro(spaceid)
	for i, entry in ipairs(menu.editedBlacklist.spaces) do
		if entry == spaceid then
			table.remove(menu.editedBlacklist.spaces, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.checkboxBlacklistDefault(group, checked)
	menu.editedBlacklist.defaults[group] = checked
end

function menu.checkboxSelectContextSetList(entry, checked)
	menu.contextMenuData.selectedData[entry] = checked or nil
end

function menu.checkboxSelectContextToggleList(checked)
	for _, entry in ipairs(menu.contextMenuData.data) do
		menu.contextMenuData.selectedData[entry] = checked or nil
	end
end

function menu.checkboxBlacklistHazard(_, checked)
	menu.editedBlacklist.hazardous = checked
end

function menu.checkboxBlacklistRelation(_, checked)
	menu.editedBlacklist.relation = checked and "enemy" or ""
end

function menu.checkboxBlacklistUseFactionWhitelist(_, checked)
	menu.editedBlacklist.usefactionwhitelist = checked
	if checked then
		menu.editedBlacklist.factions = { "player" }
	else
		menu.editedBlacklist.factions = {}
	end

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.checkboxBlacklistUseMacroWhitelist(_, checked)
	menu.editedBlacklist.usemacrowhitelist = checked
	menu.editedBlacklist.spaces = {}

	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.dropdownBlacklistType(_, newtype)
	menu.editedBlacklist.type = newtype
	menu.empireData.mode[4] = menu.editedBlacklist
	menu.refreshInfoFrame()
end

function menu.editboxBlacklistNameChanged(_, text)
	menu.noupdate = nil
	menu.editedBlacklist.name = text
end

function menu.buttonFightRuleConfirm()
	local fightrule = ffi.new("FightRuleInfo")
	fightrule.name = Helper.ffiNewString(menu.editedFightRule.name)

	fightrule.numfactions = 0
	for faction, entry in pairs(menu.editedFightRule.settings) do
		fightrule.numfactions = fightrule.numfactions + 1
	end
	fightrule.factions = Helper.ffiNewHelper("UIFightRuleSetting[?]", fightrule.numfactions)
	local i = 0
	for faction, entry in pairs(menu.editedFightRule.settings) do
		fightrule.factions[i].factionid = Helper.ffiNewString(faction)
		if entry.civilian == "default" then
			fightrule.factions[i].civiliansetting = Helper.ffiNewString("")
		else
			fightrule.factions[i].civiliansetting = Helper.ffiNewString(entry.civilian)
		end
		if entry.military == "default" then
			fightrule.factions[i].militarysetting = Helper.ffiNewString("")
		else
			fightrule.factions[i].militarysetting = Helper.ffiNewString(entry.military)
		end
		i = i + 1
	end

	if menu.editedFightRule.id then
		fightrule.id = menu.editedFightRule.id
		C.UpdateFightRule(fightrule)
	else
		menu.editedFightRule.id = C.CreateFightRule(fightrule)
	end

	if menu.editedFightRule.id ~= 0 then
		if menu.editedFightRule.defaults.attack then
			C.SetPlayerFightRuleDefault(menu.editedFightRule.id, "attack", menu.editedFightRule.defaults.attack)
		end
	end

	menu.empireData.mode[3] = menu.editedFightRule
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleRemove()
	C.RemoveFightRule(menu.editedFightRule.id)
	menu.editedFightRule = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonFightRuleCheckChanges()
	for k, v in pairs(menu.fightrule) do
		if type(v) == "table" then
			if Helper.tableLength(menu.editedFightRule[k]) ~= Helper.tableLength(v) then
				return true
			end
			for k2, v2 in pairs(v) do
				if type(v2) == "table" then
					if Helper.tableLength(menu.editedFightRule[k][k2]) ~= Helper.tableLength(v2) then
						return true
					end
					for k3, v3 in pairs(v2) do
						if menu.editedFightRule[k][k2][k3] ~= v3 then
							return true
						end
					end
				else
					if menu.editedFightRule[k][k2] ~= v2 then
						return true
					end
				end
			end
		else
			if menu.editedFightRule[k] ~= v then
				return true
			end
		end
	end
	return false
end

function menu.editboxFightRuleNameChanged(_, text)
	menu.noupdate = nil
	menu.editedFightRule.name = text
end

function menu.checkboxFightRuleDefault(group, checked)
	menu.editedFightRule.defaults[group] = checked
end

function menu.dropdownFightRuleFactionSetting(faction, id)
	if id then
		local civilian, military = string.match(id, "(.+)/(.+)")
		if menu.editedFightRule.settings[faction] then
			if (civilian == "default") and (military == "default") then
				menu.editedFightRule.settings[faction] = nil
			else
				menu.editedFightRule.settings[faction].civilian = civilian
				menu.editedFightRule.settings[faction].military = military
			end
		elseif (civilian ~= "default") or (military ~= "default") then
			menu.editedFightRule.settings[faction] = { civilian = civilian, military = military }
		end
	end
end

function menu.buttonPlayerAlertConfirm()
	local playeralert = ffi.new("PlayerAlertInfo2")
	playeralert.interval = menu.editedPlayerAlert.interval
	playeralert.repeats = menu.editedPlayerAlert.repeats or false
	playeralert.muted = menu.editedPlayerAlert.muted or false

	playeralert.numspaces = #menu.editedPlayerAlert.spaces
	playeralert.spaceids = Helper.ffiNewHelper("UniverseID[?]", playeralert.numspaces)
	for i, space in ipairs(menu.editedPlayerAlert.spaces) do
		playeralert.spaceids[i - 1] = space
	end

	local objectclass = ""
	for i, class in ipairs(menu.editedPlayerAlert.objectclasses) do
		objectclass = objectclass .. ((i > 1) and " " or "") .. class
	end
	playeralert.objectclass = Helper.ffiNewString(objectclass)

	local objectowner = ""
	for i, faction in ipairs(menu.editedPlayerAlert.objectowners) do
		objectowner = objectowner .. ((i > 1) and " " or "") .. faction
	end
	playeralert.objectowner = Helper.ffiNewString(objectowner)

	playeralert.objectpurpose = Helper.ffiNewString(menu.editedPlayerAlert.objectpurpose or "")
	playeralert.objectidcode = Helper.ffiNewString(menu.editedPlayerAlert.objectidcode or "")
	playeralert.name = Helper.ffiNewString(menu.editedPlayerAlert.name or "")
	playeralert.message = Helper.ffiNewString(menu.editedPlayerAlert.message or "")
	playeralert.soundid = Helper.ffiNewString(menu.editedPlayerAlert.soundid or "")

	if menu.editedPlayerAlert.index then
		playeralert.index = menu.editedPlayerAlert.index
		C.UpdatePlayerAlert2(playeralert)
	else
		C.AddPlayerAlert2(playeralert)
		menu.editedPlayerAlert.index = #menu.playeralerts + 1
	end

	menu.empireData.mode[3] = menu.editedPlayerAlert
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertReset()
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemove()
	C.RemovePlayerAlert(menu.editedPlayerAlert.index)
	menu.editedPlayerAlert = {}
	menu.empireData.mode[4] = nil
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertCheckChanges()
	for k, v in pairs(menu.playeralert) do
		if type(v) == "table" then
			if #menu.editedPlayerAlert[k] ~= #v then
				return true
			end
			for k2, v2 in pairs(v) do
				if menu.editedPlayerAlert[k][k2] ~= v2 then
					return true
				end
			end
		elseif menu.editedPlayerAlert[k] ~= v then
			return true
		end
	end
	return false
end

function menu.buttonPlayerAlertSoundTest()
	if menu.editedPlayerAlert.soundid ~= "" then
		PlaySound(menu.editedPlayerAlert.soundid)
	end
end

function menu.buttonPlayerAlertRemoveClass(class)
	for i, entry in ipairs(menu.editedPlayerAlert.objectclasses) do
		if entry == class then
			table.remove(menu.editedPlayerAlert.objectclasses, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemoveFaction(faction)
	for i, entry in ipairs(menu.editedPlayerAlert.objectowners) do
		if entry == faction then
			table.remove(menu.editedPlayerAlert.objectowners, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertRemoveSpace(spaceid)
	for i, entry in ipairs(menu.editedPlayerAlert.spaces) do
		if entry == spaceid then
			table.remove(menu.editedPlayerAlert.spaces, i)
			break
		end
	end

	menu.empireData.mode[4] = menu.editedPlayerAlert
	menu.refreshInfoFrame()
end

function menu.buttonPlayerAlertAddClass(x, y)
	menu.contextMenuMode = "playeralertclass"
	menu.createContext(x, y)
end

function menu.buttonPlayerAlertAddFaction(x, y)
	menu.contextMenuMode = "playeralertfaction"
	menu.createContext(x, y)
end

function menu.buttonPlayerAlertAddSpace(x, y)
	menu.contextMenuMode = "playeralertsector"
	menu.createContext(x, y)
end

function menu.buttonResetGlobalStandingOrders()
	for _, signalentry in ipairs(menu.signals) do
		C.SetDefaultResponseToSignalForFaction2(signalentry.defaultresponse, signalentry.ask, signalentry.id, "player", "")
		C.SetDefaultResponseToSignalForFaction2(signalentry.defaultresponse, signalentry.ask, signalentry.id, "player", "fight")
		C.SetDefaultResponseToSignalForFaction2(signalentry.defaultresponse, signalentry.ask, signalentry.id, "player", "auxiliary")
		menu.dropdownOrdersSetResponse("reset", "player", signalentry.id, "factionresponses")
	end

	C.SetFactionBuildMethod("player", C.GetDefaultPlayerBuildMethod())
	C.SetPlayerGlobalLoadoutLevel(0)
	C.SetPlayerTradeLoopCargoReservationSetting(true)
	C.SetFactionDefaultWeaponMode("player", "defend")
	C.SetPlayerShipsWaitForPlayer(true)
	C.SetPlayerTaxiWaitsForPlayer(true)

	menu.refreshInfoFrame()
end

function menu.buttonResetNotificationSettings()
	for i, entry in ipairs(menu.typecategories) do
		for _, type in ipairs(entry.types) do
			C.SetNotificationTypeEnabled(type.id, type.enabledByDefault)
		end
	end
	menu.refreshInfoFrame()
end

function menu.dropdownPlayerAlertSpace(_, newspace)
	menu.editedPlayerAlert.spaceid = ConvertStringTo64Bit(newspace)
end

function menu.dropdownPlayerAlertSound(_, newsound)
	menu.editedPlayerAlert.soundid = newsound
end

function menu.dropdownPlayerAlertPurpose(_, newpurpose)
	menu.editedPlayerAlert.objectpurpose = (newpurpose ~= "default") and newpurpose or ""
end

function menu.editboxPlayerAlertNameChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.name = text
end

function menu.editboxPlayerAlertMessageChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.message = text
end

function menu.editboxPlayerAlertIDCodeChanged(_, text)
	menu.noupdate = nil
	menu.editedPlayerAlert.objectidcode = text
end

function menu.slidercellPlayerAlertInterval(_, value)
	menu.editedPlayerAlert.interval = value * 60
end

function menu.checkboxPlayerAlertRepeat(_, checked)
	menu.editedPlayerAlert.repeats = checked
end

function menu.createContext(x, y)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = 1.5 * menu.contextMenuWidth,
		x = x,
		y = y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.contextMenuData = { data = {} , selectedData = {}, origSelectedData = {}}
	if menu.contextMenuMode == "blacklistfaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)
		table.insert(menu.contextMenuData.data, 1, "player")

		for _, faction in ipairs(menu.editedBlacklist.factions) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	elseif menu.contextMenuMode == "blacklistsector" then
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.data, ConvertIDTo64Bit(sector))
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortUniverseIDName)

		for _, spaceid in ipairs(menu.editedBlacklist.spaces) do
			menu.contextMenuData.selectedData[spaceid] = true
			menu.contextMenuData.origSelectedData[spaceid] = true
		end
	elseif menu.contextMenuMode == "illegalwares" then
		local n = C.GetNumWares("economy", false, "", "")
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, "economy", false, "", "")
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			table.insert(menu.contextMenuData.data, ware)
			if GetWareData(ware, "playerillegal") then
				menu.contextMenuData.selectedData[ware] = true
				menu.contextMenuData.origSelectedData[ware] = true
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortWareName)
	elseif menu.contextMenuMode == "playeralertclass" then
		menu.contextMenuData.data = { "object", "station", "ship_s", "ship_m", "ship_l", "ship_xl" }

		for _, class in ipairs(menu.editedPlayerAlert.objectclasses) do
			menu.contextMenuData.selectedData[class] = true
			menu.contextMenuData.origSelectedData[class] = true
		end
	elseif menu.contextMenuMode == "playeralertfaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)

		for _, faction in ipairs(menu.editedPlayerAlert.objectowners) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	elseif menu.contextMenuMode == "playeralertsector" then
		local clusters = GetClusters(true)
		for _, cluster in ipairs(clusters) do
			local sectors = GetSectors(cluster)
			for _, sector in ipairs(sectors) do
				table.insert(menu.contextMenuData.data, ConvertIDTo64Bit(sector))
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortUniverseIDName)

		for _, spaceid in ipairs(menu.editedPlayerAlert.spaces) do
			menu.contextMenuData.selectedData[spaceid] = true
			menu.contextMenuData.origSelectedData[spaceid] = true
		end
	elseif menu.contextMenuMode == "traderulefaction" then
		local relations = GetLibrary("factions")
		for i, relation in ipairs(relations) do
			if relation.id ~= "player" then
				table.insert(menu.contextMenuData.data, relation.id)
			end
		end
		table.sort(menu.contextMenuData.data, Helper.sortFactionName)
		table.insert(menu.contextMenuData.data, 1, "player")

		for _, faction in ipairs(menu.editedTradeRule.factions) do
			menu.contextMenuData.selectedData[faction] = true
			menu.contextMenuData.origSelectedData[faction] = true
		end
	end

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 4 })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 50)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedData) do count = count + 1 end; return #menu.contextMenuData.data == count end, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxSelectContextToggleList(checked) end
	local text = ""
	if menu.contextMenuMode == "blacklistfaction" then
		text = ReadText(1001, 9176)
	elseif menu.contextMenuMode == "blacklistsector" then
		text = ReadText(1001, 9177)
	elseif menu.contextMenuMode == "illegalwares" then
		text = ReadText(1001, 8376)
	elseif menu.contextMenuMode == "playeralertclass" then
		text = ReadText(1001, 11007)
	elseif menu.contextMenuMode == "playeralertfaction" then
		text = ReadText(1001, 9176)
	elseif menu.contextMenuMode == "playeralertsector" then
		text = ReadText(1001, 9177)
	elseif menu.contextMenuMode == "traderulefaction" then
		text = ReadText(1001, 9176)
	end
	row[2]:setColSpan(2):createText(text, Helper.headerRowCenteredProperties)

	if #menu.contextMenuData.data > 0 then
		for _, entry in ipairs(menu.contextMenuData.data) do
			local row = ftable:addRow(true, {  })
			row[1]:createCheckBox(function () return menu.contextMenuData.selectedData[entry] or false end, {  })
			row[1].handlers.onClick = function (_, checked) return menu.checkboxSelectContextSetList(entry, checked) end
			local text, color = ""
			if menu.contextMenuMode == "blacklistfaction" then
				text = GetFactionData(entry, "name")
				if entry == "player" then
					color = Color["text_player"]
				end
			elseif menu.contextMenuMode == "blacklistsector" then
				text = ffi.string(C.GetComponentName(entry))
			elseif menu.contextMenuMode == "illegalwares" then
				text = GetWareData(entry, "name")
			elseif menu.contextMenuMode == "playeralertclass" then
				text = config.classDefinitions[entry]
			elseif menu.contextMenuMode == "playeralertfaction" then
				text = GetFactionData(entry, "name")
			elseif menu.contextMenuMode == "playeralertsector" then
				text = ffi.string(C.GetComponentName(entry))
			elseif menu.contextMenuMode == "traderulefaction" then
				text = GetFactionData(entry, "name")
				if entry == "player" then
					color = Color["text_player"]
				end
			end
			row[2]:setColSpan(2):createText(text, { color = color })
		end

		local buttontable = menu.contextFrame:addTable(2, { tabOrder = 5 })

		local row = buttontable:addRow(true, { fixed = true })
		row[1]:createButton({ active = menu.isDataSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonSelectContextSetList(menu.contextMenuData.selectedData) end
		row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
		row[2].handlers.onClick = function () return menu.onCloseElement("back") end

		local dataheight = ftable:getFullHeight()
		local buttonheight = buttontable:getFullHeight()
		if menu.contextFrame.properties.y + ftable.properties.y + dataheight + buttonheight + Helper.frameBorder > Helper.viewHeight then
			buttontable.properties.y = Helper.viewHeight - menu.contextFrame.properties.y - Helper.frameBorder - buttonheight
			ftable.properties.maxVisibleHeight = buttontable.properties.y - Helper.borderSize - ftable.properties.y
	else
			buttontable.properties.y = ftable.properties.y + dataheight + Helper.borderSize
		end

		ftable:addConnection(1, 4, true)
		buttontable:addConnection(2, 4)
	else
		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(3):createText("--- " .. ReadText(1001, 32) .. " ---", { halign = "center" })
	end

	menu.contextFrame:display()
end

function menu.isDataSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedData) do
		if not menu.contextMenuData.origSelectedData[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedData) do
		if not menu.contextMenuData.selectedData[ware] then
			return true
		end
	end
	return false
end

function menu.empireCanShowObject(object)
	if menu.empireData.mode and (menu.empireData.mode[2] == "inventory") then
		return false
	elseif not C.IsComponentClass(object, "object") and not C.IsComponentClass(object, "npc") then
		return false
	elseif C.IsComponentClass(object, "ship") and GetComponentData(object, "isdocked") and not C.IsShipAtExternalDock(object) then
		return false
	end

	return true
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 4, highlightMode = "off" })

	if menu.contextMenuMode == "inventory" then
		local counter = 0
		local allowencyclopedia = true
		local allowdrop = 0
		local dropmouseovertext = ReadText(1001, 7714)
		for ware in pairs(menu.inventoryData.selectedWares) do
			counter = counter + 1
			if counter > 1 then
				allowencyclopedia = false
			end
			if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
				allowdrop = allowdrop + 1
			else
				dropmouseovertext = dropmouseovertext .. "\n" .. GetWareData(ware, "name")
			end
		end

		local title = data[2].name
		if counter > 1 then
			title = string.format(ReadText(1001, 7713), counter)
		end

		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(title, Helper.titleTextProperties)

		row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ active = allowencyclopedia, bgColor = allowencyclopedia and Color["button_background_hidden"] or Color["button_background_inactive"] }):setText(ReadText(1001, 2400), { color = allowencyclopedia and Color["text_normal"] or Color["text_inactive"] })
		row[1].handlers.onClick = function () return menu.buttonInventoryEncyclopedia(data[1]) end

		row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ active = allowdrop > 0, bgColor = allowdrop > 0 and Color["button_background_hidden"] or Color["button_background_inactive"], mouseOverText = (allowdrop == counter) and "" or dropmouseovertext }):setText((allowdrop == counter) and ReadText(1001, 7711) or string.format(ReadText(1001, 7712), allowdrop, counter), { color = allowdrop > 0 and Color["text_normal"] or Color["text_inactive"] })
		row[1].handlers.onClick = function () return menu.buttonInventoryDropAll(false) end
	elseif menu.contextMenuMode == "personnel" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:createText(menu.personnelData.curEntry.name, Helper.titleTextProperties)

		local controllable = C.ConvertStringTo64Bit(tostring(menu.personnelData.curEntry.container))
		local entity, person
		if menu.personnelData.curEntry.type == "person" then
			person = C.ConvertStringTo64Bit(tostring(menu.personnelData.curEntry.id))
		else
			entity = menu.personnelData.curEntry.id
		end

		local transferscheduled = false
		local hasarrived = true
		local personrole = ""
		if person then
			-- get real NPC if instantiated
			local instance = C.GetInstantiatedPerson(person, controllable)
			entity = (instance ~= 0 and instance or nil)
			transferscheduled = C.IsPersonTransferScheduled(controllable, person)
			hasarrived = C.HasPersonArrived(controllable, person)
			personrole = ffi.string(C.GetPersonRole(person, controllable))
		end

		local oldpilot, isonlineobject = GetComponentData(menu.personnelData.curEntry.container, "assignedaipilot", "isonlineobject")
		if oldpilot then
			oldpilot = ConvertStringTo64Bit(tostring(oldpilot))
		end

		if isonlineobject then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:createButton({ bgColor = Color["button_background_hidden"], active = false, height = Helper.standardTextHeight }):setText(ReadText(1026, 9118))
		else
			local row = ftable:addRow("info_person_containerinfo", { fixed = true })
			row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(C.IsComponentClass(controllable, "station") and ReadText(1001, 8350) or ReadText(1001, 8602))
			row[1].handlers.onClick = function () return menu.buttonContainerInfo(controllable) end

			if person then
				if transferscheduled then
					local row = ftable:addRow("info_person_cancel_transfer", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 9435))	-- Cancel all scheduled transfers
					row[1].handlers.onClick = function () return menu.buttonPersonnelCancelTransfer(controllable, person) end
				elseif hasarrived and ((personrole == "service") or (personrole == "marine") or (personrole == "unassigned")) then
					local printedtitle = C.IsComponentClass(controllable, "ship_s") and ReadText(1001, 4847) or ReadText(1001, 4848)	-- Pilot, Captain
					-- promote
					local row = ftable:addRow("info_person_promote", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1001, 9433) .. " " .. printedtitle)	-- Promote to(followed by "captain" or "pilot")
					row[1].handlers.onClick = function () return menu.buttonPersonnelReplacePilot(controllable, oldpilot, person) end
				end
			end
			if menu.personnelData.curEntry.roleid ~= "shiptrader" then
				if hasarrived then
					-- work somewhere else
					local row = ftable:addRow("info_person_worksomewhere", { fixed = true })
					row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 3008))
					if entity then
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", entity, 0 } }); menu.cleanup() end
					else
						row[1].handlers.onClick = function () Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, controllable, nil, "hire", { "signal", controllable, 0, person} }); menu.cleanup() end
					end
				end
				-- fire
				local row = ftable:addRow("info_person_fire", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight }):setText(ReadText(1002, 15800))
				row[1].handlers.onClick = function () return menu.buttonPersonnelFireNPCConfirm(controllable, entity, person, menu.personnelData.curEntry.name) end
			end

			local conversationactor = ConvertStringTo64Bit(tostring(entity))
			local player = C.GetPlayerID()
			if person and ((not entity) or (C.GetContextByClass(entity, "container", false) ~= C.GetContextByClass(player, "container", false))) then
				-- Talking to person - either not instantiated as a real entity, or the instance is far away.
				-- Note: Only start comms with instantiated NPCs if they are on the player container, otherwise they are likely to get despawned during the conversation.
				conversationactor = { context = ConvertStringToLuaID(tostring(controllable)), person = ConvertStringToLuaID(tostring(person)) }
			end
			if (not transferscheduled) and hasarrived then
				row = ftable:addRow("info_actor_comm", { fixed = true })
				row[1]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.standardTextHeight, active = (person ~= nil) or (entity and GetComponentData(entity, "caninitiatecomm")) }):setText(ReadText(1001, 3216))	-- (initiate comm)Comm
				row[1].handlers.onClick = function () menu.buttonPersonnelCommWithActor(conversationactor) end
			end
		end
	elseif menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, "left")
	elseif menu.contextMenuMode == "transactionlog" then
		local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[data]
		if entryIdx == nil then
			return
		end
		local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
		local active = (entry.partner ~= 0) and C.IsComponentOperational(entry.partner)

		local row = ftable:addRow(false, { fixed = true })
		local text = TruncateText(entry.partnername, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), contextmenuwidth - 2 * Helper.scaleX(Helper.standardButtonWidth))
		row[1]:createText(text, Helper.headerRowCenteredProperties)
		row[1].properties.mouseOverText = entry.partnername

		row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ active = active, bgColor = active and Color["button_background_default"] or Color["button_background_inactive"] }):setText(ReadText(1001, 2427), { color = active and Color["text_normal"] or Color["text_inactive"] })
		row[1].handlers.onClick = function () return menu.buttonContainerInfo(entry.partner) end

		if active and GetComponentData(ConvertStringTo64Bit(tostring(entry.partner)), "isplayerowned") then
			row = ftable:addRow(true, { fixed = true })
			row[1]:createButton({ active = active, bgColor = active and Color["button_background_default"] or Color["button_background_inactive"] }):setText(ReadText(1001, 7702), { color = active and Color["text_normal"] or Color["text_inactive"] })
			row[1].handlers.onClick = function () return menu.buttonTransactionLog(entry.partner) end
		end
	elseif menu.contextMenuMode == "venturecontactcontext" then
		Helper.createVentureContactContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturefriendlist" then
		Helper.showVentureFriendListContext(menu, menu.contextFrame)
	elseif menu.contextMenuMode == "venturereport" then
		print(nomouseout)
		Helper.createUserQuestionContext(menu, menu.contextFrame)
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	else
		menu.mouseOutBox = nil
	end
end

function menu.refreshContextFrame(setrow, setcol)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	local y = menu.contextFrame.properties.y
	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextFrame.properties.width,
		x = menu.contextFrame.properties.x,
		y = 0,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	if menu.contextMenuMode == "dropwares" then
		Helper.createDropWaresContext(menu, menu.contextFrame, "left")
	end

	if menu.contextFrame.properties.x + menu.contextMenuWidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - menu.contextMenuWidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()
end

function menu.buttonPersonnelCommWithActor(actor)
	menu.closeContextMenu()
	if menu.conversationMenu then
		Helper.closeMenuForSubConversation(menu, "default", actor)
	else
		Helper.closeMenuForNewConversation(menu, "default", actor)
	end
	menu.cleanup()
end

function menu.buttonPersonnelReplacePilot(ship, oldpilot, newpilot)
	local oldpilotluaid = oldpilot and ConvertStringToLuaID(tostring(oldpilot))
	local post = (oldpilot and IsValidComponent(oldpilot)) and GetComponentData(oldpilotluaid, "poststring") or "aipilot"

	if not C.CanControllableHaveControlEntity(ship, post) then
		return false
	end

	if oldpilot then
		-- MD handles assignment of new pilot in this case.
		C.SignalObjectWithNPCSeed(oldpilot, "npc__control_dismissed", newpilot, ship)
	else
		newpilot = C.CreateNPCFromPerson(newpilot, ship)
		if C.SetEntityToPost(ship, newpilot, post) then
			SignalObject(ConvertStringTo64Bit(tostring(newpilot)), "npc_state_reinit")
		else
			DebugError("menu.infoSubmenuReplacePilot(): failed setting new pilot.")
		end
	end
	menu.empireData.init = true

	menu.closeContextMenu()
	menu.refresh = getElapsedTime() + 2
	menu.refreshdata = "reinitempire"
end

function menu.buttonPersonnelCancelTransfer(controllable, person)
	C.ReleasePersonFromCrewTransfer(controllable, person)

	menu.closeContextMenu()
	menu.refreshInfoFrame()
end

function menu.buttonPersonnelFireNPCConfirm(controllable, entity, person, name)
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "fire", controllable = controllable, entity = entity, person = person, name = name, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.buttonPersonnelFireNPC(controllable, entity, person)
	if entity then
		SignalObject(ConvertStringTo64Bit(tostring(entity)), "npc__control_dismissed")
	else
		C.RemovePerson(controllable, person)
	end
	menu.empireData.init = true

	menu.closeContextMenu()
	menu.refresh = getElapsedTime()
	menu.refreshdata = "reinitempire"
end

function menu.buttonWarDeclarationConfirm(faction)
	menu.closeContextMenu()

	menu.contextMenuMode = "userquestion"
	menu.contextMenuData = { mode = "wardeclaration", faction = faction, width = Helper.scaleX(400), xoffset = (Helper.viewWidth - Helper.scaleX(400)) / 2, yoffset = Helper.viewHeight / 2 }

	menu.createUserQuestionFrame()
end

function menu.butttonWarDeclaration(faction)
	C.SetFactionRelationToPlayerFaction(faction, "wardeclaration", -0.32)
	menu.closeContextMenu()
	menu.refresh = getElapsedTime()
end

function menu.buttonUserQuestionConfirm()
	if menu.contextMenuData.mode == "fire" then
		menu.buttonPersonnelFireNPC(menu.contextMenuData.controllable, menu.contextMenuData.entity, menu.contextMenuData.person)
	elseif menu.contextMenuData.mode == "wardeclaration" then
		menu.butttonWarDeclaration(menu.contextMenuData.faction)
	elseif menu.contextMenuData.mode == "clearlogbook" then
		menu.buttonLogbookClear(menu.contextMenuData.category)
	end
end

function menu.buttonContainerInfo(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", controllable } })
	menu.cleanup()
end

function menu.buttonTransactionLog(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, controllable });
	menu.cleanup()
end

function menu.createUserQuestionFrame()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.contextMenuData.xoffset - 2 * Helper.borderSize,
		y = menu.contextMenuData.yoffset,
		width = menu.contextMenuData.width + 2 * Helper.borderSize,
		layer = config.contextLayer,
		standardButtons = { close = true },
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	if menu.contextMenuData.mode == "fire" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 11202), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 11201), { wordwrap = true })
	elseif menu.contextMenuData.mode == "wardeclaration" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7751), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 7752), { wordwrap = true })
	elseif menu.contextMenuData.mode == "clearlogbook" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 5722), menu.contextMenuData.name), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText((menu.contextMenuData.category == "all") and ReadText(1001, 5723) or ReadText(1001, 5724), { wordwrap = true })
	end

	ftable:addEmptyRow(Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	row[2].handlers.onClick = menu.buttonUserQuestionConfirm
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu
	ftable:setSelectedCol(4)

	-- only add one border as the table y offset already is part of frame:getUsedHeight()
	menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	menu.contextFrame:display()
end

function menu.closeContextMenu()
	Helper.clearTableConnectionColumn(menu, 4)
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextMenuMode = nil
	menu.mouseOutBox = nil
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.mainTable = ...
	elseif layer == config.infoLayer then
		if menu.mode == "logbook" then
			menu.topLevelTable, menu.titleTable, menu.infoTable, menu.buttonTable = ...
		else
			menu.topLevelTable, menu.infoTable, menu.buttonTable = ...
		end
	end
end

function menu.onInteractiveElementChanged(element)
	menu.lastactivetable = element
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.activatecutscene then
		if menu.setupEmpireRenderTarget() then
			menu.activatecutscene = nil
		end
	end
	if menu.messageData.activatecutscene then
		if menu.setupMessageRenderTarget() then
			menu.messageData.activatecutscene = nil
		end
	end
	if menu.inventoryData.activatecutscene then
		if menu.setupInventoryRenderTarget() then
			menu.inventoryData.activatecutscene = nil
		end
	end
	if menu.personnelData.activatecutscene then
		if menu.setupPersonnelRenderTarget() then
			menu.personnelData.activatecutscene = nil
		end
	end

	if Helper.hasExtension("multiverse") then
		if Helper.callExtensionFunction("multiverse", "updateVentures", menu) then
			menu.refreshInfoFrame()
		end
	end

	menu.mainFrame:update()
	menu.infoFrame:update()
	if (menu.contextMenuMode == "blacklistfaction") or
	   (menu.contextMenuMode == "blacklistsector") or
	   (menu.contextMenuMode == "illegalwares") or
	   (menu.contextMenuMode == "playeralertclass") or
	   (menu.contextMenuMode == "playeralertfaction") or
	   (menu.contextMenuMode == "playeralertsector") or
	   (menu.contextMenuMode == "traderulefaction")  or
	   (menu.contextMenuMode == "venturefriendlist") then
		menu.contextFrame:update()
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end

	if menu.mode == "transactionlog" then
		Helper.onTransactionLogUpdate()
		if not Helper.transactionLogData.noupdate then
			local curtime = getElapsedTime()
			if curtime > menu.lastTransactionLogRefreshTime + 10 then
				menu.refreshInfoFrame()
			end
		end
	end

	local curtime = getElapsedTime()
	if menu.over then
		menu.over = nil
		menu.refresh = curtime - 1
	end

	if menu.inputModeHasChanged then
		if not menu.noupdate then
			menu.refresh = curtime - 1
			menu.inputModeHasChanged = nil
		end
	end

	if menu.refresh and (menu.refresh < curtime) then
		if menu.refreshdata then
			if menu.refreshdata == "reinitempire" then
				menu.empireData.init = true
				menu.personnelData.curEntry = {}
				menu.refreshInfoFrame()
			else
				menu.refreshInfoFrame(table.unpack(menu.refreshdata))
			end
		else
			menu.refreshInfoFrame()
		end
		menu.refreshdata = nil
		menu.refresh = nil
	end
end

function menu.updateSelectedRows()
	menu.inventoryData.selectedWares = {}
	local rows, highlightedborderrow = GetSelectedRows(menu.inventoryInfoTable.id)
	for _, row in ipairs(rows) do
		local rowdata = menu.rowDataMap[menu.inventoryInfoTable.id][row]
		if type(rowdata) == "table" then
			menu.inventoryData.selectedWares[rowdata[1]] = true
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable, modified, input)
	if uitable == menu.infoTable then
		if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
			menu.onInventoryRowChange(row, rowdata, input, menu.mode)
		elseif menu.mode == "crafting" then
			if type(rowdata) == "table" then
				if menu.inventoryData.mode ~= "craft" then
					local isunbundleammo, component = GetWareData(rowdata[1], "isunbundleammo", "component")
					local ammospace = false
					if isunbundleammo then
						local playership = C.GetPlayerOccupiedShipID()
						if playership ~= 0 then
							ammospace = AddAmmo(ConvertStringToLuaID(tostring(playership)), component, 1, true) == 1
						end
					end

					local row = 1
					if menu.inventoryData.craftingHistory[1] then
						row = row + math.min(3, #menu.inventoryData.craftingHistory) + 2
					end

					if menu.findInventoryWare(menu.craftable, rowdata[1]) then
						local mot_craft = ""
						local active = false
						if rowdata[2].craftable > 0 then
							if (not isunbundleammo) or ammospace then
								mot_craft = ReadText(1026, 3900)
								active = true
							else
								mot_craft = ReadText(1026, 3903)
							end
						else
							mot_craft = ReadText(1026, 3901)
						end

						local desc = Helper.createButton(Helper.createTextInfo(ReadText(1001, 7706), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, active, 0, 0, 0, Helper.standardButtonHeight, nil, nil, nil, mot_craft)
						Helper.setCellContent(menu, menu.buttonTable, desc, row, 1, nil, "button", nil, menu.buttonInventoryCraft)
					else
						Helper.setCellContent(menu, menu.buttonTable, Helper.getEmptyCellDescriptor(), row, 1, true, "button")
					end
				end
			end
		elseif menu.mode == "factions" then
			if type(rowdata) == "table" then
				if rowdata[2].id ~= menu.factionData.curEntry.id then
					menu.factionData.curEntry = rowdata[2]
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "messages" then
			if type(rowdata) == "table" then
				if rowdata.id ~= menu.messageData.curEntry.id then
					if next(menu.messageData.curEntry) then
						C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
						AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
					end
					menu.messageData.curEntry = rowdata
					menu.messageData.showFullscreen = nil
					menu.cleanupCutsceneRenderTarget()
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "personnel" then
			if type(rowdata) == "table" then
				if tostring(rowdata[2].id) ~= tostring(menu.personnelData.curEntry.id) then
					menu.personnelData.curEntry = rowdata[2]
					menu.refresh = getElapsedTime()
				end
			end
		elseif menu.mode == "transactionlog" then
			Helper.onTransactionLogRowChanged(rowdata)
		elseif (menu.mode == "empire") or (menu.mode == "globalorders") then
			if (type(rowdata) == "table") and ((menu.empireData.mode[2] ~= rowdata[2]) or ((type(rowdata[3]) == "table") and ((menu.empireData.mode[3].id ~= rowdata[3].id) or (menu.empireData.mode[3].index ~= rowdata[3].index)))) then
				--print("onRowChanged. row: " .. tostring(row) .. ". rowdata 1: " .. tostring(rowdata[1]) .. ", rowdata 2: " .. tostring(rowdata[2]) .. ". oldmode 1: " .. tostring(menu.empireData.mode[1]) .. ", oldmode 2: " .. tostring(menu.empireData.mode[2]))
				--menu.empireData.oldmode = menu.empireData.mode
				if ((menu.empireData.mode[1] == "empire_call") and (menu.empireData.mode[2] == "inventory")) then
					menu.inventoryData.selectedWares = {}
					C.ReadAllInventoryWares()
				end
				menu.empireData.mode = rowdata
				menu.setcentertoprow = 0

				-- always clear the selected object when changing modes. selectedobject will be populated right after as appropriate.
				menu.empireData.selectedobject = nil
				menu.empireData.objecttype = nil

				menu.over = true
			end
		end
	elseif ((menu.mode == "empire") or (menu.mode == "globalorders")) and menu.empireData.mode and (type(menu.empireData.mode) == "table") then
		--print("mode 1: " .. tostring(menu.empireData.mode[1]) .. ", mode 2: " .. tostring(menu.empireData.mode[2]))
		if (menu.empireData.mode[1] == "empire_grid") then
			local changed = nil

			if (menu.empireData.mode[2] == "logo") or (menu.empireData.mode[2] == "painttheme") then
				local locship = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
				if locship and (locship ~= 0) and (locship ~= menu.empireData.selectedobject) and menu.empireCanShowObject(locship) and (not C.IsComponentClass(locship, "spacesuit")) and (not GetComponentData(locship, "paintmodlocked")) then
					--print("changing object from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(locship))
					menu.empireData.selectedobject = locship
					menu.empireData.objecttype = "object"
					changed = true
				end

				if (not menu.empireData.selectedobject) and (#menu.empireData.ships > 0) then
					for _, ship in ipairs(menu.empireData.ships) do
						if menu.empireCanShowObject(ship.ship) and (not GetComponentData(ship.ship, "paintmodlocked")) then
							menu.empireData.selectedobject = ship.ship
							menu.empireData.objecttype = "object"
							changed = true
							break
						end
					end
				end
				--print("grid. selected object: " .. tostring(menu.empireData.selectedobject))
			elseif (menu.empireData.mode[2] == "uniform") then
				if not menu.empireData.selectedobject or (menu.empireData.objecttype ~= "npc") then
					for _, employeedata in ipairs(menu.empireData.employees) do
						if (employeedata.type == "entity") and menu.empireCanShowObject(employeedata.id) then
							if (menu.empireData.selectedobject ~= employeedata.id) then
								--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(employeedata.id))
								menu.empireData.selectedobject = employeedata.id
								menu.empireData.objecttype = "npc"
								changed = true
							end
							break
						end
					end
				end
			end

			if changed then
				menu.over = true
			end
		elseif (menu.empireData.mode[1] == "empire_list") then
			--print("rowdata type: " .. tostring(type(rowdata)) .. ", rowdata: " .. tostring(rowdata))
			if (type(rowdata) == "table") then
				local changed = nil

				if (rowdata[1] == "painttheme") then
					local locship = ConvertStringTo64Bit(tostring(C.GetLastPlayerControlledShipID()))
					if locship and (locship ~= 0) and (locship ~= menu.empireData.selectedobject) and menu.empireCanShowObject(locship) and not C.IsComponentClass(locship, "spacesuit") then
						--print("changing object from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(locship))
						menu.empireData.selectedobject = locship
						menu.empireData.objecttype = "object"
						changed = true
					end

					if not menu.empireData.selectedobject and #menu.empireData.ships > 0 then
						for _, ship in ipairs(menu.empireData.ships) do
							if menu.empireCanShowObject(ship.ship) then
								menu.empireData.selectedobject = ship.ship
								menu.empireData.objecttype = "object"
								changed = true
								break
							end
						end
					end

					--print("current theme: " .. ffi.string(C.GetPlayerPaintTheme()) .. ", new theme: " .. tostring(rowdata[2]))
					if (ffi.string(C.GetPlayerPaintTheme()) ~= rowdata[2]) then
						C.SetPlayerPaintTheme(rowdata[2])
						--print("new paint theme set: " .. ffi.string(C.GetPlayerPaintTheme()))
					end
				elseif (rowdata[1] == "uniform") then
					if not menu.empireData.selectedobject or (menu.empireData.objecttype ~= "npc") then
						for _, employeedata in ipairs(menu.empireData.employees) do
							if (employeedata.type == "entity") and menu.empireCanShowObject(employeedata.id) then
								if (menu.empireData.selectedobject ~= employeedata.id) then
									--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(employeedata.id))
									menu.empireData.selectedobject = employeedata.id
									menu.empireData.objecttype = "npc"
									changed = true
								end
								break
							end
						end
					end

					--print("current uniform: " .. ffi.string(C.GetPlayerClothingTheme()) .. ", new uniform: " .. tostring(rowdata[2]))
					if (ffi.string(C.GetPlayerClothingTheme()) ~= rowdata[2]) then
						C.SetPlayerClothingTheme(rowdata[2])
						--print("new uniform set: " .. ffi.string(C.GetPlayerClothingTheme()))
					end
				elseif (rowdata[1] == "empire_ship") or (rowdata[1] == "empire_station") or (rowdata[1] == "empire_onlineship") then
					if rowdata[2] and menu.empireCanShowObject(rowdata[2]) then
						if (menu.empireData.selectedobject ~= rowdata[2]) then
							menu.empireData.selectedobject = rowdata[2]
							menu.empireData.objecttype = "object"
							changed = true
							--print("selected object: " .. ffi.string(C.GetComponentName(rowdata[2])))
						end
					end
				elseif (rowdata[1] == "empire_employee") then
					if (rowdata[2].type == "entity") then
						if menu.empireCanShowObject(rowdata[2].id) and (menu.empireData.selectedobject ~= rowdata[2].id) then
							--print("switching selectedobject from: " .. tostring(menu.empireData.selectedobject) .. " to: " .. tostring(rowdata[2].id))
							menu.empireData.selectedobject = rowdata[2].id
							menu.empireData.objecttype = "npc"
							changed = true
							--print("selected entity: " .. rowdata[2].name .. " " .. tostring(rowdata[2].id))
						end
					elseif (rowdata[2].type == "person") then
						local instantiatedperson = ConvertStringTo64Bit(tostring(C.GetInstantiatedPerson(rowdata[2].id, C.ConvertStringTo64Bit(tostring(rowdata[2].container)))))
						if (instantiatedperson ~= 0) and menu.empireCanShowObject(instantiatedperson) and (menu.empireData.selectedobject ~= instantiatedperson) then
							menu.empireData.selectedobject = instantiatedperson
							menu.empireData.objecttype = "npc"
							changed = true
							--print("selected person: " .. rowdata[2].name .. " " .. tostring(rowdata[2].id))
						end
					else
						DebugError("Empire Menu: unsupported employee type: " .. tostring(rowdata[2].type))
					end
				end

				if changed then
					menu.setselectedrow2 = row
					menu.over = true
				end
			end
		elseif (menu.empireData.mode[1] == "empire_call") then
			local changed = nil

			if (menu.empireData.mode[2] == "inventory") then
				if (type(rowdata) == "table") and (not menu.empireData.selectedobject or menu.empireData.selectedobject ~= rowdata[1]) then
					--print("ware: " .. tostring(rowdata[1]))
					menu.empireData.selectedobject = rowdata[1]
					menu.empireData.objecttype = "ware"
					changed = true
				end
				menu.onInventoryRowChange(row, rowdata, input, menu.empireData.mode[2])
			end

			if changed then
				menu.setselectedrow2 = row
				menu.over = true
			end
		end
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["onRowChanged"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onRowChanged"]) do
			uix_callback (row, rowdata, uitable, modified, input)
		end
	end
	-- kuertee end: callback
end

function menu.onInventoryRowChange(row, rowdata, input, mode)
	if type(rowdata) == "table" then
		menu.closeContextMenu()
		menu.updateSelectedRows()

		if not menu.skipread then
			C.ReadInventoryWare(rowdata[1])
			local name = menu.getInventoryName(rowdata[1], rowdata[2], true)
			Helper.updateCellText(menu.inventoryInfoTable.id, row, 1, name)
			if (input ~= "mouse") and (row > 1) then
				local prevrowdata = menu.rowDataMap[menu.inventoryInfoTable.id][row - 1]
				if type(prevrowdata) == "table" then
					C.ReadInventoryWare(prevrowdata[1])
					local name = menu.getInventoryName(prevrowdata[1], prevrowdata[2], true)
					Helper.updateCellText(menu.inventoryInfoTable.id, row - 1, 1, name)
				end
			end
		end
		menu.skipread = nil

		if menu.inventoryData.mode ~= "drop" then
			local buttonrow = (mode == "inventory") and 6 or 3
			local count = 0
			local allowdrop = false
			for ware in pairs(menu.inventoryData.selectedWares) do
				if GetWareData(ware, "allowdrop") and (not menu.onlineitems[ware]) then
					count = count + 1
					allowdrop = true
				end
			end
			local active = GetWareData(rowdata[1], "allowdrop") and (not menu.onlineitems[rowdata[1]])
			local desc = Helper.createButton(Helper.createTextInfo((count > 1) and ReadText(1001, 7733) or ReadText(1001, 7705), "center", Helper.standardFont, Helper.standardFontSize, 255, 255, 255, 100), nil, false, active, 0, 0, 0, Helper.standardButtonHeight, nil, nil, nil, nil, "playerinfo_inventory_drop")
			Helper.setCellContent(menu, menu.inventoryButtonTable.id, desc, buttonrow, 1, nil, "button", nil, menu.buttonInventoryDrop)

			if rowdata[1] ~= menu.inventoryData.curEntry[1] then
				menu.inventoryData.curEntry = rowdata
				menu.refresh = getElapsedTime()
			end
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
	--print("menu.onSelectElement")
	local rowdata = Helper.getCurrentRowData(menu, uitable)
	if uitable == menu.infoTable then
		if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
			if type(rowdata) == "table" then
				menu.closeContextMenu()
			end
		end
	end
end

function menu.onEditBoxActivated(widget)
	menu.noupdate = true
	if menu.logbookPageEditBox and (widget == menu.logbookPageEditBox.id) then
		C.SetEditBoxText(menu.logbookPageEditBox.id, tostring(menu.logbookData.curPage))
	elseif menu.personnelPageEditBox and (widget == menu.personnelPageEditBox.id) then
		C.SetEditBoxText(menu.personnelPageEditBox.id, tostring(menu.personnelData.curPage))
	elseif menu.mode == "transactionlog" then
		Helper.onTransactionLogEditBoxActivated(widget)
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if (menu.mode == "inventory") or (menu.mode == "spacesuit") then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if type(rowdata) == "table" then
				menu.inventoryData.selectedWares[rowdata[1]] = true

				local rows = {}
				for row2, rowdata2 in pairs(menu.rowDataMap[uitable]) do
					if type(rowdata2) == "table" then
						if menu.inventoryData.selectedWares[rowdata2[1]] then
							table.insert(rows, row2)
						end
					end
				end
				SetSelectedRows(menu.infoTable, rows, row)

				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "inventory"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	elseif menu.mode == "personnel" then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if type(rowdata) == "table" then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "personnel"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	elseif menu.mode == "transactionlog" then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]

			local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[rowdata]
			if entryIdx == nil then
				return
			end
			local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
			if entry.partnername ~= "" then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextMenuMode = "transactionlog"
				menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(260))
			end
		end
	elseif menu.mode == "venturecontacts" then
		if uitable == menu.infoTable then
			local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
			if type(rowdata) == "table" then
				if not rowdata.isplayer then
					menu.closeContextMenu()

					local x, y = GetLocalMousePosition()
					if x == nil then
						-- gamepad case
						x = posx
						y = -posy
					end
					menu.contextMenuMode = "venturecontactcontext"
					menu.contextMenuData = { contact = rowdata, xoffset = x + Helper.viewWidth / 2, yoffset = Helper.viewHeight / 2 - y }
					menu.createContextFrame(nil, menu.contextMenuData.xoffset, menu.contextMenuData.yoffset, Helper.scaleX(260))
				end
			end
		end
	end
end

function menu.closeMenu(dueToClose)
	if next(menu.messageData.curEntry) then
		C.SetMessageRead(menu.messageData.curEntry.id, menu.messageData.curEntry.category)
		AddUITriggeredEvent(menu.name, "message_read", ConvertStringTo64Bit(tostring(menu.messageData.curEntry.id)))
		menu.messageData.curEntry = {}
		menu.messageData.showFullscreen = nil
	end
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose)
	if menu.contextMenuMode then
		menu.closeContextMenu()
	elseif menu.messageData.showFullscreen and (dueToClose == "back") then
		menu.messageData.showFullscreen = nil
		menu.messageData.fullscreenToggled = true
		menu.refreshInfoFrame()
	elseif menu.mode and (dueToClose == "back") then
		menu.deactivatePlayerInfo()
	else
		menu.closeMenu(dueToClose)
	end
end

-- menu helpers

function menu.getInventoryName(ware, waredata, showunread)
	local volatile, gift, unread = GetWareData(ware, "volatile", "gift", "isunreadinventory")

	local name = waredata.name .. (volatile and " [" .. ReadText(1001, 3902) .. "]" or "") .. (gift and " [" .. ReadText(1001, 3903) .. "]" or "")
	local color = Color["text_normal"]
	if menu.inventoryData.policefaction and IsWareIllegalTo(ware, "player", menu.inventoryData.policefaction) then
		color = Color["text_illegal"]
	end
	if showunread and unread then
		name = ColorText["text_warning"] .. "\027[workshop_error]\027X " .. name
	end

	return name, color
end

function menu.addInventoryWareEntry(ftable, ware, waredata, iscrafting, isresource, hideprice, isonline)
	local bgColor
	if iscrafting and (not isresource) then
		bgColor = Color["row_title_background"]
	end
	local row = ftable:addRow({ware, waredata}, { bgColor = bgColor, multiSelected = menu.inventoryData.selectedWares[ware] })

	-- name
	local rawname, color = menu.getInventoryName(ware, waredata, not iscrafting)
	local name = rawname
	if isresource then
		name = "    " .. name
	end
	row[1]:setColSpan(hideprice and 4 or 1)
	row[1]:createText(name, { color = color })
	if not hideprice then
		-- amount
		if isresource then
			row[2]:createText(waredata.amount .. " / " .. waredata.needed, config.rightAlignTextProperties)
		else
			row[2]:createText(waredata.amount, config.rightAlignTextProperties)
		end
		-- base price
		local avgprice = GetWareData(ware, "avgprice")
		row[3]:createText(ConvertMoneyString(avgprice, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)
		-- total price
		row[4]:createText(ConvertMoneyString(avgprice * waredata.amount, false, true, 0, true) .. " " .. ReadText(1001, 101), config.rightAlignTextProperties)
	end

	local ispaintmod = GetWareData(ware, "ispaintmod")
	if ispaintmod then
		AddKnownItem("paintmods", ware)
	else
		AddKnownItem("inventory_wares", ware)
	end
end

function menu.findInventoryWare(array, ware)
	for _, entry in ipairs(array) do
		if entry.ware == ware then
			return true
		end
	end
	return false
end

function menu.createCraftableEntry(ware)
	if not menu.findInventoryWare(menu.craftable, ware) then
		local waredata
		if menu.inventory[ware] then
			waredata = menu.inventory[ware]
		else
			local name, buyprice = GetWareData(ware, "name", "buyprice")
			waredata = { name = name, amount = 0, price = buyprice }
		end

		local resources = {}
		local rawresources = GetWareData(ware, "resources")
		local resourcecount = 0
		local craftableamount
		if #rawresources > 0 then
			for _, resource in ipairs(rawresources) do
				local resourcedata = menu.inventory[resource.ware]
				if resourcedata then
					resourcecount = resourcecount + resourcedata.amount
					local maxcraftable = math.floor(resourcedata.amount / resource.amount)
					craftableamount = craftableamount and math.min(maxcraftable, craftableamount) or maxcraftable
					table.insert(resources, { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
				else
					local resourcename, resourcebuyprice = GetWareData(resource.ware, "name", "buyprice")
					craftableamount = 0
					table.insert(resources, { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
				end
			end
		else
			craftableamount = 0
		end
		resources.count = resourcecount

		local isunbundleammo, component = GetWareData(ware, "isunbundleammo", "component")
		if isunbundleammo then
			local playership = C.GetPlayerOccupiedShipID()
			if playership ~= 0 then
				craftableamount = AddAmmo(ConvertStringToLuaID(tostring(playership)), component, craftableamount, true)
			end
		end
		waredata.craftable = craftableamount

		table.insert(menu.craftable, { ware = ware, data = waredata, resources = resources })
	end
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- section == cArch_configureships
-- param == { 0, 0, container, mode, modeparam, immediate }

-- modes:	"purchase",	param:	{}
--			"upgrade",			{ selectableships }
--			"modify",			{ [ paintonly = false, selectedships = {} ] }
--			"customgamestart",	{ gamestartid, creative, shipproperty, shiploadoutproperty, shippeopleproperty, shippeoplefillpercentageproperty, shippilotproperty, paintthemeproperty, playerpropertyid, propertymacro, propertycommander, propertypeopledef, propertypeoplefillpercentage, propertycount, paused }
--			"comparison",		{ id }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef int32_t BlacklistID;
	typedef uint64_t BuildTaskID;
	typedef int32_t FightRuleID;
	typedef uint64_t NPCSeed;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;
	typedef struct {
		const char* ammomacroname;
		const char* weaponmode;
	} UILoadoutWeaponSetting;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BlacklistID id;
		const char* type;
	} BlacklistTypeID;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* newroleid;
		NPCSeed seed;
		uint32_t amount;
		int64_t price;
	} CrewTransferContainer2;
	typedef struct {
		CrewTransferContainer2* removed;
		uint32_t numremoved;
		CrewTransferContainer2* added;
		uint32_t numadded;
		CrewTransferContainer2* transferred;
		uint32_t numtransferred;
	} CrewTransferInfo2;
	typedef struct {
		uint32_t numremoved;
		uint32_t numadded;
		uint32_t numtransferred;
	} CrewTransferInfoCounts;
	typedef struct {
		const char* state;
		float defaultvalue;
	} CustomGameStartFloatPropertyState;
	typedef struct {
		const char* state;
	} CustomGameStartLoadoutPropertyState;
	typedef struct {
		const char* race;
		const char* tags;
		uint32_t numskills;
		SkillInfo* skills;
	} CustomGameStartPersonEntry;
	typedef struct {
		const char* state;
		const char* defaultvalue;
		const char* options;
	} CustomGameStartStringPropertyState;
	typedef struct {
		const char* tag;
		const char* name;
	} EquipmentCompatibilityInfo;
	typedef struct {
		const char* type;
		const char* ware;
		const char* macro;
		int amount;
	} EquipmentWareInfo;
	typedef struct {
		const char* PropertyType;
		float MinValueFloat;
		float MaxValueFloat;
		uint32_t MinValueUINT;
		uint32_t MaxValueUINT;
		uint32_t BonusMax;
		float BonusChance;
	} EquipmentModInfo;
	typedef struct {
		FightRuleID id;
		const char* type;
	} FightRuleTypeID;
	typedef struct {
		const char* id;
		const char* name;
		int32_t state;
		const char* requiredversion;
		const char* installedversion;
	} InvalidPatchInfo;
	typedef struct {
		const char* name;
		const char* icon;
	} LicenceInfo;
	typedef struct {
		MissionID missionid;
		const char* macroname;
		uint32_t amount;
	} MissionShipDeliveryInfo;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
	} PeopleDefinitionInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		const char* name;
		int32_t skilllevel;
		uint32_t amount;
	} RoleTierData;
	typedef struct {
		UniverseID context;
		const char* group;
		UniverseID component;
	} ShieldGroup;
	typedef struct {
		const char* max;
		const char* current;
	} SoftwareSlot;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float ForwardThrustFactor;
		float StrafeAccFactor;
		float StrafeThrustFactor;
		float RotationThrustFactor;
		float BoostAccFactor;
		float BoostThrustFactor;
		float BoostDurationFactor;
		float BoostAttackTimeFactor;
		float BoostReleaseTimeFactor;
		float BoostChargeTimeFactor;
		float BoostRechargeTimeFactor;
		float TravelThrustFactor;
		float TravelStartThrustFactor;
		float TravelAttackTimeFactor;
		float TravelReleaseTimeFactor;
		float TravelChargeTimeFactor;
	} UIEngineMod2;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
	} UIEquipmentMod;
	typedef struct {
		const char* macro;
		uint32_t amount;
		bool optional;
	} UILoadoutAmmoData;
	typedef struct {
		const char* roleid;
		uint32_t count;
		bool optional;
	} UILoadoutCrewData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
	} UILoadoutGroupData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
		UILoadoutWeaponSetting weaponsetting;
	} UILoadoutGroupData2;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
	} UILoadoutMacroData;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
		UILoadoutWeaponSetting weaponsetting;
	} UILoadoutMacroData2;
	typedef struct {
		const char* ware;
	} UILoadoutSoftwareData;
	typedef struct {
		const char* macro;
		bool optional;
	} UILoadoutVirtualMacroData;
	typedef struct {
		uint32_t numweapons;
		uint32_t numturrets;
		uint32_t numshields;
		uint32_t numengines;
		uint32_t numturretgroups;
		uint32_t numshieldgroups;
		uint32_t numammo;
		uint32_t numunits;
		uint32_t numsoftware;
		uint32_t numcrew;
	} UILoadoutCounts2;
	typedef struct {
		UILoadoutMacroData* weapons;
		uint32_t numweapons;
		UILoadoutMacroData* turrets;
		uint32_t numturrets;
		UILoadoutMacroData* shields;
		uint32_t numshields;
		UILoadoutMacroData* engines;
		uint32_t numengines;
		UILoadoutGroupData* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
	} UILoadout;
	typedef struct {
		UILoadoutMacroData2* weapons;
		uint32_t numweapons;
		UILoadoutMacroData2* turrets;
		uint32_t numturrets;
		UILoadoutMacroData2* shields;
		uint32_t numshields;
		UILoadoutMacroData2* engines;
		uint32_t numengines;
		UILoadoutGroupData2* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData2* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
		uint32_t numcrew;
		UILoadoutCrewData* crew;
		bool hascrewexperience;
	} UILoadout2;
	typedef struct {
		const char* id;
		const char* name;
		const char* iconid;
		bool deleteable;
	} UILoadoutInfo;
	typedef struct {
		const char* upgradetype;
		size_t slot;
	} UILoadoutSlot;
	typedef struct {
		float HullValue;
		float ShieldValue;
		double ShieldDelay;
		float ShieldRate;
		float GroupedShieldValue;
		double GroupedShieldDelay;
		float GroupedShieldRate;
		float BurstDPS;
		float SustainedDPS;
		float TurretBurstDPS;
		float TurretSustainedDPS;
		float GroupedTurretBurstDPS;
		float GroupedTurretSustainedDPS;
		float ForwardSpeed;
		float BoostSpeed;
		float TravelSpeed;
		float YawSpeed;
		float PitchSpeed;
		float RollSpeed;
		float HorizontalStrafeSpeed;
		float VerticalStrafeSpeed;
		float ForwardAcceleration;
		float HorizontalStrafeAcceleration;
		float VerticalStrafeAcceleration;
		float BoostAcceleration;
		float BoostRechargeRate;
		float BoostMaxDuration;
		float TravelAcceleration;
		float TravelChargeTime;
		uint32_t NumDocksShipMedium;
		uint32_t NumDocksShipSmall;
		uint32_t ShipCapacityMedium;
		uint32_t ShipCapacitySmall;
		uint32_t CrewCapacity;
		uint32_t ContainerCapacity;
		uint32_t SolidCapacity;
		uint32_t LiquidCapacity;
		uint32_t CondensateCapacity;
		uint32_t UnitCapacity;
		uint32_t MissileCapacity;
		uint32_t CountermeasureCapacity;
		uint32_t DeployableCapacity;
		float RadarRange;
	} UILoadoutStatistics5;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		uint32_t Amount;
	} UIPaintMod;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float CapacityFactor;
		float RechargeDelayFactor;
		float RechargeRateFactor;
	} UIShieldMod;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* Name;
		const char* RawName;
		const char* Ware;
		uint32_t Quality;
		const char* PropertyType;
		float DamageFactor;
		float CoolingFactor;
		float ReloadFactor;
		float SpeedFactor;
		float LifeTimeFactor;
		float MiningFactor;
		float StickTimeFactor;
		float ChargeTimeFactor;
		float BeamLengthFactor;
		uint32_t AddedAmount;
		float RotationSpeedFactor;
		float SurfaceElementFactor;
	} UIWeaponMod;
	typedef struct {
		const char* macro;
		const char* category;
		uint32_t amount;
	} UnitData;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;
	typedef struct {
		UniverseID shipid;
		const char* macroname;
		UILoadout loadout;
		uint32_t amount;
	} UIBuildOrderList;
	typedef struct {
		BlacklistTypeID* blacklists;
		uint32_t numblacklists;
		FightRuleTypeID* fightrules;
		uint32_t numfightrules;
		const char* paintmodwareid;
	} AddBuildTask6Container;
	BuildTaskID AddBuildTask6(UniverseID containerid, UniverseID defensibleid, const char* macroname, UILoadout2 uiloadout, int64_t price, CrewTransferInfo2 crewtransfer, bool immediate, const char* customname, AddBuildTask6Container* additionalinfo);
	bool CanApplyKnownLoadout(const char* macroname, const char* loadoutid);
	bool CanBuildLoadout(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	bool CanBuildMissionLoadout(UniverseID containerid, MissionID missionid, const char* uimacroname);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanGenerateValidKnownLoadout(const char* macroname);
	bool CanGenerateValidLoadout(UniverseID containerid, const char* macroname);
	bool CanPlayerUseRace(const char* raceid, const char* postid);
	bool CheckGroupedShieldModCompatibility(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool CheckShipModCompatibility(UniverseID shipid, const char* wareid);
	bool CheckWeaponModCompatibility(UniverseID weaponid, const char* wareid);
	void ClearMapBehaviour(UniverseID holomapid);
	void ClearSelectedMapMacroSlots(UniverseID holomapid);
	BlacklistID GetControllableBlacklistID(UniverseID controllableid, const char* listtype, const char* defaultgroup);
	FightRuleID GetControllableFightRuleID(UniverseID controllableid, const char* listtype);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool defaultorder);
	void DismantleEngineMod(UniverseID objectid);
	void DismantleGroupedWeaponMod(UniverseID defensibleid, UniverseID contextid, const char* group);
	void DismantleShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group);
	void DismantleShipMod(UniverseID shipid);
	void DismantleWeaponMod(UniverseID weaponid);
	bool EnableOrder(UniverseID controllableid, size_t idx);
	EquipmentModInfo GetEquipmentModInfo(const char* wareid);
	void GenerateShipKnownLoadout2(UILoadout2* result, const char* macroname, float level);
	void GenerateShipKnownLoadoutCounts2(UILoadoutCounts2* result, const char* macroname, float level);
	void GenerateShipLoadout2(UILoadout2* result, UniverseID containerid, UniverseID shipid, const char* macroname, float level);
	void GenerateShipLoadoutCounts2(UILoadoutCounts2* result, UniverseID containerid, UniverseID shipid, const char* macroname, float level);
	uint32_t GetAllCountermeasures(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllEquipment(EquipmentWareInfo* result, uint32_t resultlen, bool playerblueprint);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMissiles(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAllRoles(PeopleInfo* result, uint32_t resultlen);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllShipMacros2(const char** result, uint32_t resultlen, bool playerblueprint, bool customgamestart);
	uint32_t GetAllUnits(UnitData* result, uint32_t resultlen, UniverseID defensibleid, bool onlydrones);
	uint32_t GetAvailableEquipment(EquipmentWareInfo* result, uint32_t resultlen, UniverseID containerid, const char* classid);
	uint32_t GetAvailableEquipmentMods(UIEquipmentMod* result, uint32_t resultlen);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	double GetBuildDuration(UniverseID containerid, UIBuildOrderList order);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildResources(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* wareid);
	void GetBuildTaskCrewTransferInfo2(CrewTransferInfo2* result, UniverseID containerid, BuildTaskID id);
	BuildTaskInfo GetBuildTaskInfo(BuildTaskID id);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	int64_t GetBuildWarePrice(UniverseID containerid, const char* warename);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	uint32_t GetContainerBuilderMacros(const char** result, uint32_t resultlen, UniverseID containerid);
	float GetContainerBuildPriceFactor(UniverseID containerid);
	UILoadoutStatistics5 GetCurrentLoadoutStatistics5(UniverseID shipid);
	float GetCustomGameStartFloatProperty(const char* id, const char* propertyid, CustomGameStartFloatPropertyState* state);
	void GetCustomGameStartLoadoutProperty2(UILoadout2* result, const char* id, const char* propertyid);
	void GetCustomGameStartLoadoutPropertyCounts2(UILoadoutCounts2* result, const char* id, const char* propertyid);
	CustomGameStartLoadoutPropertyState GetCustomGameStartLoadoutPropertyState(const char* id, const char* propertyid);
	void GetCustomGameStartPlayerPropertyLoadout(UILoadout2* result, const char* id, const char* propertyid, const char* entryid);
	void GetCustomGameStartPlayerPropertyLoadoutCounts(UILoadoutCounts2* result, const char* id, const char* propertyid, const char* entryid);
	bool GetCustomGameStartPlayerPropertyPerson(CustomGameStartPersonEntry* result, const char* id, const char* propertyid, const char* entryid);
	int64_t GetCustomGameStartShipPeopleValue2(const char* id, const char* macroname, const char* peopledefid, float peoplefillpercentage);
	int64_t GetCustomGameStartShipPersonValue(const char* id, CustomGameStartPersonEntry uivalue);
	bool GetCustomGameStartShipPilot(CustomGameStartPersonEntry* result, const char* id, const char* propertyid);
	const char* GetCustomGameStartStringProperty(const char* id, const char* propertyid, CustomGameStartStringPropertyState* state);
	uint32_t GetDamagedSubComponents(UniverseID* result, uint32_t resultlen, UniverseID objectid);
	uint32_t GetDefaultLoadoutMacros(const char** result, uint32_t resultlen, const char* macroname);
	uint32_t GetDefaultMissileStorageCapacity(const char* macroname);
	uint32_t GetDefaultCountermeasureStorageCapacity(const char* macroname);
	uint32_t GetDefensibleDeployableCapacity(UniverseID defensibleid);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	const char* GetEquipmentModPropertyName(const char* wareid);
	uint32_t GetHighestEquipmentModQuality(UniverseID defensibleid);
	bool GetInstalledEngineMod2(UniverseID objectid, UIEngineMod2* enginemod);
	bool GetInstalledPaintMod(UniverseID objectid, UIPaintMod* paintmod);
	bool GetInstalledShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group, UIShieldMod* shieldmod);
	bool GetInstalledWeaponMod(UniverseID weaponid, UIWeaponMod* weaponmod);
	uint32_t GetInventoryPaintMods(UIPaintMod* result, uint32_t resultlen);
	uint32_t GetLibraryEntryAliases(const char** result, uint32_t resultlen, const char* librarytypeid, const char* id);
	bool GetLicenceInfo(LicenceInfo* result, const char* factionid, const char* licenceid);
	void GetLoadout2(UILoadout2* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutCounts2(UILoadoutCounts2* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutsInfo(UILoadoutInfo* result, uint32_t resultlen, UniverseID componentid, const char* macroname);
	UILoadoutStatistics5 GetLoadoutStatistics5(UniverseID shipid, const char* macroname, UILoadout uiloadout);
	const char* GetMacroClass(const char* macroname);
	uint32_t GetMacroDeployableCapacity(const char* macroname);
	uint32_t GetMacroMissileCapacity(const char* macroname);
	UILoadoutStatistics5 GetMaxLoadoutStatistics5(UniverseID shipid, const char* macroname);
	uint32_t GetMissileCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetMissingBuildResources(UIWareInfo* result, uint32_t resultlen);
	const char* GetMissingLoadoutBlueprints(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetMissingLoadoutResources(UIWareInfo* result, uint32_t resultlen);
	const char* GetMissingMissionLoadoutBlueprints(UniverseID containerid, MissionID missionid, const char* uimacroname);
	void GetMissionLoadout(UILoadout2* result, MissionID missionid, const char* uimacroname);
	void GetMissionLoadoutCounts(UILoadoutCounts2* result, MissionID missionid, const char* uimacroname);
	uint32_t GetNumAllCountermeasures(UniverseID defensibleid);
	uint32_t GetNumAllEquipment(bool playerblueprint);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllMissiles(UniverseID defensibleid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumAllShipMacros2(bool playerblueprint, bool customgamestart);
	uint32_t GetNumAllUnits(UniverseID defensibleid, bool onlydrones);
	uint32_t GetNumAvailableEquipment(UniverseID containerid, const char* classid);
	uint32_t GetNumAvailableEquipmentMods();
	uint32_t GetNumBlacklistTypes(void);
	uint32_t GetNumBuildResources(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* wareid);
	CrewTransferInfoCounts GetNumBuildTaskCrewTransferInfo(UniverseID containerid, BuildTaskID id);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumContainerBuilderMacros(UniverseID containerid);
	uint32_t GetNumDefaultLoadoutMacros(const char* macroname);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumFightRuleTypes(void);
	uint32_t GetNumInventoryPaintMods(void);
	uint32_t GetNumLibraryEntryAliases(const char* librarytypeid, const char* id);
	uint32_t GetNumLoadoutsInfo(UniverseID componentid, const char* macroname);
	uint32_t GetNumMissileCargo(UniverseID containerid);
	uint32_t GetNumMissingBuildResources2(UniverseID containerid, UIBuildOrderList* orders, uint32_t numorders, bool playercase);
	uint32_t GetNumMissingLoadoutResources2(UniverseID containerid, UIBuildOrderList* orders, uint32_t numorders, bool playercase);
	uint32_t GetNumPlayerPeopleDefinitions(void);
	uint32_t GetNumRepairResources2(UniverseID containerid, UniverseID defensibleid, UniverseID componenttorepairid);
	uint32_t GetNumRequestedMissionShips(void);
	uint32_t GetNumShieldGroups(UniverseID defensibleid);
	uint32_t GetNumSkills(void);
	uint32_t GetNumSlotCompatibilities(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	uint32_t GetNumSoftwarePredecessors(const char* softwarename);
	uint32_t GetNumSoftwareSlots(UniverseID controllableid, const char* macroname);
	uint32_t GetNumSubComponents(UniverseID containerid);
	uint32_t GetNumSuitableBuildProcessors(UniverseID containerid, UniverseID objectid, const char* macroname);
	uint32_t GetNumUnitCargo(UniverseID containerid, bool onlydrones);
	uint32_t GetNumUpgradeGroupCompatibilities(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumUsedLimitedShips(void);
	size_t GetNumVirtualUpgradeSlots(UniverseID objectid, const char* macroname, const char* upgradetypename);
	const char* GetObjectIDCode(UniverseID objectid);
	bool GetPaintThemeMod(const char* themeid, const char* factionid, UIPaintMod* paintmod);
	uint32_t GetPeople2(PeopleInfo* result, uint32_t resultlen, UniverseID controllableid, bool includearriving);
	uint32_t GetPeopleCapacity(UniverseID controllableid, const char* macroname, bool includepilot);
	bool GetPickedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadoutSlot* result);
	UniverseID GetPlayerOccupiedShipID(void);
	const char* GetPlayerPaintTheme(void);
	bool GetPlayerPaintThemeMod(UniverseID objectid, const char* macroname, UIPaintMod* paintmod);
	uint32_t GetPlayerPeopleDefinitions(PeopleDefinitionInfo* result, uint32_t resultlen);
	uint32_t GetPurchasableCargo(UniverseID containerid, const char*);
	int64_t GetRepairPrice(UniverseID componenttorepairid, UniverseID containerid);
	uint32_t GetRepairResources2(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID defensibleid, UniverseID componenttorepairid);
	uint32_t GetRequestedMissionShips(MissionShipDeliveryInfo* result, uint32_t resultlen);
	uint32_t GetRoleTierNPCs(NPCSeed* result, uint32_t resultlen, UniverseID controllableid, const char* role, int32_t skilllevel);
	uint32_t GetRoleTiers(RoleTierData* result, uint32_t resultlen, UniverseID controllableid, const char* role);
	bool GetShieldGroup(ShieldGroup* result, UniverseID defensibleid, UniverseID destructibleid);
	uint32_t GetShieldGroups(ShieldGroup* result, uint32_t resultlen, UniverseID defensibleid);
	int64_t GetShipValue(const char* macroname, UILoadout2 uiloadout);
	uint32_t GetSkills(SkillInfo* result, uint32_t resultlen);
	uint32_t GetSlotCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	const char* GetSlotSize(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	const char* GetSoftwareMaxCompatibleVersion(UniverseID controllableid, const char* macroname, const char* softwarename);
	uint32_t GetSoftwarePredecessors(const char** result, uint32_t resultlen, const char* softwarename);
	uint32_t GetSoftwareSlots(SoftwareSlot* result, uint32_t resultlen, UniverseID controllableid, const char* macroname);
	uint32_t GetUnitCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, bool onlydrones);
	uint32_t GetUpgradeGroupCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo2(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups(UpgradeGroup* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	const char* GetUpgradeSlotCurrentMacro(UniverseID objectid, UniverseID moduleid, const char* upgradetypename, size_t slot);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	uint32_t GetUsedLimitedShips(UIMacroCount* result, uint32_t resultlen);
	const char* GetVirtualUpgradeSlotCurrentMacro(UniverseID defensibleid, const char* upgradetypename, size_t slot);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasControllableOwnBlacklist(UniverseID controllableid, const char* listtype);
	bool HasControllableOwnFightRule(UniverseID controllableid, const char* listtype);
	bool HasDefaultLoadout2(const char* macroname, bool allowloadoutoverride);
	bool HasResearched(const char* wareid);
	bool HasSuitableBuildModule(UniverseID containerid, UniverseID defensibleid, const char* macroname);
	bool IsNextStartAnimationSkipped(bool reset);
	bool InstallEngineMod(UniverseID objectid, const char* wareid);
	bool InstallGroupedWeaponMod(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool InstallPaintMod(UniverseID objectid, const char* wareid, bool useinventory);
	bool InstallShieldMod(UniverseID defensibleid, UniverseID contextid, const char* group, const char* wareid);
	bool InstallShipMod(UniverseID shipid, const char* wareid);
	bool InstallWeaponMod(UniverseID weaponid, const char* wareid);
	bool IsAmmoMacroCompatible(const char* weaponmacroname, const char* ammomacroname);
	bool IsDeployableMacroCompatible(UniverseID containerid, const char* macroname, const char* deployablemacroname);
	bool IsLoadoutCompatible(const char* macroname, const char* loadoutid);
	bool IsLoadoutValid(UniverseID defensibleid, const char* macroname, const char* loadoutid, uint32_t* numinvalidpatches);
	bool IsSlotMandatory(UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	bool IsSoftwareDefault(UniverseID controllableid, const char* macroname, const char* softwarename);
	bool IsUnitMacroCompatible(UniverseID containerid, const char* macroname, const char* unitmacroname);
	bool IsUpgradeMacroCompatible(UniverseID objectid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool IsVirtualUpgradeMacroCompatible(UniverseID defensibleid, const char* macroname, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool RemoveLoadout(const char* source, const char* macroname, const char* localid);
	void SaveLoadout2(const char* macroname, UILoadout2 uiloadout, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SetBuildTaskTransferredMoney(BuildTaskID id, int64_t value);
	void SetCustomGameStartFloatProperty(const char* id, const char* propertyid, float uivalue);
	const char* SetCustomGameStartPlayerPropertyMacroAndLoadout2(const char* id, const char* propertyid, const char* entryid, const char* commanderid, const char* macroname, UILoadout2 uiloadout);
	void SetCustomGameStartPlayerPropertyPeople(const char* id, const char* propertyid, const char* entryid, const char* peopledefid);
	void SetCustomGameStartPlayerPropertyPeopleFillPercentage2(const char* id, const char* propertyid, const char* entryid, float fillpercentage);
	void SetCustomGameStartPlayerPropertyPerson(const char* id, const char* propertyid, const char* entryid, CustomGameStartPersonEntry uivalue);
	void SetCustomGameStartShipAndLoadoutProperty2(const char* id, const char* shippropertyid, const char* loadoutpropertyid, const char* macroname, UILoadout2 uiloadout);
	void SetCustomGameStartShipPilot(const char* id, const char* propertyid, CustomGameStartPersonEntry uivalue);
	void SetCustomGameStartStringProperty(const char* id, const char* propertyid, const char* uivalue);
	void SetMapPaintMod(UniverseID holomapid, const char* wareid);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetPaintModLocked(UniverseID objectid, bool value);
	void SetSelectedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	void ShowObjectConfigurationMap2(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout, size_t cp_idx);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void UpdateObjectConfigurationMap(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout);
]]

local utf8 = require("utf8")

local menu = {
	name = "ShipConfigurationMenu",
	currentIdx = 0,
	expandedModSlots = {},
	expandedUpgrades = {},
	captainSelected = true,
	undoStack = {},
	undoIndex = 1,
	showStats = true,
	customgamestartpeopledef = "",
	equipmentfilter_races = {},
	equipmentfilter_races_y = 0,
	equipmentsearch_editboxrow = 0,
	allownonplayerblueprints = false,
}

local config = {
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	classorder = { "ship_xl", "ship_l", "ship_m", "ship_s", "ship_xs" },
	leftBar = {
		{ name = ReadText(1001, 1103),	icon = "shipbuildst_engine",		mode = "engine",		iscapship = false },
		{ name = ReadText(1001, 8520),	icon = "shipbuildst_enginegroups",	mode = "enginegroup",	iscapship = true },
		{ name = ReadText(1001, 8001),	icon = "shipbuildst_thruster",		mode = "thruster" },
		{ name = ReadText(1001, 1317),	icon = "shipbuildst_shield",		mode = "shield" },
		{ name = ReadText(1001, 2663),	icon = "shipbuildst_weapon",		mode = "weapon" },
		{ name = ReadText(1001, 1319),	icon = "shipbuildst_turret",		mode = "turret",		iscapship = false },
		{ name = ReadText(1001, 7901),	icon = "shipbuildst_turretgroups",	mode = "turretgroup",	iscapship = true },
		{ name = ReadText(1001, 87),	icon = "shipbuildst_software",		mode = "software" },
		{ spacing = true,																			comparison = false },
		{ name = ReadText(1001, 8003),	icon = "shipbuildst_consumable",	mode = "consumables",	comparison = false },
		{ name = ReadText(1001, 80),	icon = "shipbuildst_crew",			mode = "crew",			comparison = false },
		{ spacing = true,																			customgamestart = false,	comparison = false },
		{ name = ReadText(1001, 8510),	icon = "shipbuildst_paint",			mode = "paintmods",		customgamestart = false,	comparison = false,		upgrademode = "paint",	modclass = "paint" },
		{ spacing = true,																			customgamestart = false,	comparison = false,		hascontainer = true },
		{ name = ReadText(1001, 3000),	icon = "shipbuildst_repair",		mode = "repair",		customgamestart = false,	comparison = false,		hascontainer = true },
		{ spacing = true,																			comparison = false,			hascontainer = true },
		{ name = ReadText(1001, 8549),	icon = "tlt_optionsmenu",			mode = "settings",		comparison = false,			hascontainer = true },
	},
	leftBarMods = {
		{ name = ReadText(1001, 8038),	icon = "shipbuildst_chassis",		mode = "shipmods",		upgrademode = "ship",	modclass = "ship" },
		{ name = ReadText(1001, 6600),	icon = "shipbuildst_weapon",		mode = "weaponmods",	upgrademode = "weapon",	modclass = "weapon" },
		{ name = ReadText(1001, 8004),	icon = "shipbuildst_turret",		mode = "turretmods",	upgrademode = "turret",	modclass = "weapon" },
		{ name = ReadText(1001, 8515),	icon = "shipbuildst_shield",		mode = "shieldmods",	upgrademode = "shield",	modclass = "shield" },
		{ name = ReadText(1001, 8028),	icon = "shipbuildst_engine",		mode = "enginemods",	upgrademode = "engine",	modclass = "engine" },
		{ name = ReadText(1001, 8510),	icon = "shipbuildst_paint",			mode = "paintmods",		upgrademode = "paint",	modclass = "paint" },
	},
	dropDownTextProperties = {
		halign = "center",
		font = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Color["text_normal"],
		x = 0,
		y = 0
	},
	stateKeys = {
		{ "object", "UniverseID" },
		{ "macro" },
		{ "class" },
		{ "upgradetypeMode" },
		{ "currentSlot" },
		{ "upgradeplan" },
		{ "crew" },
		{ "editingshoppinglist" },
		{ "loadoutName" },
		{ "captainSelected", "bool" },
		{ "validLicence", "bool" },
		{ "validLoadoutPossible", "bool" },
		{ "shoppinglist" },
	},
	dropdownRatios = {
		class = 0.7,
		ship = 1.3,
	},
	stats = {
		{ id = "HullValue",						name = ReadText(1001, 8048),			unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "ShieldValue",					name = ReadText(1001, 8049),			unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "ShieldRate",					name = "   " .. ReadText(1001, 8553),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "ShieldDelay",					name = "   " .. ReadText(1001, 8554),	unit = ReadText(1001, 100),	type = "double",	accuracy = 2,	inverted = true },
		{ id = "GroupedShieldValue",			name = ReadText(1001, 8533),			unit = ReadText(1001, 118),	type = "float",		accuracy = 0,	mouseovertext = ReadText(1026, 8018) },
		{ id = "GroupedShieldRate",				name = "   " .. ReadText(1001, 8553),	unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "GroupedShieldDelay",			name = "   " .. ReadText(1001, 8554),	unit = ReadText(1001, 100),	type = "double",	accuracy = 2,	inverted = true },
		{ id = "RadarRange",					name = ReadText(1001, 8068),			unit = ReadText(1001, 108),	type = "float",		accuracy = 0 },
		{ id = "BurstDPS",						name = ReadText(1001, 8073),			unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "SustainedDPS",					name = ReadText(1001, 8074),			unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "TurretSustainedDPS",			name = ReadText(1001, 8532),			unit = ReadText(1001, 119),	type = "float",		accuracy = 0,	mouseovertext = ReadText(1026, 8017),	capshipid = "GroupedTurretSustainedDPS" },
		{ id = "" },
		{ id = "ContainerCapacity",				name = ReadText(1001, 8058),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "SolidCapacity",					name = ReadText(1001, 8059),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "LiquidCapacity",				name = ReadText(1001, 8060),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "CondensateCapacity",			name = ReadText(20109, 9801),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0 },
		{ id = "" },
		{ id = "NumDocksShipMedium",			name = ReadText(1001, 8524),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "ShipCapacityMedium",			name = ReadText(1001, 8526),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "NumDocksShipSmall",				name = ReadText(1001, 8525),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "ShipCapacitySmall",				name = ReadText(1001, 8527),			unit = "",					type = "UINT",		accuracy = 0 },
		-- new column
		{ id = "ForwardSpeed",					name = ReadText(1001, 8051),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "ForwardAcceleration",			name = "   " .. ReadText(1001, 8069),	unit = ReadText(1001, 111),	type = "float",		accuracy = 0 },
		{ id = "BoostSpeed",					name = ReadText(1001, 8052),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "BoostAcceleration",				name = "   " .. ReadText(1001, 8590),	unit = ReadText(1001, 111),	type = "float",		accuracy = 0 },
		{ id = "BoostMaxDuration",				name = "   " .. ReadText(1001, 8592),	unit = ReadText(1001, 100),	type = "float",		accuracy = 1 },
		{ id = "BoostRechargeRate",				name = "   " .. ReadText(1001, 8591),	unit = ReadText(1001, 125),	type = "float",		accuracy = 1 },
		{ id = "TravelSpeed",					name = ReadText(1001, 8053),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "TravelAcceleration",			name = "   " .. ReadText(1001, 8593),	unit = ReadText(1001, 111),	type = "float",		accuracy = 0 },
		{ id = "TravelChargeTime",				name = "   " .. ReadText(1001, 8594),	unit = ReadText(1001, 100),	type = "float",		accuracy = 1,	inverted = true },
		{ id = "HorizontalStrafeSpeed",			name = ReadText(1001, 8559),			unit = ReadText(1001, 113),	type = "float",		accuracy = 1 },
		{ id = "HorizontalStrafeAcceleration",	name = "   " .. ReadText(1001, 8560),	unit = ReadText(1001, 111),	type = "float",		accuracy = 1 },
		{ id = "YawSpeed",						name = ReadText(1001, 8054),			unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "PitchSpeed",					name = ReadText(1001, 8055),			unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "RollSpeed",						name = ReadText(1001, 8056),			unit = ReadText(1001, 117),	type = "float",		accuracy = 1 },
		{ id = "" },
		{ id = "CrewCapacity",					name = ReadText(1001, 8057),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "UnitCapacity",					name = ReadText(1001, 8061),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "MissileCapacity",				name = ReadText(1001, 8062),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "DeployableCapacity",			name = ReadText(1001, 8064),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "CountermeasureCapacity",		name = ReadText(1001, 8063),			unit = "",					type = "UINT",		accuracy = 0 },
	},
	limitedStats = {
		{ id = "HullValue",						name = ReadText(1001, 8048),			unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "ShieldValue",					name = ReadText(1001, 8049),			unit = ReadText(1001, 118),	type = "float",		accuracy = 0 },
		{ id = "RadarRange",					name = ReadText(1001, 8068),			unit = ReadText(1001, 108),	type = "float",		accuracy = 0 },
		{ id = "BurstDPS",						name = ReadText(1001, 8073),			unit = ReadText(1001, 119),	type = "float",		accuracy = 0 },
		{ id = "TurretSustainedDPS",			name = ReadText(1001, 8532),			unit = ReadText(1001, 119),	type = "float",		accuracy = 0,	mouseovertext = ReadText(1026, 8017),	capshipid = "GroupedTurretSustainedDPS" },
		{ id = "ContainerCapacity",				name = ReadText(1001, 8058),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0,	hasany = true },
		{ id = "SolidCapacity",					name = ReadText(1001, 8059),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0,	hasany = true },
		{ id = "LiquidCapacity",				name = ReadText(1001, 8060),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0,	hasany = true },
		{ id = "CondensateCapacity",			name = ReadText(20109, 9801),			unit = ReadText(1001, 110),	type = "UINT",		accuracy = 0,	hasany = true },
		{ id = "NumDocksShipMedium",			name = ReadText(1001, 8524),			unit = "",					type = "UINT",		accuracy = 0,	class = { ["ship_l"] = true, ["ship_xl"] = true } },
		{ id = "ShipCapacityMedium",			name = ReadText(1001, 8526),			unit = "",					type = "UINT",		accuracy = 0,	class = { ["ship_l"] = true, ["ship_xl"] = true } },
		{ id = "NumDocksShipSmall",				name = ReadText(1001, 8525),			unit = "",					type = "UINT",		accuracy = 0,	class = { ["ship_m"] = true, ["ship_l"] = true, ["ship_xl"] = true } },
		{ id = "ShipCapacitySmall",				name = ReadText(1001, 8527),			unit = "",					type = "UINT",		accuracy = 0,	class = { ["ship_m"] = true, ["ship_l"] = true, ["ship_xl"] = true } },
		{ id = "",	class = { ["ship_s"] = true } },
		{ id = "",	class = { ["ship_s"] = true } },
		{ id = "ForwardSpeed",					name = ReadText(1001, 8051),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "BoostSpeed",					name = ReadText(1001, 8052),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "TravelSpeed",					name = ReadText(1001, 8053),			unit = ReadText(1001, 113),	type = "float",		accuracy = 0 },
		{ id = "CrewCapacity",					name = ReadText(1001, 8057),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "UnitCapacity",					name = ReadText(1001, 8061),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "MissileCapacity",				name = ReadText(1001, 8062),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "DeployableCapacity",			name = ReadText(1001, 8064),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "CountermeasureCapacity",		name = ReadText(1001, 8063),			unit = "",					type = "UINT",		accuracy = 0 },
		{ id = "",	class = { ["ship_l"] = true, ["ship_xl"] = true } },
		{ id = "",	class = { ["ship_l"] = true, ["ship_xl"] = true } },
	},
	scaleSize = 2,
	deployableOrder = {
		["satellite"]		= 1,
		["navbeacon"]		= 2,
		["resourceprobe"]	= 3,
		["lasertower"]		= 4,
		["mine"]			= 5,
		[""]				= 6,
	},
	maxStatusRowCount = 9,
	comparisonShipLibraries = { "shiptypes_xl", "shiptypes_l", "shiptypes_m", "shiptypes_s" },
	comparisonEquipmentLibraries = {
		{ library = "weapons_lasers",			type = "weapon" },
		{ library = "weapons_missilelaunchers",	type = "weapon" },
		{ library = "weapons_turrets",			type = "turret" },
		{ library = "weapons_missileturrets",	type = "turret" },
		{ library = "shieldgentypes",			type = "shield" },
		{ library = "enginetypes",				type = "engine" },
		{ library = "thrustertypes",			type = "thruster" },
	},
	maxSlotRows = 50,
	undoSteps = 100,
	maxSidePanelWidth = 800,
	maxCenterPanelWidth = 1600,
	compatibilityFontSize = 5,
	equipmentfilter_races_width = 300,
	persistentdataversion = 3,
	statsStateOrder = {
		"hidden",
		"limited",
		"full",
	},
}

__CORE_DETAILMONITOR_SHIPBUILD = __CORE_DETAILMONITOR_SHIPBUILD or {
	version = config.persistentdataversion,
	["showStats2"] = "limited",
	["showStatsPaintMod2"] = "hidden",
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.shoppinglist = {}

	if __CORE_DETAILMONITOR_SHIPBUILD.version < config.persistentdataversion then
		menu.upgradeSettingsVersion()
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.cleanup()
	if menu.paused then
		Unpause()
		menu.paused = nil
	end

	menu.isReadOnly = nil
	menu.container = nil
	menu.containerowner = nil
	menu.isplayerowned = nil
	menu.object = nil
	menu.objectgroup = nil
	menu.macro = nil
	menu.class = nil
	menu.upgradewares = {}
	menu.groups = {}
	menu.slots = {}
	menu.ammo = {}
	menu.software = {}
	menu.upgradeplan = {}
	menu.selectableships = {}
	menu.selectableshipsbyclass = {}
	menu.shoppinglist = {}
	menu.shoppinglisttotal = 0
	menu.total = nil
	menu.crewtotal = nil
	menu.activatemap = nil
	menu.editingshoppinglist = nil
	menu.updateMoney = nil
	menu.equipmentsearchtext = {}
	menu.loadoutName = ""
	menu.loadout = nil
	menu.inventory = {}
	menu.modwares = {}
	menu.captainSelected = true
	menu.initialLoadoutStatistics = {}
	menu.currentIdx = 0
	menu.immediate = nil
	menu.installedPaintMod = nil
	menu.selectedPaintMod = nil
	menu.validLicence = nil
	menu.tasks = {}
	menu.contextMode = nil
	menu.validLoadoutPossible = nil
	menu.customshipname = nil
	menu.warningShown = nil
	menu.customgamestartpeopledef = ""
	menu.customgamestartpeoplefillpercentage = nil
	menu.customgamestartpilot = {}
	menu.allownonplayerblueprints = false
	menu.clearUndoStack()

	menu.equipmentfilter_races = {}
	menu.equipmentfilter_races_y = 0
	menu.equipmentsearch_editboxrow = 0

	menu.repairplan = {}
	menu.damagedcomponents = {}
	menu.repairslots = {}
	menu.totalrepairprice = nil

	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end

	menu.frameworkData = {}
	menu.slotData = {}
	menu.planData = {}
	menu.statsData = {}
	menu.titleData = {}
	menu.mapData = {}

	menu.picking = true
	menu.pickstate = nil

	menu.leftbartable = nil
	menu.slottable = nil
	menu.plantable = nil
	menu.titlebartable = nil
	menu.map = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	if menu.bindingRegistered then
		UnregisterAddonBindings("ego_detailmonitor", "undo")
		menu.bindingRegistered = nil
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

-- button scripts

function menu.isModSlotExpanded(type, slot)
	return menu.expandedModSlots[type .. slot]
end

function menu.expandModSlot(type, slot, row)
	if menu.expandedModSlots[type .. slot] then
		menu.expandedModSlots[type .. slot] = nil
	else
		menu.expandedModSlots[type .. slot] = true
	end

	menu.currentSlot = slot
	menu.selectedRows.slots = row
	menu.refreshMenu()
end

function menu.isUpgradeExpanded(idx, ware, category)
	if ware then
		return menu.expandedUpgrades[idx .. ware .. category]
	end
	return false
end

function menu.expandUpgrade(idx, ware, category, row)
	if menu.expandedUpgrades[idx .. ware .. category] then
		menu.expandedUpgrades[idx .. ware .. category] = nil
	else
		menu.expandedUpgrades[idx .. ware .. category] = true
	end

	menu.topRows.plan = GetTopRow(menu.plantable)
	menu.selectedRows.plan = row
	menu.refreshMenu()
end

function menu.buttonSelectSlot(slot, row, col)
	if menu.currentSlot ~= slot then
		menu.currentSlot = slot
	end

	menu.selectMapMacroSlot()

	menu.topRows.slots = GetTopRow(menu.slottable)
	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.buttonSelectUpgradeMacro(type, slot, macro, row, col, keepcontext, skipvolatilecheck)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
		if macro ~= menu.upgradeplan[type][slot].macro then
			local isvolatile = false
			local currentmacro = menu.upgradeplan[type][slot].macro
			if currentmacro ~= "" then
				local j = menu.findUpgradeMacro(type, currentmacro)
				if j then
					local upgradeware = menu.upgradewares[type][j]
					isvolatile = GetWareData(upgradeware.ware, "volatile")
				end
			end

			if (not skipvolatilecheck) and isvolatile then
				menu.contextData = { mode = "removevolatile", type = type, slot = slot, macro = macro, row = row, col = col }
				menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
			else
				if upgradetype.mergeslots then
					for i, slotdata in ipairs(menu.slots[type]) do
						if menu.mode == "upgrade" then
							if slotdata.component then
								menu.removeRepairedComponent(menu.object, slotdata.component)
							end
						end
						menu.upgradeplan[type][i] = { macro = macro, ammomacro = "", weaponmode = "" }
					end
				else
					if menu.mode == "upgrade" then
						if menu.slots[type][slot].component then
							menu.removeRepairedComponent(menu.object, menu.slots[type][slot].component)
						end
					end
					menu.upgradeplan[type][slot] = { macro = macro, ammomacro = "", weaponmode = "" }
				end

				menu.addUndoStep()

				menu.selectedRows.slots = row
				menu.selectedCols.slots = col
				menu.refreshMenu()
			end
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.buttonDiscardShoppingListAndEditGroup(group, shipid)
	for i = #menu.shoppinglist, 1, -1 do
		local entry = menu.shoppinglist[i]
		for _, ship in ipairs(menu.shipgroups[group].ships) do
			if ship.ship == entry.object then
				table.remove(menu.shoppinglist, i)
				break
			end
		end
	end
	menu.closeContextMenu()
	menu.dropdownShip(_, shipid)
end

function menu.checkboxSelectCaptain(row)
	menu.captainSelected = true

	menu.addUndoStep()

	menu.selectedRows.slots = row
	menu.refreshMenu()
end

function menu.checkboxSelectSoftware(type, slot, software, row, keepcontext)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if software ~= menu.upgradeplan[type][slot] then
		AddUITriggeredEvent(menu.name, "software_added", software)
		menu.upgradeplan[type][slot] = software
	else
		AddUITriggeredEvent(menu.name, "software_removed", software)
		if menu.software[type][slot].defaultsoftware ~= 0 then
			menu.upgradeplan[type][slot] = menu.software[type][slot].possiblesoftware[menu.software[type][slot].defaultsoftware]
		else
			menu.upgradeplan[type][slot] = ""
		end
	end

	menu.selectedRows.slots = row
	menu.refreshMenu()

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.setCustomShipName()
	if menu.customshipname == nil then
		local name = ""
		if menu.object ~= 0 then
			name = ffi.string(C.GetComponentName(menu.object))
		else
			name = GetMacroData(menu.macro, "name")
		end
		menu.customshipname = name
	end

	if menu.customShipNameEditBox then
		C.SetEditBoxText(menu.customShipNameEditBox.id, menu.customshipname)
	end
end

function menu.getUpgradeTypeText(upgradetype)
	if upgradetype == "turrets" then
		return ReadText(1001, 1319)
	elseif upgradetype == "engines" then
		return ReadText(1001, 1103)
	end

	return ""
end

function menu.getCustomShipName()
	local macroname = ""
	if menu.object ~= 0 then
		macroname = GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"), "basename")
	else
		macroname = GetMacroData(menu.macro, "basename")
	end

	return macroname .. " (" .. menu.loadoutName .. ")"
end

function menu.buttonSelectRepair(row, col, objectstring, keepcontext)
	menu.repairplan[objectstring] = menu.repairplan[objectstring] or {}
	if menu.objectgroup then
		for i, ship in ipairs(menu.objectgroup.ships) do
			for j = #menu.objectgroup.shipdata[i].damagedcomponents, 1, -1 do
				if tostring(ship.ship) == objectstring then
					local componentstring = tostring(menu.objectgroup.shipdata[i].damagedcomponents[j])
					if menu.repairplan[objectstring][componentstring] then
						menu.repairplan[objectstring][componentstring] = nil
					else
						menu.repairplan[objectstring][componentstring] = true
					end
				end
			end
		end
	else
		for i = #menu.damagedcomponents, 1, -1 do
			local componentstring = tostring(menu.damagedcomponents[i])
			if menu.repairplan[objectstring][componentstring] then
				menu.repairplan[objectstring][componentstring] = nil
			else
				menu.repairplan[objectstring][componentstring] = true
			end
		end
	end

	menu.addUndoStep()

	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.removeRepairedComponent(object, component)
	local objectstring = tostring(object)
	local componentstring = tostring(component)

	if menu.repairplan[objectstring] then
		menu.repairplan[objectstring][componentstring] = nil
	end
end

function menu.buttonSelectGroupUpgrade(type, group, macro, row, col, keepcontext)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if macro ~= menu.upgradeplan[type][group].macro then
			for i, slotdata in ipairs(menu.slots[upgradetype.grouptype]) do
				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, upgradetype.grouptype, i)
				if upgradetype.mergeslots or ((groupinfo.path == menu.upgradeplan[type][group].path) and (groupinfo.group == menu.upgradeplan[type][group].group)) then
					if menu.mode == "upgrade" then
						if slotdata.component then
							menu.removeRepairedComponent(menu.object, slotdata.component)
						end
					end
				end
			end

			-- handle already installed equipment
			local haslicence = menu.checkLicence(macro)
			if (macro == menu.groups[group][upgradetype.grouptype].currentmacro) and (not haslicence) then
				menu.upgradeplan[type][group].count = math.min(menu.upgradeplan[type][group].count, menu.groups[group][upgradetype.grouptype].count)
			end

			menu.upgradeplan[type][group].macro = macro
			menu.upgradeplan[type][group].ammomacro = ""
			menu.upgradeplan[type][group].weaponmode = ""
			if (macro ~= "") and (menu.upgradeplan[type][group].count == 0) then
				menu.upgradeplan[type][group].count = 1
			elseif (macro == "") and (menu.upgradeplan[type][group].count ~= 0) then
				menu.upgradeplan[type][group].count = 0
			end

			if upgradetype.pseudogroup then
				for i, slotdata in ipairs(menu.slots[upgradetype.grouptype]) do
					local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, upgradetype.grouptype, i)
					if upgradetype.mergeslots or ((groupinfo.path == menu.upgradeplan[type][group].path) and (groupinfo.group == menu.upgradeplan[type][group].group)) then
						menu.upgradeplan[upgradetype.grouptype][i] = { macro = macro, ammomacro = "", weaponmode = "" }
					end
				end
			end

			menu.addUndoStep()

			menu.selectedRows.slots = row
			menu.selectedCols.slots = col
			menu.refreshMenu()
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.buttonTitleSave()
	if menu.contextMode and next(menu.contextMode) and (menu.contextMode.mode == "saveLoadout") then
		menu.closeContextMenu()
	else
		menu.displayContextFrame("saveLoadout", menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize, menu.titleData.offsetX + 2 * (menu.titleData.dropdownWidth + Helper.borderSize), menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonSave(overwrite)
	local loadoutid
	if overwrite then
		loadoutid = menu.loadout
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 1)
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	if menu.mode ~= "modify" then
		Helper.closeDropDownOptions(menu.titlebartable, 1, 3)
	end
	local macro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.object)), "macro")
	if macro ~= nil then
		for i, entry in ipairs(menu.crew.roles) do
			menu.upgradeplan.crew[entry.id] = entry.wanted
		end

		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SaveLoadout2(macro, loadout, "local", loadoutid or "player", loadoutid ~= nil, menu.loadoutName, "") end, nil, "UILoadout2")
		menu.getPresetLoadouts()
	end
	menu.closeContextMenu()
	menu.displayMenu()
end

function menu.buttonDismantleMod(type, component, context, group)
	local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
	menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)

	if (type == "turret") and group then
		C.DismantleGroupedWeaponMod(component, context, group)
	elseif (type == "weapon") or (type == "turret") then
		C.DismantleWeaponMod(component)
	elseif type == "engine" then
		C.DismantleEngineMod(component)
	elseif type == "shield" then
		C.DismantleShieldMod(component, context, group)
	elseif type == "ship" then
		C.DismantleShipMod(component)
	end
	menu.prepareModWares()
	menu.refreshMenu()
end

function menu.buttonInstallMod(type, component, ware, price, context, group, dismantle)
	if menu.isplayerowned or (GetPlayerMoney() >= price * menu.moddingdiscounts.totalfactor) then
		local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
		menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)

		if (type == "turret") and group then
			C.DismantleGroupedWeaponMod(component, context, group)
		elseif (type == "weapon") or (type == "turret") then
			C.DismantleWeaponMod(component)
		elseif type == "engine" then
			C.DismantleEngineMod(component)
		elseif type == "shield" then
			C.DismantleShieldMod(component, context, group)
		elseif type == "ship" then
			C.DismantleShipMod(component)
		end

		if not menu.isplayerowned then
			TransferPlayerMoneyTo(price * menu.moddingdiscounts.totalfactor, menu.container)
		end

		if (type == "turret") and group then
			C.InstallGroupedWeaponMod(component, context, group, ware)
		elseif (type == "weapon") or (type == "turret") then
			C.InstallWeaponMod(component, ware)
		elseif type == "engine" then
			C.InstallEngineMod(component, ware)
		elseif type == "shield" then
			C.InstallShieldMod(component, context, group, ware)
		elseif type == "ship" then
			C.InstallShipMod(component, ware)
		end
		AddUITriggeredEvent(menu.name, "modinstalled", { ConvertStringToLuaID(tostring(component)), ware })
		menu.prepareModWares()
		menu.refreshMenu()
	end
end

function menu.buttonContextEncyclopedia(selectedUpgrade)
	local upgradetype = Helper.findUpgradeType(selectedUpgrade.type)

	if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") or (upgradetype.supertype == "group") then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
		menu.cleanup()
	elseif upgradetype.supertype == "software" then
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, "software", selectedUpgrade.software })
		menu.cleanup()
	elseif upgradetype.supertype == "ammo" then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		if upgradetype.emode then
			local emode = upgradetype.emode
			if library == "mines" then
				emode = "Weapons"
			end
			Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, emode, library, selectedUpgrade.macro })
			menu.cleanup()
		end
	end
end

function menu.buttonEditBlacklist(blacklistid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "blacklist", (blacklistid > 0) and blacklistid or nil } })
	menu.cleanup()
end

function menu.buttonEditFightRule(fightruleid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "fightrule", (fightruleid > 0) and fightruleid or nil } })
	menu.cleanup()
end

function menu.buttonInteract(selectedData, button, row, col, posx, posy)
	menu.selectedUpgrade = selectedData
	local x, y = GetLocalMousePosition()
	if x == nil then
		-- gamepad case
		x = posx
		y = -posy
	end
	if menu.mode ~= "customgamestart" then
		menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
	end
end

function menu.buttonExpandStats()
	local statskeyword = "showStats2"
	if (menu.mode == "modify") and (menu.upgradetypeMode == "paintmods") then
		statskeyword = "showStatsPaintMod2"
	end

	local index = #config.statsStateOrder
	local curstate = __CORE_DETAILMONITOR_SHIPBUILD[statskeyword]
	for i, state in ipairs(config.statsStateOrder) do
		if state == curstate then
			index = i
			break
		end
	end
	if index < #config.statsStateOrder then
		index = index + 1
	end

	__CORE_DETAILMONITOR_SHIPBUILD[statskeyword] = config.statsStateOrder[index]
	menu.selectedCols.stats = 2
	menu.refreshMenu()
end

function menu.buttonCollapseStats()
	local statskeyword = "showStats2"
	if (menu.mode == "modify") and (menu.upgradetypeMode == "paintmods") then
		statskeyword = "showStatsPaintMod2"
	end

	local index = 1
	local curstate = __CORE_DETAILMONITOR_SHIPBUILD[statskeyword]
	for i, state in ipairs(config.statsStateOrder) do
		if state == curstate then
			index = i
			break
		end
	end
	if index > 1 then
		index = index - 1
	end

	__CORE_DETAILMONITOR_SHIPBUILD[statskeyword] = config.statsStateOrder[index]
	menu.selectedCols.stats = 3
	menu.refreshMenu()
end

function menu.slidercellSelectAmount(type, slot, macro, row, value)
	menu.closeContextMenu()

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "ammo") then
		AddUITriggeredEvent(menu.name, "ammo_changed", value)
		menu.upgradeplan[type][macro] = value
		menu.selectedRows.slots = row
	end
	menu.addUndoStep()
end

function menu.slidercellSelectCrewAmount(slot, tier, row, istier, value)
	menu.noupdate = true

	local oldwanted = istier and menu.crew.roles[slot].tiers[tier].wanted or menu.crew.roles[slot].wanted

	local change = value - oldwanted
	if istier then
		menu.crew.roles[slot].wanted = menu.crew.roles[slot].wanted + change
	else
		menu.crew.roles[slot].wanted = value
	end
	if change > 0 then
		AddUITriggeredEvent(menu.name, "crew_added", change)
		-- adding crew
		-- first use npcs from the unassigned pool
		if #menu.crew.unassigned > 0 then
			if #menu.crew.unassigned >= change then
				-- first reassign npcs from the correct role to the correct tier
				for i = #menu.crew.unassigned, 1, -1 do
					if menu.crew.unassigned[i].role == menu.crew.roles[slot].id then
						menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].wanted = menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].wanted + 1
						table.insert(menu.crew.roles[slot].tiers[menu.crew.unassigned[i].tier].currentnpcs, menu.crew.unassigned[i].npc)
						table.insert(menu.crew.transferdetails, { npc = menu.crew.unassigned[i].npc, newrole = menu.crew.roles[slot].id, price = 0 })
						table.remove(menu.crew.unassigned, i)
						change = change - 1
						if change == 0 then
							break
						end
					end
				end
				if change > 0 then
					-- if that wasn't enough, use all unassigned npcs
					for i = #menu.crew.unassigned, 1, -1 do
						menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + 1
						table.insert(menu.crew.roles[slot].tiers[tier].currentnpcs, menu.crew.unassigned[i].npc)
						table.insert(menu.crew.transferdetails, { npc = menu.crew.unassigned[i].npc, newrole = menu.crew.roles[slot].id, price = 0 })
						table.remove(menu.crew.unassigned, i)
						change = change - 1
						if change == 0 then
							break
						end
					end
				end
			else
				change = change - #menu.crew.unassigned
				for _, entry in ipairs(menu.crew.unassigned) do
					local npctier = tier
					if entry.role == menu.crew.roles[slot].id then
						npctier = entry.tier
					end
					menu.crew.roles[slot].tiers[npctier].wanted = menu.crew.roles[slot].tiers[npctier].wanted + 1
					table.insert(menu.crew.roles[slot].tiers[npctier].currentnpcs, entry.npc)
					table.insert(menu.crew.transferdetails, { npc = entry.npc, newrole = menu.crew.roles[slot].id, price = 0 })
				end
				menu.crew.unassigned = {}
			end
		end
		-- if any are left add newly hired npcs
		if change > 0 then
			menu.crew.hired = menu.crew.hired + change
			menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + change
			local found = false
			for i, entry in ipairs(menu.crew.hireddetails) do
				if entry.newrole == menu.crew.roles[slot].id then
					menu.crew.hireddetails[i].amount = menu.crew.hireddetails[i].amount + change
					found = true
					break
				end
			end
			if not found then
				table.insert(menu.crew.hireddetails, { newrole = menu.crew.roles[slot].id, amount = change, price = menu.crew.price })
			end
		end
	else
		AddUITriggeredEvent(menu.name, "crew_removed", -change)
		-- removing crew
		-- first remove newly hired crew
		for i, entry in ipairs(menu.crew.hireddetails) do
			if entry.newrole == menu.crew.roles[slot].id then
				if entry.amount >= -change then
					menu.crew.hireddetails[i].amount = menu.crew.hireddetails[i].amount + change
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted + change
					if menu.crew.hireddetails[i].amount == 0 then
						table.remove(menu.crew.hireddetails, i)
					end
					menu.crew.hired = menu.crew.hired + change
					change = 0
				else
					menu.crew.hired = menu.crew.hired - entry.amount
					change = change + entry.amount
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted - entry.amount
					table.remove(menu.crew.hireddetails, i)
				end
				break
			end
		end
		-- if any are left move them to unassigned
		if change < 0 then
			for i = 1, -change do
				local npc, npctier
				if #menu.crew.roles[slot].tiers[tier].currentnpcs > 0 then
					npc = table.remove(menu.crew.roles[slot].tiers[tier].currentnpcs)
					npctier = tier
					menu.crew.roles[slot].tiers[tier].wanted = menu.crew.roles[slot].tiers[tier].wanted - 1
				else
					for j = 1, #menu.crew.roles[slot].tiers do
						if #menu.crew.roles[slot].tiers[j].currentnpcs > 0 then
							npc = table.remove(menu.crew.roles[slot].tiers[j].currentnpcs)
							npctier = j
							menu.crew.roles[slot].tiers[j].wanted = menu.crew.roles[slot].tiers[j].wanted - 1
							break
						end
					end
				end
				if npc then
					table.insert(menu.crew.unassigned, { npc = npc, role = menu.crew.roles[slot].id, tier = npctier })
				else
					DebugError("Could not find npc to remove. [Florian]")
				end
			end
		end
	end
	menu.addUndoStep()

	menu.selectedRows.slots = row
end

function menu.slidercellSelectGroupAmount(type, group, row, keepcontext, value)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if value ~= menu.upgradeplan[type][group].count then
			menu.upgradeplan[type][group].count = value

			menu.addUndoStep()

			menu.selectedRows.slots = row
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.onSliderCellConfirm()
	menu.refreshMenu()
	menu.noupdate = nil
end

function menu.checkCommanderRepairOrders(shipidstring)
	local commander = GetCommander(ConvertStringTo64Bit(shipidstring))
	if commander then
		local commanderidstring = tostring(ConvertIDTo64Bit(commander))
		if menu.repairplan[commanderidstring] then
			return true
		else
			return menu.checkCommanderRepairOrders(commanderidstring)
		end
	end

	return false
end

function menu.getLastUnprocessedSubordinate(shipidstring, list_processed)
	local ship = ConvertStringToLuaID(tostring(shipidstring))
	local subordinates = GetSubordinates(ship)
	local subordinate = nil

	for _, locsubordinate in pairs(subordinates) do
		local skip = nil
		for _, eval in pairs(list_processed) do
			if tostring(locsubordinate) == tostring(eval) then
				skip = true
				break
			end
		end
		if not skip then
			if locsubordinate then
				local locsubordinatestring = tostring(ffi.new("UniverseID", ConvertStringTo64Bit(tostring(locsubordinate))))
				local result = menu.getLastUnprocessedSubordinate(locsubordinatestring, list_processed)
				subordinate = result[1]
				if not subordinate then
					subordinate = locsubordinate
				end
			end
		else
			skip = nil
		end
	end

	--print("returning " .. tostring(subordinate))
	return {subordinate, list_processed}
end

function menu.processRepairsFor(shipidstring, orderindex)
	local ship = ConvertStringTo64Bit(shipidstring)
	local subordinates = GetSubordinates(ConvertStringToLuaID(tostring(shipidstring)))
	local subordinateorders = {}
	local list_processed = {}

	while #subordinates > 0 do
		local result = menu.getLastUnprocessedSubordinate(shipidstring, list_processed)
		local subordinate = result[1]
		list_processed = result[2]

		if subordinate then
			table.insert(list_processed, subordinate)
			for i = #subordinates, 1, -1 do
				if tostring(subordinate) == tostring(subordinates[i]) then
					table.remove(subordinates, i)
					break
				end
			end
			local subordinateidstring = tostring(ffi.new("UniverseID", ConvertStringTo64Bit(tostring(subordinate))))
			local param2 = nil
			local param3 = {}
			if menu.repairplan[subordinateidstring] then
				for componentidstring, _ in pairs(menu.repairplan[subordinateidstring]) do
					if componentidstring ~= "processed" then
						if componentidstring == subordinateidstring then
							param2 = 100
						else
							table.insert(param3, ConvertStringToLuaID(componentidstring))
						end
					end
				end
				subordinateorders[subordinate] = { ConvertStringToLuaID(tostring(menu.container)), param2, param3, false, 0 }
				menu.repairplan[subordinateidstring]["processed"] = true
			end
		else
			break
		end
	end

	local shipluaid = ConvertStringToLuaID(tostring(shipidstring))

	-- param 1 == destination (component)
	SetOrderParam(shipluaid, orderindex, 1, nil, ConvertStringToLuaID(tostring(menu.container)))

	for componentidstring, _ in pairs(menu.repairplan[shipidstring]) do
		if componentidstring ~= "processed" then
			if componentidstring == shipidstring then
				SetOrderParam(shipluaid, orderindex, 2, nil, 100)
			else
				-- param 3 == damagedcomponents (list)
				SetOrderParam(shipluaid, orderindex, 3, nil, ConvertStringToLuaID(componentidstring))
			end
		end
	end

	-- param 4 == repairall (bool)
	SetOrderParam(shipluaid, orderindex, 4, nil, false)

	-- param 5 == acceptedcost (money)
	SetOrderParam(shipluaid, orderindex, 5, nil, menu.totalrepairprice)

	-- param 6 == urgent (bool); by default, repairs ordered by the player are always urgent
	SetOrderParam(shipluaid, orderindex, 6, nil, true)

	-- param 7 == blacklist_stations (list)

	-- param 8 == subordinaterepairorders (table)
	SetOrderParam(shipluaid, orderindex, 8, nil, subordinateorders)

	-- param 9 == subordinateorders (list) (used for undocking subordinates)

	-- param 10 == debugchance (int)
	--SetOrderParam(shipluaid, orderindex, 10, nil, 100)

	menu.repairplan[shipidstring]["processed"] = true

	if not C.EnableOrder(ship, orderindex) then
		print("ERROR: Order to initiate repairs for " .. ffi.string(C.GetComponentName(ship)) .. " was not enabled.")
	end
end

function menu.buttonConfirm()
	local playermoney = GetPlayerMoney()
	if menu.isplayerowned or ((playermoney - menu.shoppinglisttotal + menu.shoppinglistrefund) >= 0) then
		if (menu.mode == "purchase") or (menu.mode == "upgrade") then
			for i, entry in ipairs(menu.shoppinglist) do
				if i ~= menu.editingshoppinglist then
					local haspaid
					if not menu.isplayerowned then
						-- Pay upfront, receive money when build finishes
						if (entry.price + entry.crewprice) > 0 then
							TransferPlayerMoneyTo(entry.amount * (entry.price + entry.crewprice), menu.container)
							haspaid = entry.price + entry.crewprice
						end
					end

					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						for i, ship in ipairs(groupentry.ships) do
							menu.repairandupgrade(entry, ship.ship, "", entry.groupstates[i].hasupgrades, haspaid, entry.groupstates[i].price, entry.groupstates[i].crewprice)
						end
					else
						menu.repairandupgrade(entry, entry.object, entry.macro, entry.hasupgrades, haspaid)
					end
				end
			end
		elseif menu.mode == "modify" then
			-- TODO
		elseif menu.mode == "customgamestart" then
			for i, entry in ipairs(menu.crew.roles) do
				menu.upgradeplan.crew[entry.id] = entry.wanted
			end
			if menu.modeparam.playerpropertyid then
				local entryid = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SetCustomGameStartPlayerPropertyMacroAndLoadout2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid, menu.modeparam.propertycommander, menu.macro, loadout) end, nil, "UILoadout2")
				C.SetCustomGameStartPlayerPropertyPeople(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, menu.customgamestartpeopledef)
				C.SetCustomGameStartPlayerPropertyPeopleFillPercentage2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, menu.customgamestartpeoplefillpercentage)

				local numskills = C.GetNumSkills()
				local buf = ffi.new("CustomGameStartPersonEntry")
				buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
				buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
				local skillbuf = ffi.new("SkillInfo[?]", numskills)
				numskills = C.GetSkills(skillbuf, numskills)
				buf.numskills = numskills
				buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
				for i = 0, numskills - 1 do
					local id = ffi.string(skillbuf[i].id)
					buf.skills[i].id = Helper.ffiNewString(id)
					buf.skills[i].value = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0
				end
				C.SetCustomGameStartPlayerPropertyPerson(menu.modeparam.gamestartid, menu.modeparam.shipproperty, entryid, buf)
			else
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.SetCustomGameStartShipAndLoadoutProperty2(menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.shiploadoutproperty, menu.macro, loadout) end, nil, "UILoadout2")
				C.SetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shippeopleproperty, menu.customgamestartpeopledef)
				C.SetCustomGameStartFloatProperty(menu.modeparam.gamestartid, menu.modeparam.shippeoplefillpercentageproperty, menu.customgamestartpeoplefillpercentage)

				if menu.modeparam.shippilotproperty then
					local numskills = C.GetNumSkills()
					local buf = ffi.new("CustomGameStartPersonEntry")
					buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
					buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
					local skillbuf = ffi.new("SkillInfo[?]", numskills)
					numskills = C.GetSkills(skillbuf, numskills)
					buf.numskills = numskills
					buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
					for i = 0, numskills - 1 do
						local id = ffi.string(skillbuf[i].id)
						buf.skills[i].id = Helper.ffiNewString(id)
						buf.skills[i].value = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0
					end
					C.SetCustomGameStartShipPilot(menu.modeparam.gamestartid, menu.modeparam.shippilotproperty, buf)
				end
			end
		elseif menu.mode == "comparison" then
			Helper.addShipComparison(menu.modeparam[1], menu.macro, menu.upgradeplan)
		end

		menu.closeMenu("back")
	else
		menu.displayMenu()
	end
end

function menu.buttonSelectPaintMod(entry, row, col)
	menu.selectedPaintMod = entry
	C.SetMapPaintMod(menu.holomap, entry.ware)

	menu.selectedRows.slots = row
	menu.selectedCols.slots = col
	menu.refreshMenu()
end

function menu.buttonInstallPaintMod()
	if (menu.mode == "modify") and menu.modeparam[1] then
		for _, ship in pairs(menu.modeparam[2]) do
			local change = false
			local paintmod = ffi.new("UIPaintMod")
			if C.GetInstalledPaintMod(ship, paintmod) then
				if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
					change = true
				end
			else
				change = true
			end
			if change then
				C.InstallPaintMod(ship, menu.selectedPaintMod.ware, not menu.selectedPaintMod.isdefault)
				AddUITriggeredEvent(menu.name, "paintmodinstalled", { ConvertStringToLuaID(tostring(ship)), menu.selectedPaintMod.ware })
			end
		end
	else
		if menu.objectgroup then
			for i, ship in ipairs(menu.objectgroup.ships) do
				local change = false
				local paintmod = ffi.new("UIPaintMod")
				if C.GetInstalledPaintMod(ship.ship, paintmod) then
					if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
						change = true
					end
				else
					change = true
				end
				if change then
					C.InstallPaintMod(ship.ship, menu.selectedPaintMod.ware, not menu.selectedPaintMod.isdefault)
					AddUITriggeredEvent(menu.name, "paintmodinstalled", { ConvertStringToLuaID(tostring(ship)), menu.selectedPaintMod.ware })
				end
			end
		else
			C.InstallPaintMod(menu.object, menu.selectedPaintMod.ware, not menu.selectedPaintMod.isdefault)
			AddUITriggeredEvent(menu.name, "paintmodinstalled", { ConvertStringToLuaID(tostring(menu.object)), menu.selectedPaintMod.ware })
		end
	end

	menu.selectedRows.slots = Helper.currentTableRow[menu.slottable]
	menu.selectedCols.slots = Helper.currentTableCol[menu.slottable]

	menu.mapstate = ffi.new("HoloMapState")
	C.GetMapState(menu.holomap, menu.mapstate)
	menu.prepareModWares()
	menu.getDataAndDisplay(menu.upgradeplan, menu.crew, nil, nil, true)
end

function menu.dropdownShipClass(_, class)
	AddUITriggeredEvent(menu.name, "shipclass_selected", class)
	if class ~= menu.class then
		menu.class = class or ""
		if menu.usemacro then
			menu.validLicence = false
			menu.macro = ""
		elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
			local entry = menu.selectableshipsbyclass[class][1]
			if type(entry) == "table" then
				if entry.group then
					menu.objectgroup = menu.shipgroups[entry.group]
					menu.object = menu.objectgroup.ships[1].ship
				elseif entry.grouped ~= nil then
					menu.objectgroup = nil
					menu.object = entry.ship.ship
				else
					menu.objectgroup = nil
					menu.object = entry.ship
				end
			else
				menu.objectgroup = nil
				menu.object = entry
			end

			menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

			if menu.mode == "upgrade" then
				local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
				if aipilot then
					menu.captainSelected = true
				else
					menu.captainSelected = false
				end
			elseif menu.mode == "modify" then
				local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
				menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
			end
		end
		menu.prepareModWares()
		menu.customshipname = nil
		menu.loadoutName = ""
		menu.selectedPaintMod = nil
		menu.clearUndoStack()
		menu.getDataAndDisplay()
	end
end

function menu.dropdownShip(_, shipid)
	if menu.usemacro then
		AddUITriggeredEvent(menu.name, "shipmacro_selected", shipid)
		local oldmacro = menu.macro
		menu.macro = shipid or ""
		if menu.macro ~= oldmacro then
			menu.hasDefaultLoadout = false
			menu.defaultLoadoutMacros = {}
			if menu.macro ~= "" then
				menu.hasDefaultLoadout = C.HasDefaultLoadout2(menu.macro, true)
				if menu.hasDefaultLoadout then
					local n = C.GetNumDefaultLoadoutMacros(menu.macro)
					local buf = ffi.new("const char*[?]", n)
					n = C.GetDefaultLoadoutMacros(buf, n, menu.macro)
					for i = 0, n - 1 do
						menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
					end
				end
			end

			menu.setdefaulttable = true
			menu.currentSlot = nil
			menu.captainSelected = (menu.mode == "customgamestart") or (menu.mode == "comparison")
			menu.validLicence = menu.checkLicence(menu.macro, true)
			if menu.mode == "customgamestart" then
				menu.validLoadoutPossible = true
			elseif menu.mode == "comparison" then
				menu.validLoadoutPossible = C.CanGenerateValidKnownLoadout(menu.macro)
			else
				menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, menu.macro)
			end
			menu.customshipname = nil
			menu.loadoutName = ""
			menu.selectedPaintMod = nil
			menu.clearUndoStack()
			menu.getDataAndDisplay()
		end
	elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
		AddUITriggeredEvent(menu.name, "ship_selected", shipid)
		local oldobject = menu.object
		local oldobjectgroup = menu.objectgroup and menu.objectgroup.idx or 0

		local i
		if menu.mode == "upgrade" then
			i = menu.findMacroIdx(menu.shipgroups, shipid)
		end
		if i then
			for idx, entry in ipairs(menu.shoppinglist) do
				for _, ship in ipairs(menu.shipgroups[i].ships) do
					if ship.ship == entry.object then
						menu.contextData = { mode = "replacesingleshoppinglistentry", group = i, shipid = shipid }
						menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
						return
					end
				end
			end

			menu.objectgroup = menu.shipgroups[i]
			menu.object = menu.objectgroup.ships[1].ship
		else
			menu.objectgroup = nil
			menu.object = ffi.new("UniverseID", ConvertStringTo64Bit(shipid))
		end
		menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
		menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

		if (menu.object ~= oldobject) or ((menu.objectgroup and menu.objectgroup.idx or 0) ~= oldobjectgroup) then
			menu.setdefaulttable = true
			if menu.editingshoppinglist then
				table.remove(menu.shoppinglist, menu.editingshoppinglist)
			end

			menu.hasDefaultLoadout = false
			menu.defaultLoadoutMacros = {}
			if menu.object ~= 0 then
				local macro = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
				menu.hasDefaultLoadout = C.HasDefaultLoadout2(macro, true)
				if menu.hasDefaultLoadout then
					local n = C.GetNumDefaultLoadoutMacros(macro)
					local buf = ffi.new("const char*[?]", n)
					n = C.GetDefaultLoadoutMacros(buf, n, macro)
					for i = 0, n - 1 do
						menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
					end
				end
			end

			if menu.mode == "upgrade" then
				local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
				if aipilot then
					menu.captainSelected = true
				else
					menu.captainSelected = false
				end
			elseif menu.mode == "modify" then
				local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
				menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
			end
			menu.selectedPaintMod = nil
			menu.prepareModWares()

			local found = false
			for idx, entry in ipairs(menu.shoppinglist) do
				if menu.object == entry.object then
					found = true

					menu.editingshoppinglist = idx
					menu.object = entry.object
					menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
					menu.macro = entry.macro
					menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
					menu.clearUndoStack()
					menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true)
					break
				elseif menu.objectgroup and (menu.objectgroup.idx == entry.objectgroup) then
					found = true

					menu.editingshoppinglist = idx
					menu.clearUndoStack()
					menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true)
					break
				end
			end

			if not found then
				menu.editingshoppinglist = nil

				menu.currentSlot = nil
				menu.customshipname = nil
				menu.loadoutName = ""
				menu.selectedPaintMod = nil
				menu.clearUndoStack()
				menu.getDataAndDisplay(nil, nil, nil, true)
			end
		end
	end
end

function menu.dropdownLoadout(_, loadoutid)
	if loadoutid ~= nil then
		menu.loadout = loadoutid
		local preset, mission
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				menu.setCustomShipName()
				if loadout.preset then
					preset = loadout.preset
					menu.loadout = nil
				elseif loadout.mission then
					menu.loadoutName = string.match(menu.loadoutName, "\27#.*#\27%[.*%] (.*)\27X")
					mission = loadout.mission
					menu.loadout = nil
				end
				break
			end
		end
		local loadout, crew
		if preset then
			if menu.mode == "customgamestart" then
				loadout = Helper.getLoadoutHelper2(C.GenerateShipLoadout2, C.GenerateShipLoadoutCounts2, "UILoadout2", 0, menu.object, menu.macro, preset)
			elseif menu.mode == "comparison" then
				loadout = Helper.getLoadoutHelper2(C.GenerateShipKnownLoadout2, C.GenerateShipKnownLoadoutCounts2, "UILoadout2", menu.macro, preset)
			else
				loadout = Helper.getLoadoutHelper2(C.GenerateShipLoadout2, C.GenerateShipLoadoutCounts2, "UILoadout2", menu.container, menu.object, menu.macro, preset)
			end
			if menu.usemacro then
				if menu.mode ~= "customgamestart" then
					local intendedcrew = preset * menu.crew.capacity
					local intendedcrewperrole = math.floor(intendedcrew / #menu.crew.roles)

					crew = {
						roles = {},
						unassigned = {},
						hired = 0,
						hireddetails = {},
						fired = {},
					}

					for i, entry in ipairs(menu.crew.roles) do
						crew.roles[i] = { tiers = { [1] = {} } }
						crew.roles[i].wanted = intendedcrewperrole
						crew.roles[i].tiers[1].wanted = intendedcrewperrole

						crew.hired = crew.hired + intendedcrewperrole
						table.insert(crew.hireddetails, { newrole = entry.id, amount = intendedcrewperrole, price = menu.crew.price })
					end
				else
					if preset >= 0.9 then
						menu.customgamestartpeopledef = "player_argon_elite_freighter_crew"
					elseif preset >= 0.4 then
						menu.customgamestartpeopledef = "player_argon_veteran_freighter_crew"
					elseif preset > 0 then
						menu.customgamestartpeopledef = "player_argon_regular_freighter_crew"
					else
						menu.customgamestartpeopledef = ""
					end
					menu.customgamestartpeoplefillpercentage = preset * 100
				end
			end
		elseif mission then
			loadout = Helper.getLoadoutHelper2(C.GetMissionLoadout, C.GetMissionLoadoutCounts, "UILoadout2", mission.id, mission.macro)
		else
			loadout = Helper.getLoadoutHelper2(C.GetLoadout2, C.GetLoadoutCounts2, "UILoadout2", menu.object, menu.macro, loadoutid)
		end
		local upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
		if menu.usemacro then
			menu.captainSelected = true
		end
		menu.getDataAndDisplay(upgradeplan, crew)
	end
end

function menu.dropdownLoadoutRemoved(_, loadoutid)
	local macro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.object)), "macro")
	C.RemoveLoadout("local", macro, loadoutid)
	if loadoutid == menu.loadout then
		menu.loadout = nil
		menu.loadoutName = ""
	end
	for i, loadout in ipairs(menu.loadouts) do
		if loadout.id == loadoutid then
			table.remove(menu.loadouts, i)
			break
		end
	end
end

function menu.dropdownChangePurchaseAmount(idx, amountstring)
	local entry = menu.shoppinglist[idx]
	entry.amount = tonumber(amountstring)
	menu.refreshMenu()
	AddUITriggeredEvent(menu.name, "shipconfig_purchaseamount", entry.amount)
end

function menu.onDropDownActivated()
	menu.closeContextMenu()
end

function menu.buttonAddPurchase(hasupgrades, hasrepairs)
	menu.closeContextMenu()

	local objectgroup
	local object = menu.object
	local groupstates = {}
	if menu.objectgroup then
		objectgroup = menu.objectgroup.idx
		object = nil
		groupstates = menu.objectgroup.states
	end
	local paintmodware
	if menu.mode == "purchase" then
		paintmodware = menu.selectedPaintMod and menu.selectedPaintMod.ware or nil
	end

	table.insert(menu.shoppinglist, { objectgroup = objectgroup, groupstates = groupstates, object = object, macro = menu.macro, hasupgrades = hasupgrades, upgradeplan = menu.upgradeplan, crew = menu.crew, settings = menu.settings, amount = 1, price = menu.total, crewprice = menu.crewtotal, duration = menu.duration, warnings = menu.warnings, customshipname = menu.customshipname, loadoutName = menu.loadoutName, paintmodware = paintmodware })
	menu.object = 0
	menu.objectgroup = nil
	menu.damagedcomponents = {}
	menu.macro = ""
	menu.customshipname = nil
	menu.loadoutName = ""
	menu.selectedPaintMod = nil
	menu.clearUndoStack()
	menu.getDataAndDisplay()
end

function menu.buttonConfirmPurchaseEdit(hasupgrades, hasrepairs)
	menu.closeContextMenu()

	if (not hasupgrades) and (not hasrepairs) then
		table.remove(menu.shoppinglist, menu.editingshoppinglist)
	else
		if menu.objectgroup then
			menu.shoppinglist[menu.editingshoppinglist].objectgroup = menu.objectgroup.idx
			menu.shoppinglist[menu.editingshoppinglist].groupstates = menu.objectgroup.states
		else
			menu.shoppinglist[menu.editingshoppinglist].object = menu.object
		end
		menu.shoppinglist[menu.editingshoppinglist].macro = menu.macro
		menu.shoppinglist[menu.editingshoppinglist].hasupgrades = hasupgrades
		menu.shoppinglist[menu.editingshoppinglist].upgradeplan = menu.upgradeplan
		menu.shoppinglist[menu.editingshoppinglist].settings = menu.settings
		menu.shoppinglist[menu.editingshoppinglist].crew = menu.crew
		menu.shoppinglist[menu.editingshoppinglist].price = menu.total
		menu.shoppinglist[menu.editingshoppinglist].crewprice = menu.crewtotal
		menu.shoppinglist[menu.editingshoppinglist].duration = menu.duration
		menu.shoppinglist[menu.editingshoppinglist].warnings = menu.warnings
		menu.shoppinglist[menu.editingshoppinglist].customshipname = menu.customshipname
		menu.shoppinglist[menu.editingshoppinglist].loadoutName = menu.loadoutName
		menu.shoppinglist[menu.editingshoppinglist].paintmodware = menu.selectedPaintMod and menu.selectedPaintMod.ware or nil
	end

	menu.object = 0
	menu.objectgroup = nil
	menu.damagedcomponents = {}
	menu.macro = ""
	menu.customshipname = nil
	menu.loadoutName = ""
	menu.selectedPaintMod = nil
	menu.editingshoppinglist = nil
	menu.clearUndoStack()
	menu.getDataAndDisplay()
end

function menu.buttonEditPurchase(idx)
	menu.closeContextMenu()

	local entry = menu.shoppinglist[idx]
	menu.editingshoppinglist = idx
	if entry.objectgroup then
		menu.objectgroup = menu.shipgroups[entry.objectgroup]
		menu.object = menu.objectgroup.ships[1].ship
	else
		menu.objectgroup = nil
		menu.object = entry.object
	end
	if (menu.mode == "upgrade") or (menu.mode == "modify") then
		menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
	end
	menu.macro = entry.macro
	if menu.object ~= 0 then
		menu.class = ffi.string(C.GetComponentClass(menu.object))
	elseif menu.macro ~= "" then
		menu.class = ffi.string(C.GetMacroClass(menu.macro))
	end
	menu.customshipname = entry.customshipname
	menu.loadoutName = entry.loadoutName
	if entry.paintmodware then
		local found = false
		for _, modwares in pairs(menu.modwares) do
			for _, modentry in ipairs(modwares) do
				if modentry.ware == entry.paintmodware then
					menu.selectedPaintMod = modentry
					found = true
					break
				end
			end
			if found then
				break
			end
		end
	end
	menu.captainSelected = true
	menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, (menu.object ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro") or menu.macro)
	menu.clearUndoStack()
	menu.getDataAndDisplay(entry.upgradeplan, entry.crew, true, true, nil, entry.settings)
end

function menu.buttonRemovePurchase(idx)
	table.remove(menu.shoppinglist, idx)
	menu.refreshMenu()
end

function menu.buttonLeftBar(mode, row, overrideMode, overrideSlot)
	local isreopencontextframe, contextmodemode, contextmodewidth, contextmodex, contextmodey
	if menu.contextMode then
		if menu.contextMode.mode == "equipmentfilter" then
			if menu.upgradetypeMode ~= "crew" and menu.upgradetypeMode ~= "repair" and menu.upgradetypeMode ~= "settings" then
				isreopencontextframe = true
			end
		end
		if isreopencontextframe then
			contextmodemode = menu.contextMode.mode
			contextmodewidth = menu.contextMode.width
			contextmodex = menu.contextMode.x
			contextmodey = menu.contextMode.y
		end
	end
	menu.closeContextMenu()

	menu.prevUpgradetypeMode = menu.upgradetypeMode
	if (overrideMode ~= nil) and (menu.upgradetypeMode == overrideMode) and (menu.currentSlot == overrideSlot) then
		menu.upgradetypeMode = nil
	else
		AddUITriggeredEvent(menu.name, mode, menu.upgradetypeMode == mode and "off" or "on")
		if menu.upgradetypeMode == mode then
			PlaySound("ui_negative_back")
			menu.upgradetypeMode = nil
		else
			menu.setdefaulttable = true
			PlaySound("ui_positive_select")
			menu.upgradetypeMode = overrideMode or mode
		end
	end
	menu.currentSlot = overrideSlot or 1

	if menu.upgradetypeMode then
		menu.selectMapMacroSlot()
	else
		C.ClearSelectedMapMacroSlots(menu.holomap)
	end

	menu.displayMenu(true)
	if isreopencontextframe then
		if contextmodemode == "equipmentfilter" then
			contextmodey = menu.equipmentfilter_races_y
		end
		menu.displayContextFrame(contextmodemode, contextmodewidth, contextmodex, contextmodey, true)
	end
end

function menu.deactivateUpgradeMode()
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	PlaySound("ui_negative_back")
	menu.upgradetypeMode = nil
	menu.currentSlot = 1
	C.ClearSelectedMapMacroSlots(menu.holomap)
	menu.displayMenu()
end

function menu.buttonModCategory(category, row, col)
	if category ~= menu.modCategory then
		menu.modCategory = category

		menu.topRows.slots = GetTopRow(menu.slottable)
		menu.displayMenu()
	end
end

function menu.getModQuality(category)
	for i, entry in ipairs(Helper.modQualities) do
		if entry.category == category then
			return i
		end
	end
end

function menu.buttonResetCrew()
	menu.crew.fired = {}
	menu.crew.hired = 0
	menu.crew.hireddetails = {}
	menu.crew.transferdetails = {}
	menu.crew.unassigned = {}
	for i, entry in ipairs(menu.crew.roles) do
		menu.crew.roles[i].wanted = entry.total
		for j, tier in ipairs(entry.tiers) do
			for _, npc in ipairs(menu.crew.roles[i].tiers[j].npcs) do
				table.insert(menu.crew.roles[i].tiers[j].currentnpcs, npc)
			end
			menu.crew.roles[i].tiers[j].wanted = tier.total
		end
	end

	menu.addUndoStep()

	menu.refreshMenu()
end

function menu.buttonFireCrew()
	for _, entry in ipairs(menu.crew.unassigned) do
		table.insert(menu.crew.fired, { npc = entry.npc, price = menu.crew.price })
	end
	menu.crew.unassigned = {}

	menu.addUndoStep()

	menu.refreshMenu()
end

function menu.buttonClearCustomShipName()
	menu.customshipname = ""
	if menu.customShipNameEditBox then
		C.SetEditBoxText(menu.customShipNameEditBox.id, menu.customshipname)
	end
	menu.refreshMenu()
end

function menu.buttonCustomShipNameAppendShip(name)
	if menu.customshipname == "" then
		menu.customshipname = name
	else
		if utf8.sub(menu.customshipname, -1) ~= " " then
			menu.customshipname = menu.customshipname .. " "
		end
		menu.customshipname = menu.customshipname .. name
	end

	if menu.customShipNameEditBox then
		C.SetEditBoxText(menu.customShipNameEditBox.id, menu.customshipname)
	end
	menu.refreshMenu()
end

function menu.buttonCustomShipNameAppendLoadout()
	if menu.customshipname == "" then
		menu.customshipname = menu.loadoutName
	else
		if utf8.sub(menu.customshipname, -1) ~= " " then
			menu.customshipname = menu.customshipname .. " "
		end
		menu.customshipname = menu.customshipname .. menu.loadoutName
	end

	if menu.customShipNameEditBox then
		C.SetEditBoxText(menu.customShipNameEditBox.id, menu.customshipname)
	end
	menu.refreshMenu()
end

-- editbox scripts
function menu.editboxSearchUpdateText(_, text, textchanged)
	if textchanged then
		table.insert(menu.equipmentsearchtext, { text = text })
	end

	menu.refreshMenu()
end

function menu.editboxLoadoutNameUpdateText(_, text)
	menu.loadoutName = text
	menu.setCustomShipName()
	menu.loadout = nil
end

function menu.editboxCustomShipName(_, text)
	menu.customshipname = text
end

function menu.editboxCustomShipNameDeactivated(_, text, textchanged)
	menu.refreshMenu()
end

-- Menu member functions

function menu.hotkey(action)
	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_UNDO" then
		menu.undoHelper(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REDO" then
		menu.undoHelper(false)
	end
end

function menu.undoHelper(undo)
	if undo then
		menu.undoIndex = math.min(#menu.undoStack, menu.undoIndex + 1)
	else
		menu.undoIndex = math.max(1, menu.undoIndex - 1)
	end
	menu.captainSelected = menu.undoStack[menu.undoIndex].captainSelected
	menu.repairplan = Helper.tableCopy(menu.undoStack[menu.undoIndex].repairplan, 3)
	menu.getDataAndDisplay(menu.undoStack[menu.undoIndex].upgradeplan, menu.undoStack[menu.undoIndex].crew, nil, nil, true)
end

function menu.addUndoStep(upgradeplan, crew)
	-- making a new branch, remove current redos
	for i = menu.undoIndex - 1, 1, -1 do
		table.remove(menu.undoStack, i)
	end
	-- add current data
	menu.undoIndex = 1
	table.insert(menu.undoStack, 1, { upgradeplan = Helper.tableCopy(upgradeplan or menu.upgradeplan, 3), crew = Helper.tableCopy(crew or menu.crew, 3), captainSelected = menu.captainSelected, repairplan = Helper.tableCopy(menu.repairplan, 3) })
	-- check for stack limit
	while #menu.undoStack > config.undoSteps do
		table.remove(menu.undoStack)
	end
end

function menu.clearUndoStack()
	menu.undoIndex = 1
	menu.undoStack = {}
end

function menu.refreshMenu()
	if not menu.topRows.slots then
		menu.topRows.slots = GetTopRow(menu.slottable)
	end
	if not menu.selectedRows.slots then
		menu.selectedRows.slots = Helper.currentTableRow[menu.slottable]
	end

	menu.displayMenu()
end

function menu.findUpgradeMacro(loctype, macro)
	if type(menu.upgradewares[loctype]) == "table" then
		for i, upgradeware in ipairs(menu.upgradewares[loctype]) do
			if upgradeware.macro == macro then
				return i
			end
		end
	end
end

function menu.determineInitialSlot()
	menu.currentSlot = 1
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		local curslotsizepriority
		for i, group in ipairs(menu.groups) do
			if (menu.upgradetypeMode == "enginegroup") == (group["engine"].total > 0) then
				if group.slotsize and (group.slotsize ~= "") then
					local sizeorder = Helper.slotSizeOrder[group.slotsize] or 0
					if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
						curslotsizepriority = sizeorder
						menu.currentSlot = i
					end
				end
			end
		end
	end
end

function menu.onShowMenu(state)
	menu.damagedcomponents = {}

	-- layout
	menu.scaleSize = Helper.scaleX(config.scaleSize)
	menu.frameworkData = {
		sidebarWidth = Helper.scaleX(Helper.sidebarWidth),
		offsetX = Helper.frameBorder,
		offsetY = Helper.frameBorder + 20,
		scaleWidth = 3 * menu.scaleSize,
	}
	local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
	local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
	reservedSidePanelWidth = reservedSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize
	menu.slotData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetX = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + menu.frameworkData.offsetX + 3 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}
	menu.planData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}

	local reserverdCenterPanelWidth = Helper.viewWidth - 2 * menu.slotData.offsetX - 2 * reservedSidePanelWidth - 4 * Helper.borderSize
	local actualCenterPanelWidth = math.min(reserverdCenterPanelWidth, Helper.scaleX(config.maxCenterPanelWidth))
	menu.statsData = {
		width =  actualCenterPanelWidth,
		offsetX = menu.slotData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData = {
		width =  actualCenterPanelWidth,
		height = Helper.scaleY(40),
		offsetX = menu.slotData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData.dropdownWidth = math.floor((menu.titleData.width - 4 * (menu.titleData.height + Helper.borderSize) - 2 * Helper.borderSize) / 3)
	menu.planData.offsetX = Helper.viewWidth - actualSidePanelWidth - 2 * Helper.borderSize
	menu.mapData = {
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		offsetX = 0,
		offsetY = 0
	}
	menu.subHeaderRowHeight = Helper.scaleY(26)

	menu.headerTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = Color["row_background"],
		titleColor = Color["row_title"],
	}

	menu.headerWarningTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = Color["row_background"],
		color = function () return menu.warningColor(Color["text_warning"]) end,
		titleColor = Color["text_warning"],
		halign = "center",
	}

	menu.subHeaderTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		minRowHeight = menu.subHeaderRowHeight,
		scaling = false,
		cellBGColor = Color["row_background"],
		titleColor = Color["row_title"],
	}

	menu.subHeaderSliderCellTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		scaling = false,
	}

	-- parameters
	menu.mode = menu.param[4]
	if menu.param[3] == nil then
		if menu.mode == "upgrade" then
			menu.isReadOnly = true
		end
	else
		menu.container = ConvertIDTo64Bit(menu.param[3])
		menu.containerowner, menu.isplayerowned  = GetComponentData(menu.container, "owner", "isplayerowned")
	end
	menu.modeparam = {}
	if type(menu.param[5]) == "table" then
		if menu.mode == "modify" then
			if menu.param[5][1] == 1 then
				menu.modeparam[1] = true
				menu.modeparam[2] = {}
				for _, ship in pairs(menu.param[5][2]) do
					table.insert(menu.modeparam[2], ConvertIDTo64Bit(ship))
				end
			end
		elseif menu.mode == "customgamestart" then
			menu.modeparam = menu.param[5]
			menu.modeparam.gamestartid							= menu.modeparam[1]
			menu.modeparam.creative								= menu.modeparam[2] ~= 0
			menu.modeparam.shipproperty							= menu.modeparam[3]
			menu.modeparam.shiploadoutproperty					= menu.modeparam[4]
			menu.modeparam.shippeopleproperty					= menu.modeparam[5]
			menu.modeparam.shippeoplefillpercentageproperty		= menu.modeparam[6]
			menu.modeparam.shippilotproperty					= menu.modeparam[7]
			menu.modeparam.paintthemeproperty					= menu.modeparam[8]
			menu.modeparam.playerpropertyid						= menu.modeparam[9]
			menu.modeparam.propertymacro						= menu.modeparam[10]
			menu.modeparam.propertycommander					= menu.modeparam[11]
			menu.modeparam.propertypeopledef					= menu.modeparam[12]
			menu.modeparam.propertypeoplefillpercentage			= menu.modeparam[13]
			menu.modeparam.propertycount						= menu.modeparam[14] or 1
			if menu.modeparam[15] ~= 0 then
				menu.paused = true
				Pause()
			end
		elseif menu.mode == "comparison" then
			menu.modeparam = menu.param[5]
		else
			for _, ship in pairs(menu.param[5]) do
				table.insert(menu.modeparam, ConvertIDTo64Bit(ship))
			end
		end
	end
	menu.immediate = false
	if menu.param[6] then
		menu.immediate = menu.param[6]
	end
	menu.usemacro = nil
	if (menu.mode == "purchase") or (menu.mode == "customgamestart") or (menu.mode == "comparison") then
		menu.usemacro = true
	end

	if menu.mode == "modify" then
		--menu.frameworkData.offsetY = 2 * (menu.titleData.height + Helper.borderSize) + menu.slotData.offsetY
		menu.titleData.dropdownWidth = math.floor((menu.titleData.width - 3 * (menu.titleData.height + Helper.borderSize) - Helper.borderSize) / 2)
	end

	-- prepare ships
	menu.usedLimitedMacros = {}
	if menu.mode == "purchase" then
		menu.availableshipmacros = {}
		local n = C.GetNumContainerBuilderMacros(menu.container)
		if n > 0 then
			local buf = ffi.new("const char*[?]", n)
			n = C.GetContainerBuilderMacros(buf, n, menu.container)
			for i = 0, n - 1 do
				table.insert(menu.availableshipmacros, ffi.string(buf[i]))
			end
		end

		menu.object = 0
		if not menu.macro then
			menu.macro = ""
		end
		menu.customshipname = nil
		menu.loadoutName = ""
		menu.class = ""

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end

		local n = C.GetNumUsedLimitedShips()
		if n > 0 then
			local buf = ffi.new("UIMacroCount[?]", n)
			n = C.GetUsedLimitedShips(buf, n)
			for i = 0, n - 1 do
				local macro = ffi.string(buf[i].macro)
				menu.usedLimitedMacros[macro] = buf[i].amount
			end
		end
	elseif menu.mode == "upgrade" then
		menu.selectableships = {}
		if #menu.modeparam > 0 then
			for _, ship in pairs(menu.modeparam) do
				--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to list of ships.")
				table.insert(menu.selectableships, ffi.new("UniverseID", ConvertStringTo64Bit(ship)))
			end
		elseif not menu.isReadOnly then
			Helper.ffiVLA(menu.selectableships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.container, "player")
		end

		for i = #menu.selectableships, 1, -1 do
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.selectableships[i], hasloop)

			if (not menu.isReadOnly) and (not C.CanContainerEquipShip(menu.container, menu.selectableships[i])) and (not C.CanContainerSupplyShip(menu.container, menu.selectableships[i])) then
				table.remove(menu.selectableships, i)
			elseif ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
				table.remove(menu.selectableships, i)
			elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
				menu.object = menu.selectableships[i]
			elseif (not menu.isReadOnly) and hasloop[0] then
				-- loops on player occupied ship is allowed, so do this check after the player occupied check
				table.remove(menu.selectableships, i)
			end
		end
		for i, ship in ipairs(menu.selectableships) do
			local name = ffi.string(C.GetComponentName(ship))
			local idcode = ffi.string(C.GetObjectIDCode(ship))
			local class = ffi.string(C.GetComponentClass(ship))
			local primarypurpose, icon, macro, hasanymod = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "primarypurpose", "icon", "macro", "hasanymod")
			menu.selectableships[i] = { ship = ship, icon = icon, name = name, objectid = idcode, class = class, purpose = primarypurpose, macro = macro, hasanymod = hasanymod }
		end
		table.sort(menu.selectableships, Helper.sortShipsByClassAndPurpose)

		if not menu.object then
			menu.object = menu.selectableships[1] and menu.selectableships[1].ship
		end
		menu.macro = ""
		menu.customshipname = nil
		menu.loadoutName = ""

		menu.class = ""
		menu.repairplan = {}
		if menu.object then
			menu.class = ffi.string(C.GetComponentClass(menu.object))
			menu.damagedcomponents = menu.determineNeededRepairs(menu.object)
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

			local aipilot = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "assignedaipilot")
			if aipilot then
				menu.captainSelected = true
			else
				menu.captainSelected = false
			end
		else
			menu.object = 0
		end

		menu.shipgroups = {}
		for _, ship in ipairs(menu.selectableships) do
			local hastask = false
			local n = C.GetNumOrders(ship.ship)
			local buf = ffi.new("Order[?]", n)
			n = C.GetOrders(buf, n, ship.ship)
			for i = 0, n - 1 do
				if ffi.string(buf[i].orderdef) == "Equip" then
					local params = GetOrderParams(ConvertStringTo64Bit(tostring(ship.ship)), tonumber(buf[i].queueidx))
					hastask = params[1].value
					break
				elseif ffi.string(buf[i].orderdef) == "Repair" then
					hastask = true
					break
				end
			end

			if (not ship.hasanymod) and (not hastask) then
				local i = menu.findMacroIdx(menu.shipgroups, ship.macro)
				if i then
					table.insert(menu.shipgroups[i].ships, ship)
				else
					table.insert(menu.shipgroups, { idx = #menu.shipgroups + 1, macro = ship.macro, ships = { ship }, shipdata = {}, states = {} })
				end
			else
				table.insert(menu.shipgroups, { ship = ship })
			end
		end

		menu.selectableshipsbyclass = {}
		for i, entry in ipairs(menu.shipgroups) do
			if entry.ships then
				if #entry.ships > 1 then
					local groupentry = { group = i }
					if menu.selectableshipsbyclass[entry.ships[1].class] then
						table.insert(menu.selectableshipsbyclass[entry.ships[1].class], groupentry)
					else
						menu.selectableshipsbyclass[entry.ships[1].class] = { groupentry }
					end
				end
				for _, ship in ipairs(entry.ships) do
					local shipentry = { ship = ship, grouped = #entry.ships > 1, groupidx = i }
					if menu.selectableshipsbyclass[ship.class] then
						table.insert(menu.selectableshipsbyclass[ship.class], shipentry)
					else
						menu.selectableshipsbyclass[ship.class] = { shipentry }
					end
				end
			else
				if menu.selectableshipsbyclass[entry.ship.class] then
					table.insert(menu.selectableshipsbyclass[entry.ship.class], entry.ship)
				else
					menu.selectableshipsbyclass[entry.ship.class] = { entry.ship }
				end
			end
		end

		menu.prepareModWares()
	elseif menu.mode == "modify" then
		menu.selectableships = {}
		if menu.modeparam[1] then
			for _, ship in pairs(menu.modeparam[2]) do
				--print("adding " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to list of ships.")
				table.insert(menu.selectableships, ship)
			end
			for i = #menu.selectableships, 1, -1 do
				if ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
					table.remove(menu.selectableships, i)
				elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
					menu.object = menu.selectableships[i]
				end
			end
		else
			Helper.ffiVLA(menu.selectableships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.container, "player")
			for i = #menu.selectableships, 1, -1 do
				if not C.CanContainerEquipShip(menu.container, menu.selectableships[i]) then
					table.remove(menu.selectableships, i)
				elseif ffi.string(C.GetOwnerDetails(menu.selectableships[i]).factionID) ~= "player" then
					table.remove(menu.selectableships, i)
				elseif menu.selectableships[i] == C.GetPlayerOccupiedShipID() then
					menu.object = menu.selectableships[i]
				end
			end
		end

		table.sort(menu.selectableships, Helper.sortUniverseIDName)

		if not menu.object then
			menu.object = menu.selectableships[1]
		end
		menu.macro = ""

		menu.class = ""
		if menu.object then
			menu.class = ffi.string(C.GetComponentClass(menu.object))
			menu.validLoadoutPossible = (not menu.isReadOnly) and menu.container and C.CanGenerateValidLoadout(menu.container, GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))

			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
			menu.initialLoadoutStatistics = Helper.convertLoadoutStats(fficurrentloadoutstats)
		else
			menu.object = 0
		end

		menu.selectableshipsbyclass = {}
		for _, ship in ipairs(menu.selectableships) do
			local class = ffi.string(C.GetComponentClass(ship))
			if menu.selectableshipsbyclass[class] then
				table.insert(menu.selectableshipsbyclass[class], ship)
			else
				menu.selectableshipsbyclass[class] = { ship }
			end
		end

		menu.prepareModWares()
	elseif menu.mode == "customgamestart" then
		menu.object = 0
		local options = ""
		if menu.modeparam.playerpropertyid then
			menu.macro = menu.modeparam.propertymacro or ""
			menu.customgamestartpeopledef = menu.modeparam.propertypeopledef or ""
			menu.customgamestartpeoplefillpercentage = menu.modeparam.propertypeoplefillpercentage or 100
			if menu.customgamestartpeoplefillpercentage == -1 then
				menu.customgamestartpeoplefillpercentage = 100
			end

			menu.customgamestartpilot = {}
			if menu.macro ~= "" then
				local buf = ffi.new("CustomGameStartPersonEntry[1]")
				buf[0].numskills = C.GetNumSkills()
				buf[0].skills = Helper.ffiNewHelper("SkillInfo[?]", buf[0].numskills)
				if C.GetCustomGameStartPlayerPropertyPerson(buf, menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid) then
					menu.customgamestartpilot.race = ffi.string(buf[0].race)
					menu.customgamestartpilot.tags = ffi.string(buf[0].tags)
					menu.customgamestartpilot.skills = {}
					for i = 0, buf[0].numskills - 1 do
						local skill = ffi.string(buf[0].skills[i].id)
						menu.customgamestartpilot.skills[skill] = buf[0].skills[i].value
					end
				end
			end
		else
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			menu.macro = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shipproperty, buf))
			options = ffi.string(buf[0].options)
			menu.customgamestartpeopledef = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.shippeopleproperty, buf))
			local buf = ffi.new("CustomGameStartFloatPropertyState[1]")
			menu.customgamestartpeoplefillpercentage = tonumber(C.GetCustomGameStartFloatProperty(menu.modeparam.gamestartid, menu.modeparam.shippeoplefillpercentageproperty, buf))
			if menu.customgamestartpeoplefillpercentage == -1 then
				menu.customgamestartpeoplefillpercentage = 100
			end

			menu.customgamestartpilot = {}
			if menu.modeparam.shippilotproperty then
				local buf = ffi.new("CustomGameStartPersonEntry[1]")
				buf[0].numskills = C.GetNumSkills()
				buf[0].skills = Helper.ffiNewHelper("SkillInfo[?]", buf[0].numskills)
				if C.GetCustomGameStartShipPilot(buf, menu.modeparam.gamestartid, menu.modeparam.shippilotproperty) then
					menu.customgamestartpilot.race = ffi.string(buf[0].race)
					menu.customgamestartpilot.tags = ffi.string(buf[0].tags)
					menu.customgamestartpilot.skills = {}
					for i = 0, buf[0].numskills - 1 do
						local skill = ffi.string(buf[0].skills[i].id)
						menu.customgamestartpilot.skills[skill] = buf[0].skills[i].value
					end
				end
			end
		end
		menu.class = (menu.macro ~= "") and ffi.string(C.GetMacroClass(menu.macro)) or ""

		menu.availableshipmacros = {}
		if options ~= "" then
			for macro in string.gmatch(options, "[%a_]+") do
				table.insert(menu.availableshipmacros, macro)
			end
		else
			local n = C.GetNumAllShipMacros2(not menu.allownonplayerblueprints, not menu.modeparam.creative)
			if n > 0 then
				local buf = ffi.new("const char*[?]", n)
				n = C.GetAllShipMacros2(buf, n, not menu.allownonplayerblueprints, not menu.modeparam.creative)
				for i = 0, n - 1 do
					table.insert(menu.availableshipmacros, ffi.string(buf[i]))
				end
			end
		end

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end

		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local playershipmacro = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, "ship", buf))
		local ware = GetMacroData(playershipmacro, "ware")
		local islimited = GetWareData(ware, "islimited")
		if islimited then
			menu.usedLimitedMacros[playershipmacro] = (menu.usedLimitedMacros[playershipmacro] or 0) + 1
		end

		local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.modeparam.gamestartid, "playerproperty")
		if state.numvalues > 0 then
			local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
			local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.modeparam.gamestartid, "playerproperty")
			if n > 0 then
				local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
				for i = 0, n - 1 do
					buf[i].numcargo = counts[i].numcargo
					buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
				end
				n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.modeparam.gamestartid, "playerproperty")
				for i = 0, n - 1 do
					local type = ffi.string(buf[i].type)
					if type == "ship" then
						local macro = ffi.string(buf[i].macroname)
						local ware = GetMacroData(macro, "ware")
						local islimited = GetWareData(ware, "islimited")
						if islimited then
							menu.usedLimitedMacros[macro] = (menu.usedLimitedMacros[macro] or 0) + buf[i].count
						end
					end
				end
			end
		end
		if (menu.macro ~= "") and menu.usedLimitedMacros[menu.macro] then
			menu.usedLimitedMacros[menu.macro] = math.max(0, menu.usedLimitedMacros[menu.macro] - menu.modeparam.propertycount)
		end
	elseif menu.mode == "comparison" then
		menu.object = 0
		menu.macro = Helper.getShipComparisonMacro(menu.modeparam[1]) or ""
		menu.class = ffi.string(C.GetMacroClass(menu.macro))

		menu.availableshipmacros = {}
		for _, library in ipairs(config.comparisonShipLibraries) do
			local data = GetLibrary(library)
			for _, entry in ipairs(data) do
				table.insert(menu.availableshipmacros, entry.id)
			end
		end

		menu.availableshipmacrosbyclass = {}
		for _, macro in ipairs(menu.availableshipmacros) do
			local class = ffi.string(C.GetMacroClass(macro))
			if menu.availableshipmacrosbyclass[class] then
				table.insert(menu.availableshipmacrosbyclass[class], macro)
			else
				menu.availableshipmacrosbyclass[class] = { macro }
			end
		end
	end

	menu.hasDefaultLoadout = false
	menu.defaultLoadoutMacros = {}
	if (menu.object ~= 0) or (menu.macro ~= "") then
		local macro
		if menu.macro ~= "" then
			macro = menu.macro
		else
			macro = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
		end
		menu.hasDefaultLoadout = C.HasDefaultLoadout2(macro, true)
		if menu.hasDefaultLoadout then
			local n = C.GetNumDefaultLoadoutMacros(macro)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetDefaultLoadoutMacros(buf, n, macro)
			for i = 0, n - 1 do
				menu.defaultLoadoutMacros[ffi.string(buf[i])] = true
			end
		end
	end

	menu.equipmentsearchtext = {}
	menu.loadoutName = ""
	if (menu.mode == "purchase") or (menu.mode == "upgrade") or (menu.mode == "customgamestart") or (menu.mode == "comparison") then
		menu.upgradetypeMode = "engine"
	elseif menu.mode == "modify" then
		menu.upgradetypeMode = "shipmods"
	end
	menu.loadouts = {}

	menu.modCategory = "basic"

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	local upgradeplan, crew
	if state then
		upgradeplan, crew = menu.onRestoreState(state)
	elseif menu.mode == "customgamestart" then
		menu.software = {}
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "software" then
				menu.software[upgradetype.type] = {}
				if menu.macro ~= "" then
					local n = C.GetNumSoftwareSlots(0, menu.macro)
					local buf = ffi.new("SoftwareSlot[?]", n)
					n = C.GetSoftwareSlots(buf, n, 0, menu.macro)
					for j = 0, n - 1 do
						local entry = {}
						entry.maxsoftware = ffi.string(buf[j].max)
						entry.currentsoftware = ffi.string(buf[j].current)
						table.insert(menu.software[upgradetype.type], entry)
					end
				end
			end
		end

		if menu.modeparam.playerpropertyid then
			if menu.macro ~= "" then
				local loadout = Helper.getLoadoutHelper2(C.GetCustomGameStartPlayerPropertyLoadout, C.GetCustomGameStartPlayerPropertyLoadoutCounts, "UILoadout2", menu.modeparam.gamestartid, menu.modeparam.shipproperty, menu.modeparam.playerpropertyid)
				upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
			end
		else
			local loadout = Helper.getLoadoutHelper2(C.GetCustomGameStartLoadoutProperty2, C.GetCustomGameStartLoadoutPropertyCounts2, "UILoadout2", menu.modeparam.gamestartid, menu.modeparam.shiploadoutproperty)
			upgradeplan = Helper.convertLoadout(menu.object, menu.macro, loadout, menu.software, "UILoadout2")
		end
	elseif menu.mode == "comparison" then
		if menu.macro ~= "" then
			menu.software = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				if upgradetype.supertype == "software" then
					menu.software[upgradetype.type] = {}
					local n = C.GetNumSoftwareSlots(0, menu.macro)
					local buf = ffi.new("SoftwareSlot[?]", n)
					n = C.GetSoftwareSlots(buf, n, 0, menu.macro)
					for j = 0, n - 1 do
						local entry = {}
						entry.maxsoftware = ffi.string(buf[j].max)
						entry.currentsoftware = ffi.string(buf[j].current)
						table.insert(menu.software[upgradetype.type], entry)
					end
				end
			end

			upgradeplan = Helper.getShipComparisonUpgradeplan(menu.modeparam[1])
		end
	end

	if menu.container then
		menu.moddingdiscounts = GetComponentData(menu.container, "moddingdiscounts")
		menu.moddingdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.moddingdiscounts) do
			menu.moddingdiscounts.totalfactor = menu.moddingdiscounts.totalfactor - entry.amount / 100
		end

		menu.repairdiscounts = GetComponentData(menu.container, "repairdiscounts")
		menu.repairdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.repairdiscounts) do
			menu.repairdiscounts.totalfactor = menu.repairdiscounts.totalfactor - entry.amount / 100
		end

		menu.hiringdiscounts = GetComponentData(menu.container, "hiringdiscounts")
		menu.hiringdiscounts.totalfactor = 1
		for _, entry in ipairs(menu.hiringdiscounts) do
			menu.hiringdiscounts.totalfactor = menu.hiringdiscounts.totalfactor - entry.amount / 100
		end
	else
		menu.moddingdiscounts = { totalfactor = 1 }
		menu.repairdiscounts  = { totalfactor = 1 }
		menu.hiringdiscounts  = { totalfactor = 1 }
	end

	menu.displayMainFrame()

	AddUITriggeredEvent(menu.name, menu.upgradetypeMode)

	menu.getDataAndDisplay(upgradeplan, crew, nil, true)

	if not menu.bindingRegistered then
		menu.bindingRegistered = true
		RegisterAddonBindings("ego_detailmonitor", "undo")
		Helper.setKeyBinding(menu, menu.hotkey)
	end
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_ship_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.displayMainFrame()
	Helper.removeAllWidgetScripts(menu, config.mainLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainLayer,
		standardButtons = { back = true, close = menu.mode ~= "customgamestart" },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- construction map
	menu.mainFrame:addRenderTarget({width = menu.mapData.width, height = menu.mapData.height, x = menu.mapData.offsetX, y = menu.mapData.offsetY, scaling = false, alpha = 100})

	menu.mainFrame:display()
end

function menu.displayLeftBar(frame)
	local leftBar = config.leftBar
	if menu.mode == "modify" then
		leftBar = config.leftBarMods
	end
	local spacingHeight = menu.frameworkData.sidebarWidth / 4
	local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)

	local ftable = frame:addTable(2, { tabOrder = 2, width = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + Helper.borderSize, height = 0, x = menu.frameworkData.offsetX, y = menu.slotData.offsetY + menu.titleData.height + 2 * Helper.borderSize + maxSlotWidth, scaling = false, reserveScrollBar = false })
	if (menu.upgradetypeMode == nil) and menu.setdefaulttable then
		ftable.properties.defaultInteractiveObject = true
		menu.setdefaulttable = nil
	end
	ftable:setColWidth(1, menu.frameworkData.scaleWidth)

	-- Fallback if nothing is selected yet, so if it is a shipyard show the groups, if not do not (so this condition can change when looking at a equipment dock)
	local iscapship = menu.container and GetComponentData(menu.container, "isshipyard") or false
	-- If we have an object or a macro use its size information
	if menu.object ~= 0 then
		iscapship = C.IsComponentClass(menu.object, "ship_l") or C.IsComponentClass(menu.object, "ship_xl")
	elseif menu.macro ~= "" then
		iscapship = IsMacroClass(menu.macro, "ship_l") or IsMacroClass(menu.macro, "ship_xl")
	end

	local found = true
	for _, entry in ipairs(leftBar) do
		local condition = true
		if condition and (entry.iscapship ~= nil) then
			condition = entry.iscapship == iscapship
		end
		if condition and (entry.customgamestart ~= nil) then
			condition = entry.customgamestart == (menu.mode == "customgamestart")
		end
		if condition and (entry.comparison ~= nil) then
			condition = entry.comparison == (menu.mode == "comparison")
		end
		if condition and (entry.hascontainer ~= nil) then
			condition = entry.hascontainer == (menu.container ~= nil)
		end

		if condition then
			if entry.spacing then
				local row = ftable:addRow(false, { fixed = true })
				row[1]:setColSpan(2):createIcon("mapst_seperator_line", { width = menu.frameworkData.sidebarWidth + menu.frameworkData.scaleWidth + Helper.borderSize, height = spacingHeight })
			else
				local active, skip = false, false
				local selected = entry.mode == menu.upgradetypeMode
				local prevSelected = entry.mode == menu.prevUpgradetypeMode
				local missing = false
				local overrideMode, overrideSlot
				local count, total = 0, 0
				local canequip = true
				if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
					canequip = C.CanContainerEquipShip(menu.container, menu.object)
				end
				local mouseovertext

				local upgradetype = Helper.findUpgradeType(entry.mode)

				if menu.mode == "modify" then
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)
					if entry.upgrademode == "paint" then
						active = true
					elseif (entry.upgrademode == "ship") or (menu.slots[entry.upgrademode] and ((menu.slots[entry.upgrademode].count > 0) or (#menu.slots[entry.upgrademode] > 0))) then
						active = not menu.modeparam[1]
						if ((entry.upgrademode == "turret") and next(menu.groups)) or (entry.upgrademode == "shield") then
							active = active and (#menu.shieldgroups > 0)
							if #menu.shieldgroups == 0 then
								mouseovertext = ColorText["text_negative"] .. ReadText(1001, 4808) .. "\27X"
							end
						elseif menu.slots[entry.upgrademode] and (menu.slots[entry.upgrademode].count > 0) then
							local found = false
							for _, slot in ipairs(menu.slots[entry.upgrademode]) do
								if slot.currentmacro ~= "" then
									found = true
									break
								end
							end
							active = active and found
							if not found then
								mouseovertext = ColorText["text_negative"] .. ReadText(1001, 4808) .. "\27X"
							end
						end
					else
						mouseovertext = ColorText["text_error"] .. ReadText(1001, 39) .. "\27X"
					end
				elseif entry.mode == "repair" then
					if menu.objectgroup then
						for i, ship in ipairs(menu.objectgroup.ships) do
							if #menu.objectgroup.shipdata[i].damagedcomponents > 0 then
								active = true
								total = total + #menu.objectgroup.shipdata[i].damagedcomponents
								if menu.repairplan and menu.repairplan[tostring(ship.ship)] then
									for componentidstring in pairs(menu.repairplan[tostring(ship.ship)]) do
										count = count + 1
									end
								end
							end
						end
					else
						if #menu.damagedcomponents > 0 then
							active = true
							total = #menu.damagedcomponents
							if menu.repairplan and menu.repairplan[tostring(menu.object)] then
								for componentidstring in pairs(menu.repairplan[tostring(menu.object)]) do
									count = count + 1
								end
							end
						end
					end
				elseif entry.mode == "settings" then
					if (menu.object ~= 0) or (menu.macro ~= "") then
						active = true
					end
				elseif (entry.mode == "enginegroup") or (entry.mode == "turretgroup") then
					skip = not canequip
					if next(menu.groups) then
						active = true
						local curslotsizepriority
						for slot, groupdata in pairs(menu.groups) do
							if groupdata[upgradetype.grouptype] and (groupdata[upgradetype.grouptype].total > 0) then
								if groupdata.slotsize and (groupdata.slotsize ~= "") then
									local sizeorder = Helper.slotSizeOrder[groupdata.slotsize] or 0
									if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
										curslotsizepriority = sizeorder
										overrideSlot = slot
									end
								end
							end
						end
						for _, upgradetype in ipairs(Helper.upgradetypes) do
							if upgradetype.supertype == "group" then
								for slot, group in pairs(menu.upgradeplan[upgradetype.type]) do
									if (entry.mode == "enginegroup") == (menu.groups[slot]["engine"].total > 0) then
										if (menu.groups[slot][upgradetype.grouptype].total > 0) then
											if upgradetype.mergeslots then
												count = count + ((menu.upgradeplan[upgradetype.type][slot].count > 0) and 1 or 0)
												total = total + 1
											else
												count = count + menu.upgradeplan[upgradetype.type][slot].count
												total = total + menu.groups[slot][upgradetype.grouptype].total
											end
										end
									end
								end
							end
						end
					end
					for _, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if upgradetype.allowempty == false then
								if ((upgradetype.grouptype == "engine") and (entry.mode == "enginegroup")) or ((upgradetype.grouptype == "turret") and (entry.mode == "turretgroup")) or ((upgradetype.grouptype ~= "engine") and (upgradetype.grouptype ~= "turret")) then
									for slot, group in pairs(menu.upgradeplan[upgradetype.type]) do
										if (group.macro == "") and (menu.groups[slot][upgradetype.grouptype].total > 0) then
											missing = true
											break
										end
									end
								end
							end
						end
					end
				elseif entry.mode == "software" then
					if menu.software[entry.mode] and (#menu.software[entry.mode] > 0) then
						active = true
						total = #menu.software[entry.mode]
						for slot, ware in ipairs(menu.upgradeplan[entry.mode]) do
							if ware ~= "" then
								count = count + 1
							end
						end
						for slot, slotdata in ipairs(menu.software[upgradetype.type]) do
							if #slotdata.possiblesoftware > 0 then
								if (slotdata.defaultsoftware ~= 0) and (menu.upgradeplan[upgradetype.type][slot] == "") then
									missing = true
									break
								end
							end
						end
					end
				elseif entry.mode == "consumables" then
					for _, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "ammo" then
							if next(menu.ammo[upgradetype.type]) then
								local ammocount, capacity = menu.getAmmoUsage(upgradetype.type)
								for macro, amount in pairs(menu.upgradeplan[upgradetype.type]) do
									if (ammocount > 0) or ((capacity > 0) and menu.isAmmoCompatible(upgradetype.type, macro)) then
										active = true
										count = count + ammocount
										total = total + capacity
										break
									end
								end

								if ((ammocount > 0) or (capacity > 0)) and active then
									if ammocount > capacity then
										missing = true
									end
								end
							end
						end
					end
				elseif entry.mode == "crew" then
					if (menu.object ~= 0) or (menu.macro ~= "") then
						active = menu.objectgroup == nil
						if menu.crew.capacity > 0 then
							if active then
								if menu.mode == "customgamestart" then
									count = ((menu.customgamestartpeopledef == "") and 0 or Helper.round(menu.crew.capacity * menu.customgamestartpeoplefillpercentage / 100)) + (menu.modeparam.playerpropertyid and 1 or 0)
									total = menu.crew.capacity + (menu.modeparam.playerpropertyid and 1 or 0)
								else
									count = menu.crew.total + menu.crew.hired - #menu.crew.fired + (menu.captainSelected and 1 or 0)
									total = menu.crew.capacity + 1
								end
							end
							if menu.usemacro and (not menu.captainSelected) then
								missing = true
							end
							if #menu.crew.unassigned > 0 then
								missing = true
							end
						else
							if active then
								if menu.mode == "customgamestart" then
									active = active and (menu.modeparam.playerpropertyid ~= nil)
									count = menu.modeparam.playerpropertyid and 1 or 0
									total = menu.modeparam.playerpropertyid and 1 or 0
								else
									count = menu.captainSelected and 1 or 0
									total = 1
								end
							end
							if menu.usemacro and (not menu.captainSelected) then
								missing = true
							end
						end
					end
				elseif entry.mode == "paintmods" then
					if (menu.object ~= 0) or (menu.macro ~= "") then
						active = true
					end
				elseif upgradetype and (upgradetype.supertype == "macro") then
					skip = not canequip
					if menu.slots[entry.mode] and (menu.slots[entry.mode].count > 0) then
						active = true
						total = menu.slots[entry.mode].count
						for slot, data in ipairs(menu.upgradeplan[entry.mode]) do
							if data.macro ~= "" then
								count = count + 1
							end
						end
						local curslotsizepriority
						for slot, slotdata in ipairs(menu.slots[entry.mode]) do
							if not slotdata.isgroup then
								if slotdata.slotsize and (slotdata.slotsize ~= "") then
									local sizeorder = Helper.slotSizeOrder[slotdata.slotsize] or 0
									if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
										curslotsizepriority = sizeorder
										overrideSlot = slot
									end
								end
							end
						end
					else
						-- override engine category to point to group with engines
						if upgradetype.type == "engine" then
							if next(menu.groups) then
								active = true
								overrideMode = "enginegroup"
								for slot, groupdata in pairs(menu.groups) do
									if groupdata[upgradetype.type].total > 0 then
										overrideSlot = slot
										break
									end
								end
							end
						end
					end
					for slot, data in pairs(menu.upgradeplan[upgradetype.type]) do
						if data.macro == "" then
							if (upgradetype.allowempty == false) or C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, slot) then
								missing = true
								break
							end
						end
					end
				else
					skip = not canequip
					if menu.slots[entry.mode] and (#menu.slots[entry.mode] > 0) then
						active = true
						total = #menu.slots[entry.mode]
						for slot, data in ipairs(menu.upgradeplan[entry.mode]) do
							if data.macro ~= "" then
								count = count + 1
							end
						end
					end
					if upgradetype.allowempty == false then
						for slot, data in pairs(menu.upgradeplan[upgradetype.type]) do
							if data.macro == "" then
								missing = true
								break
							end
						end
					end
				end

				if not skip then
					if menu.mode == "purchase" then
						active = active and (menu.validLicence == true)
					end

					-- if nothing selected yet, select this one if active
					if (not found) and active and (menu.upgradetypeMode ~= nil) then
						found = true
						selected = true
						menu.upgradetypeMode = entry.mode
						menu.selectMapMacroSlot()
					end

					-- if selected, but not active, select next active entry
					if selected and (not active) then
						found = false
						selected = false
					end

					local row = ftable:addRow(active, { fixed = true })
					if total > 0 then
						local height = math.floor((menu.frameworkData.sidebarWidth - 2 * menu.scaleSize) * math.min(count, total) / total)
						row[1]:createIcon("solid", { cellBGColor = active and Color["row_background_blue"] or Color["row_background_unselectable"], width = menu.scaleSize, height = height, x = menu.scaleSize, y = (menu.frameworkData.sidebarWidth - height - 2 * menu.scaleSize) / 2 })
					else
						row[1]:createText("", { cellBGColor = active and Color["row_background_blue"] or Color["row_background_unselectable"], x = 0, y = 0 })
					end

					if selected then
						menu.selectedRows.left = row.index
					elseif prevSelected then
						menu.selectedRows.left = row.index
					end
					if mouseovertext then
						mouseovertext = entry.name .. "\n" .. mouseovertext
					else
						mouseovertext = entry.name
					end
					row[2]:createButton({ active = active, height = menu.frameworkData.sidebarWidth, mouseOverText = mouseovertext, bgColor = selected and Color["row_background_selected"] or Color["button_background_default"], helpOverlayID = "shipconfig_leftbar_" .. entry.mode, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setIcon(entry.icon, { color = function () return menu.buttonLeftBarColor(entry.mode, active, missing) end })
					row[2].handlers.onClick = function () return menu.buttonLeftBar(entry.mode, row.index, overrideMode, overrideSlot) end
				elseif selected then
					found = false
				end
			end
		else
			if entry.mode == menu.upgradetypeMode then
				found = false
			end
		end
	end
	ftable:setTopRow(menu.topRows.left)
	ftable:setSelectedRow(menu.selectedRows.left)
	menu.topRows.left = nil
	menu.selectedRows.left = nil

	ftable:addConnection(1, 1, true)
end

function menu.buttonLeftBarColor(mode, active, missing)
	if active then
		if menu.mode ~= "modify" then
			if (mode == "enginegroup") or (mode == "turretgroup") then
				for _, upgradegroup in ipairs(menu.groups) do
					if (upgradegroup["engine"].total > 0) == (mode == "enginegroup") then
						for _, upgradetype2 in ipairs(Helper.upgradetypes) do
							if upgradetype2.supertype == "group" then
								menu.groupedupgrades[upgradetype2.grouptype] = {}
								for _, macro in ipairs(upgradegroup[upgradetype2.grouptype].possiblemacros) do
									if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(mode, macro, menu.equipmentsearchtext) then
										return missing and Color["icon_error"] or Color["icon_normal"]
									end
								end
							end
						end
					end
				end
			elseif mode == "software" then
				if menu.software[mode] then
					for slot, slotdata in ipairs(menu.software[mode]) do
						for i, software in ipairs(slotdata.possiblesoftware) do
							if i >= slotdata.defaultsoftware then
								if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(mode, software, menu.equipmentsearchtext) then
									return missing and Color["icon_error"] or Color["icon_normal"]
								end
							end
						end
					end
				end
			elseif mode == "consumables" then
				for _, upgradetype in ipairs(Helper.upgradetypes) do
					if upgradetype.supertype == "ammo" then
						if next(menu.ammo[upgradetype.type]) then
							local total, capacity = menu.getAmmoUsage(upgradetype.type)
							local display = false
							for macro, _ in pairs(menu.ammo[upgradetype.type]) do
								if (total > 0) or menu.isAmmoCompatible(upgradetype.type, macro) then
									display = true
									break
								end
							end

							if ((total > 0) or (capacity > 0)) and display then
								for macro in pairs(menu.ammo[upgradetype.type]) do
									if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(mode, macro, menu.equipmentsearchtext) then
										return missing and Color["icon_error"] or Color["icon_normal"]
									end
								end
							end
						end
					end
				end
			elseif (mode ~= "crew") and (mode ~= "repair") and (mode ~= "settings") and (mode ~= "paintmods") then
				local upgradetype = Helper.findUpgradeType(mode)
				if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					local slots = menu.slots[mode]
					for _, slot in ipairs(slots) do
						for _, macro in ipairs(slot.possiblemacros) do
							if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(mode, macro, menu.equipmentsearchtext) then
								return missing and Color["icon_error"] or Color["icon_normal"]
							end
						end
					end
				end
			end
		end
		return missing and Color["icon_error"] or Color["icon_normal"]
	end
	return missing and Color["icon_error_inactive"] or Color["icon_inactive"]
end

function menu.buttonSlotColor(slot, haserror)
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		local upgradegroup = menu.groups[slot]
		if upgradegroup then
			for _, upgradetype2 in ipairs(Helper.upgradetypes) do
				if upgradetype2.supertype == "group" then
					menu.groupedupgrades[upgradetype2.grouptype] = {}
					for _, macro in ipairs(upgradegroup[upgradetype2.grouptype].possiblemacros) do
						if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, macro, menu.equipmentsearchtext) then
							return haserror and Color["icon_error"] or Color["icon_normal"]
						end
					end
				end
			end
		end
	elseif (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "repair") and (menu.upgradetypeMode ~= "settings") then
		local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
		if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
			local slots = menu.slots[menu.upgradetypeMode]
			if slots[slot] then
				for _, macro in ipairs(slots[slot].possiblemacros) do
					if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, macro, menu.equipmentsearchtext) then
						return haserror and Color["icon_error"] or Color["icon_normal"]
					end
				end
			end
		end
	end
	return haserror and Color["icon_error_inactive"] or Color["icon_inactive"]
end

function menu.getPresetLoadouts()
	menu.loadouts = {}
	if not menu.isReadOnly then
		if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
			local currentmacro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
			local n = C.GetNumLoadoutsInfo(menu.object, menu.macro)
			local buf = ffi.new("UILoadoutInfo[?]", n)
			n = C.GetLoadoutsInfo(buf, n, menu.object, menu.macro)
			for i = 0, n - 1 do
				local id = ffi.string(buf[i].id)
				local active = false
				local mouseovertext = ""
				local numinvalidpatches = ffi.new("uint32_t[?]", 1)
				if not C.IsLoadoutValid(menu.object, menu.macro, id, numinvalidpatches) then
					local numpatches = numinvalidpatches[0]
					local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
					numpatches = C.GetLoadoutInvalidPatches(patchbuf, numpatches, menu.object, menu.macro, id)
					mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
					for j = 0, numpatches - 1 do
						if j > 3 then
							mouseovertext = mouseovertext .. "\n- ..."
							break
						end
						mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
						if patchbuf[j].state == 2 then
							mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
						elseif patchbuf[j].state == 3 then
							mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
						elseif patchbuf[j].state == 4 then
							mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
						end
					end
				elseif not C.IsLoadoutCompatible(currentmacro, id) then
					mouseovertext = ReadText(1026, 8024)
				elseif menu.mode == "customgamestart" then
					active = true
				elseif menu.mode == "comparison" then
					active = C.CanApplyKnownLoadout(menu.macro, id)
					if not active then
						mouseovertext = ReadText(1026, 8015)
					end
				else
					local result = ffi.string(C.GetMissingLoadoutBlueprints(menu.container, menu.object, menu.macro, id))
					active = result == ""
					if not active then
						mouseovertext = ReadText(1026, 8011)

						local missingmacros = {}
						if string.find(result, "error") ~= 1 then
							for macro in string.gmatch(result, "([^;]+);") do
								missingmacros[macro] = true
							end
						end
						local missingmacronames = {}
						for macro, v in pairs(missingmacros) do
							table.insert(missingmacronames, GetMacroData(macro, "name"))
						end
						table.sort(missingmacronames)
						for _, name in ipairs(missingmacronames) do
							mouseovertext = mouseovertext .. "\n· " .. name
						end
					end
				end
				table.insert(menu.loadouts, { id = id, name = ffi.string(buf[i].name), icon = ffi.string(buf[i].iconid), deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
			end
		end
		table.sort(menu.loadouts, Helper.sortName)

		local missionloadouts = {}
		if (menu.mode == "purchase") or (menu.mode == "upgrade") then
			if (menu.object ~= 0) or (menu.macro ~= "") then
				local currentmacro = (menu.macro ~= "") and menu.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro")
				local n = C.GetNumRequestedMissionShips()
				local buf = ffi.new("MissionShipDeliveryInfo[?]", n)
				n = C.GetRequestedMissionShips(buf, n)
				for i = 0, n - 1 do
					local id = buf[i].missionid
					local macro = ffi.string(buf[i].macroname)
					if macro == currentmacro then
						local missiondetails = C.GetMissionIDDetails(id)

						local result = ffi.string(C.GetMissingMissionLoadoutBlueprints(menu.container, id, macro))
						active = result == ""
						if not active then
							mouseovertext = ReadText(1026, 8011)

							local missingmacros = {}
							if string.find(result, "error") ~= 1 then
								for macro in string.gmatch(result, "([^;]+);") do
									missingmacros[macro] = true
								end
							end
							local missingmacronames = {}
							for macro, v in pairs(missingmacros) do
								table.insert(missingmacronames, GetMacroData(macro, "name"))
							end
							table.sort(missingmacronames)
							for _, name in ipairs(missingmacronames) do
								mouseovertext = mouseovertext .. "\n· " .. name
							end
						end

						table.insert(missionloadouts, 1, { id = "mission" .. i, name = ColorText["text_mission"] .. "\27[" .. "missiontype_" .. ffi.string(missiondetails.subType) .. "] " .. ffi.string(missiondetails.missionName) .. "\27X", icon = "", deleteable = false, mission = { id = id, macro = macro }, active = active, mouseovertext = mouseovertext })
					end
				end
			end
		end
		table.sort(missionloadouts, Helper.sortName)
		for i, entry in ipairs(missionloadouts) do
			table.insert(menu.loadouts, i, entry)
		end

		local hasanymod = false
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			local slots = (upgradetype.supertype == "group") and menu.upgradeplan[upgradetype.type] or menu.slots[upgradetype.type]
			local first = true
			for slot, macro in pairs(slots or {}) do
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					if menu.groups[slot] and (menu.groups[slot][upgradetype.grouptype].total > 0) then
						local hasmod = menu.checkMod(upgradetype.grouptype, menu.groups[slot][upgradetype.grouptype].currentcomponent, true)
						if hasmod then
							hasanymod = true
							break
						end
					end
				elseif upgradetype.supertype == "macro" then
					if type(slot) == "number" then
						local hasmod = menu.checkMod(upgradetype.type, slots[slot].component)
						if hasmod then
							hasanymod = true
							break
						end
					end
				end
			end
			if hasanymod then
				break
			end
		end

		if not menu.hasDefaultLoadout then
			local text = ColorText["text_warning"] .. (menu.container and string.format(ReadText(1026, 8026), ffi.string(C.GetComponentName(menu.container))) or ReadText(1026, 8027)) .. "\n\n\27X"
			local removingitems = ""
			for i, entry in ipairs(menu.missingUpgrades) do
				removingitems = removingitems .. ((i == 1) and text or "\n") .. "· " .. entry.amount .. ReadText(1001, 42) .. " " .. entry.name
			end

			local mouseovertext = ""
			if hasanymod then
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n\n"
				end
				mouseovertext = mouseovertext .. ColorText["text_error"] .. ReadText(1026, 8020) .. "\27X"
			end
			if removingitems ~= "" then
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n\n"
				end
				mouseovertext = mouseovertext .. removingitems
			end

			table.insert(menu.loadouts, 1, { id = "empty",	name = ReadText(1001, 7941), icon = "", deleteable = false, preset = 0,		active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = mouseovertext })
			table.insert(menu.loadouts, 2, { id = "low",	name = ReadText(1001, 7910), icon = "", deleteable = false, preset = 0.1,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = mouseovertext })
			table.insert(menu.loadouts, 3, { id = "medium",	name = ReadText(1001, 7911), icon = "", deleteable = false, preset = 0.5,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = mouseovertext })
			table.insert(menu.loadouts, 4, { id = "high",	name = ReadText(1001, 7912), icon = "", deleteable = false, preset = 1.0,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = mouseovertext })
		else
			table.insert(menu.loadouts, 1, { id = "default",	name = ReadText(1001, 3231), icon = "", deleteable = false,	active = menu.validLoadoutPossible and (not hasanymod),	mouseovertext = hasanymod and (ColorText["text_error"] .. ReadText(1026, 8020)) or "" })
		end
	end
end

function menu.getDataAndDisplay(upgradeplan, crew, newedit, firsttime, noundo, settings)
	-- init upgradeplan
	menu.upgradeplan = {}
	menu.upgradewares = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		menu.upgradeplan[upgradetype.type] = {}
		if upgradetype.supertype ~= "group" then
			menu.upgradewares[upgradetype.type] = {}
		end
	end

	-- assemble possible upgrades (wares, macros, stock)
	if menu.mode == "comparison" then
		for _, libraryentry in ipairs(config.comparisonEquipmentLibraries) do
			local data = GetLibrary(libraryentry.library)
			for _, dataentry in ipairs(data) do
				-- check all aliases due to collision / no-collision compatibilities
				local n = C.GetNumLibraryEntryAliases(libraryentry.library, dataentry.id)
				local buf = ffi.new("const char*[?]", n)
				n = C.GetLibraryEntryAliases(buf, n, libraryentry.library, dataentry.id)
				for j = 0, n - 1 do
					local aliasid = ffi.string(buf[j])
					local entry = {}
					local ware, name = GetMacroData(aliasid, "ware", "name")
					entry.ware = ware
					entry.macro = aliasid
					entry.name = name
					entry.objectamount = 0
					entry.isFromShipyard = true

					if menu.upgradewares[libraryentry.type] then
						table.insert(menu.upgradewares[libraryentry.type], entry)
					else
						menu.upgradewares[libraryentry.type] = { entry }
					end
				end
			end
		end
	else
		local n = 0
		local buf
		if menu.mode == "customgamestart" then
			n = C.GetNumAllEquipment(not menu.allownonplayerblueprints)
			buf = ffi.new("EquipmentWareInfo[?]", n)
			n = C.GetAllEquipment(buf, n, not menu.allownonplayerblueprints)
		elseif (not menu.isReadOnly) and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
			n = C.GetNumAvailableEquipment(menu.container, "")
			buf = ffi.new("EquipmentWareInfo[?]", n)
			n = C.GetAvailableEquipment(buf, n, menu.container, "")
		end
		if n > 0 then
			for i = 0, n - 1 do
				local type = ffi.string(buf[i].type)
				local entry = {}
				entry.ware = ffi.string(buf[i].ware)
				entry.macro = ffi.string(buf[i].macro)
				if type == "software" then
					entry.name = GetWareData(entry.ware, "name")
				else
					entry.name = GetMacroData(entry.macro, "name")
				end
				entry.objectamount = 0
				entry.isFromShipyard = true
				if (type == "lasertower") or (type == "satellite") or (type == "mine") or (type == "navbeacon") or (type == "resourceprobe") then
					type = "deployable"
				end
				if type == "" then
					DebugError(string.format("Could not find upgrade type for the equipment ware: '%s'. Check the ware tags. [Florian]", entry.ware))
				else
					if menu.upgradewares[type] then
						table.insert(menu.upgradewares[type], entry)
					else
						menu.upgradewares[type] = { entry }
					end
				end
			end
		end
	end

	-- sort
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype ~= "group" then
			table.sort(menu.upgradewares[upgradetype.type], Helper.sortName)
		end
	end

	-- assemble available slots/ammo/software
	menu.groups = {}
	menu.slots = {}
	menu.ammo = { missile = {}, drone = {}, deployable = {}, countermeasure = {}, }
	menu.software = {}
	menu.crew = {
		total = 0,
		capacity = 0,
		unassigned = {},
		roles = {},
		hired = 0,
		hireddetails = {},
		transferdetails = {},
		fired = {},
		ware = "crew",
		availableworkforce = 0,
		maxavailableworkforce = 0,
		availabledockcrew = 0,
		maxavailabledockcrew = 0,
	}
	if settings then
		menu.settings = settings
	else
		menu.settings = {
			blacklists = {},
			fightrules = {},
		}
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
		if C.IsComponentClass(menu.container, "ship") then
			local n = C.GetNumAllRoles()
			local buf = ffi.new("PeopleInfo[?]", n)
			n = C.GetPeople2(buf, n, menu.container, true)
			local numhireable = 0
			for i = 0, n - 1 do
				menu.crew.availabledockcrew = menu.crew.availabledockcrew + buf[i].amount
			end
			menu.crew.maxavailabledockcrew = C.GetPeopleCapacity(menu.container, "", false)
		else
			local workforceinfo = C.GetWorkForceInfo(menu.container, "")
			menu.crew.availableworkforce = workforceinfo.available
			menu.crew.maxavailableworkforce = workforceinfo.maxavailable
		end

		local minprice, maxprice = GetWareData(menu.crew.ware, "minprice", "maxprice")
		menu.crew.price = Helper.round(menu.hiringdiscounts.totalfactor * C.GetContainerBuildPriceFactor(menu.container) * (maxprice - (menu.crew.availableworkforce + menu.crew.availabledockcrew) / (menu.crew.maxavailableworkforce + menu.crew.maxavailabledockcrew) * (maxprice - minprice)))
	end

	menu.defaultpaintmod = {
		name = "",
		quality = 1,
	}
	local buf = ffi.new("UIPaintMod")
	if (menu.object ~= 0) or (menu.macro ~= "") then
		if C.GetPlayerPaintThemeMod(menu.object, menu.macro, buf) then
			menu.defaultpaintmod.name = ffi.string(buf.Name)
			menu.defaultpaintmod.ware = ffi.string(buf.Ware)
			menu.defaultpaintmod.quality = buf.Quality
			menu.defaultpaintmod.isdefault = true
			if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				menu.modwaresByWare[menu.defaultpaintmod.ware] = menu.defaultpaintmod
			end
		end
	end

	menu.installedPaintMod = nil
	if menu.object ~= 0 then
		local paintmod = ffi.new("UIPaintMod")
		if C.GetInstalledPaintMod(menu.object, paintmod) then
			menu.installedPaintMod = {}
			menu.installedPaintMod.name = ffi.string(paintmod.Name)
			menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
			menu.installedPaintMod.quality = paintmod.Quality
			menu.installedPaintMod.amount = paintmod.Amount
			menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
		end
	elseif menu.macro ~= "" then
		if menu.mode == "customgamestart" then
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			local painttheme = ffi.string(C.GetCustomGameStartStringProperty(menu.modeparam.gamestartid, menu.modeparam.paintthemeproperty, buf))
			local paintmod = ffi.new("UIPaintMod")
			if C.GetPaintThemeMod(painttheme, "player", paintmod) then
				menu.installedPaintMod = {}
				menu.installedPaintMod.name = ffi.string(paintmod.Name)
				menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
				menu.installedPaintMod.quality = paintmod.Quality
				menu.installedPaintMod.amount = paintmod.Amount
				menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
			end
		else
			local paintmod = ffi.new("UIPaintMod")
			if C.GetPlayerPaintThemeMod(menu.object, menu.macro, paintmod) then
				menu.installedPaintMod = {}
				menu.installedPaintMod.name = ffi.string(paintmod.Name)
				menu.installedPaintMod.ware = ffi.string(paintmod.Ware)
				menu.installedPaintMod.quality = paintmod.Quality
				menu.installedPaintMod.amount = paintmod.Amount
				menu.installedPaintMod.isdefault = menu.defaultpaintmod.ware == menu.installedPaintMod.ware
			end
		end
	end

	menu.missingUpgrades = {}

	menu.groups = {}
	if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
		menu.setupGroupData(menu.object, menu.macro, menu.groups, true)
	end

	if menu.usemacro then
		if menu.macro ~= "" then
			menu.prepareMacroUpgradeSlots(menu.macro)
			menu.prepareMacroCrewInfo(menu.macro)
		end
	elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
		if menu.object ~= 0 then
			menu.prepareComponentUpgradeSlots(menu.object, menu.slots, menu.ammo, menu.software, true)
			menu.prepareComponentCrewInfo(menu.object)

			menu.checkCurrentBuildTasks()

			if menu.objectgroup then
				for i = 1, #menu.objectgroup.ships do
					menu.objectgroup.shipdata[i] = {
						slots = {},
						groups = {},
						ammo = {},
						software = {},
					}
					menu.prepareComponentUpgradeSlots(menu.objectgroup.ships[i].ship, menu.objectgroup.shipdata[i].slots, menu.objectgroup.shipdata[i].ammo, menu.objectgroup.shipdata[i].software, false)
					menu.setupGroupData(menu.objectgroup.ships[i].ship, "", menu.objectgroup.shipdata[i].groups, false)
					menu.objectgroup.shipdata[i].damagedcomponents = menu.determineNeededRepairs(menu.objectgroup.ships[i].ship)
				end

				-- check for foreign macros (aka not sold by shipyard) - if all ships have the same as menu.object, it's fine. Otherwise the macro has to be deinstalled
				-- This is necessary as otherwise each ship in the group would need to keep track of an individual upgradeplan
				for i, upgradetype in ipairs(Helper.upgradetypes) do
					if upgradetype.supertype == "macro" then
						for j = 1, tonumber(C.GetNumUpgradeSlots(menu.object, "", upgradetype.type)) do
							if menu.upgradeplan[upgradetype.type][j].checkforeignmacro then
								local found = false
								for i = 1, #menu.objectgroup.ships do
									if menu.upgradeplan[upgradetype.type][j].macro ~= menu.objectgroup.shipdata[i].slots[upgradetype.type][j].currentmacro then
										menu.upgradeplan[upgradetype.type][j].macro = ""
										menu.slots[upgradetype.type][j].hasstock = false
										found = true
										break
									end
								end
								if not found then
									menu.upgradeplan[upgradetype.type][j].checkforeignmacro = nil
								end
							end
						end
					elseif upgradetype.supertype == "group" then
						for j, group in pairs(menu.upgradeplan[upgradetype.type]) do
							if group.checkforeignmacro then
								local found = false
								for i = 1, #menu.objectgroup.ships do
									if group.macro ~= menu.objectgroup.shipdata[i].groups[j][upgradetype.grouptype].currentmacro then
										menu.upgradeplan[upgradetype.type][j].macro = ""
										menu.groups[j][upgradetype.grouptype].hasstock = false
										found = true
										break
									end
								end
								if not found then
									menu.upgradeplan[upgradetype.type][j].checkforeignmacro = nil
								end
							end
						end
					end
				end
			end
		end
	end

	table.sort(menu.missingUpgrades, Helper.sortName)

	if menu.mode == "modify" then
		if menu.object ~= 0 then
			menu.shieldgroups = {}
			local shieldsizecounts = {}
			local n = C.GetNumShieldGroups(menu.object)
			local buf = ffi.new("ShieldGroup[?]", n)
			n = C.GetShieldGroups(buf, n, menu.object)
			for i = 0, n - 1 do
				local entry = {}
				entry.context = buf[i].context
				entry.group = ffi.string(buf[i].group)
				entry.component = buf[i].component
				table.insert(menu.shieldgroups, entry)
			end
			table.sort(menu.shieldgroups, function (a, b) return a.group < b.group end)
			for i, entry in ipairs(menu.shieldgroups) do
				if (entry.context == menu.object) and (entry.group == "") then -- mainship
					local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "shield")
					menu.shieldgroups[i].slotsize = ffi.string(groupinfo.slotsize)
					menu.shieldgroups[i].count = groupinfo.count
					menu.shieldgroups[i].upgradetype = "shields"
				else
					local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "engine")
					if groupinfo.total > 0 then	-- EngineGroup
						menu.shieldgroups[i].slotsize = ffi.string(groupinfo.slotsize)
						menu.shieldgroups[i].upgradetype = "engines"
					else -- TurretGroup
						local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", entry.context, "", entry.group, "turret")
						menu.shieldgroups[i].slotsize = ffi.string(groupinfo.slotsize)
						menu.shieldgroups[i].upgradetype = "turrets"
					end
				end
				menu.shieldgroups[i].sizecount = 0

				if menu.shieldgroups[i].slotsize ~= "" then
					if shieldsizecounts[menu.shieldgroups[i].upgradetype] then
						if shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize] then
							shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize] = shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize] + 1
						else
							shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize] = 1
						end
					else
						shieldsizecounts[menu.shieldgroups[i].upgradetype] = {}
						shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize] = 1
					end
					menu.shieldgroups[i].sizecount = shieldsizecounts[menu.shieldgroups[i].upgradetype][menu.shieldgroups[i].slotsize]
				end
			end
			for i, entry in ipairs(menu.shieldgroups) do
				if (entry.context == menu.object) and (entry.group == "") then
					menu.shieldgroups.hasMainGroup = true
					-- force maingroup to first index
					table.insert(menu.shieldgroups, 1, entry)
					table.remove(menu.shieldgroups, i + 1)
					break
				end
			end
		end
	end

	if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		if menu.installedPaintMod then
			if menu.modwares["paint"] then
				local found = false
				for i, mod in ipairs(menu.modwares["paint"]) do
					if mod.ware == menu.installedPaintMod.ware then
						found = true
						break
					end
				end
				if not found then
					table.insert(menu.modwares["paint"], menu.installedPaintMod)
					menu.modwaresByWare[menu.installedPaintMod.ware] = menu.installedPaintMod
				end
			else
				menu.modwares["paint"] = { menu.installedPaintMod }
				menu.modwaresByWare[menu.installedPaintMod.ware] = menu.installedPaintMod
			end
		end
	end

	if menu.currentSlot == nil then
		menu.determineInitialSlot()
	end

	-- assemble possible upgrades per slot
	local objectmakerraces = menu.object ~= 0 and GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "makerraceid") or (menu.macro ~= "" and GetMacroData(menu.macro, "makerraceid") or nil)
	for type, slots in pairs(menu.slots) do
		local upgradetype = Helper.findUpgradeType(type)
		if upgradetype.supertype == "macro" then
			slots.count = #slots
			local sizecounts = {}
			for i, slot in ipairs(slots) do
				if menu.upgradewares[type] then
					for _, upgradeware in ipairs(menu.upgradewares[type]) do
						if menu.checkCompatibility(upgradeware.macro, objectmakerraces) and C.IsUpgradeMacroCompatible(menu.object, 0, menu.macro, false, type, i, upgradeware.macro) then
							if upgradeware.isFromShipyard or (slot.currentmacro == upgradeware.macro) then
								table.insert(slot.possiblemacros, upgradeware.macro)
							end
						elseif slot.currentmacro and (slot.currentmacro == upgradeware.macro) then
							table.insert(slot.possiblemacros, upgradeware.macro)
						end
					end
					table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
				end

				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, type, i)
				if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
					slot.isgroup = true
					slots.count = slots.count - 1
				end
				if not slot.isgroup then
					slot.slotname = i
					slot.slotsize = ffi.string(C.GetSlotSize(menu.object, 0, menu.macro, false, upgradetype.type, i))
					if slot.slotsize ~= "" then
						if sizecounts[slot.slotsize] then
							sizecounts[slot.slotsize] = sizecounts[slot.slotsize] + 1
						else
							sizecounts[slot.slotsize] = 1
						end
						slot.slotname = upgradetype.shorttext[slot.slotsize] .. sizecounts[slot.slotsize]
					end
				end
			end
		elseif upgradetype.supertype == "virtualmacro" then
			for i, slot in ipairs(slots) do
				if menu.upgradewares[type] then
					for _, upgradeware in ipairs(menu.upgradewares[type]) do
						if menu.checkCompatibility(upgradeware.macro, objectmakerraces) and C.IsVirtualUpgradeMacroCompatible(menu.object, menu.macro, type, i, upgradeware.macro) then
							table.insert(slot.possiblemacros, upgradeware.macro)
						end
					end
					table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
				end
			end
		end
	end

	-- assemble possible upgrades per group
	for i, group in ipairs(menu.groups) do
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local wares = menu.upgradewares[upgradetype.grouptype] or {}
				for _, upgradeware in ipairs(wares) do
					if upgradeware.macro ~= "" then
						if menu.checkCompatibility(upgradeware.macro, objectmakerraces) and C.IsUpgradeGroupMacroCompatible(menu.object, menu.macro, group.path, group.group, upgradetype.grouptype, upgradeware.macro) then
							if upgradeware.isFromShipyard or (group[upgradetype.grouptype].currentmacro == upgradeware.macro) then
								table.insert(menu.groups[i][upgradetype.grouptype].possiblemacros, upgradeware.macro)
							end
						end
					end
				end
				table.sort(menu.groups[i][upgradetype.grouptype].possiblemacros, Helper.sortMacroRaceAndShortname)
			end
		end
	end

	-- assemble possible software per slot
	for type, softwarelist in pairs(menu.software) do
		for j, software in ipairs(softwarelist) do
			software.defaultsoftware = 0
			software.possiblesoftware = {}
			local n = C.GetNumSoftwarePredecessors(software.maxsoftware)
			local buf = ffi.new("const char*[?]", n)
			n = C.GetSoftwarePredecessors(buf, n, software.maxsoftware)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				if (not menu.isReadOnly) or (ware == software.currentsoftware) then
					table.insert(software.possiblesoftware, ware)
				end
				if C.IsSoftwareDefault(menu.object, menu.macro, ware) then
					software.defaultsoftware = i + 1
					if software.currentsoftware == "" then
						if upgradeplan or (menu.mode ~= "purchase") or (menu.upgradeplan[type][j] ~= "") then
							menu.upgradeplan[type][j] = ware
						end
					end
				end
			end
			if (not menu.isReadOnly) or (software.maxsoftware == software.currentsoftware) then
				table.insert(software.possiblesoftware, software.maxsoftware)
			end
			if C.IsSoftwareDefault(menu.object, menu.macro, software.maxsoftware) then
				software.defaultsoftware = #software.possiblesoftware
				if software.currentsoftware == "" then
					if upgradeplan or (menu.mode ~= "purchase") or (menu.upgradeplan[type][j] ~= "") then
						menu.upgradeplan[type][j] = software.maxsoftware
					end
				end
			end
		end
	end

	-- get preset loadouts
	menu.getPresetLoadouts()

	if upgradeplan then
		for type, upgradelist in pairs(menu.upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if upgradetype.supertype == "group" then
					local found = false
					for key2, upgrade2 in pairs(upgradeplan[type]) do
						if (upgrade2.path == upgrade.path) and (upgrade2.group == upgrade.group) then
							found = true
							menu.upgradeplan[type][key].macro = upgrade2.macro or ""
							menu.upgradeplan[type][key].count = upgrade2.count or 0
							menu.upgradeplan[type][key].ammomacro = upgrade2.ammomacro or ""
							menu.upgradeplan[type][key].weaponmode = upgrade2.weaponmode or ""
							break
						end
					end
					if not found then
						menu.upgradeplan[type][key].macro = ""
						menu.upgradeplan[type][key].count = 0
					end
				else
					local newvalue
					if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
						newvalue = upgradeplan[type][key] or { macro = "", ammomacro = "", weaponmode = "" }
					elseif (upgradetype.supertype == "software") then
						if not upgradeplan[type][key] then
							if menu.upgradeplan[type][key] ~= "" then
								if menu.software[type][key].defaultsoftware ~= 0 then
									newvalue = menu.software[type][key].possiblesoftware[menu.software[type][key].defaultsoftware]
								else
									newvalue = ""
								end
							else
								newvalue = ""
							end
						else
							newvalue = upgradeplan[type][key]
						end
					elseif (upgradetype.supertype == "ammo") then
						newvalue = 0
					end
					menu.upgradeplan[type][key] = newvalue
				end
			end
			if upgradetype.supertype == "crew" then
				if menu.usemacro then
					menu.crew.hired = 0
					menu.crew.hireddetails = {}
					menu.crew.unassigned = {}
					menu.crew.fired = {}

					for i, entry in ipairs(menu.crew.roles) do
						for roleid, amount in pairs(upgradeplan[type]) do
							if roleid == entry.id then
								menu.crew.roles[i].wanted = amount
								menu.crew.roles[i].tiers[1].wanted = amount

								menu.crew.hired = menu.crew.hired + amount
								table.insert(menu.crew.hireddetails, { newrole = roleid, amount = amount, price = menu.crew.price })
								break
							end
						end
					end
				end
			end
		end
		-- second pass due to ammo commpatibility being based on weapons and turrets
		for type, upgradelist in pairs(menu.upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if (upgradetype.supertype == "ammo") then
					newvalue = upgradeplan[type][key] or 0
					menu.upgradeplan[type][key] = newvalue
				end
			end
		end
		menu.upgradeplan.hascrewexperience = upgradeplan.hascrewexperience
	end
	if crew then
		menu.crew.hired = crew.hired
		for _, entry in ipairs(crew.fired) do
			table.insert(menu.crew.fired, entry)
		end
		menu.crew.unassigned = crew.unassigned
		for _, entry in ipairs(crew.hireddetails) do
			table.insert(menu.crew.hireddetails, entry)
		end
		for i, entry in ipairs(crew.roles) do
			menu.crew.roles[i].wanted = entry.wanted
			for j, tier in ipairs(entry.tiers) do
				menu.crew.roles[i].tiers[j].wanted = tier.wanted
			end
		end
	end

	if not noundo then
		menu.addUndoStep()
	end

	if menu.holomap and (menu.holomap ~= 0) then
		if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
			if (not newedit) and upgradeplan then
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.object, 0, menu.macro, false, loadout) end)
			else
				menu.currentIdx = menu.currentIdx + 1
				Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.object, 0, menu.macro, false, loadout, 0) end)
			end
			if menu.selectedPaintMod then
				C.SetMapPaintMod(menu.holomap, menu.selectedPaintMod.ware)
			elseif menu.installedPaintMod then
				C.SetMapPaintMod(menu.holomap, menu.installedPaintMod.ware)
			end
			menu.selectMapMacroSlot()
			if menu.mapstate then
				C.SetMapState(menu.holomap, menu.mapstate)
				menu.mapstate = nil
			end
		else
			C.ClearMapBehaviour(menu.holomap)
		end
	end

	menu.displayMenu(firsttime)
end

function menu.checkCurrentBuildTasks()
	menu.tasks = {}
	local n = C.GetNumOrders(menu.object)
	local buf = ffi.new("Order[?]", n)
	n = C.GetOrders(buf, n, menu.object)
	for i = 0, n - 1 do
		if ffi.string(buf[i].orderdef) == "Equip" then
			local params = GetOrderParams(ConvertStringTo64Bit(tostring(menu.object)), tonumber(buf[i].queueidx))
			menu.tasks[tostring(menu.object)] = params[1].value
			break
		elseif ffi.string(buf[i].orderdef) == "Repair" then
			menu.tasks[tostring(menu.object)] = true
			break
		end
	end
end

function menu.checkCompatibility(macro, objectmakerraces)
	local makerrace = GetMacroData(macro, "makerraceid")
	local allowed = true
	for _, race in ipairs(makerrace) do
		if objectmakerraces then
			local raceallowed = false
			for _, objectrace in ipairs(objectmakerraces) do
				if objectrace == race then
					raceallowed = true
					break
				end
			end
			if raceallowed then
				-- always allow the equipment if the maker race matches the maker race of the object it is for
				allowed = true
				break
			end
		end
		if race == "xenon" then
			allowed = false
		end
		if race == "khaak" then
			allowed = false
		end
		if not allowed then
			break
		end
	end

	if menu.hasDefaultLoadout then
		return menu.defaultLoadoutMacros[macro]
	else
		return (next(makerrace) == nil) or allowed
	end
end

function menu.displayAmmoSlot(ftable, type, macro, total, capacity, first)
	if (menu.upgradeplan[type][macro] and (menu.upgradeplan[type][macro] > 0)) or (menu.ammo[type][macro] and (menu.ammo[type][macro] > 0)) or menu.isAmmoCompatible(type, macro) then
		local planned = menu.upgradeplan[type][macro] or 0
		local name, infolibrary = GetMacroData(macro, "name", "infolibrary")
		AddKnownItem(infolibrary, macro)

		local difference = planned - menu.ammo[type][macro]
		local color = Color["text_normal"]
		if difference < 0 then
			color = Color["text_negative"]
		elseif difference > 0 then
			color = Color["text_positive"]
		end

		local errorcase = total > capacity

		local scale = {
			min            = 0,
			max            = math.max(capacity, planned),
			maxSelect      = errorcase and planned or math.min(capacity, planned + capacity - total),
			start          = planned,
			step           = 1,
			suffix         = "",
			exceedMaxValue = false,
			readOnly       = menu.isReadOnly,
		}

		local price
		local j = menu.findUpgradeMacro(type, macro)
		if j then
			local upgradeware = menu.upgradewares[type][j]
			if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
			end

			if (not errorcase) and (not upgradeware.isFromShipyard) then
				if menu.objectgroup then
					local maxamount = math.floor((upgradeware.objectamount - menu.ammo[type][macro]) / #menu.objectgroup.ships)
					scale.maxSelect = math.min(scale.maxSelect, maxamount)
					scale.start = math.min(scale.start, scale.maxSelect)
					menu.upgradeplan[type][macro] = math.min(planned, maxamount)
				else
					scale.maxSelect = math.min(scale.maxSelect, upgradeware.objectamount)
				end
			end
		end

		if not first then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = ftable:addRow((type ~= "countermeasure") and { type = type, name = name, macro = macro } or true, { scaling = true, borderBelow = false })
		row[1]:setColSpan(price and 8 or 11):setBackgroundColSpan(11):createBoxText(name)
		if price then
			row[9]:setColSpan(3):createBoxText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
		end

		local row = ftable:addRow(true, { scaling = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly, helpOverlayID = "shipconfig_ammo_" .. macro, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 1202), { color = color })
		row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectAmount(type, nil, macro, row.index, ...) end
		row[1].handlers.onRightClick = function (...) return menu.buttonInteract({ type = type, name = name, macro = macro }, ...) end

		return row
	end
end

function menu.displayCrewSlot(ftable, idx, data, buttonWidth, price, first)
	local lastrow
	if data.canhire then
		local color = Color["text_normal"]
		local capacity = menu.crew.capacity
		if menu.object ~= 0 then
			local n = C.GetNumAllRoles()
			local buf = ffi.new("PeopleInfo[?]", n)
			n = C.GetPeople2(buf, n, menu.object, true)
			for i = 0, n - 1 do
				local role = ffi.string(buf[i].id)
				local wanted = buf[i].amount
				for _, entry in ipairs(menu.crew.roles) do
					if role == entry.id then
						if wanted ~= entry.wanted then
							wanted = entry.wanted
						end
						break
					end
				end
				if role ~= data.id then
					capacity = capacity - wanted
				end
			end
		else
			for _, entry in ipairs(menu.crew.roles) do
				if entry.id ~= data.id then
					capacity = capacity - entry.wanted
				end
			end
		end
		capacity = math.max(0, capacity)

		local scale
		if (menu.mode == "purchase") or (menu.mode == "customgamestart") then
			scale = {
				min            = 0,
				max            = menu.crew.capacity,
				maxSelect      = capacity,
				start          = data.wanted,
				step           = 1,
				suffix         = "",
				exceedMaxValue = false,
				readOnly       = menu.isReadOnly,
			}
		else
			scale = {
				min            = 0,
				max            = menu.crew.capacity,
				maxSelect      = math.min(data.wanted + #menu.crew.unassigned + menu.crew.availableworkforce + menu.crew.availabledockcrew, capacity),
				start          = math.min(data.wanted, capacity),
				step           = 1,
				suffix         = "",
				exceedMaxValue = false,
				readOnly       = menu.isReadOnly,
			}
			--print("role: " .. tostring(data.id) .. ", maxSelect: " .. tostring(math.min(data.wanted + #menu.crew.unassigned + menu.crew.availableworkforce + menu.crew.availabledockcrew, capacity)))
		end

		if not first then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end

		local row = ftable:addRow(true, { scaling = true, borderBelow = false })
		row[1]:setColSpan(((not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart")) and 8 or 11):setBackgroundColSpan(11):createBoxText(data.name)
		if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") then
			local mouseovertext = ""
			if #menu.hiringdiscounts > 0 then
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n\n"
				end
				mouseovertext = mouseovertext .. ReadText(1001, 2819) .. ReadText(1001, 120)
				for _, entry in ipairs(menu.hiringdiscounts) do
					mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. " " .. entry.amount .. " %"
				end
			end
			row[9]:setColSpan(3):createBoxText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", mouseOverText = mouseovertext })
		end

		local row = ftable:addRow(true, { scaling = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly, helpOverlayID = "shipconfig_crew_" .. data.id, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 1202), { color = color })
		row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectCrewAmount(idx, 1, row.index, false, ...) end
		lastrow = row

		if menu.mode ~= "purchase" then
			for j, tier in ipairs(data.tiers) do
				if not tier.hidden then
					local scale = {
						min            = 0,
						max            = data.wanted,
						maxSelect      = tier.wanted,
						start          = tier.wanted,
						step           = 1,
						suffix         = "",
						exceedMaxValue = false,
						readOnly       = menu.isReadOnly,
					}

					local row = ftable:addRow(true, { scaling = true, bgColor = Color["row_background_blue"] })
					row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = scale.min, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, readOnly = scale.readOnly, helpOverlayID = "shipconfig_crew_" .. data.id .. j, helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText("  " .. tier.name, { color = color })
					row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectCrewAmount(idx, j, row.index, true, ...) end
					lastrow = row
				end
			end
		end
	else
		local row = ftable:addRow(false, { scaling = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(11):createText(data.name .. ": " .. data.total)
		lastrow = row
	end

	return lastrow
end

function menu.displaySoftwareSlot(ftable, type, slot, slotdata)
	local plansoftware = menu.upgradeplan[menu.upgradetypeMode][slot]
	local name = GetWareData(slotdata.possiblesoftware[1], "factoryname")

	local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
	local lastrow = row
	if slotdata.defaultsoftware ~= 0 then
		local color = Color["text_normal"]
		if plansoftware == "" then
			color = Color["text_error"]
		end

		row[1]:setColSpan(7):setBackgroundColSpan(11):createText(name, menu.subHeaderTextProperties)
		row[1].properties.color = color
		row[8]:setColSpan(4):createText(ReadText(1001, 8047), menu.subHeaderTextProperties)
		row[8].properties.color = color
		row[8].properties.halign = "right"
	else
		row[1]:setColSpan(11):createText(name, menu.subHeaderTextProperties)
	end

	for i, software in ipairs(slotdata.possiblesoftware) do
		if i >= slotdata.defaultsoftware then
			if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, software, menu.equipmentsearchtext) then
				local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(software, nil, true)

				local price
				if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringTo64Bit(tostring(menu.container)), software, false)
				end

				local installcolor = Color["text_normal"]
				if software == slotdata.currentsoftware then
					if software ~= plansoftware then
						installcolor = Color["text_negative"]
					end
				elseif software == plansoftware then
					installcolor = Color["text_positive"]
				end

				local active = not menu.isReadOnly
				if software == plansoftware then
					if i == slotdata.defaultsoftware then
						active = false
					end
				end

				local name = GetWareData(software, "name")
				AddKnownItem("software", software)
				local row = ftable:addRow({ type = type, name = name, software = software }, { scaling = true })
				row[1]:setColSpan(1):createCheckBox(software == plansoftware, { scaling = false, active = active, width = menu.rowHeight, height = menu.rowHeight, helpOverlayID = "shipconfig_software_" .. software, helpOverlayText = " ", helpOverlayHighlightOnly = true })
				row[1].handlers.onClick = function () return menu.checkboxSelectSoftware(type, slot, software, row.index) end
				row[2]:setColSpan(price and 7 or 10):createText(name, { color = installcolor })
				if price then
					row[9]:setColSpan(3):createText(ConvertMoneyString(price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
				end
				lastrow = row
			end
		end
	end

	return lastrow
end

function menu.checkCurrentSlot(slots, slot)
	local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
	if upgradetype then
		if menu.upgradetypeMode == "enginegroup" then
			if (not menu.groups[slot]) or (menu.groups[slot]["engine"].total == 0) then
				for i, upgradegroup in ipairs(menu.groups) do
					if upgradegroup["engine"].total > 0 then
						slot = i
						break
					end
				end
			end
		elseif menu.upgradetypeMode == "turretgroup" then
			if (not menu.groups[slot]) or (menu.groups[slot]["engine"].total > 0) then
				for i, upgradegroup in ipairs(menu.groups) do
					if upgradegroup["engine"].total == 0 then
						slot = i
						break
					end
				end
			end
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "software") then
			if not upgradetype.mergeslots then
				if (not slots[slot]) or slots[slot].isgroup then
					for i, slot2 in ipairs(slots) do
						if not slot2.isgroup then
							slot = i
							break
						end
					end
				end
			else
				slot = 1
			end
		end
	end

	return slot
end

function menu.buttonEquipmentFilter(offsety)
	if menu.contextMode and (menu.contextMode.mode == "equipmentfilter") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 1)
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		Helper.closeDropDownOptions(menu.titlebartable, 1, 3)
		menu.displayContextFrame("equipmentfilter", Helper.scaleX(config.equipmentfilter_races_width), menu.slotData.offsetX + menu.slotData.width + Helper.borderSize, offsety)
	end
end

function menu.displaySlots(frame, firsttime)
	if menu.upgradetypeMode and ((menu.mode ~= "purchase") or menu.validLicence) then
		local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)

		local count, rowcount, slidercount = 1, 0, 0
		menu.groupedupgrades = {}

		local slots = {}
		if (menu.upgradetypeMode ~= "enginegroup") and (menu.upgradetypeMode ~= "turretgroup") and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "repair") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
				slots = menu.slots[menu.upgradetypeMode] or {}
			end
		end

		menu.currentSlot = menu.checkCurrentSlot(slots, menu.currentSlot)
		local currentSlotInfo = {}

		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local upgradegroup = menu.groups[menu.currentSlot]
			if upgradegroup then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					local upgradegroupcount = 1
					if upgradetype2.supertype == "group" then
						menu.groupedupgrades[upgradetype2.grouptype] = {}
						for i, macro in ipairs(upgradegroup[upgradetype2.grouptype].possiblemacros) do
							local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
							for race_i, race in ipairs(makerrace) do
								if (not menu.equipmentfilter_races[race]) then
									menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
								end
								if (not menu.equipmentfilter_races[race].upgradeTypes) then
									menu.equipmentfilter_races[race].upgradeTypes = {}
								end
								if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
									menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
								end
							end
							if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, macro, menu.equipmentsearchtext) then
								local group = math.ceil(upgradegroupcount / 3)
								menu.groupedupgrades[upgradetype2.grouptype][group] = menu.groupedupgrades[upgradetype2.grouptype][group] or {}
								table.insert(menu.groupedupgrades[upgradetype2.grouptype][group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = macroname })
								upgradegroupcount = upgradegroupcount + 1
							end
						end

						if (not menu.isReadOnly) and upgradetype2.allowempty then
							local group = math.ceil(upgradegroupcount / 3)
							menu.groupedupgrades[upgradetype2.grouptype][group] = menu.groupedupgrades[upgradetype2.grouptype][group] or {}
							table.insert(menu.groupedupgrades[upgradetype2.grouptype][group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906), helpOverlayID = "upgrade_empty", helpOverlayText = " ", helpOverlayHighlightOnly = true })
							upgradegroupcount = upgradegroupcount + 1
						end
					end
					if upgradegroupcount > 1 then
						slidercount = slidercount + 1
					end
					rowcount = rowcount + math.ceil((upgradegroupcount - 1) / 3)
				end
			end
		elseif (menu.upgradetypeMode == "repair") then
			if menu.objectgroup then
				for i, ship in ipairs(menu.objectgroup.ships) do
					if #menu.objectgroup.shipdata[i].damagedcomponents > 0 then
						local group = math.ceil(count / 3)
						menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
						table.insert(menu.groupedupgrades[group], { macro = ship.macro, icon = (C.IsIconValid("ship_" .. ship.macro) and ("ship_" .. ship.macro) or "ship_notfound"), name = ship.name, component = ship.ship })
						count = count + 1
					end
				end
			else
				local component = menu.object
				local group = math.ceil(count / 3)
				local macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
				local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
				for race_i, race in ipairs(makerrace) do
					if (not menu.equipmentfilter_races[race]) then
						menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
					end
					if (not menu.equipmentfilter_races[race].upgradeTypes) then
						menu.equipmentfilter_races[race].upgradeTypes = {}
					end
					if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
						menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
					end
				end
				menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
				table.insert(menu.groupedupgrades[group], { macro = macro, icon = (C.IsIconValid("ship_" .. macro) and ("ship_" .. macro) or "ship_notfound"), name = macroname, component = component })
				count = count + 1
			end
			rowcount = rowcount + math.ceil(count / 3)
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if #slots > 0 then
				if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					for i, macro in ipairs(slots[menu.currentSlot].possiblemacros) do
						local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
						for race_i, race in ipairs(makerrace) do
							if (not menu.equipmentfilter_races[race]) then
								menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
							end
							if (not menu.equipmentfilter_races[race].upgradeTypes) then
								menu.equipmentfilter_races[race].upgradeTypes = {}
							end
							if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
								menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
							end
						end
						if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, macro, menu.equipmentsearchtext) then
							local group = math.ceil(count / 3)
							menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
							table.insert(menu.groupedupgrades[group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = macroname })
							count = count + 1
						end
					end

					if (not menu.isReadOnly) and (upgradetype.allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))) then
						local group = math.ceil(count / 3)
						menu.groupedupgrades[group] = menu.groupedupgrades[group] or {}
						table.insert(menu.groupedupgrades[group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906), helpOverlayID = "upgrade_empty", helpOverlayText = " ", helpOverlayHighlightOnly = true })
						count = count + 1
					end
				end
			end
			rowcount = rowcount + math.ceil(count / 3)
		end

		menu.groupedslots = {}
		local groupedslots = {}
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local groupcount = 1
			for i, upgradegroup in ipairs(menu.groups) do
				if (menu.upgradetypeMode == "enginegroup") == (upgradegroup["engine"].total > 0) then
					local groupname = upgradegroup.groupname
					local slotsize = upgradegroup[upgradetype.grouptype].slotsize
					local compatibilities = upgradegroup[upgradetype.grouptype].compatibilities

					if i == menu.currentSlot then
						currentSlotInfo.slotsize = slotsize
						currentSlotInfo.compatibilities = compatibilities
					end

					table.insert(groupedslots, { i, upgradegroup, groupname, sizecount = i, slotsize = slotsize, compatibilities = compatibilities })
					groupcount = groupcount + 1
				end
			end
		elseif menu.upgradetypeMode == "repair" then
			local slotcount = 1
			menu.repairslots = {}

			if menu.objectgroup then
				local count = 1
				for i, ship in ipairs(menu.objectgroup.ships) do
					if #menu.objectgroup.shipdata[i].damagedcomponents > 0 then
						local group = math.ceil(count / 3)

						menu.repairslots[group] = menu.repairslots[group] or {}
						table.insert(menu.repairslots[group], { i, ship.macro, i, ship.ship })
						count = count + 1
					end
				end
			else
				if #menu.damagedcomponents > 0 then
					local component = menu.object
					local group = math.ceil(slotcount / 3)
					local macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
					local slotnum = 1

					menu.repairslots[group] = menu.repairslots[group] or {}
					table.insert(menu.repairslots[group], { slotnum, macro, slotcount, component })
				end
			end
		elseif (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if not upgradetype.mergeslots then
				for i, slot in ipairs(slots) do
					if not slot.isgroup then
						local slotname = slot.slotname
						local slotsize = slot.slotsize

						local compatibilities
						local n = C.GetNumSlotCompatibilities(menu.object, 0, menu.macro, false, upgradetype.type, i)
						if n > 0 then
							compatibilities = {}
							local buf = ffi.new("EquipmentCompatibilityInfo[?]", n)
							n = C.GetSlotCompatibilities(buf, n, menu.object, 0, menu.macro, false, upgradetype.type, i)
							for j = 0, n - 1 do
								compatibilities[ffi.string(buf[j].tag)] = ffi.string(buf[j].name)
							end
						end

						if i == menu.currentSlot then
							currentSlotInfo.slotsize = slotsize
							currentSlotInfo.compatibilities = compatibilities
						end

						table.insert(groupedslots, { i, slot, slotname, sizecount = i, slotsize = slotsize, compatibilities = compatibilities })
					end
				end
			else
				if upgradetype.supertype == "macro" then
					currentSlotInfo.slotsize = ffi.string(C.GetSlotSize(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))

					local n = C.GetNumSlotCompatibilities(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot)
					if n > 0 then
						currentSlotInfo.compatibilities = {}
						local buf = ffi.new("EquipmentCompatibilityInfo[?]", n)
						n = C.GetSlotCompatibilities(buf, n, menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot)
						for j = 0, n - 1 do
							currentSlotInfo.compatibilities[ffi.string(buf[j].tag)] = ffi.string(buf[j].name)
						end
					end
				end
			end
		end
		table.sort(groupedslots, Helper.sortSlots)

		for i, entry in ipairs(groupedslots) do
			local group = math.ceil(i / 9)
			menu.groupedslots[group] = menu.groupedslots[group] or {}
			table.insert(menu.groupedslots[group], entry)
		end

		menu.rowHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
		menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)

		local hasScrollbar = false
		local headerHeight = menu.titleData.height + #menu.groupedslots * (maxSlotWidth + Helper.borderSize) + menu.rowHeight + 2 * Helper.borderSize
		local boxTextHeight = math.ceil(C.GetTextHeight(" \n ", Helper.standardFont, menu.extraFontSize, 0)) + 2 * Helper.borderSize
		--[[ Keep for simpler debugging
			print((Helper.viewHeight - 2 * menu.slotData.offsetY) .. " vs " .. (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)))
			print(headerHeight)
			print(boxTextHeight)
			print(rowcount .. " * " .. 3 * (maxSlotWidth + Helper.borderSize))
			print(slidercount .. " * " .. menu.subHeaderRowHeight + Helper.borderSize) --]]
		if (Helper.viewHeight - 2 * menu.slotData.offsetY) < (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)) then
			hasScrollbar = true
		end

		local slotWidth = maxSlotWidth - math.floor((hasScrollbar and Helper.scrollbarWidth or 0) / 9)
		local extraPixels = (menu.slotData.width - 8 * Helper.borderSize) % 9
		local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
		if extraPixels > 0 then
			for i = 1, extraPixels do
				slotWidths[i] = slotWidths[i] + 1
			end
		end
		-- prevent negative column width
		if slotWidths[1] - menu.rowHeight - Helper.borderSize < 1 then
			slotWidths[1] = menu.rowHeight + Helper.borderSize + 1
		end
		local columnWidths = {}
		local maxColumnWidth = 0
		for i = 1, 3 do
			columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
			maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
		end
		local slidercellWidth = menu.slotData.width - math.floor(hasScrollbar and Helper.scrollbarWidth or 0)

		local maxVisibleHeight
		local highlightmode = "column"
		if (menu.upgradetypeMode == "consumables") or (menu.upgradetypeMode == "crew") or (menu.upgradetypeMode == "software") or (menu.upgradetypeMode == "settings") then
			highlightmode = "on"
		end
		local ftable = frame:addTable(11, { tabOrder = 1, width = menu.slotData.width, maxVisibleHeight = Helper.viewHeight - 2 * menu.slotData.offsetY, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, reserveScrollBar = menu.upgradetypeMode == "consumables", highlightMode = highlightmode, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		ftable:setColWidth(1, menu.rowHeight)
		ftable:setColWidth(2, slotWidths[1] - menu.rowHeight - Helper.borderSize)
		-- exact col widths are unimportant in these menus, keeping them variable and equal helps with scrollbar support
		if (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			for i = 2, 8 do
				ftable:setColWidth(i + 1, slotWidths[i])
			end
		end
		ftable:setColWidth(11, menu.rowHeight)
		ftable:setDefaultColSpan(1, 4)
		ftable:setDefaultColSpan(5, 3)
		ftable:setDefaultColSpan(8, 4)

		local name = menu.getLeftBarEntry(menu.upgradetypeMode).name or ""
		local sizeicon
		if (menu.upgradetypeMode ~= "enginegroup") and (menu.upgradetypeMode ~= "turretgroup") and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") and (menu.upgradetypeMode ~= "repair") and (menu.upgradetypeMode ~= "software") and (menu.upgradetypeMode ~= "settings") then
			if upgradetype.supertype == "macro" and ((menu.object ~= 0) or (menu.macro ~= "")) then
				if currentSlotInfo.slotsize and (currentSlotInfo.slotsize ~= "") then
					name = upgradetype.text[currentSlotInfo.slotsize]
					sizeicon = "be_upgrade_size_" .. currentSlotInfo.slotsize
				end
			elseif upgradetype.supertype == "virtualmacro" then
				if menu.class == "ship_s" then
					name = upgradetype.text["small"]
					sizeicon = "be_upgrade_size_small"
				elseif menu.class == "ship_m" then
					name = upgradetype.text["medium"]
					sizeicon = "be_upgrade_size_medium"
				elseif menu.class == "ship_l" then
					name = upgradetype.text["large"]
					sizeicon = "be_upgrade_size_large"
				elseif menu.class == "ship_xl" then
					name = upgradetype.text["extralarge"]
					sizeicon = "be_upgrade_size_extralarge"
				end
			end
		end

		local color = Color["text_normal"]
		if upgradetype then
			local allowempty = upgradetype.allowempty
			if upgradetype.supertype == "macro" then
				allowempty = allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, menu.currentSlot))
			end
			if not allowempty then
				if menu.upgradeplan[upgradetype.type][menu.currentSlot].macro == "" then
					color = Color["text_error"]
				end
			end
		end
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(11):createText(name, menu.headerTextProperties)
		row[1].properties.color = color

		for _, group in ipairs(menu.groupedslots) do
			local row = ftable:addRow(true, {  })
			for i = 1, 9 do
				if group[i] then
					local col = (i > 1) and (i + 1) or 1
					local colspan = ((i == 1) or (i == 9)) and 2 or 1

					local color = Color["text_normal"]
					local haserror = false
					local bgcolor = Color["row_title_background"]
					if group[i][1] == menu.currentSlot then
						bgcolor = Color["row_background_selected"]
					end
					local count, total = 0, 0
					if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
						for _, upgradetype2 in ipairs(Helper.upgradetypes) do
							if upgradetype2.supertype == "group" then
								if menu.groups[group[i][1]][upgradetype2.grouptype].total > 0 then
									if upgradetype2.mergeslots then
										count = count + ((menu.upgradeplan[upgradetype2.type][group[i][1]].count > 0) and 1 or 0)
										total = total + 1
									else
										count = count + menu.upgradeplan[upgradetype2.type][group[i][1]].count
										total = total + menu.groups[group[i][1]][upgradetype2.grouptype].total
									end
									if upgradetype2.allowempty == false then
										if menu.upgradeplan[upgradetype2.type][group[i][1]].macro == "" then
											color = Color["text_error"]
											haserror = true
										end
									end
								end
							end
						end
					else
						total = 1
						if menu.upgradeplan[upgradetype.type][group[i][1]].macro == "" then
							if (upgradetype.allowempty == false) or C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, group[i][1]) then
								color = Color["text_error"]
								haserror = true
							end
						else
							count = 1
						end
					end

					local mouseovertext = ""
					if upgradetype then
						mouseovertext = ReadText(1001, 66) .. " " .. group[i][3]
					else
						mouseovertext = ReadText(1001, 8023) .. " " .. group[i][3]
					end

					row[col]:setColSpan(colspan):createButton({ height = slotWidths[i], width = slotWidths[i], bgColor = bgcolor, mouseOverText = mouseovertext, helpOverlayID = "shipconfig_slot_" .. group[i][3], helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_slot_" .. group[i][3] }):setText(group[i][3], { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), color = function () return menu.buttonSlotColor(group[i][1], haserror) end })
					if total > 0 then
						local width = math.max(1, math.floor(count * (slotWidths[i] - 2 * menu.scaleSize) / total))
						row[col]:setIcon("solid", { width = width + 2 * Helper.configButtonBorderSize, height = menu.scaleSize + 2 * Helper.configButtonBorderSize, x = menu.scaleSize - Helper.configButtonBorderSize, y = slotWidths[i] - 2 * menu.scaleSize - Helper.configButtonBorderSize })
					end
					if group[i].compatibilities then
						local compatibilitytext = ""
						local j = 0
						for _, entry in ipairs(Helper.equipmentCompatibilities) do
							if group[i].compatibilities[entry.tag] then
								compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. "\27[menu_weaponslot]"
								j = j + 1
							end
							if (j > 0) and (j % 4 == 0) then
								compatibilitytext = compatibilitytext .. "\n"
							end
						end
						-- slotwidth is based on Helper.viewWidth but limited, so we need to reflect that here
						local fontsize = math.floor(config.compatibilityFontSize * Helper.viewWidth / 1920)
						local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
						local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
						fontsize = fontsize * actualSidePanelWidth / reservedSidePanelWidth

						local compatibilityTextHeight = math.ceil(C.GetTextHeight(compatibilitytext, Helper.standardFont, fontsize, 0)) + 2 * Helper.borderSize
						row[col]:setText2(compatibilitytext, { halign = "center", fontsize = fontsize, y = (slotWidths[i] - compatibilityTextHeight) / 2 })
					end
					row[col].handlers.onClick = function () return menu.buttonSelectSlot(group[i][1], row.index, col) end
				end
			end
		end

		if currentSlotInfo.compatibilities then
			local row = ftable:addRow(nil, { fixed = true, scaling = true })
			row[1]:setBackgroundColSpan(11):setColSpan(5):createText(ReadText(1001, 8548) .. ReadText(1001, 120))
			local compatibilitytext = ""
			for _, entry in ipairs(Helper.equipmentCompatibilities) do
				if currentSlotInfo.compatibilities[entry.tag] then
					compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. currentSlotInfo.compatibilities[entry.tag]
				end
			end
			row[6]:setColSpan(6):createText(compatibilitytext, { halign = "right" })
		end

		if next(menu.groupedupgrades) then
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					if upgradetype2.supertype == "group" then
						if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 0) then
							local plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot]
							local slotsize = menu.groups[menu.currentSlot][upgradetype2.grouptype].slotsize

							local name = upgradetype2.headertext.default
							if slotsize ~= "" then
								name = upgradetype2.headertext[slotsize]
							end

							local row = ftable:addRow(nil, { fixed = true, scaling = true })
							row[1]:setBackgroundColSpan(11):setColSpan(5):createText(name .. ReadText(1001, 120))
							if not upgradetype2.mergeslots then
								row[6]:setColSpan(6):createText(plandata.count .. " / " .. menu.groups[menu.currentSlot][upgradetype2.grouptype].total, { halign = "right" })
							else
								row[6]:setColSpan(6):createText(((plandata.macro == "") and 0 or menu.groups[menu.currentSlot][upgradetype2.grouptype].total) .. " / " .. menu.groups[menu.currentSlot][upgradetype2.grouptype].total, { halign = "right" })
							end
						end
					end
				end
			end
		end

		ftable:addEmptyRow(Helper.standardTextHeight / 2)

		-- local editboxheight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
		local rowy = ftable:getFullHeight()
		local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		local issearchandfilteractive = menu.upgradetypeMode ~= "crew" and menu.upgradetypeMode ~= "repair" and menu.upgradetypeMode ~= "settings"
		row[1]:setColSpan(10):createEditBox({ active = issearchandfilteractive, defaultText = ReadText(1001, 3250), scaling = true }):setText("", { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
		row[1].handlers.onEditBoxDeactivated = menu.editboxSearchUpdateText
		menu.equipmentsearch_editboxrow = row.index
		row[11]:createButton({ active = issearchandfilteractive, height = menu.rowHeight }):setIcon("menu_filter")
		menu.equipmentfilter_races_y = menu.slotData.offsetY + rowy + Helper.borderSize
		row[11].handlers.onClick = function () return menu.buttonEquipmentFilter(menu.equipmentfilter_races_y) end

		if #menu.equipmentsearchtext > 0 and issearchandfilteractive then
			table.sort(menu.equipmentsearchtext, function (a, b)
				if a.race == b.race then
					return a.text < b.text
				end
				if (a.race == "generic") or (b.race == "generic") then
					return a.race == "generic"
				end
				return a.text < b.text
			end)
			local row = ftable:addRow((#menu.equipmentsearchtext > 0), { fixed = true })
			local searchindex = 0
			local cols = { 1, 5, 8 }
			for i = 1, math.min(3, #menu.equipmentsearchtext) do
				searchindex = searchindex + 1
				local truncatedString = TruncateText(menu.equipmentsearchtext[i].text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), row[cols[i]]:getWidth() - 3 * Helper.scaleX(10))
				if i < 3 or #menu.equipmentsearchtext <= 3 then
					row[cols[i]]:createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.equipmentsearchtext[i].text) and menu.equipmentsearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				else
					row[cols[i]]:setColSpan(2):createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.equipmentsearchtext[i].text) and menu.equipmentsearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				end
				if menu.equipmentsearchtext[i].race then
					row[cols[i]]:setIcon("menu_filter", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				end
				row[cols[i]].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
			end
			if #menu.equipmentsearchtext > 3 then
				row[10]:setColSpan(2):createText(string.format("%+d", #menu.equipmentsearchtext - 3), { scaling = true })
			end
		end

		local row = ftable:addEmptyRow(Helper.standardTextHeight / 2)
		row.properties.fixed = true

		if next(menu.groupedupgrades) then
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				for i, upgradetype2 in ipairs(Helper.upgradetypes) do
					if upgradetype2.supertype == "group" then
						if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 0) then
							local hasmod, modicon = menu.checkMod(upgradetype2.grouptype, menu.groups[menu.currentSlot][upgradetype2.grouptype].currentcomponent, true)

							local color = Color["text_normal"]
							if upgradetype2.allowempty == false then
								if menu.upgradeplan[upgradetype2.type][menu.currentSlot].macro == "" then
									color = Color["text_error"]
								end
							end
							local plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot]

							local row = ftable:addRow(true, { bgColor = upgradetype2.mergeslots and Color["row_background_blue"] or nil })
							local name = upgradetype2.text.default
							local slotsize = menu.groups[menu.currentSlot][upgradetype2.grouptype].slotsize
							if slotsize ~= "" then
								name = upgradetype2.text[slotsize]
								sizeicon = "be_upgrade_size_" .. slotsize
							end

							if plandata.macro ~= "" then
								name = GetMacroData(plandata.macro, "name")
							end

							if not upgradetype2.mergeslots then
								local scale = {
									min       = 0,
									minSelect = (plandata.macro == "") and 0 or 1,
									max       = menu.groups[menu.currentSlot][upgradetype2.grouptype].total,
								}
								scale.maxSelect = (plandata.macro == "") and 0 or scale.max

								-- handle already installed equipment
								if (plandata.macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) then
									local haslicence = menu.checkLicence(plandata.macro)
									if not haslicence then
										scale.maxSelect = math.min(scale.maxSelect, menu.groups[menu.currentSlot][upgradetype2.grouptype].count)
										menu.upgradeplan[upgradetype2.type][menu.currentSlot].count = math.min(scale.maxSelect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count)
									end
									local j = menu.findUpgradeMacro(upgradetype2.grouptype, plandata.macro)
									if j then
										local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
										if not upgradeware.isFromShipyard then
											scale.maxSelect = math.min(scale.maxSelect, menu.groups[menu.currentSlot][upgradetype2.grouptype].count)
											menu.upgradeplan[upgradetype2.type][menu.currentSlot].count = math.min(scale.maxSelect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count)
										end
									end
								end
								scale.start = math.max(scale.minSelect, math.min(scale.maxSelect, plandata.count))

								local mouseovertext = ""
								if hasmod then
									mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X"
								end

								row[1]:setColSpan(11):createSliderCell({ width = slidercellWidth, height = menu.subHeaderRowHeight, valueColor = Color["slider_value"], min = scale.min, minSelect = scale.minSelect, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, readOnly = hasmod or menu.isReadOnly, mouseOverText = mouseovertext }):setText(name, menu.subHeaderSliderCellTextProperties)
								row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectGroupAmount(upgradetype2.type, menu.currentSlot, row.index, false, ...) end
								row[1].properties.text.color = color
							else
								row[1]:setColSpan(11):createText(name, menu.subHeaderTextProperties)
								row[1].properties.color = color
							end

							if #menu.groupedupgrades[upgradetype2.grouptype] > 0 then
								for _, group in ipairs(menu.groupedupgrades[upgradetype2.grouptype]) do
									local row = ftable:addRow(true, { borderBelow = false })
									local row2 = ftable:addRow(false, {  })
									for i = 1, 3 do
										if group[i] then
											local column = i * 3 - 2
											if i > 1 then
												column = column + 1
											end

											local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(group[i].macro)
											local extraText = ""
											local untruncatedExtraText = ""

											-- handle already installed equipment
											if (group[i].macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (not haslicence) then
												haslicence = true
												mouseovertext = mouseovertext .. "\n" .. ColorText["text_positive"] .. ReadText(1026, 8004)
											end

											local weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
											if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
												weaponicon = "\27[" .. weaponicon .. "]"
											else
												weaponicon = ""
											end
											if compatibility then
												local color = Color["text_normal"]
												for _, entry in ipairs(Helper.equipmentCompatibilities) do
													if entry.tag == compatibility then
														color = entry.color
														break
													end
												end
												weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
											end
											if hasmod then
												mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
											end

											local price
											local hasstock = group[i].macro == ""
											local j = menu.findUpgradeMacro(upgradetype2.grouptype, group[i].macro)
											if j then
												local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]

												local isvolatile = GetWareData(upgradeware.ware, "volatile")
												if isvolatile then
													icon = "\27[bse_venture]"
												end

												if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (not isvolatile) then
													price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
													if upgradetype2.mergeslots then
														price = menu.groups[menu.currentSlot][upgradetype2.grouptype].total * price
													end
												end

												hasstock = upgradeware.isFromShipyard or ((menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro == group[i].macro) and (menu.groups[menu.currentSlot][upgradetype2.grouptype].hasstock ~= false))
											end

											local amounttext = ""
											if upgradetype2.mergeslots and (menu.groups[menu.currentSlot][upgradetype2.grouptype].total > 1) then
												amounttext = menu.groups[menu.currentSlot][upgradetype2.grouptype].total .. ReadText(1001, 42) .. " "
											end
											if group[i].macro ~= "" then
												local name, shortname, infolibrary = GetMacroData(group[i].macro, "name", "shortname", "infolibrary")
												extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. shortname, amounttext .. name, group[i].macro, price)
												AddKnownItem(infolibrary, group[i].macro)
											else
												extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. group[i].name, nil, nil, price)
											end

											local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
											if not haslicence then
												installcolor = Color["text_inactive"]
											elseif (group[i].macro ~= "") then
												if (group[i].macro == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (group[i].macro ~= plandata.macro) then
													installicon = "be_upgrade_uninstalled"
													installcolor = Color["text_negative"]
												elseif (group[i].macro == plandata.macro) then
													installicon = "be_upgrade_installed"
													installcolor = Color["text_positive"]
													if hasmod then
														weaponicon = weaponicon .. " " .. modicon
													end
													if firsttime then
														menu.selectedRows.slots = row.index
														menu.selectedCols.slots = column
														firsttime = nil
													end
												end
											end

											-- start: mycu call-back
											if menu.uix_callbacks ["displaySlots_on_before_create_button_mouseovertext"] then
												for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySlots_on_before_create_button_mouseovertext"]) do
													result = uix_callback (group[i].macro, plandata.macro, mouseovertext)
													if result then
														mouseovertext = result.mouseovertext
													end
												end
											end
											-- end: mycu call-back

											mouseovertext = untruncatedExtraText .. ((mouseovertext ~= "") and ("\n\n" .. mouseovertext) or "")

											local active = ((group[i].macro == plandata.macro) or (not hasmod))
											local useable = hasstock and haslicence
											local overlayid
											if group[i].macro == "" then
												overlayid = "shipconfig_upgrade_empty"
											else
												overlayid = "shipconfig_upgrade_" .. group[i].macro
											end
											row[column]:createButton({
												active = active,
												width = columnWidths[i],
												height = maxColumnWidth,
												mouseOverText = mouseovertext,
												bgColor = useable and Color["button_background_default"] or Color["button_background_inactive"],
												highlightColor = useable and Color["button_highlight_bigbutton"] or Color["button_highlight_inactive"],
												helpOverlayID = overlayid,
												helpOverlayText = " ",
												helpOverlayHighlightOnly = true,
											}):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText(icon, { y = maxColumnWidth / 2 - Helper.scaleY(Helper.standardTextHeight) / 2 - Helper.configButtonBorderSize, halign = "right", color = overridecolor, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
											if useable then
												row[column].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, group[i].macro, row.index, column) end
											end
											if group[i].macro ~= "" then
												row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = upgradetype2.type, name = group[i].name, macro = group[i].macro }, ...) end
											end

											row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = (active and useable) and Color["button_background_default"] or Color["button_background_inactive"], mouseOverText = untruncatedExtraText })
										end
									end
									if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
										maxVisibleHeight = ftable:getFullHeight()
									end
								end
							else
								local row = ftable:addRow(nil, { scaling = true })
								row[1]:setColSpan(11):createText("--- " .. upgradetype2.nonetext.default .. " ---")
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "repair" then
				for k, group in ipairs(menu.groupedupgrades) do
					local row = ftable:addRow(true, { borderBelow = false })
					local row2 = ftable:addRow(false, {  })
					for i = 1, 3 do
						if group[i] then
							local repairslotdata = menu.repairslots[k][i]
							local componentstring = tostring(repairslotdata[4])

							local totalprice = 0
							local mouseovertext = ""
							if menu.objectgroup then
								for j, ship in ipairs(menu.objectgroup.ships) do
									if ship.ship == repairslotdata[4] then
										for k = #menu.objectgroup.shipdata[j].damagedcomponents, 1, -1 do
											local component = menu.objectgroup.shipdata[j].damagedcomponents[k]
											if k ~= #menu.objectgroup.shipdata[j].damagedcomponents then
												mouseovertext = mouseovertext .. "\n"
											end

											local price = tonumber(C.GetRepairPrice(component, menu.container))
											if price then
												totalprice = totalprice + price
											end
											local hull = GetComponentData(ConvertStringTo64Bit(tostring(component)), "hullpercent")
											mouseovertext = mouseovertext .. group[i].name .. " (" .. (100 - hull) .. "% " .. ReadText(1001, 1) .. ")"
										end
										break
									end
								end
							else
								for j = #menu.damagedcomponents, 1, -1 do
									local component = menu.damagedcomponents[j]
									local macro

									if component == menu.object then
										macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
									else
										for _, upgradetype in ipairs(Helper.upgradetypes) do
											if upgradetype.supertype == "macro" then
												if menu.slots[upgradetype.type] then
													for k = 1, #menu.slots[upgradetype.type] do
														if menu.slots[upgradetype.type][k].component == component then
															macro = GetComponentData(ConvertStringTo64Bit(tostring(component)), "macro")
															break
														end
													end
												end
											end
										end
									end
									if macro then
										if j ~= #menu.damagedcomponents then
											mouseovertext = mouseovertext .. "\n"
										end

										local price = tonumber(C.GetRepairPrice(component, menu.container))
										if price then
											totalprice = totalprice + price
										end
										local shortname = GetMacroData(macro, "shortname")
										local hull = GetComponentData(ConvertStringTo64Bit(tostring(component)), "hullpercent")
										mouseovertext = mouseovertext .. shortname .. " (" .. (100 - hull) .. "% " .. ReadText(1001, 1) .. ")"
									end
								end
							end

							if #menu.repairdiscounts > 0 then
								if mouseovertext ~= "" then
									mouseovertext = mouseovertext .. "\n\n"
								end
								mouseovertext = mouseovertext .. ReadText(1001, 2819) .. ReadText(1001, 120)
								for _, entry in ipairs(menu.repairdiscounts) do
									mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. " " .. entry.amount .. " %"
								end
							end

							local name, shortname
							if menu.objectgroup then
								shortname = group[i].name .. "\n" .. ffi.string(C.GetObjectIDCode(group[i].component))
							else
								name, shortname = GetMacroData(group[i].macro, "name", "shortname")
							end
							local extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], shortname, name, group[i].macro, (totalprice > 0) and totalprice * menu.repairdiscounts.totalfactor or nil, repairslotdata[4])

							local color = Color["button_background_default"]
							-- TODO: handle button colors for queued items here.

							local installicon, installcolor = sizeicon or ""
							menu.repairplan[componentstring] = menu.repairplan[componentstring] or {}
							if menu.repairplan[componentstring][componentstring] then
								installicon = "be_upgrade_installed"
								installcolor = Color["text_positive"]
							end

							mouseovertext = untruncatedExtraText .. ((mouseovertext ~= "") and ("\n\n" .. mouseovertext) or "")

							local column = i * 3 - 2
							if i > 1 then
								column = column + 1
							end
							--print("adding button for component: " .. tostring(componentstring) .. " row: " .. tostring(row.index) .. ", col: " .. tostring(column))
							row[column]:createButton({
								width = columnWidths[i],
								height = maxColumnWidth,
								bgColor = color,
								mouseOverText = mouseovertext,
								highlightColor = Color["button_highlight_bigbutton"],
								helpOverlayID = "shipconfig_repair_" .. group[i].macro,
								helpOverlayText = " ",
								helpOverlayHighlightOnly = true,
								uiTriggerID = "shipconfig_repair",
							}):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor })
							row[column].handlers.onClick = function () return menu.buttonSelectRepair(row.index, column, componentstring) end
							row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, mouseOverText = untruncatedExtraText })
						end
					end
					if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
						maxVisibleHeight = ftable:getFullHeight()
					end
				end
			else
				local plandata = menu.upgradeplan[menu.upgradetypeMode][menu.currentSlot]
				local hasmod, modicon = menu.checkMod(upgradetype.type, slots[menu.currentSlot].component)

				for _, group in ipairs(menu.groupedupgrades) do
					local row = ftable:addRow(true, { borderBelow = false })
					local row2 = ftable:addRow(false, {  })
					for i = 1, 3 do
						if group[i] then
							local column = i * 3 - 2
							if i > 1 then
								column = column + 1
							end

							local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(group[i].macro, nil, false)
							local extraText = ""
							local untruncatedExtraText = ""

							-- handle already installed equipment
							if (group[i].macro == slots[menu.currentSlot].currentmacro) and (not haslicence) then
								haslicence = true
								mouseovertext = mouseovertext .. "\n" .. ColorText["text_positive"] .. ReadText(1026, 8004)
							end

							local weaponicon, compatibility
							if upgradetype.supertype == "macro" then
								weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
							end
							if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
								weaponicon = "\27[" .. weaponicon .. "]"
							else
								weaponicon = ""
							end
							if compatibility then
								local color = Color["text_normal"]
								for _, entry in ipairs(Helper.equipmentCompatibilities) do
									if entry.tag == compatibility then
										color = entry.color
										break
									end
								end
								weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
							end
							if hasmod then
								mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
							end

							local price
							local hasstock = group[i].macro == ""
							local j = menu.findUpgradeMacro(upgradetype.type, group[i].macro)
							if j then
								local upgradeware = menu.upgradewares[upgradetype.type][j]
								if upgradeware.ware ~= nil then
									local isvolatile = GetWareData(upgradeware.ware, "volatile")
									if isvolatile then
										icon = "\27[bse_venture]"
									end

									if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (not isvolatile) then
										price = tonumber(C.GetBuildWarePrice(menu.container, upgradeware.ware))
										if upgradetype.mergeslots then
											price = #menu.upgradeplan[upgradetype.type] * price
										end
									end

									hasstock = upgradeware.isFromShipyard or ((slots[menu.currentSlot].currentmacro == group[i].macro) and (slots[menu.currentSlot].hasstock ~= false))
								else
									DebugError("Found upgradeware info for '" .. group[i].macro .. "', but no ware is set. Is it not defined?")
								end
							end

							local amounttext = ""
							if upgradetype.mergeslots and (#menu.upgradeplan[upgradetype.type] > 1) then
								amounttext = #menu.upgradeplan[upgradetype.type] .. ReadText(1001, 42) .. " "
							end
							if group[i].macro ~= "" then
								local name, shortname, infolibrary = GetMacroData(group[i].macro, "name", "shortname", "infolibrary")
								extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. shortname, amounttext .. name, group[i].macro, price, nil, upgradetype.type)
								AddKnownItem(infolibrary, group[i].macro)
							else
								extraText, untruncatedExtraText = menu.getExtraText(columnWidths[i], amounttext .. group[i].name, nil, nil, price)
							end

							local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
							if not haslicence then
								installcolor = Color["text_inactive"]
							else
								if (group[i].macro ~= "") then
									if (group[i].macro == slots[menu.currentSlot].currentmacro) and (group[i].macro ~= plandata.macro) then
										installicon = "be_upgrade_uninstalled"
										installcolor = Color["text_negative"]
									elseif (group[i].macro == plandata.macro) then
										installicon = "be_upgrade_installed"
										installcolor = Color["text_positive"]
										if hasmod then
											weaponicon = weaponicon .. " " .. modicon
										end
										if firsttime then
											menu.selectedRows.slots = row.index
											menu.selectedCols.slots = column
											firsttime = nil
										end
									end
								end
							end

							-- start: mycu call-back
							if menu.uix_callbacks ["displaySlots_on_before_create_button_mouseovertext"] then
								for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySlots_on_before_create_button_mouseovertext"]) do
									result = uix_callback (group[i].macro, plandata.macro, mouseovertext)
									if result then
										mouseovertext = result.mouseovertext
									end
								end
							end
							-- end: mycu call-back

							mouseovertext = untruncatedExtraText .. ((mouseovertext ~= "") and ("\n\n" .. mouseovertext) or "")

							local active = ((group[i].macro == plandata.macro) or (not hasmod))
							local useable = hasstock and haslicence
							local overlayid
							if group[i].macro == "" then
								overlayid = "shipconfig_upgrade_empty"
							else
								overlayid = "shipconfig_upgrade_" .. group[i].macro
							end
							row[column]:createButton({
								active = active,
								width = columnWidths[i],
								height = maxColumnWidth,
								mouseOverText = mouseovertext,
								bgColor = useable and Color["button_background_default"] or Color["button_background_inactive"],
								highlightColor = useable and Color["button_highlight_bigbutton"] or Color["button_highlight_inactive"],
								helpOverlayID = overlayid,
								helpOverlayText = " ",
								helpOverlayHighlightOnly = true,
							}):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText(icon, { y = maxColumnWidth / 2 - Helper.scaleY(Helper.standardTextHeight) / 2 - Helper.configButtonBorderSize, halign = "right", color = overridecolor, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
							if useable then
								row[column].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(menu.upgradetypeMode, menu.currentSlot, group[i].macro, row.index, column, nil, (menu.mode == "customgamestart") or (menu.mode == "comparison")) end
							end
							if group[i].macro ~= "" then
								row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = menu.upgradetypeMode, name = group[i].name, macro = group[i].macro }, ...) end
							end

							row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = (active and useable) and Color["button_background_default"] or Color["button_background_inactive"], mouseOverText = untruncatedExtraText })
						end
					end
					if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
						maxVisibleHeight = ftable:getFullHeight()
					end
				end
			end
		else
			if menu.upgradetypeMode == "consumables" then
				-- ammo
				local titlefirst = true
				for _, upgradetype in ipairs(Helper.upgradetypes) do
					if upgradetype.supertype == "ammo" then
						if next(menu.ammo[upgradetype.type]) then
							local total, capacity = menu.getAmmoUsage(upgradetype.type)
							local display = false
							if (upgradetype.type == "missile") and (menu.mode == "upgrade") then
								display = C.GetNumAllMissiles(menu.object) > 0
							end
							for macro, _ in pairs(menu.ammo[upgradetype.type]) do
								if (total > 0) or menu.isAmmoCompatible(upgradetype.type, macro) then
									display = true
									break
								end
							end

							if ((total > 0) or (capacity > 0)) and display then
								if not titlefirst then
									ftable:addEmptyRow(Helper.standardTextHeight / 2)
								end
								titlefirst = false

								local name = upgradetype.type
								if upgradetype.type == "drone" then
									name = ReadText(1001, 8)
								elseif upgradetype.type == "missile" then
									name = ReadText(1001, 1304)
								elseif upgradetype.type == "deployable" then
									name = ReadText(1001, 1332)		-- "Deployables"
								elseif upgradetype.type == "countermeasure" then
									name = ReadText(1001, 8063)		-- "Countermeasures"
								end

								local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
								row[1]:setColSpan(7):setBackgroundColSpan(10):createText(name, menu.subHeaderTextProperties)
								row[8]:setColSpan(4):createText(total .. "\27X" .. " / " .. capacity, menu.subHeaderTextProperties)
								row[8].properties.halign = "right"
								row[8].properties.color = (total > capacity) and Color["text_error"] or Color["text_normal"]

								local first = true
								local sortedammo = Helper.orderedKeys(menu.ammo[upgradetype.type], menu.sortAmmo)
								for _, macro in ipairs(sortedammo) do
									local macroname, makerrace, makerracename = GetMacroData(macro, "name", "makerraceid", "makerracename")
									for race_i, race in ipairs(makerrace) do
										if (not menu.equipmentfilter_races[race]) then
											menu.equipmentfilter_races[race] = { id = race, name = makerracename[race_i] }
										end
										if (not menu.equipmentfilter_races[race].upgradeTypes) then
											menu.equipmentfilter_races[race].upgradeTypes = {}
										end
										if (not menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode]) then
											menu.equipmentfilter_races[race].upgradeTypes[menu.upgradetypeMode] = true
										end
									end
									if (#menu.equipmentsearchtext == 0) or menu.filterUpgradeByText(menu.upgradetypeMode, macro, menu.equipmentsearchtext) then
										local row = menu.displayAmmoSlot(ftable, upgradetype.type, macro, total, capacity, first)
										first = false
										if (maxVisibleHeight == nil) and row and row.index >= config.maxSlotRows then
											maxVisibleHeight = ftable:getFullHeight()
										end
									end
								end
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "crew" then
				-- crew
				if ((menu.mode == "purchase") or (not menu.usemacro)) and (not menu.isReadOnly) then
					-- total hires on the shoppinglist without current ship
					local totalhiring = 0
					for idx, entry in ipairs(menu.shoppinglist) do
						if idx ~= menu.editingshoppinglist then
							totalhiring = totalhiring + entry.amount * entry.crew.hired
						end
					end
					-- amount of current ship
					local shoppinglistamount = 1
					if menu.editingshoppinglist then
						shoppinglistamount = menu.shoppinglist[menu.editingshoppinglist].amount
					end
					-- still available workforce
					local availableworkforce = menu.crew.availableworkforce + menu.crew.availabledockcrew - menu.addedCrewByPlayerBuildTasks - totalhiring - shoppinglistamount * menu.crew.hired
					-- resources for next resource shift
					local resourceinfos = GetWorkForceRaceResources(ConvertStringTo64Bit(tostring(menu.container)))
					local races = {}
					local n = C.GetNumAllRaces()
					local buf = ffi.new("RaceInfo[?]", n)
					n = C.GetAllRaces(buf, n)
					for i = 0, n - 1 do
						local entry = {}
						entry.id = ffi.string(buf[i].id)
						entry.name = ffi.string(buf[i].name)

						table.insert(races, entry)
					end
					local workforceresources = {}
					for _, race in ipairs(races) do
						local workforceinfo = C.GetWorkForceInfo(menu.container, race.id)
						if workforceinfo.capacity > 0 then
							local resourcedata
							for _, resourceinfo in ipairs(resourceinfos) do
								if resourceinfo.race == race.id then
									resourcedata = resourceinfo
								end
							end
							for i, resource in ipairs(resourcedata.resources) do
								local amount = Helper.round(resource.cycle * workforceinfo.current / resourcedata.productamount)
								if workforceresources[resource.ware] then
									workforceresources[resource.ware] = workforceresources[resource.ware] + amount
								else
									workforceresources[resource.ware] = amount
								end
							end
						end
					end
					-- compare with station cargo
					local resourceerror
					local cargo = GetComponentData(ConvertStringTo64Bit(tostring(menu.container)), "cargo")
					for ware, amount in pairs(workforceresources) do
						if (cargo[ware] or 0) < amount then
							resourceerror = ReadText(1001, 8540)
							break
						end
					end

					local errormessage, errorcolor
					local color = Color["text_normal"]
					if availableworkforce < 0 then
						errormessage = C.IsComponentClass(menu.container, "station") and ReadText(1001, 8541) or ReadText(1001, 8545)
						errorcolor = Color["text_error"]
						color = Color["text_error"]
					elseif menu.crew.availableworkforce + menu.crew.availabledockcrew - totalhiring < shoppinglistamount * menu.crew.capacity then
						errormessage = C.IsComponentClass(menu.container, "station") and ReadText(1001, 8538) or ReadText(1001, 8544)
						errorcolor = Color["text_warning"]
						color = Color["text_warning"]
					end

					local row = ftable:addRow(nil, {  })
					row[1]:setColSpan(11):createText(C.IsComponentClass(menu.container, "station") and ReadText(1001, 8542) or ReadText(1001, 8543), menu.subHeaderTextProperties)

					local row = ftable:addRow(false, { scaling = true })
					row[1]:setColSpan(8):createText(string.format(ReadText(1001, 8024), ffi.string(C.GetComponentName(menu.container))), { mouseOverText = menu.isplayerowned and "" or (ReadText(1001, 2808) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(menu.crew.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101)) })
					row[9]:setColSpan(3):createText(math.max(0, availableworkforce), { halign = "right", color = color })

					if menu.mode == "purchase" then
						local row = ftable:addRow(nil, { scaling = true })
						row[1]:setColSpan(11):createText(ReadText(1001, 8539), { wordwrap = true })
					end

					if errormessage then
						local row = ftable:addRow(nil, { scaling = true })
						row[1]:setColSpan(11):createText(errormessage, { wordwrap = true, color = errorcolor })
					end
					if resourceerror then
						local row = ftable:addRow(nil, { scaling = true })
						row[1]:setColSpan(11):createText(resourceerror, { wordwrap = true, color = Color["text_warning"] })
					end

					local row = ftable:addRow(false, { scaling = true })
					row[1]:setColSpan(11):createText("")
				end

				local isbigship = (menu.class == "ship_m") or (menu.class == "ship_l") or (menu.class == "ship_xl")
				if menu.mode == "customgamestart" then
					if menu.modeparam.shippilotproperty or menu.modeparam.playerpropertyid then
						local value = 0
						if next(menu.customgamestartpilot) then
							local skills = {}
							for skill, value in pairs(menu.customgamestartpilot.skills or {}) do
								table.insert(skills, { id = skill, value = value })
							end
							local buf = ffi.new("CustomGameStartPersonEntry")
							buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
							buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
							buf.numskills = #skills
							buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
							for i, entry in ipairs(skills) do
								buf.skills[i - 1].id = Helper.ffiNewString(entry.id)
								buf.skills[i - 1].value = entry.value
							end
							value = tonumber(C.GetCustomGameStartShipPersonValue(menu.modeparam.gamestartid, buf))
						end

						local row = ftable:addRow(nil, {  })
						if menu.modeparam.creative then
							row[1]:setColSpan(11):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), menu.subHeaderTextProperties)
						else
							row[1]:setColSpan(7):setBackgroundColSpan(11):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), menu.subHeaderTextProperties)
							row[8]:setColSpan(4):createText(ConvertIntegerString(value, true, 0, true)  .. " " .. ColorText["customgamestart_budget_people"] .. "\27[gamestart_custom_people]", menu.subHeaderTextProperties)
							row[8].properties.halign = "right"
						end

						local raceoptions = {}
						local n = C.GetNumAllRaces()
						local buf = ffi.new("RaceInfo[?]", n)
						n = C.GetAllRaces(buf, n)
						for i = 0, n - 1 do
							local id = ffi.string(buf[i].id)
							local name = ffi.string(buf[i].name)
							if C.CanPlayerUseRace(id, "aipilot") then
								table.insert(raceoptions, { id = id, text = name, icon = "", displayremoveoption = false })
							end
						end
						table.sort(raceoptions, function (a, b) return a.text < b.text end)
						table.insert(raceoptions, 1, { id = "any", text = ReadText(1001, 9930), icon = "", displayremoveoption = false })

						local row = ftable:addRow(true, { scaling = true })
						row[1]:setColSpan(11):createDropDown(raceoptions, { startOption = (menu.customgamestartpilot.race and (menu.customgamestartpilot.race ~= "")) and menu.customgamestartpilot.race or "any", height = Helper.standardTextHeight, x = Helper.standardTextOffsetx })
						row[1].handlers.onDropDownConfirmed = function(_, raceid) if raceid == "any" then menu.customgamestartpilot.race = "" else menu.customgamestartpilot.race = raceid end; menu.refreshMenu() end

						ftable:addEmptyRow(Helper.standardTextHeight / 2)

						local numskills = C.GetNumSkills()
						local buf = ffi.new("SkillInfo[?]", numskills)
						numskills = C.GetSkills(buf, numskills)
						for i = 0, numskills - 1 do
							local id = ffi.string(buf[i].id)

							local row = ftable:addRow(true, { scaling = true })
							row[1]:setColSpan(11):createSliderCell({ height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = 0, max = 15, start = menu.customgamestartpilot.skills and menu.customgamestartpilot.skills[id] or 0, step = 1 }):setText(ReadText(1013, buf[i].textid))
							row[1].handlers.onSliderCellChanged = function(_, newamount) if menu.customgamestartpilot.skills then menu.customgamestartpilot.skills[id] = newamount else menu.customgamestartpilot.skills = { [id] = newamount } end end
						end

						ftable:addEmptyRow()
					end
				end

				if (menu.mode ~= "customgamestart") or (menu.crew.capacity > 0) then
					local row = ftable:addRow(menu.mode ~= "customgamestart", {  })
					row[1]:setColSpan(7):setBackgroundColSpan(9):createText(ReadText(1001, 80), menu.subHeaderTextProperties)
					-- include the +1 for the captain
					if menu.mode ~= "customgamestart" then
						row[8]:setColSpan(3):createText((menu.crew.total + menu.crew.hired - #menu.crew.fired + (menu.captainSelected and 1 or 0)) .. " / " .. (menu.crew.capacity + 1), menu.subHeaderTextProperties)
						row[8].properties.halign = "right"
						row[11]:createButton({ active = (not menu.isReadOnly), mouseOverText = ReadText(1026, 8001), height = menu.rowHeight, y = math.max(0, row:getHeight() - menu.rowHeight) }):setIcon("menu_reset")
						row[11].handlers.onClick = menu.buttonResetCrew
					elseif not menu.modeparam.creative then
						local value = tonumber(C.GetCustomGameStartShipPeopleValue2(menu.modeparam.gamestartid, menu.macro, menu.customgamestartpeopledef, menu.customgamestartpeoplefillpercentage))

						row[8]:setColSpan(4):createText(ConvertIntegerString(value, true, 0, true)  .. " " .. ColorText["customgamestart_budget_people"] .. "\27[gamestart_custom_people]", menu.subHeaderTextProperties)
						row[8].properties.halign = "right"
					else
						row[8]:setColSpan(4):createText(" ", menu.subHeaderTextProperties)
					end
				end

				if menu.mode ~= "customgamestart" then
					local row = ftable:addRow(true, { scaling = true })
					row[1]:setColSpan(1):createCheckBox(menu.captainSelected, { scaling = false, active = (menu.mode == "purchase") and (not menu.captainSelected), width = menu.rowHeight, height = menu.rowHeight, helpOverlayID = "shipconfig_crew_captain", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_crew_captain" })
					row[1].handlers.onClick = function () return menu.checkboxSelectCaptain(row.index) end
					row[2]:setColSpan(7):createText(isbigship and ReadText(1001, 4848) or ReadText(1001, 4847), { color = ((menu.mode ~= "purchase") or menu.captainSelected) and Color["text_normal"] or Color["text_error"] })
					if menu.usemacro then
						row[9]:setColSpan(3):createText(ReadText(1001, 8047), { halign = "right", color = menu.captainSelected and Color["text_normal"] or Color["text_error"] })
					end
				end

				if menu.crew.capacity > 0 then
					if menu.mode == "customgamestart" then
						local peopleoptions = {}
						local n = C.GetNumPlayerPeopleDefinitions()
						local buf = ffi.new("PeopleDefinitionInfo[?]", n)
						n = C.GetPlayerPeopleDefinitions(buf, n)
						for i = 0, n - 1 do
							table.insert(peopleoptions, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false, mouseovertext = ffi.string(buf[i].desc) })
						end
						table.sort(peopleoptions, function (a, b) return a.text < b.text end)
						table.insert(peopleoptions, 1, { id = "none", text = ReadText(1001, 9931), icon = "", displayremoveoption = false })

						local row = ftable:addRow(true, { scaling = true })
						row[1]:setColSpan(11):createDropDown(peopleoptions, { startOption = (menu.customgamestartpeopledef and (menu.customgamestartpeopledef ~= "")) and menu.customgamestartpeopledef or "none", height = Helper.standardTextHeight, x = Helper.standardTextOffsetx })
						row[1].handlers.onDropDownConfirmed = function(_, peopledefid) if peopledefid == "none" then menu.customgamestartpeopledef = "" else menu.customgamestartpeopledef = peopledefid end; menu.refreshMenu() end

						local row = ftable:addRow(true, { scaling = true })
						row[1]:setColSpan(11):createSliderCell({ height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = 0, max = menu.crew.capacity, start = (menu.customgamestartpeopledef == "") and 0 or Helper.round(menu.crew.capacity * menu.customgamestartpeoplefillpercentage / 100), step = 1, readOnly = menu.customgamestartpeopledef == "" }):setText(ReadText(1001, 47))
						row[1].handlers.onSliderCellChanged = function(_, newamount) menu.customgamestartpeoplefillpercentage = newamount / menu.crew.capacity * 100 end
					else
						local row = ftable:addRow(false, { scaling = true })
						row[1]:setColSpan(11):createText("")

						if (not menu.usemacro) and (not menu.isReadOnly) then
							local color = Color["text_normal"]
							if #menu.crew.unassigned > 0 then
								color = Color["text_error"]
							end

							local row = ftable:addRow(true, { scaling = true })
							row[1]:setColSpan(7):createText(ReadText(1001, 8025))
							row[8]:setColSpan(3):createText(#menu.crew.unassigned, { halign = "right", color = color })
							row[11]:createButton({ active = (not menu.isReadOnly), mouseOverText = ReadText(1026, 8002) }):setIcon("menu_dismiss")
							row[11].handlers.onClick = menu.buttonFireCrew
						end

						local first = true
						for i, entry in ipairs(menu.crew.roles) do
							local row = menu.displayCrewSlot(ftable, i, entry, buttonWidth, menu.crew.price, first)
							first = false
							if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
								maxVisibleHeight = ftable:getFullHeight()
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "software" then
				-- software
				local first = true
				if menu.software[menu.upgradetypeMode] then
					for slot, slotdata in ipairs(menu.software[menu.upgradetypeMode]) do
						if #slotdata.possiblesoftware > 0 then
							if first then
								first = false
							else
								local row = ftable:addRow(false, {  })
								row[1]:setColSpan(11):createText(" ")
							end
							local row = menu.displaySoftwareSlot(ftable, menu.upgradetypeMode, slot, slotdata)
							if (maxVisibleHeight == nil) and row.index >= config.maxSlotRows then
								maxVisibleHeight = ftable:getFullHeight()
							end
						end
					end
				end
			elseif menu.upgradetypeMode == "settings" then
				-- settings
				-- blacklists
				local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
				row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 9143), menu.subHeaderTextProperties)

				local blacklists = Helper.getBlackLists()

				local purpose = GetMacroData(menu.macro, "primarypurpose")
				local group = ((purpose == "fight") or (purpose == "auxiliary")) and "military" or "civilian"
				local types = {
					{ type = "sectortravel",	name = ReadText(1001, 9165) },
					{ type = "sectoractivity",	name = ReadText(1001, 9166) },
					{ type = "objectactivity",	name = ReadText(1001, 9167) },
				}
				for i, entry in ipairs(types) do
					row = ftable:addRow(false, { scaling = true })
					row[1]:setColSpan(11):createText(entry.name .. ReadText(1001, 120))

					local hasownlist = false
					local currentblacklistid = 0
					if menu.object then
						hasownlist = C.HasControllableOwnBlacklist(menu.object, entry.type)
						currentblacklistid = C.GetControllableBlacklistID(menu.object, entry.type, group)
					end
					menu.settings.blacklists[entry.type] = menu.settings.blacklists[entry.type] or (hasownlist and currentblacklistid or 0)

					local rowdata = "orders_blacklist_" .. entry.type .. "_global"
					local row = ftable:addRow({ rowdata }, { scaling = true })
					row[1]:setColSpan(1):createCheckBox(menu.settings.blacklists[entry.type] == 0, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
					row[1].handlers.onClick = function(_, checked) menu.settings.blacklists[entry.type] = checked and 0 or -1; menu.refreshMenu() end
					row[2]:setColSpan(10):createText(ReadText(1001, 8367))

					local locresponses = {
						{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
					}

					local defaultblacklistid = -1
					for _, blacklist in ipairs(blacklists) do
						if blacklist.type == entry.type then
							if blacklist.defaults[group] then
								defaultblacklistid = blacklist.id
							end
							table.insert(locresponses, { id = blacklist.id, text = blacklist.name, icon = "", displayremoveoption = false })
						end
					end
					local row = ftable:addRow("orders_resupply", { scaling = true })
					row[1]:setColSpan(10):createDropDown(locresponses, { startOption = (menu.settings.blacklists[entry.type] ~= 0) and menu.settings.blacklists[entry.type] or defaultblacklistid, active = menu.settings.blacklists[entry.type] ~= 0 })
					row[1].handlers.onDropDownConfirmed = function (_, id) menu.settings.blacklists[entry.type] = tonumber(id) end
					row[11]:createButton({ mouseOverText = ReadText(1026, 8413) }):setIcon("menu_edit")
					row[11].handlers.onClick = function () return menu.buttonEditBlacklist((menu.settings.blacklists[entry.type] ~= 0) and menu.settings.blacklists[entry.type] or defaultblacklistid) end

					ftable:addEmptyRow()
				end

				-- fight rules
				local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
				row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 7753), menu.subHeaderTextProperties)

				local fightrules = Helper.getFightRules()

				local hasownlist = false
				local currentfightruleid = 0
				if menu.object then
					hasownlist = C.HasControllableOwnFightRule(menu.object, "attack")
					currentfightruleid = C.GetControllableFightRuleID(menu.object, "attack")
				end
				menu.settings.fightrules["attack"] = menu.settings.fightrules["attack"] or (hasownlist and currentfightruleid or 0)

				local rowdata = "orders_fightrule_attack_global"
				local row = ftable:addRow({ rowdata }, { scaling = true })
				row[1]:setColSpan(1):createCheckBox(menu.settings.fightrules["attack"] == 0, { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				row[1].handlers.onClick = function(_, checked) menu.settings.fightrules["attack"] = checked and 0 or -1; menu.refreshMenu() end
				row[2]:setColSpan(10):createText(ReadText(1001, 8367))

				local locresponses = {
					{ id = -1, text = ReadText(1001, 7726), icon = "", displayremoveoption = false },
				}

				local defaultfightruleid = -1
				for _, fightrule in ipairs(fightrules) do
					if fightrule.defaults["attack"] then
						defaultfightruleid = fightrule.id
					end
					table.insert(locresponses, { id = fightrule.id, text = fightrule.name, icon = "", displayremoveoption = false })
				end
				local row = ftable:addRow("orders_resupply", { scaling = true })
				row[1]:setColSpan(10):createDropDown(locresponses, { startOption = (menu.settings.fightrules["attack"] ~= 0) and menu.settings.fightrules["attack"] or defaultfightruleid, active = menu.settings.fightrules["attack"] ~= 0 })
				row[1].handlers.onDropDownConfirmed = function (_, id) menu.settings.fightrules["attack"] = tonumber(id) end
				row[11]:createButton({ mouseOverText = ReadText(1026, 8414) }):setIcon("menu_edit")
				row[11].handlers.onClick = function () return menu.buttonEditFightRule((menu.settings.fightrules["attack"] ~= 0) and menu.settings.fightrules["attack"] or defaultfightruleid) end

				-- missile launchers
				local hasmissilelauncher = false
				for slot, data in pairs(menu.upgradeplan.weapon) do
					if data.macro ~= "" then
						if IsMacroClass(data.macro, "missilelauncher") then
							hasmissilelauncher = true
							break
						end
					end
				end
				if hasmissilelauncher then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 9030), menu.subHeaderTextProperties)
					for slot, data in pairs(menu.upgradeplan.weapon) do
						if data.macro ~= "" then
							if IsMacroClass(data.macro, "missilelauncher") then
								menu.displayWeaponAmmoSelection(ftable, "weapon", slot, data)
							end
						end
					end
				end
				-- turrets
				local hasindividualturrets = false
				for slot, data in pairs(menu.upgradeplan.turret) do
					if data.macro ~= "" then
						hasindividualturrets = true
						break
					end
				end
				if hasindividualturrets then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 1319), menu.subHeaderTextProperties)
					for slot, data in pairs(menu.upgradeplan.turret) do
						if data.macro ~= "" then
							menu.displayWeaponModeSelection(ftable, "turret", slot, data)
						end
					end
				end
				-- turret groups
				if next(menu.upgradeplan.turretgroup) then
					ftable:addEmptyRow()

					local row = ftable:addRow(false, { bgColor = Color["player_info_background"] })
					row[1]:setColSpan(11):setBackgroundColSpan(10):createText(ReadText(1001, 7901), menu.subHeaderTextProperties)
					for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
						if groupdata.macro ~= "" then
							menu.displayWeaponModeSelection(ftable, "turretgroup", slot, groupdata)
						end
					end
				end
			end
		end

		if maxVisibleHeight ~= nil then
			ftable.properties.maxVisibleHeight = maxVisibleHeight
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)

		ftable:addConnection(1, 2, true)
	else
		Helper.clearTableConnectionColumn(menu, 2)
	end

	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.getExtraText(columnwidth, basetext, fullbasetext, macro, price, component, upgradetype)
	local extraText = ""
	local untruncatedExtraText = ""
	if price then
		extraText = ConvertMoneyString(price, false, true, 3, true) .. " " .. ReadText(1001, 101)
	end
	if macro then
		local makerrace, mk = GetMacroData(macro, "makerrace", "mk")
		local extraText2 = ""
		if component then
			local class = ffi.string(C.GetComponentClass(component))
			if (class == "weapon") or (class == "missilelauncher") then
				if mk > 0 then
					extraText2 = ReadText(20111, 100 * mk + 1)
				end
			end
		end
		if upgradetype == "weapon" then
			if mk > 0 then
				extraText2 = ReadText(20111, 100 * mk + 1)
			end
		end
		for _, racestring in ipairs(makerrace) do
			extraText2 = racestring .. ((extraText2 ~= "") and " - " or "") .. extraText2
		end

		local separator = ((extraText2 ~= "") and (extraText ~= "")) and "\n" or ""
		local untruncatedExtraText2
		if fullbasetext == nil then
			untruncatedExtraText2 = extraText2 .. separator .. extraText
		else
			untruncatedExtraText2 = extraText
		end
		untruncatedExtraText = (fullbasetext or basetext) .. ((untruncatedExtraText2 ~= "") and ("\n" .. untruncatedExtraText2) or "")
		extraText = extraText2 .. separator .. extraText
		local truncatedtext = TruncateText(basetext, Helper.standardFont, menu.extraFontSize, columnwidth - 2 * Helper.borderSize)
		extraText = truncatedtext .. "\n" .. extraText
	else
		untruncatedExtraText = (fullbasetext or basetext) .. ((extraText ~= "") and ("\n" .. extraText) or "")
		if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			extraText = "\n" .. extraText
		end
		local truncatedtext = TruncateText(basetext, Helper.standardFont, menu.extraFontSize, columnwidth - 2 * Helper.borderSize)
		extraText = truncatedtext .. "\n" .. extraText
	end
	return extraText, untruncatedExtraText
end

function menu.displayWeaponAmmoSelection(ftable, upgradetype, slot, data)
	local dropdowndata = {}
	for macro, _ in pairs(menu.ammo["missile"]) do
		if C.IsAmmoMacroCompatible(data.macro, macro) then
			table.insert(dropdowndata, {id = macro, text = GetMacroData(macro, "name"), icon = "", displayremoveoption = false})
		end
	end

	local row = ftable:addRow("ammo_config", { scaling = true })
	local name = GetMacroData(data.macro, "name")
	if upgradetype == "turretgroup" then
		name = menu.groups[slot].groupname .. " - " .. name
	else
		name = menu.slots[upgradetype][slot].slotname .. " - " .. name
	end
	row[1]:setColSpan(6):createText(name)
	row[7]:setColSpan(5):createDropDown(dropdowndata, { startOption = data.ammomacro })
	row[7].handlers.onDropDownConfirmed = function(_, newammomacro) menu.upgradeplan[upgradetype][slot].ammomacro = newammomacro end
end

function menu.displayWeaponModeSelection(ftable, upgradetype, slot, data)
	local row = ftable:addRow("ammo_config", { scaling = true })
	local name = GetMacroData(data.macro, "name")
	if upgradetype == "turretgroup" then
		name = menu.groups[slot].groupname .. " - " .. name
	else
		name = menu.slots[upgradetype][slot].slotname .. " - " .. name
	end
	row[1]:setColSpan(6):createText(name)
	row[7]:setColSpan(5):createDropDown(Helper.getMacroTurretModes(data.macro), { startOption = data.weaponmode })
	row[7].handlers.onDropDownConfirmed = function(_, newturretmode) menu.upgradeplan[upgradetype][slot].weaponmode = newturretmode end
end

function menu.displayModifySlots(frame)
	if menu.upgradetypeMode then
		local slotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)
		local modIconWidth = C.GetTextWidth("\27[" .. Helper.modQualities[3].icon2 .. "]", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)) + 2 * Helper.scaleX(Helper.standardTextOffsetx)

		local ftable = frame:addTable(8, { tabOrder = 1, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		ftable:setColWidth(1, Helper.scaleX(Helper.standardTextHeight))
		ftable:setColWidth(2, slotWidth - Helper.scaleX(Helper.standardTextHeight) - Helper.borderSize)
		ftable:setColWidth(3, slotWidth)
		ftable:setColWidth(4, slotWidth)
		ftable:setColWidth(6, menu.slotData.width * 2 / 9)
		ftable:setColWidth(7, menu.slotData.width * 1 / 9)
		ftable:setColWidth(8, modIconWidth)
		ftable:setDefaultBackgroundColSpan(1, 8)

		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(8):createText(ReadText(1001, 8031), menu.headerTextProperties)

		local row = ftable:addRow(true, { fixed = true })
		for i, entry in ipairs(Helper.modQualities) do
			local col = i
			if i > 1 then
				col = col + 1
			end

			local bgColor = Color["button_background_default"]
			if entry.category == menu.modCategory then
				bgColor = Color["row_background_selected"]
			end

			row[col]:setColSpan((i == 1) and 2 or 1):createButton({ height = slotWidth, mouseOverText = entry.name, bgColor = bgColor }):setIcon(entry.icon)
			row[col].handlers.onClick = function () return menu.buttonModCategory(entry.category, row.index, col) end
		end
		row[6]:setColSpan(3)

		if menu.object ~= 0 then
			local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
			if next(entry) then
				if entry.upgrademode == "ship" then
					menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, 1)
				elseif entry.upgrademode == "shield" then
					table.sort(menu.shieldgroups, Helper.sortSlots)
					for i, shieldgroupdata in ipairs(menu.shieldgroups) do
						menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, i, shieldgroupdata)
					end
				elseif (entry.upgrademode == "turret") and next(menu.groups) then
					table.sort(menu.shieldgroups, Helper.sortSlots)
					for i, shieldgroupdata in ipairs(menu.shieldgroups) do
						menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, i, shieldgroupdata, true)
					end
				else
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)

					if upgradetype.mergeslots then
						local slotdata = menu.slots[entry.upgrademode][1]
						if slotdata.currentmacro ~= "" then
							menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, 1, slotdata)
						end
					else
						for slot, slotdata in ipairs(menu.slots[entry.upgrademode]) do
							if slotdata.currentmacro ~= "" then
								menu.displayModSlot(ftable, entry.upgrademode, entry.modclass, slot, slotdata)
							end
						end
					end
				end
			end
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)

		ftable:addConnection(1, 2, true)
	else
		Helper.clearTableConnectionColumn(menu, 2)
	end
	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.displayModifyPaintSlots(frame)
	if menu.upgradetypeMode then
		local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
		-- available mods
		local categoryQuality = menu.getModQuality(menu.modCategory)
		if not categoryQuality then
			DebugError(string.format("Could not resolve mod category '%s' to quality level. Check Helper.modQualities [Florian]", menu.modCategory))
			return
		end

		if not menu.selectedPaintMod then
			if menu.modeparam[1] and (#menu.selectableships > 1) then
				menu.selectedPaintMod = menu.defaultpaintmod
			elseif menu.installedPaintMod then
				menu.selectedPaintMod = menu.installedPaintMod
			else
				menu.selectedPaintMod = menu.defaultpaintmod
			end
		end

		local count = 0
		menu.paintmodgroups = {}

		if categoryQuality == 1 then
			if menu.defaultpaintmod then
				count = count + 1
				local group = math.ceil(count / 3)
				if menu.paintmodgroups[group] then
					table.insert(menu.paintmodgroups[group], menu.defaultpaintmod)
				else
					menu.paintmodgroups[group] = { menu.defaultpaintmod }
				end
			end
		end

		if menu.modwares[entry.modclass] then
			for _, entry in ipairs(menu.modwares[entry.modclass]) do
				if (entry.quality == categoryQuality) and ((menu.defaultpaintmod == nil) or (entry.ware ~= menu.defaultpaintmod.ware)) then
					count = count + 1
					local group = math.ceil(count / 3)
					if menu.paintmodgroups[group] then
						table.insert(menu.paintmodgroups[group], entry)
					else
						menu.paintmodgroups[group] = { entry }
					end
				end
			end
		end

		local offsety = Helper.viewHeight - Helper.frameBorder
		local buttontable
		if (menu.mode == "modify") or (menu.mode == "upgrade") then
			buttontable = frame:addTable(3, { tabOrder = 9, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = 0, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			buttontable:setColWidth(1, Helper.standardTextHeight)
			buttontable:setColWidthPercent(3, 40)

			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(3):createText(ReadText(1001, 8550), menu.headerTextProperties)

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText(menu.installedPaintMod and (menu.installedPaintMod.isdefault and ReadText(1001, 8516) or menu.installedPaintMod.name) or "", { color =  menu.installedPaintMod and Helper.modQualities[menu.installedPaintMod.quality].color or Color["text_normal"] })

			local row = buttontable:addRow(true, { fixed = true })
			local islocked = false
			if menu.object ~= 0 then
				islocked = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "paintmodlocked")
			end
			row[1]:createCheckBox(islocked, { active = true })
			row[1].handlers.onClick = function () return C.SetPaintModLocked(menu.object, not islocked) end
			row[2]:setColSpan(2):createText(ReadText(1001, 8551))

			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(3):createText(ReadText(1001, 8514), menu.headerTextProperties)

			local active = menu.selectedPaintMod ~= nil
			local missingcount
			if menu.selectedPaintMod then
				if (menu.mode == "modify") and menu.modeparam[1] then
					missingcount = 0
					for _, ship in pairs(menu.modeparam[2]) do
						local paintmod = ffi.new("UIPaintMod")
						if C.GetInstalledPaintMod(ship, paintmod) then
							if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
								missingcount = missingcount + 1
							end
						else
							missingcount = missingcount + 1
						end
					end
					if (missingcount == 0) or ((not menu.selectedPaintMod.isdefault) and (missingcount > menu.selectedPaintMod.amount)) then
						active = false
					end
				elseif menu.objectgroup then
					local missingcount = 0
					for i, ship in ipairs(menu.objectgroup.ships) do
						local paintmod = ffi.new("UIPaintMod")
						if C.GetInstalledPaintMod(ship.ship, paintmod) then
							if menu.selectedPaintMod.ware ~= ffi.string(paintmod.Ware) then
								missingcount = missingcount + 1
							end
						else
							missingcount = missingcount + 1
						end
					end
					if (missingcount == 0) or ((not menu.selectedPaintMod.isdefault) and (missingcount > menu.selectedPaintMod.amount)) then
						active = false
					end
				else
					active = menu.selectedPaintMod.ware ~= (menu.installedPaintMod and menu.installedPaintMod.ware or "")
				end
			end

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:setColSpan(3):createText(menu.selectedPaintMod and (menu.selectedPaintMod.isdefault and ReadText(1001, 8516) or (((missingcount and (missingcount > 0)) and (missingcount .. ReadText(1001, 42) .. " ") or "") .. menu.selectedPaintMod.name)) or "", { color =  menu.selectedPaintMod and Helper.modQualities[menu.selectedPaintMod.quality].color or Color["text_normal"] })

			local row = buttontable:addRow(true, { fixed = true })
			row[3]:createButton({ active = active }):setText(ReadText(1001, 4803), { halign = "center" })
			row[3].handlers.onClick = menu.buttonInstallPaintMod

			buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - Helper.frameBorder
			offsety = buttontable.properties.y
		end

		menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
		local maxSlotWidth = math.floor((menu.slotData.width - 8 * Helper.borderSize) / 9)
		local boxTextHeight = math.ceil(C.GetTextHeight(" ", Helper.standardFont, menu.extraFontSize, 0)) + 2 * Helper.borderSize
		local headerHeight = menu.titleData.height + (maxSlotWidth + Helper.borderSize) + 2 * Helper.borderSize
		--[[ Keep for simpler debugging
			print((buttontable.properties.y - menu.slotData.offsetY) .. " vs " .. (headerHeight + #menu.paintmodgroups * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight)))
			print(headerHeight)
			print(boxTextHeight)
			print(#menu.paintmodgroups .. " * " .. 3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) --]]
		if (offsety - menu.slotData.offsetY) < (headerHeight + #menu.paintmodgroups * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight)) then
			hasScrollbar = true
		end

		local slotWidth = maxSlotWidth - math.floor((hasScrollbar and Helper.scrollbarWidth or 0) / 9)
		local extraPixels = (menu.slotData.width - 8 * Helper.borderSize) % 9
		local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
		if extraPixels > 0 then
			for i = 1, extraPixels do
				slotWidths[i] = slotWidths[i] + 1
			end
		end
		columnWidths = {}
		maxColumnWidth = 0
		for i = 1, 3 do
			columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
			maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
		end

		local ftable = frame:addTable(9, { tabOrder = 1, width = menu.slotData.width, maxVisibleHeight = offsety - menu.slotData.offsetY, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = false, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"], highlightMode = "column" })
		if menu.setdefaulttable then
			ftable.properties.defaultInteractiveObject = true
			menu.setdefaulttable = nil
		end
		for i = 1, 8 do
			ftable:setColWidth(i, slotWidths[i])
		end

		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(9):createText(ReadText(1001, 8031), menu.headerTextProperties)

		local row = ftable:addRow(true, { fixed = true })
		for i, entry in ipairs(Helper.modQualities) do
			local col = i

			local bgColor = Color["button_background_default"]
			if entry.category == menu.modCategory then
				bgColor = Color["row_background_selected"]
			end

			row[col]:createButton({ height = slotWidth, mouseOverText = entry.name, bgColor = bgColor }):setIcon(entry.icon)
			row[col].handlers.onClick = function () return menu.buttonModCategory(entry.category, row.index, col) end
		end

		if next(menu.paintmodgroups) then
			local shoppinglistpaintmods = {}
			if menu.mode == "purchase" then
				for i, entry in ipairs(menu.shoppinglist) do
					if i ~= menu.editingshoppinglist then
						if entry.paintmodware then
							shoppinglistpaintmods[entry.paintmodware] = (shoppinglistpaintmods[entry.paintmodware] or 0) + entry.amount
						end
					end
				end
			end

			for _, group in ipairs(menu.paintmodgroups) do
				local row = ftable:addRow(true, { borderBelow = false })
				local row2 = ftable:addRow(false, {  })
				for i, entry in ipairs(group) do
					local col = i * 3 - 2

					local amount = (entry.amount or 0) - (shoppinglistpaintmods[entry.ware] or 0)
					local active, overridecolor = entry.isdefault or (amount >= (menu.shoppinglist[menu.editingshoppinglist] and menu.shoppinglist[menu.editingshoppinglist].amount or 1)), nil
					if (menu.mode == "modify") and menu.modeparam[1] then
						local missingcount = 0
						for _, ship in pairs(menu.modeparam[2]) do
							local paintmod = ffi.new("UIPaintMod")
							if C.GetInstalledPaintMod(ship, paintmod) then
								if entry.ware ~= ffi.string(paintmod.Ware) then
									missingcount = missingcount + 1
								end
							else
								missingcount = missingcount + 1
							end
						end
						if (not entry.isdefault) and (missingcount > amount) then
							active = false
							overridecolor = Color["text_error"]
						end
					elseif menu.objectgroup then
						local missingcount = 0
						for i, ship in ipairs(menu.objectgroup.ships) do
							local paintmod = ffi.new("UIPaintMod")
							if C.GetInstalledPaintMod(ship.ship, paintmod) then
								if entry.ware ~= ffi.string(paintmod.Ware) then
									missingcount = missingcount + 1
								end
							else
								missingcount = missingcount + 1
							end
						end
						if (not entry.isdefault) and (missingcount > amount) then
							active = false
							overridecolor = Color["text_error"]
						end
					end

					local installicon, installcolor = "", Color["text_normal"]
					if entry.ware == menu.selectedPaintMod.ware then
						installicon = "be_upgrade_installed"
						installcolor = Color["text_positive"]
					elseif menu.installedPaintMod and (entry.ware == menu.installedPaintMod.ware) then
						installicon = "be_upgrade_uninstalled"
						installcolor = Color["text_negative"]
					end

					row[col]:setColSpan(3):createButton({
						width = columnWidths[i],
						height = maxColumnWidth,
						bgColor = active and Color["button_background_default"] or Color["button_background_inactive"],
						highlightColor = active and Color["button_highlight_default"] or Color["button_highlight_inactive"],
					}):setIcon(entry.ware):setIcon2(installicon, { color = installcolor }):setText((amount > 0) and (ReadText(1001, 42) .. " " .. amount) or "", { x = Helper.scaleX(Helper.configButtonBorderSize), y = - maxColumnWidth / 2 + Helper.standardTextHeight / 2 + Helper.configButtonBorderSize, halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize), color = overridecolor })
					if active then
						row[col].handlers.onClick = function () return menu.buttonSelectPaintMod(entry, row.index, col) end
					end

					local untruncatedExtraText = entry.isdefault and ReadText(1001, 8516) or entry.name
					local extraText = TruncateText(untruncatedExtraText, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
					row2[col]:setColSpan(3):createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, color = overridecolor, boxColor = active and Color["button_background_default"] or Color["button_background_inactive"], mouseOverText = (extraText ~= untruncatedExtraText) and untruncatedExtraText or "" })
				end
			end
		else
			local row = ftable:addRow(true, { scaling = true })
			row[1]:setColSpan(9):createText("  " .. Helper.modQualities[categoryQuality].paintnonetext, { color = Helper.modQualities[categoryQuality].color })
		end

		ftable:setTopRow(menu.topRows.slots)
		ftable:setSelectedRow(menu.selectedRows.slots)
		ftable:setSelectedCol(menu.selectedCols.slots or 0)

		ftable:addConnection(1, 2, true)
		if buttontable then
			buttontable:addConnection(2, 2)
		end
	else
		Helper.clearTableConnectionColumn(menu, 2)
	end
	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil

end

function menu.displayModSlot(ftable, type, modclass, slot, slotdata, isgroup)
	local upgradetype
	if type ~= "ship" then
		upgradetype = Helper.findUpgradeType(type)
	end

	local isexpanded = menu.isModSlotExpanded(type, slot)
	if (type == "ship") or (upgradetype and upgradetype.mergeslots) then
		isexpanded = true
	end

	local turretcomponent
	local installedmod = {}
	local hasinstalledmod = false
	if type == "engine" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object)
	elseif type == "shield" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object, slotdata.context, slotdata.group)
	elseif (type == "turret") and isgroup then
		local groupinfo = C.GetUpgradeGroupInfo2(menu.object, "", slotdata.context, "", slotdata.group, "turret")
		turretcomponent = groupinfo.currentcomponent
		if turretcomponent == 0 then
			-- Nothing to mod here
			return
		end
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object, slotdata.context, slotdata.group, isgroup)
	elseif type == "ship" then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, menu.object)
	elseif (type == "weapon") or (type == "turret") then
		hasinstalledmod, installedmod = Helper.getInstalledModInfo(type, slotdata.component)
	end

	local row = ftable:addRow({ slot }, { scaling = true, bgColor = Color["row_background_blue"] })
	if slot == menu.currentSlot then
		menu.selectedRows.slots = row.index
	end
	if (type ~= "ship") and ((not upgradetype) or (not upgradetype.mergeslots)) then
		row[1]:setBackgroundColSpan(1):createButton({ active = true }):setText(isexpanded and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function() return menu.expandModSlot(type, slot, row.index) end
		row[2]:setBackgroundColSpan(7)
	end
	if type == "ship" then
		if hasinstalledmod then
			row[2]:setColSpan(6)
			row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
		else
			row[2]:setColSpan(7)
		end
		row[2]:createText(ffi.string(C.GetComponentName(menu.object)) .. " (" .. ReadText(1001, 8008) .. ReadText(1001, 120) .. " " .. GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"), "name") .. ")")
	elseif type == "shield" then
		if (slotdata.context == menu.object) and (slotdata.group == "") then
			if hasinstalledmod then
				row[2]:setColSpan(6)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[2]:setColSpan(7)
			end

			local name = upgradetype.text.default
			if slotdata.slotsize ~= "" then
				name = upgradetype.text[slotdata.slotsize]
			end
			row[2]:createText(slotdata.count .. "x " .. name)
		else
			if hasinstalledmod then
				row[6]:setColSpan(2)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[6]:setColSpan(3)
			end
			row[2]:setColSpan(4):createText(GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(slotdata.component)), "macro"), "name"))
			row[6]:createText("[" .. ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(slotdata.slotsize) .. slotdata.sizecount .. " (" .. menu.getUpgradeTypeText(slotdata.upgradetype) .. ")]")
		end
	elseif (type == "turret") and isgroup then
		if (slotdata.context ~= menu.object) or (slotdata.group ~= "") then
			if hasinstalledmod then
				row[6]:setColSpan(2)
				row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]", { halign = "right" })
			else
				row[6]:setColSpan(3)
			end
			row[2]:setColSpan(4):createText(GetMacroData(GetComponentData(ConvertStringTo64Bit(tostring(turretcomponent)), "macro"), "name"))
			row[6]:createText("[" .. ReadText(1001, 8023) .. " " .. Helper.getSlotSizeText(slotdata.slotsize) .. slotdata.sizecount .. "]")
		end
	else
		if hasinstalledmod then
			row[6]:setColSpan(2)
			row[8]:createText("\27[" .. Helper.modQualities[installedmod.Quality].icon2 .. "]")
		else
			row[6]:setColSpan(3)
		end

		row[2]:setColSpan(4):createText(GetMacroData(slotdata.currentmacro, "name"))
		if (not uprgadetype) or (not upgradetype.mergeslots) then
			row[6]:createText("[" .. ReadText(1001, 66) .. " " .. slot .. "]", { halign = "right" })
		end
	end

	if isexpanded then
		if hasinstalledmod then
			-- name
			local color = Helper.modQualities[installedmod.Quality].color
			local row = ftable:addRow(true, { scaling = true })
			row[2]:setColSpan(5):createText(installedmod.Name, { color = color })
			row[7]:setColSpan(2):createText(ReadText(1001, 8033), { halign = "right", color = color })
			-- Effects
			local row = ftable:addRow(true, { scaling = true })
			row[2]:setColSpan(7):createText("   " .. ReadText(1001, 8034) .. ReadText(1001, 120))
			-- default property
			for i, property in ipairs(Helper.modProperties[modclass]) do
				if property.key == installedmod.PropertyType then
					if installedmod[property.key] ~= property.basevalue then
						local effectcolor
						if installedmod[property.key] > property.basevalue then
							effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
						else
							effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
						end
						local row = ftable:addRow(true, { scaling = true })
						row[2]:setColSpan(5):createText("      " .. property.text, { font = Helper.standardFontBold })
						row[7]:setColSpan(2):createText(property.eval(installedmod[property.key]), { font = Helper.standardFontBold, halign = "right", color = effectcolor })
					end
					break
				end
			end
			-- other properties
			for i, property in ipairs(Helper.modProperties[modclass]) do
				if property.key ~= installedmod.PropertyType then
					if installedmod[property.key] ~= property.basevalue then
						local effectcolor
						if installedmod[property.key] > property.basevalue then
							effectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
						else
							effectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
						end
						local row = ftable:addRow(true, { scaling = true })
						row[2]:setColSpan(5):createText("      " .. property.text)
						row[7]:setColSpan(2):createText(property.eval(installedmod[property.key]), { halign = "right", color = effectcolor })
					end
				end
			end
			-- dismantle
			local row = ftable:addRow(true, { scaling = true })
			row[1]:setColSpan(4)
			row[5]:setColSpan(4):createButton({  }):setText(ReadText(1001, 6601), { halign = "center" })
			if (type == "ship") or (type == "engine") then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object) end
			elseif (type == "turret") and isgroup then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object, slotdata.context, slotdata.group) end
			elseif type == "shield" then
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, menu.object, slotdata.context, slotdata.group) end
			else
				row[5].handlers.onClick = function () return menu.buttonDismantleMod(type, slotdata.component) end
			end
		else
			local row = ftable:addRow(true, { scaling = true })
			row[2]:setColSpan(7):createText(ReadText(1001, 8032))
		end

		-- available mods
		local categoryQuality = menu.getModQuality(menu.modCategory)
		if not categoryQuality then
			DebugError(string.format("Could not resolve mod category '%s' to quality level. Check Helper.modQualities [Florian]", menu.modCategory))
			return
		end
		local found = false
		if menu.modwares[modclass] then
			for _, entry in ipairs(menu.modwares[modclass]) do
				if entry.quality == categoryQuality then
					if (type == "turret") and isgroup then
						if C.CheckWeaponModCompatibility(turretcomponent, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware, isgroup)
						end
					elseif modclass == "weapon" then
						if C.CheckWeaponModCompatibility(slotdata.component, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					elseif modclass == "shield" then
						if C.CheckGroupedShieldModCompatibility(menu.object, slotdata.context, slotdata.group, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					elseif modclass == "ship" then
						if C.CheckShipModCompatibility(menu.object, entry.ware) then
							found = true
							menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
						end
					else
						found = true
						menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, entry, hasinstalledmod, installedmod.Ware)
					end
				end
			end
		end
		if not found then
			local row = ftable:addRow(true, { scaling = true })
			row[2]:setColSpan(7):createText(" " .. Helper.modQualities[categoryQuality].nonetext, { color = Helper.modQualities[categoryQuality].color })
		end
	end
end

function menu.displayModBlueprint(ftable, type, slot, slotdata, modclass, moddata, hasinstalledmod, installedmodware, isgroup)
	local isexpanded = menu.isModSlotExpanded(type, slot .. moddata.ware)
	-- mod name
	local propertymodname = ffi.string(C.GetEquipmentModPropertyName(moddata.ware))
	local row = ftable:addRow(true, { scaling = true })
	row[1]:setBackgroundColSpan(1):createButton({ active = true }):setText(isexpanded and "-" or "+", { halign = "center" })
	row[1].handlers.onClick = function() return menu.expandModSlot(type, slot .. moddata.ware, row.index) end
	row[2]:setBackgroundColSpan(6):setColSpan(5):createText(" " .. GetWareData(moddata.ware, "shortname") .. ((propertymodname ~= "") and (" (" .. propertymodname .. ")") or ""), { color = Helper.modQualities[moddata.quality].color })
	row[7]:setColSpan(2):createText(ReadText(1001, 42) .. " " .. moddata.craftableamount, { halign = "right" })

	if isexpanded then
		-- Resources
		for _, resource in ipairs(moddata.resources) do
			local row = ftable:addRow(true, { scaling = true })
			local color = (resource.data.amount < resource.data.needed) and Color["text_inactive"] or Color["text_normal"]
			-- name
			row[2]:setColSpan(5):createText("      " .. resource.data.name, { color = color })
			-- amount
			row[7]:setColSpan(2):createText(resource.data.amount .. " / " .. resource.data.needed, { halign = "right", color = color })
		end
		-- Effects
		local row = ftable:addRow(true, { scaling = true })
		row[2]:setColSpan(7):createText("   " .. ReadText(1001, 8034) .. ReadText(1001, 120))
		-- Property
		local moddef = C.GetEquipmentModInfo(moddata.ware)
		local propertytype = ffi.string(moddef.PropertyType)
		for i, property in ipairs(Helper.modProperties[modclass]) do
			if property.key == propertytype then
				local minvalue = moddef["MinValue" .. property.type]
				local mineffectcolor = Color["text_normal"]
				if minvalue > property.basevalue then
					mineffectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				elseif minvalue < property.basevalue then
					mineffectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end

				local maxvalue = moddef["MaxValue" .. property.type]
				local maxeffectcolor = Color["text_normal"]
				if maxvalue > property.basevalue then
					maxeffectcolor = property.pos_effect and Color["text_positive"] or Color["text_negative"]
				elseif maxvalue < property.basevalue then
					maxeffectcolor = property.pos_effect and Color["text_negative"] or Color["text_positive"]
				end

				local row = ftable:addRow(true, { scaling = true })
				row[2]:setColSpan(4):createText("      " .. property.text, { font = Helper.standardFontBold })
				if property.pos_effect and (minvalue < maxvalue) or (minvalue > maxvalue) then
					row[6]:setColSpan(3):createText(property.eval2(minvalue, mineffectcolor, maxvalue, maxeffectcolor), { font = Helper.standardFontBold, halign = "right" })
				else
					row[6]:setColSpan(3):createText(property.eval2(maxvalue, maxeffectcolor, minvalue, mineffectcolor), { font = Helper.standardFontBold, halign = "right" })
				end
				break
			end
		end
		-- Bonus properties
		if moddef.BonusMax > 0 then
			local mouseovertext = ReadText(1026, 8005) .. ReadText(1001, 120)
			for n = 1, moddef.BonusMax do
				-- n < n_max:
				-- p_n = p^n * (1-p)
				-- n == n_max:
				-- p_n_max = p^n_max
				local probability = ((moddef.BonusChance ^ n) * ((n ~= moddef.BonusMax) and (1 - moddef.BonusChance) or 1))
				mouseovertext = mouseovertext .. "\n" .. string.format("%+d %s%s %4.1f%%", n, ReadText(1001, 6602), ReadText(1001, 120), probability * 100)
			end

			local row = ftable:addRow(true, { scaling = true })
			row[2]:setColSpan(5):createText("      " .. ((moddef.BonusMax == 1) and ReadText(1001, 8039) or string.format(ReadText(1001, 8040), moddef.BonusMax)), { mouseOverText = mouseovertext })
			row[7]:setColSpan(2):createText("???", { halign = "right" })
		end
		-- Install
		local row = ftable:addRow(true, { scaling = true })
		row[1]:setColSpan(4)
		local playermoney = GetPlayerMoney()
		local text = menu.isplayerowned and ReadText(1001, 4803) or string.format(ReadText(1001, 8043) .. " " .. ReadText(1001, 101), ConvertMoneyString(Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false))
		local active = true
		local mouseovertext = ""
		local dismantle = false

		local hasmoney = menu.isplayerowned or (playermoney >= Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor)
		if hasinstalledmod then
			if (moddata.ware == installedmodware) then
				if (moddata.normalcraftableamount > 0) and hasmoney then
					text = menu.isplayerowned and ReadText(1001, 6608) or string.format(ReadText(1001, 6609) .. " " .. ReadText(1001, 101), ConvertMoneyString(Helper.modQualities[moddata.quality].price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false))
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					end
					mouseovertext = mouseovertext .. ReadText(1026, 6601)
					dismantle = true
				end
			else
				active = false
				if mouseovertext ~= "" then
					mouseovertext = mouseovertext .. "\n"
				end
				mouseovertext = mouseovertext .. ReadText(1026, 8006)
			end
		end
		if (not dismantle) and (moddata.craftableamount == 0) then
			active = false
			if mouseovertext ~= "" then
				mouseovertext = mouseovertext .. "\n"
			end
			mouseovertext = mouseovertext .. ReadText(1026, 8007)
		end
		if not hasmoney then
			active = false
			if mouseovertext ~= "" then
				mouseovertext = mouseovertext .. "\n"
			end
			mouseovertext = mouseovertext .. ReadText(1026, 8008)
		end
		if not dismantle then
			if mouseovertext ~= "" then
				mouseovertext = ColorText["text_error"] .. mouseovertext
			end
		end
		row[5]:setColSpan(4):createButton({ active = active, mouseOverText = mouseovertext }):setText(text, { halign = "center" })
		if (type == "ship") or (type == "engine") then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, nil, nil, dismantle) end
		elseif (type == "turret") and isgroup then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, slotdata.context, slotdata.group, dismantle) end
		elseif type == "shield" then
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, menu.object, moddata.ware, Helper.modQualities[moddata.quality].price, slotdata.context, slotdata.group, dismantle) end
		else
			row[5].handlers.onClick = function () return menu.buttonInstallMod(type, slotdata.component, moddata.ware, Helper.modQualities[moddata.quality].price, nil, nil, dismantle) end
		end
	end
end

function menu.displayEmptySlots(frame)
	local ftable = frame:addTable(1, { tabOrder = 1, width = menu.slotData.width, height = 0, x = menu.slotData.offsetX, y = menu.slotData.offsetY, scaling = true, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })

	local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
	row[1]:createText(ReadText(1001, 7935), menu.headerTextProperties)

	row = ftable:addRow(false, { scaling = true })
	row[1]:createText(ReadText(1001, 8013))

	ftable:addConnection(1, 2, true)

	menu.topRows.slots = nil
	menu.selectedRows.slots = nil
	menu.selectedCols.slots = nil
end

function menu.checkLicence(macro, rawicon, issoftware, rawmouseovertext)
	local haslicence = true
	local icon
	local overridecolor = Color["text_normal"]
	local mouseovertext = ""
	local limitstring = ""
	if macro ~= "" then
		local ware
		if issoftware then
			ware = macro
		else
			ware = GetMacroData(macro, "ware")
		end
		if ware == nil or ware == "" then
			print("no ware defined for macro '" .. macro .. "'")
		else
			local tradelicence, isblueprintsaleonly, researchprecursors, islimited = GetWareData(ware, "tradelicence", "isblueprintsaleonly", "productionresearchprecursors", "islimited")
			if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				local alreadyinshoppinglist = false
				for i, entry in ipairs(menu.shoppinglist) do
					if i ~= menu.editingshoppinglist then
						if entry.macro == macro then
							alreadyinshoppinglist = true
						end
					end
				end

				if (not menu.isplayerowned) and isblueprintsaleonly then
					haslicence = false
					icon = "menu_locked"
					mouseovertext = ReadText(1026, 8019)
				elseif researchprecursors and (#researchprecursors > 0) then
					mouseovertext = ReadText(1026, 8023) .. " "
					local first = true
					for _, research in ipairs(researchprecursors) do
						if (not C.HasResearched(research)) or alreadyinshoppinglist then
							haslicence = false
							mouseovertext = mouseovertext .. (first and " " or "\n") .. ColorText["text_error"] .. GetWareData(research, "name") .. "\27X"
						else
							mouseovertext = mouseovertext .. (first and " " or "\n") .. GetWareData(research, "name")
						end
					end
					icon = "gamestart_custom_research"
				else
					if tradelicence ~= "" then
						haslicence = HasLicence("player", tradelicence, menu.containerowner)
						local licenceinfo = ffi.new("LicenceInfo")
						if C.GetLicenceInfo(licenceinfo, menu.containerowner, tradelicence) then
							icon = ffi.string(licenceinfo.icon)
							if icon ~= "" then
								if not rawicon then
									icon = "\27[" .. icon .. "]"
								end
								mouseovertext = (rawmouseovertext and "" or (haslicence and "" or ColorText["text_error"])) .. string.format(ReadText(1026, 8003), ffi.string(licenceinfo.name))
							end
						end
					end
				end
			end
			if islimited and (not menu.isReadOnly) and (menu.mode ~= "comparison") and (not menu.modeparam.creative) then
				local limitamount = Helper.getLimitedWareAmount(ware)
				local shoppinglistamount = 0
				for i, entry in ipairs(menu.shoppinglist) do
					if i ~= menu.editingshoppinglist then
						if entry.macro == macro then
							shoppinglistamount = shoppinglistamount + entry.amount
						end
					end
				end

				local used = (menu.usedLimitedMacros[macro] or 0) + shoppinglistamount
				if used >= limitamount then
					haslicence = false
					icon = "menu_locked"
					mouseovertext = ReadText(1026, 8028)
				end
				limitstring = " (" .. used .. "/" .. limitamount .. ")"
			end
			if not haslicence then
				overridecolor = Color["text_error"]
			end
		end
	end

	return haslicence, icon, overridecolor, mouseovertext, limitstring
end

function menu.checkMod(type, component, isgroup)
	local hasmod, modicon = false, ""
	if component then
		if (type == "turret") and isgroup then
			local shieldgroup = ffi.new("ShieldGroup")
			local found = C.GetShieldGroup(shieldgroup, menu.object, component)
			if found then
				local buf = ffi.new("UIWeaponMod")
				hasmod = C.GetInstalledGroupedWeaponMod(menu.object, shieldgroup.context, shieldgroup.group, buf)
				if hasmod then
					modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
				end
			end
		elseif (type == "weapon") or (type == "turret") then
			local buf = ffi.new("UIWeaponMod")
			hasmod = C.GetInstalledWeaponMod(component, buf)
			if hasmod then
				modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
			end
		elseif type == "engine" then
			local buf = ffi.new("UIEngineMod2")
			hasmod = C.GetInstalledEngineMod2(menu.object, buf)
			if hasmod then
				modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
			end
		elseif type == "shield" then
			local shieldgroup = ffi.new("ShieldGroup")
			local found = C.GetShieldGroup(shieldgroup, menu.object, component)
			if found then
				local buf = ffi.new("UIShieldMod")
				hasmod = C.GetInstalledShieldMod(menu.object, shieldgroup.context, shieldgroup.group, buf)
				if hasmod then
					modicon = "\27[" .. Helper.modQualities[buf.Quality].icon2 .. "]"
				end
			end
		end
	end

	return hasmod, modicon
end

function menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment, data, object)
	local canequip = true
	if menu.mode == "upgrade" then
		if not menu.isReadOnly then
			canequip = C.CanContainerEquipShip(menu.container, object or menu.object)
		end
	end
	local hasupgrades, hasrepairs = false, false
	local objectEquipment = {
		removed = {},
		current = {},
		new = {},
		repaired = {},
	}

	local groups   = data and data.groups   or menu.groups
	local slots    = data and data.slots    or menu.slots
	local ammo     = data and data.ammo     or menu.ammo
	local software = data and data.software or menu.software
	-- Equipment
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local upgradeplanslots = menu.upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(upgradeplanslots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					local data = macro
					local oldslotdata = groups[slot][upgradetype.grouptype]

					if canequip then
						if data.macro ~= "" then
							local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
							if not i then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.grouptype][i]

							if oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

								if data.macro == oldslotdata.currentmacro then
									if upgradetype.mergeslots then
										menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count))
									else
										if oldslotdata.count < data.count then
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, oldslotdata.count)
											menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, data.count - oldslotdata.count, "normal")
											hasupgrades = true
										elseif oldslotdata.count > data.count then
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, data.count)
											menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, upgradeware.ware, oldslotdata.count - data.count, "normal")
											hasupgrades = true
										else
											menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count))
										end
									end
								else
									menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
									menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count), "normal")
									hasupgrades = true
								end
							else
								menu.insertWare(newEquipment, objectEquipment.new, upgradetype.grouptype, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or data.count), "normal")
								hasupgrades = true
							end
						elseif oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
							hasupgrades = true
						end
					else
						if oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.grouptype, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or oldslotdata.count), "normal")
						end
					end
				elseif (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					local data = macro
					local oldslotdata = slots[upgradetype.type][slot]
					if oldslotdata == nil then
						-- for catching a rare bug
						print(upgradetype.type, slot)
						for k, v in pairs(slots[upgradetype.type]) do
							print(k .. ": " .. tostring(v))
						end
					end
					if canequip then
						if data.macro ~= "" then
							local i = menu.findUpgradeMacro(upgradetype.type, data.macro)
							if not i then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.type][i]

							if oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.type, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.type][j]

								if data.macro == oldslotdata.currentmacro then
									menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1))
								else
									menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
									menu.insertWare(newEquipment, objectEquipment.new, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
									hasupgrades = true
								end
							else
								menu.insertWare(newEquipment, objectEquipment.new, upgradetype.type, upgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
								hasupgrades = true
							end
						elseif oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.type, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.type][j]

							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
							hasupgrades = true
						end
					else
						if oldslotdata.currentmacro ~= "" then
							local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
							if not j then
								break
							end
							local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

							menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.type, oldupgradeware.ware, (upgradetype.mergeslots and #upgradeplanslots or 1), "normal")
						end
					end
				elseif upgradetype.supertype == "ammo" then
					if ammo[upgradetype.type][slot] then
						local current = ammo[upgradetype.type][slot]
						local new = macro
						local macro = slot
						if (current > 0) or (current ~= new) then
							local j = menu.findUpgradeMacro(upgradetype.type, macro)
							if not j then
								break
							end
							local upgradeware = menu.upgradewares[upgradetype.type][j]

							if current < new then
								if current > 0 then
									menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, current)
								end
								menu.insertWare(newEquipment, objectEquipment.new, "consumables", upgradeware.ware, new - current, "normal")
								hasupgrades = true
							elseif current > new then
								if new > 0 then
									menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, new)
								end
								menu.insertWare(removedEquipment, objectEquipment.removed, "consumables", upgradeware.ware, current - new, "normal")
								hasupgrades = true
							elseif current > 0 then
								menu.insertWare(currentEquipment, objectEquipment.current, "consumables", upgradeware.ware, current)
							end
						end
					end
				elseif upgradetype.supertype == "software" then
					local newware = macro
					local oldware = software[upgradetype.type][slot].currentsoftware
					if oldware ~= newware then
						if oldware ~= "" then
							menu.insertWare(removedEquipment, objectEquipment.removed, upgradetype.supertype, oldware, 1, "software")
							hasupgrades = true
						end
						if newware ~= "" then
							menu.insertWare(newEquipment, objectEquipment.new, upgradetype.supertype, newware, 1, "software")
							hasupgrades = true
						end
					elseif newware ~= "" then
						menu.insertWare(currentEquipment, objectEquipment.current, upgradetype.supertype, newware, 1)
					end
				end
			end
		end
	end

	-- Crew
	if menu.objectgroup == nil then
		if menu.crew.hired > 0 then
			local color = Color["text_positive"]

			menu.insertWare(newEquipment, objectEquipment.new, "crew", menu.crew.ware, menu.crew.hired, "crew")
			hasupgrades = true
			if menu.crew.total - #menu.crew.fired > 0 then
				menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total - #menu.crew.fired)
			end
			if #menu.crew.fired > 0 then
				menu.insertWare(removedEquipment, objectEquipment.removed, "crew", menu.crew.ware, #menu.crew.fired, "crew")
				hasupgrades = true
			end
		elseif #menu.crew.fired > 0 then
			menu.insertWare(removedEquipment, objectEquipment.removed, "crew", menu.crew.ware, #menu.crew.fired, "crew")
			hasupgrades = true
			if (menu.crew.total - #menu.crew.fired) > 0 then
				menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total - #menu.crew.fired)
			end
		elseif menu.crew.total > 0 then
			menu.insertWare(currentEquipment, objectEquipment.current, "crew", menu.crew.ware, menu.crew.total)
		end
	end

	-- Repair
	local objectidstring = tostring(object or menu.object)
	if menu.repairplan and menu.repairplan[objectidstring] then
		for componentidstring in pairs(menu.repairplan[objectidstring]) do
			if componentidstring ~= "processed" then
				menu.insertComponent(repairedEquipment, objectEquipment.repaired, componentidstring, "normal")
				hasrepairs = true
			end
		end
	end

	local totalprice = 0
	local totalcrewprice = 0
	if not menu.isplayerowned then
		if menu.object == 0 then
			if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				totalprice = totalprice + tonumber(C.GetBuildWarePrice(menu.container, GetMacroData(menu.macro, "ware") or ""))
			end
		end
		for _, data in pairs(removedEquipment) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					totalcrewprice = totalcrewprice - entry.amount * entry.price
				else
					totalprice = totalprice - entry.amount * entry.price
				end
			end
		end
		for _, data in pairs(newEquipment) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					totalcrewprice = totalcrewprice + entry.amount * entry.price
				else
					totalprice = totalprice + entry.amount * entry.price
				end
			end
		end
		for _, entry in ipairs(repairedEquipment) do
			totalprice = totalprice + entry.price
		end
	end
	local objectprice = 0
	local objectcrewprice = 0
	if not menu.isplayerowned then
		if menu.object == 0 then
			if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
				objectprice = objectprice + tonumber(C.GetBuildWarePrice(menu.container, GetMacroData(menu.macro, "ware") or ""))
			end
		end
		for _, data in pairs(objectEquipment.removed) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					objectcrewprice = objectcrewprice - entry.amount * entry.price
				else
					objectprice = objectprice - entry.amount * entry.price
				end
			end
		end
		for _, data in pairs(objectEquipment.new) do
			for _, entry in ipairs(data) do
				if entry.ware == menu.crew.ware then
					objectcrewprice = objectcrewprice + entry.amount * entry.price
				else
					objectprice = objectprice + entry.amount * entry.price
				end
			end
		end
		for _, entry in ipairs(objectEquipment.repaired) do
			objectprice = objectprice + entry.price
		end
	end

	return RoundTotalTradePrice(totalprice), RoundTotalTradePrice(totalcrewprice), hasupgrades, hasrepairs, RoundTotalTradePrice(objectprice), RoundTotalTradePrice(objectcrewprice)
end

function menu.getAddedPeopleFromBuildTask(container, taskid)
	local result = 0

	local numcrewentries = C.GetNumBuildTaskCrewTransferInfo(container, taskid)
	local crewtransferinfo = ffi.new("CrewTransferInfo2")
	crewtransferinfo.numadded = numcrewentries.numadded
	crewtransferinfo.added = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numadded)
	crewtransferinfo.numremoved = numcrewentries.numremoved
	crewtransferinfo.removed = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numremoved)
	crewtransferinfo.numtransferred = numcrewentries.numtransferred
	crewtransferinfo.transferred = Helper.ffiNewHelper("CrewTransferContainer2[?]", numcrewentries.numtransferred)

	C.GetBuildTaskCrewTransferInfo2(crewtransferinfo, container, taskid)
	for j = 0, crewtransferinfo.numadded - 1 do
		result = result + crewtransferinfo.added[j].amount
	end

	return result
end

function menu.warningColor(normalcolor)
	local color = normalcolor

	local curtime = getElapsedTime()
	if menu.warningShown and (curtime < menu.warningShown + 2) then
		-- number between 0 and 1, duration 1s
		local x = curtime % 1

		normalcolor = normalcolor or Color["text_warning"]
		overridecolor = Color["text_normal"]
		color = {
			r = (1 - x) * overridecolor.r + x * normalcolor.r,
			g = (1 - x) * overridecolor.g + x * normalcolor.g,
			b = (1 - x) * overridecolor.b + x * normalcolor.b,
			a = (1 - x) * overridecolor.a + x * normalcolor.a,
		}
	end
	return color
end

function menu.displayPlan(frame)
	-- errors & warnings
	menu.criticalerrors = {}
	menu.errors = {}
	menu.warnings = {}

	if (menu.mode == "purchase") or (menu.mode == "upgrade") then
		if menu.container and ((menu.object ~= 0) or (menu.macro ~= "")) then
			if not C.HasSuitableBuildModule(menu.container, menu.object, menu.macro) then
				menu.errors[4] = menu.objectgroup and ReadText(1001, 8572) or ReadText(1001, 8563)
			end
			if menu.customshipname == "" then
				menu.errors[5] = ReadText(1001, 8587)
			end
		end
	end

	if (menu.mode == "purchase") and (menu.macro ~= "") then
		if not menu.validLicence then
			local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(menu.macro, true, nil, true)
			menu.errors[2] = mouseovertext
		end
		if not menu.validLoadoutPossible then
			menu.criticalerrors[5] = ReadText(1001, 8528)
		end
	end

	if (menu.mode == "customgamestart") and (menu.macro ~= "") and (not menu.modeparam.creative) then
		local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(menu.macro, true, nil, true)
		if not haslicence then
			menu.criticalerrors[6] = mouseovertext
		end
	end

	if ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
		if menu.tasks[tostring(menu.object)] then
			menu.errors[3] = function (_, notime)
				local timestring
				if (not notime) and (type(menu.tasks[tostring(menu.object)]) == "userdata") then
					timestring = "--:--"
					local buildtask = ConvertIDTo64Bit(menu.tasks[tostring(menu.object)])
					local buildtaskinfo = C.GetBuildTaskInfo(buildtask)
					if buildtaskinfo.buildingcontainer ~= 0 then
						if (buildtaskinfo.queueposition == 0) and (buildtaskinfo.buildercomponent ~= 0) then
							timestring = ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(buildtaskinfo.buildercomponent), "%h:%M:%S")
						end
					end
				end
				return ReadText(1001, 8521) .. (timestring and (" (" .. ReadText(1001, 2923) .. ReadText(1001, 120) .. " " .. timestring .. ")") or "")
			end
		end
	end

	local hasminingequipment, hasmilitaryequipment = false, false
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = menu.upgradeplan[upgradetype.type]
		for slot, macro in pairs(slots) do
			-- current allowempty warning
			local allowempty
			if upgradetype.supertype == "macro" then
				local data = macro
				if data.macro == "" then
					allowempty = upgradetype.allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type, slot))
				else
					local isminingweapon = GetMacroData(data.macro, "isminingweapon")
					hasminingequipment = hasminingequipment or isminingweapon
					hasmilitaryequipment = hasmilitaryequipment or (not isminingweapon)
				end
			elseif upgradetype.supertype == "group" then
				local data = macro
				if data.macro ~= "" then
					local isminingweapon = GetMacroData(data.macro, "isminingweapon")
					hasminingequipment = hasminingequipment or isminingweapon
					hasmilitaryequipment = hasmilitaryequipment or (not isminingweapon)
				end
			elseif upgradetype.supertype == "virtualmacro" then
				local data = macro
				if data.macro == "" then
					allowempty = upgradetype.allowempty
				end
			else
				if macro == "" then
					allowempty = upgradetype.allowempty
				end
			end
			if allowempty == false then
				if (menu.mode == "customgamestart") or (menu.mode == "comparison") then
					menu.criticalerrors[2] = ReadText(1001, 8020)
				else
					menu.errors[1] = menu.objectgroup and ReadText(1001, 8568) or ReadText(1001, 8020)
				end
				break
			end
		end
		-- missing software
		if upgradetype.supertype == "software" then
			if menu.software[upgradetype.type] then
				for slot, slotdata in ipairs(menu.software[upgradetype.type]) do
					if #slotdata.possiblesoftware > 0 then
						if (slotdata.defaultsoftware ~= 0) and (menu.upgradeplan[upgradetype.type][slot] == "") then
							if (menu.mode == "customgamestart") or (menu.mode == "comparison") then
								menu.criticalerrors[2] = ReadText(1001, 8020)
							else
								menu.errors[1] = menu.objectgroup and ReadText(1001, 8568) or ReadText(1001, 8020)
							end
							break
						end
					end
				end
			end
		end
		-- missing captain
		if (menu.mode == "purchase") and (not menu.captainSelected) then
			menu.errors[1] = ReadText(1001, 8020)
		end
		-- current ammo warning
		if upgradetype.supertype == "ammo" then
			local total, capacity = menu.getAmmoUsage(upgradetype.type)
			if total > capacity then
				menu.warnings[2] = menu.objectgroup and ReadText(1001, 8569) or ReadText(1001, 8021)
			end
		end
	end
	local purpose, storagetags
	local transporttypes
	if menu.macro ~= "" then
		purpose, storagetags = GetMacroData(menu.macro, "primarypurpose", "storagetags")
	elseif menu.object ~= 0 then
		local primarypurpose, macro = GetComponentData(ConvertStringToLuaID(tostring(menu.object)), "primarypurpose", "macro")
		purpose = primarypurpose
		storagetags = GetMacroData(macro, "storagetags")
	end
	if purpose ~= nil then
		-- mining equipment warning
		if (purpose == "mine") and (storagetags["universal"] or storagetags["solid"]) and (not hasminingequipment) then
			menu.warnings[7] = menu.objectgroup and ReadText(1001, 8584) or ReadText(1001, 8583)
		end
		-- combat equipment warning
		if ((purpose == "fight") or (purpose == "auxiliary")) and (not hasmilitaryequipment) then
			menu.warnings[8] = menu.objectgroup and ReadText(1001, 8586) or ReadText(1001, 8585)
		end
	end

	-- current crew warning
	if #menu.crew.unassigned > 0 then
		menu.warnings[3] = ReadText(1001, 8022)
	end
	-- resource warning
	if menu.mode == "purchase" then
		local considerCurrent = false
		if (menu.macro ~= "") and (menu.editingshoppinglist == nil) then
			considerCurrent = true
		end
		local numorders = #menu.shoppinglist + (considerCurrent and 1 or 0)
		local buildorders = ffi.new("UIBuildOrderList[?]", numorders)
		for i, entry in ipairs(menu.shoppinglist) do
			buildorders[i - 1].shipid = 0
			buildorders[i - 1].macroname = Helper.ffiNewString(entry.macro)
			buildorders[i - 1].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[i - 1].amount = entry.amount
		end
		if considerCurrent then
			local index = #menu.shoppinglist
			buildorders[index].shipid = 0
			buildorders[index].macroname = Helper.ffiNewString(menu.macro)
			buildorders[index].loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[index].amount = 1
		end

		menu.missingResources = {}
		if not menu.errors[4] then
			local n = C.GetNumMissingBuildResources2(menu.container, buildorders, numorders, true)
			local buf = ffi.new("UIWareInfo[?]", n)
			n = C.GetMissingBuildResources(buf, n)
			for i = 0, n - 1 do
				table.insert(menu.missingResources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		if (not menu.isReadOnly) and (#menu.missingResources > 0) then
			menu.warnings[4] = ReadText(1001, 8018)
		end
	elseif menu.mode == "upgrade" then
		local considerCurrent = false
		if (menu.object ~= 0) and (menu.editingshoppinglist == nil) then
			considerCurrent = true
		end
		local numorders = considerCurrent and 1 or 0
		for i, entry in ipairs(menu.shoppinglist) do
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				numorders = numorders + #groupentry.ships
			else
				numorders = numorders + 1
			end
		end
		local buildorders = ffi.new("UIBuildOrderList[?]", numorders)
		local i = 0
		for _, entry in ipairs(menu.shoppinglist) do
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				for _, ship in ipairs(groupentry.ships) do
					buildorders[i].shipid = ship.ship
					buildorders[i].macroname = ""
					buildorders[i].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
					buildorders[i].amount = 1
					i = i + 1
				end
			else
				buildorders[i].shipid = entry.object
				buildorders[i].macroname = ""
				buildorders[i].loadout = Helper.callLoadoutFunction(entry.upgradeplan, nil, function (loadout, _) return loadout end, false)
				buildorders[i].amount = entry.amount
				i = i + 1
			end
		end
		if considerCurrent then
			local index = numorders - 1
			buildorders[index].shipid = menu.object
			buildorders[index].macroname = ""
			buildorders[index].loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end, false)
			buildorders[index].amount = 1
		end

		menu.missingResources = {}
		if menu.container then
			local n = C.GetNumMissingLoadoutResources2(menu.container, buildorders, numorders, true)
			local buf = ffi.new("UIWareInfo[?]", n)
			n = C.GetMissingLoadoutResources(buf, n)
			for i = 0, n - 1 do
				table.insert(menu.missingResources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		if (not menu.isReadOnly) and (#menu.missingResources > 0) then
			menu.warnings[4] = ReadText(1001, 8018)
		end
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		menu.addedCrewByPlayerBuildTasks = 0
		local constructions = {}
		-- current builds
		local n = C.GetNumBuildTasks(menu.container, 0, true, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.container, 0, true, true)
		menu.buildInProgress = n
		for i = 0, n - 1 do
			menu.addedCrewByPlayerBuildTasks = menu.addedCrewByPlayerBuildTasks + menu.getAddedPeopleFromBuildTask(menu.container, buf[i].id)
		end
		-- other builds
		n = C.GetNumBuildTasks(menu.container, 0, false, true)
		local buf = ffi.new("BuildTaskInfo[?]", n)
		n = C.GetBuildTasks(buf, n, menu.container, 0, false, true)
		for i = 0, n - 1 do
			local factionid = ffi.string(buf[i].factionid)
			table.insert(constructions, { id = buf[i].id, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = factionid, buildercomponent = buf[i].buildercomponent, price = buf[i].price, inprogress = false })
			if factionid == "player" then
				menu.addedCrewByPlayerBuildTasks = menu.addedCrewByPlayerBuildTasks + menu.getAddedPeopleFromBuildTask(menu.container, buf[i].id)
			end
		end
		menu.queuePosition = #constructions + 1
		for i, construction in ipairs(constructions) do
			if (not construction.inprogress) and (construction.factionid ~= "player") then
				menu.queuePosition = i
				break
			end
		end
		Helper.ffiClearNewHelper()
	end

	menu.shoppinglisttotal = 0
	menu.shoppinglistrefund = 0
	menu.timetotal = 0
	local shoppinglistpaintmods = {}
	for i, entry in ipairs(menu.shoppinglist) do
		entry.color = menu.warnings[4] and Color["text_warning"] or Color["text_normal"]
		if i ~= menu.editingshoppinglist then
			local object = entry.object
			local groupamount = 1
			if entry.objectgroup then
				local groupentry = menu.shipgroups[entry.objectgroup]
				object = groupentry.ships[1].ship
				groupamount = #groupentry.ships
			end
			menu.timetotal = menu.timetotal + math.max(math.ceil(entry.amount * groupamount / C.GetNumSuitableBuildProcessors(menu.container, object, entry.macro)) * entry.duration, entry.duration)
			menu.shoppinglisttotal = menu.shoppinglisttotal + entry.amount * (entry.price + entry.crewprice)
			if (entry.price + entry.crewprice) < 0 then
				menu.shoppinglistrefund = menu.shoppinglistrefund + entry.amount * (entry.price + entry.crewprice)
			end
			-- ammo error
			if entry.warnings[2] then
				entry.color = Color["text_criticalerror"]
				menu.criticalerrors[3] = ReadText(1001, 8016)
			end
			-- crew error
			if #entry.crew.unassigned > 0 then
				entry.color = Color["text_criticalerror"]
				menu.criticalerrors[4] = ReadText(1001, 8017)
			end
			if entry.paintmodware then
				shoppinglistpaintmods[entry.paintmodware] = (shoppinglistpaintmods[entry.paintmodware] or 0) + entry.amount
			end
		end
		for _, upgradetype in ipairs(Helper.upgradetypes) do
			local slots = entry.upgradeplan[upgradetype.type]
			for slot, macro in pairs(slots) do
				-- allowempty error
				local allowempty
				if (upgradetype.supertype == "macro") and (upgradetype.supertype == "virtualmacro") then
					local data = macro
					if data.macro == "" then
						allowempty = upgradetype.allowempty and (not C.IsSlotMandatory(entry.object, 0, entry.macro, false, upgradetype.type, slot))
					end
				else
					if macro == "" then
						allowempty = upgradetype.allowempty
					end
				end
				if allowempty == false then
					if i ~= menu.editingshoppinglist then
						entry.color = Color["text_criticalerror"]
						menu.criticalerrors[2] = ReadText(1001, 8015)
					end
					break
				end
			end
		end
	end
	-- money error
	local playerMoney = GetPlayerMoney()
	if (not menu.isplayerowned) and (menu.shoppinglisttotal - menu.shoppinglistrefund > playerMoney) then
		menu.criticalerrors[1] = ReadText(1001, 8014)
		if menu.shoppinglistrefund < 0 then
			menu.criticalerrors[1] = menu.criticalerrors[1] .. " (" .. string.format(ReadText(1001, 8547), ConvertMoneyString(menu.shoppinglisttotal - menu.shoppinglistrefund, false, true, 0, true, false) .. " " .. ReadText(1001, 101)) .. ")"
		end
	end
	-- selling parts, not getting money immediately
	if menu.shoppinglistrefund < 0 then
		menu.warnings[6] = ReadText(1001, 8546)
	end

	Helper.ffiClearNewHelper()
	if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		-- edit warning
		if (menu.macro ~= "") or (menu.object ~= 0) then
			menu.warnings[5] = menu.objectgroup and ReadText(1001, 8567) or ReadText(1001, 8019)
		end
	end

	-- BUTTONS
	local buttontable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = 0, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
	local row

	local infoCount = 0
	local visibleHeight

	if not menu.isReadOnly then
		if menu.mode == "comparison" then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(2):createText(ReadText(1001, 3701), menu.headerTextProperties)
		elseif menu.mode == "customgamestart" then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(2):createText(ReadText(1001, 2302), menu.headerTextProperties)

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 9923))
			row[2]:createText(ConvertMoneyString((menu.macro ~= "") and tonumber(Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetShipValue(menu.macro, loadout) end, nil, "UILoadout2")) or 0, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })

			if not menu.modeparam.creative then
				local row = buttontable:addRow(false, { fixed = true })
				row[1]:createText(ReadText(1001, 9929))

				local value = 0
				if menu.macro ~= "" then
					value = value + tonumber(C.GetCustomGameStartShipPeopleValue2(menu.modeparam.gamestartid, menu.macro, menu.customgamestartpeopledef, menu.customgamestartpeoplefillpercentage))

					if next(menu.customgamestartpilot) then
						local skills = {}
						for skill, value in pairs(menu.customgamestartpilot.skills or {}) do
							table.insert(skills, { id = skill, value = value })
						end
						local buf = ffi.new("CustomGameStartPersonEntry")
						buf.race = Helper.ffiNewString(menu.customgamestartpilot.race or "")
						buf.tags = Helper.ffiNewString(menu.customgamestartpilot.tags or "")
						buf.numskills = #skills
						buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
						for i, entry in ipairs(skills) do
							buf.skills[i - 1].id = Helper.ffiNewString(entry.id)
							buf.skills[i - 1].value = entry.value
						end
						value = value + tonumber(C.GetCustomGameStartShipPersonValue(menu.modeparam.gamestartid, buf))
					end
				end

				row[2]:createText(ConvertIntegerString(value, true, 0, true)  .. " " .. ColorText["customgamestart_budget_people"] .. "\27[gamestart_custom_people]", { halign = "right" })
			end
		else
			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(2):createText(menu.container and string.format(ReadText(1001, 8531), (menu.isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(menu.container))) or ReadText(1001, 8012), menu.headerTextProperties)

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 8522))
			row[2]:createText(menu.buildInProgress, { halign = "right" })
			infoCount = infoCount + 1

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 8523))
			row[2]:createText(menu.queuePosition - 1, { halign = "right" })
			infoCount = infoCount + 1

			local row = buttontable:addRow(false, { fixed = true })
			row[1]:createText(ReadText(1001, 8509))
			row[2]:createText("#" .. menu.queuePosition .. " - " .. (menu.warnings[4] and "--:--" or ConvertTimeString(menu.timetotal, (menu.timetotal >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
			infoCount = infoCount + 1

			if not menu.isplayerowned then
				local row = buttontable:addRow(false, { fixed = true })
				row[1]:createText(ReadText(1001, 2927))
				row[2]:createText(ConvertMoneyString(menu.shoppinglisttotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
				infoCount = infoCount + 1

				local row = buttontable:addRow(false, { fixed = true })
				row[1]:createText(ReadText(1001, 2003))
				row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney(), false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				infoCount = infoCount + 1

				local row = buttontable:addRow(false, { fixed = true })
				row[1]:createText(ReadText(1001, 2004))
				row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney() - menu.shoppinglisttotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right", color = function () return GetPlayerMoney() - menu.shoppinglisttotal < 0 and Color["text_negative"] or Color["text_normal"] end })
				infoCount = infoCount + 1
			end
		end
	end

	if menu.isReadOnly then
		row = buttontable:addRow(true, { fixed = true })
		row[2]:createButton({ }):setText(ReadText(1001, 8035), { halign = "center" })
		row[2].handlers.onClick = function () return menu.closeMenu("back") end
	else
		row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
		local button = row[1]:createButton({ active = ((#menu.shoppinglist > (menu.editingshoppinglist and 1 or 0)) or (menu.mode == "customgamestart") or ((menu.mode == "comparison") and (menu.macro ~= ""))) and (next(menu.criticalerrors) == nil), helpOverlayID = "shipconfig_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_confirm" }):setText(((menu.mode == "customgamestart") or (menu.mode == "comparison")) and ReadText(1001, 2821) or ReadText(1001, 8011), { halign = "center" })
		if (menu.object == 0) and (menu.macro == "") then
			button:setHotkey("INPUT_STATE_DETAILMONITOR_X", { displayIcon = true })
		end
		row[1].handlers.onClick = menu.buttonConfirm
		row[2]:createButton({  }):setText(((menu.mode == "customgamestart") or (menu.mode == "comparison")) and ReadText(1001, 64) or ReadText(1001, 8010), { halign = "center" })
		row[2].handlers.onClick = function () return menu.closeMenu("back") end
	end
	buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - menu.planData.offsetY

	-- STATUS
	local statustable, resourcetable
	if not menu.isReadOnly then
		if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			if #menu.missingResources > 0 then
				resourcetable = frame:addTable(2, { tabOrder = 8, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = true, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })

				local row = resourcetable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
				row[1]:setColSpan(2):createText(ReadText(1001, 8046), menu.headerWarningTextProperties)
				-- disable blink effect
				row[1].properties.color = Color["text_warning"]

				local visibleHeight
				for i, entry in ipairs(menu.missingResources) do
					local row = resourcetable:addRow(true, {  })
					row[1]:createText(GetWareData(entry.ware, "name"), { color = Color["text_warning"] })
					row[2]:createText(ConvertIntegerString(entry.amount, true, 0, true), { halign = "right", color = Color["text_warning"] })
					if i == 5 then
						visibleHeight = resourcetable:getFullHeight()
					end
				end

				if visibleHeight then
					resourcetable.properties.maxVisibleHeight = visibleHeight
				else
					resourcetable.properties.maxVisibleHeight = resourcetable:getFullHeight()
				end
				resourcetable.properties.y = buttontable.properties.y - resourcetable:getVisibleHeight() - 2 * Helper.borderSize
			end
		end

		if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
			if not menu.warningShown then
				PlaySound("ui_notification_pickup_fail")
			end
			menu.warningShown = menu.warningShown or getElapsedTime()
			local iconfactor = 1.6
			local iconsize = iconfactor * Helper.headerRow1Height

			statustable = frame:addTable(4, { tabOrder = 7, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			statustable:setColWidth(1, iconsize)
			statustable:setColWidth(4, iconsize)

			local row = statustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setBackgroundColSpan(4):createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
			row[1].properties.fontsize = iconfactor * row[1].properties.fontsize
			row[1].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))
			row[2]:setColSpan(2):createText(ReadText(1001, 8342), menu.headerWarningTextProperties)
			row[4]:createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
			row[4].properties.fontsize = iconfactor * row[4].properties.fontsize
			row[4].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))

			for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
				row = statustable:addRow(true, {  })
				row[1]:setColSpan(4):createText(errorentry, { color = Color["text_criticalerror"], wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end
			for _, errorentry in Helper.orderedPairs(menu.errors) do
				row = statustable:addRow(true, {  })
				row[1]:setColSpan(4):createText(errorentry, { color = Color["text_error"], wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end
			for _, warningentry in Helper.orderedPairs(menu.warnings) do
				row = statustable:addRow(true, {  })
				row[1]:setColSpan(4):createText(warningentry, { color = Color["text_warning"], wordwrap = true })
				infoCount = infoCount + 1
				if infoCount == config.maxStatusRowCount then
					visibleHeight = statustable:getFullHeight()
				end
			end

			if visibleHeight then
				statustable.properties.maxVisibleHeight = visibleHeight
			else
				statustable.properties.maxVisibleHeight = statustable:getFullHeight()
			end
			if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (#menu.missingResources > 0) then
				statustable.properties.y = resourcetable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
			else
				statustable.properties.y = buttontable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
			end
		else
			menu.warningShown = nil
		end
	end

	-- SHOPPINGLIST
	local maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY
	if (not menu.isReadOnly) then
		if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
			maxVisibleHeight = statustable.properties.y - menu.planData.offsetY
		elseif (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") and (#menu.missingResources > 0) then
			maxVisibleHeight = resourcetable.properties.y - menu.planData.offsetY
		end
	end
	local ftable = frame:addTable(6, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = maxVisibleHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
	local iconwidth = 5 * Helper.scaleY(Helper.standardTextHeight) + 4 * Helper.borderSize
	local dropdownWidth = 0.2 * menu.planData.width
	local valueWidth = (menu.planData.width - iconwidth - Helper.borderSize) / 2
	ftable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	ftable:setColWidth(2, iconwidth - Helper.scaleY(Helper.standardTextHeight) - Helper.borderSize, false)
	ftable:setColWidth(4, Helper.scaleY(Helper.standardTextHeight), false)
	ftable:setColWidth(5, valueWidth - dropdownWidth - Helper.borderSize, false)
	ftable:setColWidth(6, dropdownWidth, false)

	if IsCheatVersion() and (menu.mode == "customgamestart") then
		local row = ftable:addRow(true, {  })
		row[1]:createCheckBox(menu.allownonplayerblueprints)
		row[1].handlers.onClick = function () menu.allownonplayerblueprints = not menu.allownonplayerblueprints; menu.onShowMenu(menu.onSaveState()) end
		row[2]:setColSpan(5):createText("Allow non-playerblueprint ships and equipment [Cheat only]") -- cheat only
	end

	-- currently editing
	local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
	row[1]:setColSpan(6):createText(menu.isReadOnly and ReadText(1001, 8045) or ReadText(1001, 8005), menu.headerTextProperties)

	if (menu.object ~= 0) or (menu.macro ~= "") then
		local removedEquipment = {}
		local currentEquipment = {}
		local newEquipment = {}
		local repairedEquipment = {}
		if menu.objectgroup then
			for i = 1, #menu.objectgroup.ships do
				local total, crewtotal, hasupgrades, hasrepairs, objecttotal, objectcrewtotal = menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment, menu.objectgroup.shipdata[i], menu.objectgroup.ships[i].ship)
				menu.objectgroup.states[i] = {
					hasupgrades = hasupgrades,
					hasrepairs = hasrepairs,
					price = objecttotal,
					crewprice = objectcrewtotal,
				}
				-- menu.checkEquipment() sums up the value of all changes
				menu.total = total
				menu.crewtotal = crewtotal
			end
		else
			menu.total, menu.crewtotal = menu.checkEquipment(removedEquipment, currentEquipment, newEquipment, repairedEquipment)
		end

		local buildorder = ffi.new("UIBuildOrderList")
		buildorder.shipid = menu.object
		buildorder.macroname = Helper.ffiNewString(menu.macro)
		buildorder.loadout = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return loadout end)
		buildorder.amount = 1
		if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.duration = (not menu.errors[4]) and C.GetBuildDuration(menu.container, buildorder) or 0
		end

		local colspan = 3
		if menu.isReadOnly then
			colspan = 5
		end

		local row = ftable:addRow(true, {  })
		local name = ""
		if menu.object ~= 0 then
			name = ffi.string(C.GetComponentName(menu.object))
		else
			name = GetMacroData(menu.macro, "name")
		end
		if menu.customshipname == nil then
			menu.customshipname = name
		end

		if menu.objectgroup then
			row[1]:setColSpan(colspan + 2):createText(#menu.objectgroup.ships .. ReadText(1001, 42) .. " " .. GetMacroData(menu.objectgroup.macro, "name"))
		elseif (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.customShipNameEditBox = row[1]:setColSpan(colspan):createEditBox({ description = ReadText(1001, 8537), height = Helper.standardTextHeight }):setText(menu.customshipname, { halign = "left" })
			row[1].handlers.onTextChanged = menu.editboxCustomShipName
			row[1].handlers.onEditBoxDeactivated = menu.editboxCustomShipNameDeactivated
			row[colspan + 1]:createButton({ height = Helper.standardTextHeight }):setText("X", { halign = "center" })
			row[colspan + 1].handlers.onClick = menu.buttonClearCustomShipName

			if not menu.isplayerowned then
				row[5]:setColSpan(2):createText(ConvertMoneyString(menu.total + menu.crewtotal, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
			end

			local row = ftable:addRow(true, {  })
			row[1]:setColSpan(colspan + 1):createButton({ height = Helper.standardTextHeight, active = function () return not utf8.find(menu.customshipname, name, nil, true) end }):setText(ReadText(1001, 8588), { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonCustomShipNameAppendShip(name) end

			local row = ftable:addRow(true, {  })
			row[1]:setColSpan(colspan + 1):createButton({ height = Helper.standardTextHeight, active = function () return not utf8.find(menu.customshipname, menu.loadoutName, nil, true) end }):setText(ReadText(1001, 8589), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCustomShipNameAppendLoadout

			local row = ftable:addRow(false, { bgColor = Color["row_background_unselectable"] })
			row[1]:setBackgroundColSpan(6)
			if (next(removedEquipment) == nil) and (next(newEquipment) == nil) and (#repairedEquipment > 0) then
				row[2]:setColSpan(3):createText(ReadText(1001, 8535))
			else
				row[2]:setColSpan(3):createText(ReadText(1001, 8508))
			end
			row[5]:setColSpan(2):createText((menu.warnings[4] and "--:--" or ConvertTimeString(menu.duration, (menu.duration >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
		else
			row[1]:setColSpan(colspan + 1):createText((menu.customshipname ~= "") and menu.customshipname or name)
		end

		if next(removedEquipment) or next(currentEquipment) or next(newEquipment) or (#repairedEquipment > 0) or (menu.object == 0) then
			-- chassis
			if menu.object == 0 then
				local ware = GetMacroData(menu.macro, "ware")
				if ware then
					local isextended = menu.isUpgradeExpanded(menu.currentIdx, ware, "chassis")
					local name = GetWareData(ware, "name")
					local resources = menu.getBuildResources(ware)

					row = ftable:addRow(true, {  })
					if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
						row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
						row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, ware, "chassis", row.index) end
					end
					row[2]:setColSpan(colspan):createText(ReadText(1001, 8008), { color = Color["text_positive"] })
					if (not menu.isReadOnly) and (not menu.isplayerowned) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
						row[5]:setColSpan(2):createText(ConvertMoneyString(tonumber(C.GetBuildWarePrice(menu.container, ware or "")), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Color["text_positive"] })
					end
					if resources and (#resources > 0) and isextended then
						menu.displayUpgradeResources(ftable, resources, 1)
					end
				end
			end
			for _, entry in ipairs(config.leftBar) do
				if removedEquipment[entry.mode] or currentEquipment[entry.mode] or newEquipment[entry.mode] then
					row = ftable:addRow(true, {  })
					row[2]:setColSpan(5):createText(entry.name,{ font = Helper.standardFontBold, titleColor = Color["row_title"] })
				end
				-- removed
				if removedEquipment[entry.mode] then
					for _, entry in ipairs(removedEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "removed")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						local mouseOverText = (name or "") .. "\n" .. string.format(ReadText(1026, 8010), ConvertMoneyString(-entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101))
						row = ftable:addRow(true, {  })
						if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
							row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, entry.ware, "removed", row.index) end
						end
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. (name or ""), { color = Color["text_negative"], mouseOverText = mouseOverText })
						if entry.price and (entry.price > 0) and (not menu.isplayerowned) then
							row[5]:setColSpan(2):createText(ConvertMoneyString(-entry.amount * entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Color["text_negative"], mouseOverText = mouseOverText })
						end
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
				-- current
				if currentEquipment[entry.mode] then
					for _, entry in ipairs(currentEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "current")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						row = ftable:addRow(true, {  })
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { mouseOverText = name })
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
				-- new
				if newEquipment[entry.mode] then
					for _, entry in ipairs(newEquipment[entry.mode]) do
						local isextended = menu.isUpgradeExpanded(menu.currentIdx, entry.ware, "new")
						local name = GetWareData(entry.ware, "name")
						local resources = menu.getBuildResources(entry.ware)
						local mouseOverText = (name or "") .. "\n" .. string.format(ReadText(1026, 8010), ConvertMoneyString(entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101))
						row = ftable:addRow(true, {  })
						if (resources ~= nil) and (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
							row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, entry.ware, "new", row.index) end
						end
						row[2]:setColSpan(colspan):createText(entry.amount .. ReadText(1001, 42) .. " " .. (name or ""), { color = Color["text_positive"], mouseOverText = mouseOverText })
						if entry.price and (entry.price > 0) and (not menu.isplayerowned) then
							row[5]:setColSpan(2):createText(ConvertMoneyString(entry.amount * entry.price, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Color["text_positive"], mouseOverText = mouseOverText })
						end
						if resources and (#resources > 0) and isextended then
							menu.displayUpgradeResources(ftable, resources, entry.amount)
						end
					end
				end
			end
			-- repaired
			if #repairedEquipment > 0 then
				row = ftable:addRow(true, {  })
				row[2]:setColSpan(5):createText(ReadText(1001, 3000),{ font = Helper.standardFontBold, titleColor = Color["row_title"] })
			end
			for _, entry in ipairs(repairedEquipment) do
				local repaircomponent = ConvertStringTo64Bit(entry.component)
				local isextended = menu.isUpgradeExpanded(menu.currentIdx, repaircomponent, "repair")
				local name = ffi.string(C.GetComponentName(repaircomponent)) .. " (" .. ffi.string(C.GetObjectIDCode(repaircomponent)) .. ")"

				local resources = {}
				local n = C.GetNumRepairResources2(menu.container, menu.object, repaircomponent)
				local buf = ffi.new("UIWareInfo[?]", n)
				n = C.GetRepairResources2(buf, n, menu.container, menu.object, repaircomponent)
				for i = 0, n - 1 do
					local amount = buf[i].amount
					if amount > 0 then
						table.insert(resources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
					end
				end

				row = ftable:addRow(true, {  })
				if (#resources > 0) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
					row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.expandUpgrade(menu.currentIdx, repaircomponent, "repair", row.index) end
				end
				row[2]:setColSpan(colspan):createText(ReadText(1001, 4217) .. ReadText(1001, 120) .. " " .. name, { color = Color["text_positive"], mouseOverText = name })
				if not menu.isplayerowned then
					row[5]:setColSpan(2):createText(ConvertMoneyString(tonumber(C.GetRepairPrice(repaircomponent, menu.container) * menu.repairdiscounts.totalfactor), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right", color = Color["text_positive"] })
				end
				if (#resources > 0) and isextended then
					menu.displayUpgradeResources(ftable, resources, 1)
				end
			end
		else
			row = ftable:addRow(true, {  })
			row[2]:setColSpan(5):createText("--- " .. ReadText(1001, 7936) .. " ---", { halign = "center" } )
		end

		if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			local row = ftable:addRow(true, {  })
			local hasupgrades = (next(removedEquipment) ~= nil) or (next(newEquipment) ~= nil) or (#menu.crew.transferdetails > 0)
			local hasrepairs = (#repairedEquipment > 0)
			local mouseovertext = ""
			for i, error in Helper.orderedPairs(menu.errors) do
				if (i >= 1) and (i <= 3) then
					if mouseovertext ~= "" then
						mouseovertext = mouseovertext .. "\n"
					else
						mouseovertext = ColorText["text_error"]
					end
					mouseovertext = mouseovertext .. ((type(error) == "function") and error(nil, true) or error)
				end
			end
			local button = row[3]:setColSpan(4):createButton({ active = (not menu.errors[1]) and (not menu.errors[2]) and (not menu.errors[3]) and (not menu.errors[5]) and (hasupgrades or hasrepairs), mouseOverText = mouseovertext, helpOverlayID = "shipconfig_addtoshoppinglist", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_addtoshoppinglist" }):setText(ReadText(1001, 8006), { halign = "center" })
			if (menu.object ~= 0) or (menu.macro ~= "") then
				button:setHotkey("INPUT_STATE_DETAILMONITOR_X", { displayIcon = true })
			end
			row[3].handlers.onClick = menu.editingshoppinglist and function () menu.buttonConfirmPurchaseEdit(hasupgrades, hasrepairs) end or function () menu.buttonAddPurchase(hasupgrades, hasrepairs) end
		end
	else
		-- nothing selected
		local row = ftable:addRow(true, {  })
		row[2]:setColSpan(5):createText(ReadText(1001, 8007))

		local row = ftable:addRow(true, {  })
		row[3]:setColSpan(4):createButton({ active = false, helpOverlayID = "shipconfig_addtoshoppinglist", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_addtoshoppinglist" }):setText(ReadText(1001, 8006), { halign = "center" })
	end

	if (not menu.isReadOnly) and (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
		-- shoppinglist
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(6):createText(ReadText(1001, 8009), menu.headerTextProperties)

		if next(menu.shoppinglist) then
			for i, entry in ipairs(menu.shoppinglist) do
				if i ~= menu.editingshoppinglist then
					-- name & icon
					local name, icon
					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						name = #groupentry.ships .. ReadText(1001, 42) .. " " .. GetMacroData(groupentry.macro, "name")
						icon = C.IsIconValid("ship_" .. groupentry.macro) and ("ship_" .. groupentry.macro) or "ship_notfound"
					elseif entry.object ~= 0 then
						name = ffi.string(C.GetComponentName(entry.object)) .. " (" .. ffi.string(C.GetObjectIDCode(entry.object)) .. ")"
						local macro = GetComponentData(ConvertStringTo64Bit(tostring(entry.object)), "macro")
						icon = C.IsIconValid("ship_" .. macro) and ("ship_" .. macro) or "ship_notfound"
					else
						name = GetMacroData(entry.macro, "name")
						icon = C.IsIconValid("ship_" .. entry.macro) and ("ship_" .. entry.macro) or "ship_notfound"
					end
					local row = ftable:addRow(false, {  })
					row[1]:setColSpan(2):createIcon(icon, { width = iconwidth, height = iconwidth, scaling = false, affectRowHeight = false, y = (iconwidth - Helper.scaleY(Helper.standardTextHeight)) / 2 })
					row[3]:setColSpan(4):createText((entry.customshipname ~= "") and entry.customshipname or name, { color = entry.color, font = Helper.standardFontBold, mouseOverText = menu.getLoadoutSummary(entry.upgradeplan, entry.crew, menu.repairplan and menu.repairplan[tostring(entry.object)], entry.paintmodware) })
					-- amount
					local researchprecursors, limitedamount
					if menu.mode == "purchase" then
						local ware = GetMacroData(entry.macro, "ware")
						local islimited = GetWareData(ware, "islimited")
						researchprecursors = GetWareData(ware, "productionresearchprecursors")

						if islimited then
							local limitamount = Helper.getLimitedWareAmount(ware)
							local shoppinglistamount = 0
							for i, entry in ipairs(menu.shoppinglist) do
								if i ~= menu.editingshoppinglist then
									if entry.macro == macro then
										shoppinglistamount = shoppinglistamount + entry.amount
									end
								end
							end

							local used = (menu.usedLimitedMacros[macro] or 0) + shoppinglistamount
							limitedamount = limitamount - used
						end
					end
					if (menu.mode == "purchase") and ((not researchprecursors) or (#researchprecursors == 0)) then
						local row = ftable:addRow(true, {  })
						row[3]:setColSpan(3):createText(ReadText(1001, 1202) .. ReadText(1001, 120))
						local options = {}
						for i = 1, 20 do
							if (not limitedamount) or (i <= limitedamount) then
								local active = true
								local mouseovertext = ""
								if (not menu.isplayerowned) and (playerMoney - menu.shoppinglisttotal - (i - entry.amount) * entry.price < 0) then
									active = false
									mouseovertext = ColorText["text_error"] .. ReadText(1026, 8016)
								end
								if entry.paintmodware and (not menu.modwaresByWare[entry.paintmodware].isdefault) then
									if (menu.modwaresByWare[entry.paintmodware].amount - shoppinglistpaintmods[entry.paintmodware]) < (i - entry.amount) then
										active = false
										mouseovertext = ColorText["text_error"] .. ReadText(1026, 8029)
									end
								end
								table.insert(options, { id = i, text = i, icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext, helpOverlayID = "shipconfig_purchaseamount_" .. i, helpOverlayText = " ", helpOverlayHighlightOnly = true })
							end
						end
						for i = 30, 100, 10 do
							if (not limitedamount) or (i <= limitedamount) then
								local active = true
								local mouseovertext = ""
								if (not menu.isplayerowned) and (playerMoney - menu.shoppinglisttotal - (i - entry.amount) * entry.price < 0) then
									active = false
									mouseovertext = ColorText["text_error"] .. ReadText(1026, 8016)
								end
								if entry.paintmodware and (not menu.modwaresByWare[entry.paintmodware].isdefault) then
									if (menu.modwaresByWare[entry.paintmodware].amount - shoppinglistpaintmods[entry.paintmodware]) < (i - entry.amount) then
										active = false
										mouseovertext = ColorText["text_error"] .. ReadText(1026, 8029)
									end
								end
								table.insert(options, { id = i, text = i, icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext, helpOverlayID = "shipconfig_purchaseamount_" .. i, helpOverlayText = " ", helpOverlayHighlightOnly = true })
							end
						end
						row[6]:createDropDown(options, { startOption = entry.amount, helpOverlayID = "shipconfig_purchaseamount", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setTextProperties({ halign = "right", x = Helper.standardTextOffsetx })
						row[6].handlers.onDropDownConfirmed = function (_, amountstring) return menu.dropdownChangePurchaseAmount(i, amountstring) end
					else
						local row = ftable:addRow(false, {  })
						row[1]:setColSpan(6):createText(" ")
					end
					-- price
					if not menu.isplayerowned then
						local row = ftable:addRow(false, {  })
						row[3]:setColSpan(2):createText(ReadText(1001, 2927) .. ReadText(1001, 120))
						row[5]:setColSpan(2):createText(ConvertMoneyString(entry.amount * (entry.price and (entry.price + entry.crewprice) or 0), false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
					end
					-- Time estimate
					local row = ftable:addRow(false, {  })
					row[3]:setColSpan(2):createText(ReadText(1001, 8508) .. ReadText(1001, 120))
					local object = entry.object
					local groupamount = 1
					if entry.objectgroup then
						local groupentry = menu.shipgroups[entry.objectgroup]
						object = groupentry.ships[1].ship
						groupamount = #groupentry.ships
					end
					local duration = math.max(math.ceil(entry.amount * groupamount / C.GetNumSuitableBuildProcessors(menu.container, object, entry.macro)) * entry.duration, entry.duration)
					row[5]:setColSpan(2):createText((menu.warnings[4] and "- -:- -" or ConvertTimeString(duration, (duration >= 3600) and "%h:%M:%S" or "%M:%S")), { halign = "right" })
					-- edit & remove
					local row = ftable:addRow(true, {  })
					row[3]:setColSpan(2):createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 8529), { halign = "center" })
					row[3].handlers.onClick = function () return menu.buttonEditPurchase(i) end
					row[5]:setColSpan(2):createButton({ height = Helper.standardTextHeight }):setText(ReadText(1001, 8530), { halign = "center" })
					row[5].handlers.onClick = function () return menu.buttonRemovePurchase(i) end
					if i ~= #menu.shoppinglist then
						local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
						row[1]:setColSpan(6):createText(" ", { height = 2, fontsize = 1 })
					end
				end
			end
		else
			local row = ftable:addRow(true, {  })
			row[2]:setColSpan(5):createText("--- " .. ReadText(1001, 34) .. " ---")
		end
	end

	ftable:addConnection(1, 4, true)
	local offset = 1
	if statustable then
		offset = offset + 1
		statustable:addConnection(offset, 4)
	end
	if resourcetable then
		offset = offset + 1
		resourcetable:addConnection(offset, 4)
	end
	offset = offset + 1
	buttontable:addConnection(offset, 4)

	menu.topRows.plan = nil
	menu.selectedRows.plan = nil
	menu.selectedCols.plan = nil
end

function menu.getBuildResources(ware)
	local resources = {}
	if menu.container and (not menu.errors[4]) then
		local n = C.GetNumBuildResources(menu.container, menu.object, menu.macro, ware)
		local buf = ffi.new("UIWareInfo[?]", n)
		n = C.GetBuildResources(buf, n, menu.container, menu.object, menu.macro, ware)
		for i = 0, n - 1 do
			local amount = buf[i].amount
			if amount > 0 then
				table.insert(resources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
	end
	return resources
end

function menu.displayUpgradeResources(ftable, resources, upgradeamount)
	local colspan = 3
	if menu.isReadOnly then
		colspan = 6
	end

	for _, resource in ipairs(resources) do
		local ismissing = false
		for _, entry in ipairs(menu.missingResources) do
			if entry.ware == resource.ware then
				ismissing = true
				break
			end
		end
		local row = ftable:addRow(true, {  })
		local color = Color["text_normal"]
		if ismissing then
			color = Color["text_error"]
		end
		row[2]:setColSpan(colspan):createText("   " .. upgradeamount * resource.amount .. ReadText(1001, 42) .. " " .. GetWareData(resource.ware, "name"), { color = color, mouseOverText = mouseOverText })
	end
end

function menu.displayModifyPlan(frame)
	-- errors & warnings
	menu.criticalerrors = {}
	menu.errors = {}
	if menu.upgradetypeMode == "paintmods" then
		menu.warnings = {}

		local isdefaultpaintmod = false
		local buf = ffi.new("UIPaintMod")
		if (menu.object ~= 0) or (menu.macro ~= "") then
			if C.GetPlayerPaintThemeMod(menu.object, menu.macro, buf) then
				if menu.installedPaintMod and (ffi.string(buf.Ware) == menu.installedPaintMod.ware) then
					isdefaultpaintmod = true
				end
			end
		end
		if not isdefaultpaintmod then
			menu.warnings = {
				[1] = ReadText(1001, 8518)
			}
		end
	else
		menu.warnings = {}
		if not menu.isplayerowned then
			menu.warnings[1] = ReadText(1001, 8036)
		end
	end

	menu.shoppinglisttotal = 0

	-- BUTTONS
	local buttontable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = Helper.viewHeight - Helper.scaleY(Helper.standardButtonHeight) - menu.planData.offsetY, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })

	if not menu.isplayerowned then
		local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setColSpan(2):createText(menu.container and string.format(ReadText(1001, 8531), (menu.isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(menu.container))) or ReadText(1001, 8012), menu.headerTextProperties)

		local row = buttontable:addRow(false, { fixed = true })
		row[1]:createText(ReadText(1001, 2003))
		row[2]:createText(function () return ConvertMoneyString(GetPlayerMoney(), false, true, 0, true, false) .. " " .. ReadText(1001, 101) end, { halign = "right" })
	end

	local row = buttontable:addRow(true, { fixed = true })
	row[2]:createButton({ }):setText(ReadText(1001, 8035), { halign = "center" })
	row[2].handlers.onClick = function () return menu.closeMenu("back") end

	buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - menu.planData.offsetY

	-- STATUS
	local infoCount = 0
	local visibleHeight

	local statustable
	if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
		if not menu.warningShown then
			PlaySound("ui_notification_pickup_fail")
		end
		menu.warningShown = menu.warningShown or getElapsedTime()

		local iconfactor = 1.6
		local iconsize = iconfactor * Helper.headerRow1Height

		statustable = frame:addTable(4, { tabOrder = 7, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		statustable:setColWidth(1, iconsize)
		statustable:setColWidth(4, iconsize)

		local row = statustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:setBackgroundColSpan(4):createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
		row[1].properties.fontsize = iconfactor * row[1].properties.fontsize
		row[1].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))
		row[2]:setColSpan(2):createText(ReadText(1001, 8342), menu.headerWarningTextProperties)
		row[4]:createText("\27[maptr_illegal]", menu.headerWarningTextProperties)
		row[4].properties.fontsize = iconfactor * row[4].properties.fontsize
		row[4].properties.y = math.floor((menu.titleData.height - Helper.scaleY(iconfactor * Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety))

		for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
			row = statustable:addRow(true, {  })
			row[1]:setColSpan(4):createText(errorentry, { color = Color["text_criticalerror"], wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end
		for _, errorentry in Helper.orderedPairs(menu.errors) do
			row = statustable:addRow(true, {  })
			row[1]:setColSpan(4):createText(errorentry, { color = Color["text_error"], wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end
		for _, warningentry in Helper.orderedPairs(menu.warnings) do
			row = statustable:addRow(true, {  })
			row[1]:setColSpan(4):createText(warningentry, { color = Color["text_warning"], wordwrap = true })
			infoCount = infoCount + 1
			if infoCount == 4 then
				visibleHeight = statustable:getFullHeight()
			end
		end

		if visibleHeight then
			statustable.properties.maxVisibleHeight = visibleHeight
		else
			statustable.properties.maxVisibleHeight = statustable:getFullHeight()
		end
		statustable.properties.y = buttontable.properties.y - statustable:getVisibleHeight() - 2 * Helper.borderSize
	else
		menu.warningShown = nil
	end

	-- PRICE LIST
	local maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY
	if next(menu.criticalerrors) or next(menu.errors) or next(menu.warnings) then
		maxVisibleHeight = statustable.properties.y - menu.planData.offsetY
	end
	local ftable = frame:addTable(2, { tabOrder = 0, width = menu.planData.width, maxVisibleHeight = maxVisibleHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
	ftable:setColWidth(2, 0.3 * menu.planData.width)

	if not menu.isplayerowned then
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(2):createText(ReadText(1001, 8037), menu.headerTextProperties)

		if menu.upgradetypeMode == "paintmods" then
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8517))
		else
			for i = #Helper.modQualities, 1, -1 do
				local entry = Helper.modQualities[i]
				local row = ftable:addRow(false, {  })
				row[1]:createText(entry.name)
				row[2]:createText(ConvertMoneyString(entry.price * menu.moddingdiscounts.totalfactor, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
			end

			if #menu.moddingdiscounts > 0 then
				ftable:addEmptyRow()

				local row = ftable:addRow(nil, { bgColor = Color["row_title_background"] })
				row[1]:setColSpan(2):createText(ReadText(1001, 2819), menu.subHeaderTextProperties)

				for _, entry in ipairs(menu.moddingdiscounts) do
					local row = ftable:addRow(nil, {  })
					row[1]:createText(entry.name)
					row[2]:createText(entry.amount .. " %", { halign = "right" })
				end
			end
		end
	end

	-- SELECTEDSHIPS
	if menu.modeparam[1] then
		local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
		row[1]:setColSpan(2):createText(ReadText(1001, 8519), menu.headerTextProperties)
		for _, ship in pairs(menu.modeparam[2]) do
			local row = ftable:addRow(false, {  })
			row[1]:createText(ffi.string(C.GetComponentName(ship)) .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")", { color = Color["text_player"] })
			local paintmod = ffi.new("UIPaintMod")
			if C.GetInstalledPaintMod(ship, paintmod) then
				row[2]:createText(ffi.string(paintmod.Name), { color = Helper.modQualities[paintmod.Quality].color, halign = "right" })
			end
		end
	end

	buttontable:addConnection(1, 4, true)

	menu.topRows.plan = nil
	menu.selectedRows.plan = nil
	menu.selectedCols.plan = nil
end

function menu.displayStats(frame)
	-- title
	local titletable = frame:addTable(7, { tabOrder = 19, width = menu.statsData.width, x = menu.statsData.offsetX, y = 0, reserveScrollBar = false })
	local title = ReadText(1001, 8534)
	local titlewidth = C.GetTextWidth(title, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)) + 2 * (Helper.headerRow1Offsetx + Helper.borderSize)
	local checkboxwidth = Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize
	titletable:setColWidth(2, checkboxwidth, false)
	titletable:setColWidth(3, checkboxwidth, false)
	titletable:setColWidth(4, titlewidth, false)
	titletable:setColWidth(5, checkboxwidth, false)
	titletable:setColWidth(6, checkboxwidth, false)

	local statskeyword = "showStats2"
	if (menu.mode == "modify") and (menu.upgradetypeMode == "paintmods") then
		statskeyword = "showStatsPaintMod2"
	end

	local row = titletable:addRow(true, { fixed = true, borderBelow = false })
	local upactive = __CORE_DETAILMONITOR_SHIPBUILD[statskeyword] ~= "full"
	row[2]:createButton({ height = checkboxwidth, scaling = false, active = upactive }):setIcon("widget_arrow_up_02")
	row[2].handlers.onClick = menu.buttonExpandStats
	local downactive = __CORE_DETAILMONITOR_SHIPBUILD[statskeyword] ~= "hidden"
	row[3]:createButton({ height = checkboxwidth, scaling = false, active = downactive }):setIcon("widget_arrow_down_02")
	row[3].handlers.onClick = menu.buttonCollapseStats
	row[4]:createText(title, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, halign = "left" })

	if menu.selectedCols.stats then
		if ((menu.selectedCols.stats ~= 2) or upactive) and ((menu.selectedCols.stats ~= 3) or downactive) then
			titletable:setSelectedCol(menu.selectedCols.stats)
		end
	end
	menu.selectedCols.stats = nil

	if __CORE_DETAILMONITOR_SHIPBUILD[statskeyword] ~= "hidden" then
		local row = titletable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(7):createText(" ", { fontsize = 1, height = 2 })

		local loadoutstats, currentloadoutstats
		if menu.usemacro then
			local ffiloadoutstats = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetLoadoutStatistics5(0, menu.macro, loadout) end)
			loadoutstats = Helper.convertLoadoutStats(ffiloadoutstats)

			currentloadoutstats = Helper.convertLoadoutStats(ffi.new("UILoadoutStatistics5", 0))
		elseif menu.mode == "upgrade" then
			local ffiloadoutstats = Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.GetLoadoutStatistics5(menu.object, "", loadout) end)
			loadoutstats = Helper.convertLoadoutStats(ffiloadoutstats)

			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
			currentloadoutstats = Helper.convertLoadoutStats(fficurrentloadoutstats)
		elseif menu.mode == "modify" then
			local fficurrentloadoutstats = C.GetCurrentLoadoutStatistics5(menu.object)
			loadoutstats = Helper.convertLoadoutStats(fficurrentloadoutstats)

			currentloadoutstats = menu.initialLoadoutStatistics
		end

		local ffimaxloadoutstats = C.GetMaxLoadoutStatistics5(menu.object, menu.macro)
		local maxloadoutstats = Helper.convertLoadoutStats(ffimaxloadoutstats)

		local ftable = frame:addTable(6, { tabOrder = 0, width = menu.statsData.width, x = menu.statsData.offsetX, y = titletable:getFullHeight() + Helper.borderSize, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		ftable:setColWidthPercent(2, 10)
		ftable:setColWidthPercent(5, 10)

		local iscapship = false
		-- If we have an object or a macro use its size information
		if menu.object ~= 0 then
			iscapship = C.IsComponentClass(menu.object, "ship_l") or C.IsComponentClass(menu.object, "ship_xl")
		elseif menu.macro ~= "" then
			iscapship = IsMacroClass(menu.macro, "ship_l") or IsMacroClass(menu.macro, "ship_xl")
		end

		local stats = {}
		local islimited = __CORE_DETAILMONITOR_SHIPBUILD[statskeyword] == "limited"
		if islimited then
			stats = Helper.tableCopy(config.limitedStats)
			for i = #stats, 1, -1 do
				if stats[i].hasany and (loadoutstats[stats[i].id] == 0) then
					table.remove(stats, i)
				elseif stats[i].class and (not stats[i].class[menu.class]) then
					table.remove(stats, i)
				end
			end
		else
			stats = config.stats
		end

		local numRows = math.ceil(#stats / 2)
		for i = 1, numRows do
			if (not islimited) or (stats[i].id ~= "") or ((i + numRows <= #stats) and (stats[i + numRows].id ~= "")) then
				local row = ftable:addRow(false, {  })
				local entry = stats[i]

				local id = entry.id
				if entry.capshipid ~= nil then
					id = iscapship and entry.capshipid or id
				end

				if id ~= "" then
					local color = (maxloadoutstats[id] == 0) and Color["text_inactive"] or Color["text_normal"]
					row[1]:createText(entry.name .. ((entry.unit ~= "") and (" (" .. entry.unit .. ")") or ""), { mouseOverText = entry.mouseovertext, color = color })
					if loadoutstats[id] > currentloadoutstats[id] then
						color = entry.inverted and (menu.usemacro and Color["text_normal"] or Color["text_negative"]) or Color["text_positive"]
					elseif loadoutstats[id] < currentloadoutstats[id] then
						color = entry.inverted and Color["text_positive"] or Color["text_negative"]
					end
					local value
					if entry.type == "UINT" then
						value = ConvertIntegerString(Helper.round(loadoutstats[id], 0), true, 0, true, false)
					elseif (entry.type == "float") or (entry.type == "double") then
						local int, frac = math.modf(Helper.floor(loadoutstats[id], entry.accuracy))
						value = ConvertIntegerString(int, true, 0, true, false)
						if entry.accuracy > 0 then
							frac = Helper.round(math.abs(frac or 0) * (10 ^ entry.accuracy))
							value = value .. ReadText(1001, 105) .. string.format("%0".. (entry.accuracy) .."d", frac)
						end
					end
					row[2]:createText(value, { halign = "right", color = color })
						local posChangeColor, negChangeColor
						if entry.inverted then
							if menu.usemacro then
								posChangeColor = Color["statusbar_value_default"]
							else
								posChangeColor = Color["statusbar_diff_neg_default"]
							end
							negChangeColor = Color["statusbar_diff_pos_default"]
						end
					row[3]:createStatusBar({ current = loadoutstats[id], start = currentloadoutstats[id], max = maxloadoutstats[id], cellBGColor = Color["ship_stat_background"], posChangeColor = posChangeColor, negChangeColor = negChangeColor })
				else
					row[1]:createText("")
				end
				if i + numRows <= #stats then
					local entry2 = stats[i + numRows]

					local id2 = entry2.id
					if entry2.capshipid ~= nil then
						id2 = iscapship and entry2.capshipid or id2
					end

					if id2 ~= "" then
						row[4]:createText(entry2.name .. ((entry2.unit ~= "") and (" (" .. entry2.unit .. ")") or ""))
						local color = Color["text_normal"]
						if loadoutstats[id2] > currentloadoutstats[id2] then
							color = entry2.inverted and (menu.usemacro and Color["text_normal"] or Color["text_negative"]) or Color["text_positive"]
						elseif loadoutstats[id2] < currentloadoutstats[id2] then
							color = entry2.inverted and Color["text_positive"] or Color["text_negative"]
						end
						local value
						if entry2.type == "UINT" then
							value = ConvertIntegerString(Helper.round(loadoutstats[id2], 0), true, 0, true, false)
						elseif (entry2.type == "float") or (entry2.type == "double") then
							local int, frac = math.modf(Helper.floor(loadoutstats[id2], entry2.accuracy))
							value = ConvertIntegerString(int, true, 0, true, false)
							if entry2.accuracy > 0 then
								frac = Helper.round(math.abs(frac or 0) * (10 ^ entry2.accuracy))
								value = value .. ReadText(1001, 105) .. string.format("%0".. (entry2.accuracy) .."d", frac)
							end
						end
						row[5]:createText(value, { halign = "right", color = color })
						local posChangeColor, negChangeColor
						if entry2.inverted then
							if menu.usemacro then
								posChangeColor = Color["statusbar_value_default"]
							else
								posChangeColor = Color["statusbar_diff_neg_default"]
							end
							negChangeColor = Color["statusbar_diff_pos_default"]
						end
						row[6]:createStatusBar({ current = loadoutstats[id2], start = currentloadoutstats[id2], max = maxloadoutstats[id2], cellBGColor = Color["ship_stat_background"], posChangeColor = posChangeColor, negChangeColor = negChangeColor })
					else
						row[4]:createText("")
					end
				end
			end
		end

		titletable.properties.y = Helper.viewHeight - titletable:getFullHeight() - Helper.borderSize - ftable:getVisibleHeight() - menu.statsData.offsetY
		ftable.properties.y = titletable.properties.y + ftable.properties.y
	else
		titletable.properties.y = Helper.viewHeight - titletable:getFullHeight() - menu.statsData.offsetY
	end

	menu.statsTableOffsetY = titletable.properties.y

	titletable:addConnection(2, 3)
end

function menu.evaluateShipOptions()
	local classOptions = {}
	for _, class in ipairs(config.classorder) do
		if menu.usemacro then
			if menu.availableshipmacrosbyclass[class] then
				table.insert(classOptions, { id = class, text = ReadText(1001, 8026) .. " " .. Helper.getClassText(class), icon = "", displayremoveoption = false, helpOverlayID = "shipconfig_classoptions_" .. class, helpOverlayText = " ", helpOverlayHighlightOnly = true })
			end
		elseif (menu.mode == "upgrade") or (menu.mode == "modify") then
			if menu.selectableshipsbyclass[class] then
				table.insert(classOptions, { id = class, text = ReadText(1001, 8026) .. " " .. Helper.getClassText(class), icon = "", displayremoveoption = false, helpOverlayID = "shipconfig_classoptions_" .. class, helpOverlayText = " ", helpOverlayHighlightOnly = true })
			end
		end
	end

	local shipOptions = {}
	local curShipOption
	if menu.usemacro then
		if menu.class ~= "" then
			for _, macro in ipairs(menu.availableshipmacrosbyclass[menu.class]) do
				local haslicence, icon, overridecolor, mouseovertext, limitstring = menu.checkLicence(macro, true)
				local name, infolibrary, shiptypename, primarypurpose, shipicon, ware = GetMacroData(macro, "name", "infolibrary", "shiptypename", "primarypurpose", "icon", "ware")

				-- start: alexandretk call-back
				if menu.uix_callbacks ["evaluateShipOptions_override_shiptypename"] then
					local shiptypename_override
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["evaluateShipOptions_override_shiptypename"]) do
						shiptypename_override = uix_callback (shiptypename, shipicon, menu.class)
						if shiptypename_override then
							shiptypename = shiptypename_override
							break
						end
					end
				end
				-- end: alexandretk call-back

				local ishiddenwithoutlicence = GetWareData(ware, "ishiddenwithoutlicence")
				if (not ishiddenwithoutlicence) or haslicence then
					table.insert(shipOptions, { id = macro, text = "\27[" .. shipicon .. "] " .. name .. " - " .. shiptypename .. limitstring, icon = icon or "", displayremoveoption = false, overridecolor = overridecolor, mouseovertext = mouseovertext, name = name .. " - " .. shiptypename, objectid = "", class = menu.class, purpose = primarypurpose, helpOverlayID = "shipconfig_shipoptions_" .. macro, helpOverlayText = " ", helpOverlayHighlightOnly = true })
					AddKnownItem(infolibrary, macro)
				end
			end
		end
		curShipOption = menu.macro
		table.sort(shipOptions, Helper.sortShipsByClassAndPurpose)
	elseif menu.class ~= "" then
		if menu.mode == "upgrade" then
			for _, entry in ipairs(menu.selectableshipsbyclass[menu.class] or {}) do
				if entry.group then
					local groupentry = menu.shipgroups[entry.group]
					local name = GetMacroData(groupentry.macro, "name")

					local icon = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.objectgroup == entry.group then
							icon = "menu_shoppingcart"
							break
						end
					end

					local mouseovertext = ""
					for i, ship in ipairs(groupentry.ships) do
						if i ~= 1 then
							mouseovertext = mouseovertext .. "\n"
						end
						mouseovertext = mouseovertext .. "\27[" .. ship.icon .. "] " .. ship.name .. " (" .. ship.objectid .. ")"
					end
					table.insert(shipOptions, { id = groupentry.macro, text = "\27[" .. groupentry.ships[1].icon .. "] " .. #groupentry.ships .. ReadText(1001, 42) .. " " .. name, icon = icon, displayremoveoption = false, mouseovertext = mouseovertext })
				elseif entry.grouped ~= nil then
					local icon = ""
					local active = true
					local mouseovertext = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.objectgroup == entry.groupidx then
							icon = "menu_shoppingcart"
							if entry.grouped then
								active = false
								mouseovertext = ReadText(1026, 8025)
							end
							break
						elseif shoppinglistentry.object == entry.ship.ship then
							icon = "menu_shoppingcart"
							break
						end
					end

					table.insert(shipOptions, { id = tostring(entry.ship.ship), text = (entry.grouped and "       " or "") .. "\27[" .. entry.ship.icon .. "] " .. entry.ship.name .. " (" .. entry.ship.objectid .. ")", icon = icon, displayremoveoption = false, active = active, mouseovertext = mouseovertext })
				else
					local icon = ""
					for i, shoppinglistentry in ipairs(menu.shoppinglist) do
						if shoppinglistentry.object == entry.ship then
							icon = "menu_shoppingcart"
							break
						end
					end

					local modicon = ""
					local modquality = C.GetHighestEquipmentModQuality(entry.ship)
					if modquality > 0 then
						modicon = " \27[mods_grade_0" .. modquality .. "]"
					end

					table.insert(shipOptions, { id = tostring(entry.ship), text = "\27[" .. entry.icon .. "] " .. entry.name .. " (" .. entry.objectid .. ")" .. modicon, icon = icon, displayremoveoption = false })
				end
			end
			if menu.objectgroup then
				curShipOption = menu.objectgroup.macro
			else
				curShipOption = tostring(menu.object)
			end
		elseif menu.mode == "modify" then
			for _, ship in ipairs(menu.selectableshipsbyclass[menu.class] or {}) do
				local name = ffi.string(C.GetComponentName(ship))
				local idcode = ffi.string(C.GetObjectIDCode(ship))
				local primarypurpose, icon = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "primarypurpose", "icon")

				table.insert(shipOptions, { id = tostring(ship), text = "\27[" .. icon .. "] " .. name .. " (" .. idcode .. ")", icon = "", displayremoveoption = false, name = name, objectid = idcode, class = menu.class, purpose = primarypurpose })
			end
			table.sort(shipOptions, Helper.sortShipsByClassAndPurpose)
			curShipOption = tostring(menu.object)
		end
	end

	local loadoutOptions = {}
	if next(menu.loadouts) then
		for _, loadout in ipairs(menu.loadouts) do
			table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
		end
	end

	return classOptions, shipOptions, curShipOption, loadoutOptions
end

function menu.createTitleBar(frame)
	local classOptions, shipOptions, curShipOption, loadoutOptions = menu.evaluateShipOptions()

	if menu.mode == "modify" then
		local ftable = frame:addTable(5, { tabOrder = 4, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
		ftable:setColWidth(1, menu.titleData.dropdownWidth)
		ftable:setColWidth(2, menu.titleData.dropdownWidth)
		ftable:setColWidth(3, menu.titleData.height)
		ftable:setColWidth(4, menu.titleData.height)
		ftable:setColWidth(5, menu.titleData.height)

		local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		-- class
		row[1]:createDropDown(classOptions, { startOption = menu.class, active = (not menu.isReadOnly) and (#classOptions > 0), optionWidth = menu.titleData.dropdownWidth, helpOverlayID = "shipconfig_classoptions", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_classoptions" }):setTextProperties(config.dropDownTextProperties)
		row[1].handlers.onDropDownConfirmed = menu.dropdownShipClass
		-- ships
		local dropDownIconProperties = {
			width = menu.titleData.height / 2,
			height = menu.titleData.height / 2,
			x = menu.titleData.dropdownWidth - 1.5 * menu.titleData.height,
			y = 0,
			scaling = false,
		}

		row[2]:createDropDown(shipOptions, { startOption = curShipOption, active = (not menu.isReadOnly) and (menu.class ~= ""), optionWidth = menu.titleData.dropdownWidth, optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder, helpOverlayID = "shipconfig_shipoptions", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_shipoptions" }):setTextProperties(config.dropDownTextProperties):setIconProperties(dropDownIconProperties)
		row[2].properties.text.halign = "left"
		row[2].handlers.onDropDownConfirmed = menu.dropdownShip
		-- reset camera
		row[3]:createButton({ active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[3].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		row[4]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex < #menu.undoStack) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[4].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		row[5]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex > 1) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[5].handlers.onClick = function () return menu.undoHelper(false) end

		ftable:addConnection(1, 3, true)
	else
		local ftable = frame:addTable(7, { tabOrder = 4, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
		if ((menu.macro == "") and (menu.object == 0)) then
			ftable.properties.defaultInteractiveObject = true
		end
		ftable:setColWidth(1, config.dropdownRatios.class * menu.titleData.dropdownWidth)
		ftable:setColWidth(2, config.dropdownRatios.ship * menu.titleData.dropdownWidth)
		ftable:setColWidth(3, menu.titleData.dropdownWidth)
		ftable:setColWidth(4, menu.titleData.height)
		ftable:setColWidth(5, menu.titleData.height)
		ftable:setColWidth(6, menu.titleData.height)
		ftable:setColWidth(7, menu.titleData.height)

		local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
		-- class
		row[1]:createDropDown(classOptions, { startOption = menu.class, active = (not menu.isReadOnly) and (#classOptions > 0), helpOverlayID = "shipconfig_classoptions", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setTextProperties(config.dropDownTextProperties)
		row[1].handlers.onDropDownConfirmed = menu.dropdownShipClass
		-- ships
		local dropDownIconProperties = {
			width = menu.titleData.height / 2,
			height = menu.titleData.height / 2,
			x = config.dropdownRatios.ship * menu.titleData.dropdownWidth - 1.5 * menu.titleData.height,
			y = 0,
			scaling = false,
		}

		local dropdown = row[2]:createDropDown(shipOptions, { startOption = curShipOption, active = (not menu.isReadOnly) and (menu.class ~= ""), optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder, helpOverlayID = "shipconfig_shipoptions", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setTextProperties(config.dropDownTextProperties):setIconProperties(dropDownIconProperties)
		row[2].properties.text.halign = "left"
		row[2].handlers.onDropDownConfirmed = menu.dropdownShip
		local active = true
		if (menu.mode == "purchase") and (menu.macro ~= "") and (not menu.validLicence) then
			active = false
			local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(menu.macro, true)
			dropdown.properties.text.color = overridecolor
			dropdown.properties.icon.color = overridecolor
		end
		if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
			if not C.CanContainerEquipShip(menu.container, menu.object) then
				active = false
			end
		end

		-- loadout
		row[3]:createDropDown(loadoutOptions, { textOverride = ReadText(1001, 7905), active = (not menu.isReadOnly) and active and ((menu.object ~= 0) or (menu.macro ~= "")) and (next(menu.loadouts) ~= nil), optionWidth = menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize, optionHeight = (menu.statsTableOffsetY or Helper.viewHeight) - menu.titleData.offsetY - Helper.frameBorder, mouseOverText = (menu.mode == "customgamestart") and (ColorText["text_warning"] .. ReadText(1026, 8022)) or "" }):setTextProperties(config.dropDownTextProperties)
		row[3].handlers.onDropDownConfirmed = menu.dropdownLoadout
		row[3].handlers.onDropDownRemoved = menu.dropdownLoadoutRemoved
		-- save

		-- mycu start: callback
		if menu.uix_callbacks ["displaySlots_on_before_create_store_loadout_button"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySlots_on_before_create_store_loadout_button"]) do
				uix_callback ()
			end
		end
		-- mycu end: callback

		row[4]:createButton({ active = (not menu.isReadOnly) and active and ((menu.object ~= 0) or (menu.macro ~= "")), height = menu.titleData.height, mouseOverText = ReadText(1026, 7905), helpOverlayID = "shipconfig_saveloadout", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_saveloadout" }):setIcon("menu_save")
		row[4].handlers.onClick = menu.buttonTitleSave

		-- mycu start: callback
		if menu.uix_callbacks ["displaySlots_on_after_create_store_loadout_button"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySlots_on_after_create_store_loadout_button"]) do
				uix_callback ()
			end
		end
		-- mycu end: callback

		-- reset camera
		row[5]:createButton({ active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[5].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		row[6]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex < #menu.undoStack) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[6].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		row[7]:createButton({ active = function () return (#menu.undoStack > 1) and (menu.undoIndex > 1) end, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[7].handlers.onClick = function () return menu.undoHelper(false) end

		ftable:addConnection(1, 3, true)
	end

	menu.topRows.ship = nil
	menu.selectedRows.ship = nil
	menu.selectedCols.ship = nil
end

function menu.displayMenu(firsttime)
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.infoLayer)
	Helper.currentTableRow = {}

	menu.infoFrame = Helper.createFrameHandle(menu, {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- title bar
	menu.createTitleBar(menu.infoFrame)

	menu.displayLeftBar(menu.infoFrame)

	if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
		if menu.upgradetypeMode == "paintmods" then
			menu.displayModifyPaintSlots(menu.infoFrame)
		else
			menu.displaySlots(menu.infoFrame, firsttime)
		end
	elseif menu.mode == "modify" then
		if menu.upgradetypeMode == "paintmods" then
			menu.displayModifyPaintSlots(menu.infoFrame)
		else
			menu.displayModifySlots(menu.infoFrame)
		end
	else
		menu.displayEmptySlots(menu.infoFrame)
	end

	if menu.usemacro or (menu.mode == "upgrade") then
		menu.displayPlan(menu.infoFrame)
	elseif menu.mode == "modify" then
		menu.displayModifyPlan(menu.infoFrame)
	end

	menu.statsTableOffsetY = nil
	if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
		menu.displayStats(menu.infoFrame)
	end

	menu.infoFrame:display()
end

function menu.displayContextFrame(mode, width, x, y)
	PlaySound("ui_positive_click")
	menu.contextMode = { mode = mode, width = width, x = x, y = y }
	if mode == "saveLoadout" then
		menu.createLoadoutSaveContext()
	elseif mode == "equipment" then
		menu.createEquipmentContext()
	elseif mode == "userquestion" then
		menu.createUserQuestionContext()
	elseif mode == "equipmentfilter" then
		menu.createEquipmentFilterContext()
	elseif mode == "slot" then
		menu.createSlotContext()
	end
end

function menu.createSlotContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
	local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
	local slotdata
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		slotdata = menu.groups[menu.currentSlot][upgradetype2.grouptype]
	else
		slotdata = menu.slots[upgradetype.type][menu.contextData.slot]
	end
	local plandata
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		plandata = menu.upgradeplan[upgradetype2.type][menu.currentSlot].macro
	else
		plandata = menu.upgradeplan[upgradetype.type][menu.contextData.slot].macro
	end
	local prefix = ""
	if upgradetype.mergeslots then
		prefix = #menu.slots[upgradetype.type] .. ReadText(1001, 42) .. " "
	end

	local hasmod, modicon = false, ""
	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		hasmod, modicon = menu.checkMod(upgradetype2.grouptype, slotdata.currentcomponent, true)
	else
		hasmod, modicon = menu.checkMod(upgradetype.type, slotdata.component)
	end

	local canequip = not menu.isReadOnly
	if (menu.mode == "upgrade") and (not menu.isReadOnly) and (menu.object ~= 0) then
		canequip = C.CanContainerEquipShip(menu.container, menu.object)
	end

	if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
		local name = upgradetype2.text.default
		if plandata == "" then
			if slotdata.slotsize ~= "" then
				name = upgradetype2.text[slotdata.slotsize]
			end
		else
			name = GetMacroData(plandata, "name")
		end

		if not upgradetype2.mergeslots then
			local minselect = (plandata == "") and 0 or 1
			local maxselect = (plandata == "") and 0 or slotdata.total

			local scale = {
				min       = 0,
				minselect = minselect,
				max       = slotdata.total,
				maxselect = maxselect,
				step      = 1,
				suffix    = "",
				exceedmax = false,
				readonly = canequip and (hasmod or menu.isReadOnly),
			}

			-- handle already installed equipment
			local haslicence = menu.checkLicence(plandata)
			if (plandata == menu.groups[menu.currentSlot][upgradetype2.grouptype].currentmacro) and (not haslicence) then
				scale.maxselect = math.min(scale.maxselect, slotdata.count)
			end
			local j = menu.findUpgradeMacro(upgradetype2.grouptype, plandata)
			if j then
				local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
				if not upgradeware.isFromShipyard then
					scale.maxselect = menu.objectgroup and 0 or math.min(scale.maxselect, slotdata.count)
					if menu.objectgroup then
						scale.minselect = 0
					end
				end
			end
			scale.start = math.max(scale.minselect, math.min(scale.maxselect, menu.upgradeplan[upgradetype2.type][menu.currentSlot].count))

			local mouseovertext = ""
			if hasmod then
				mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X"
			end

			local row = ftable:addRow(true)
			row[1]:createSliderCell({ height = Helper.headerRow1Height, valueColor = Color["slider_value"], min = scale.min, minSelect = scale.minselect, max = scale.max, maxSelect = scale.maxselect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedmax, readOnly = scale.readonly, mouseOverText = mouseovertext }):setText(name, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
			row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectGroupAmount(upgradetype2.type, menu.currentSlot, nil, row.index, ...) end
		else
			local row = ftable:addRow(nil)
			row[1]:createText(name)
		end
	end

	for k, macro in ipairs(slotdata.possiblemacros) do
		local name = prefix .. GetMacroData(macro, "name")

		local haslicence, icon, overridecolor, mouseovertext = menu.checkLicence(macro, true)

		-- handle already installed equipment
		if (macro == slotdata.currentmacro) and (not haslicence) then
			haslicence = true
			mouseovertext = mouseovertext .. "\n" .. ColorText["text_positive"] .. ReadText(1026, 8004)
		end

		if hasmod then
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X\n" .. mouseovertext
		end

		mouseovertext = name .. "\n" .. mouseovertext

		local bgcolor = Color["button_background_default"]
		if not haslicence then
			bgcolor = Color["button_background_inactive"]
		end

		local color = Color["text_normal"]
		if (macro == slotdata.currentmacro) and (macro ~= plandata) then
			color = Color["text_negative"]
		elseif (macro == plandata) then
			color = Color["text_positive"]
			if hasmod then
				name = name .. " " .. modicon
			end
		end

		local hasstock = false
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local j = menu.findUpgradeMacro(upgradetype2.grouptype, macro)
			if j then
				local upgradeware = menu.upgradewares[upgradetype2.grouptype][j]
					hasstock = upgradeware.isFromShipyard or ((slotdata.currentmacro == macro) and (slotdata.hasstock ~= false))
			end
		else
			local j = menu.findUpgradeMacro(upgradetype.type, macro)
			if j then
				local upgradeware = menu.upgradewares[upgradetype.type][j]
					hasstock = upgradeware.isFromShipyard or ((slotdata.currentmacro == macro) and (slotdata.hasstock ~= false))
			end
		end

		local row = ftable:addRow(true)
		row[1]:createButton({ active = canequip and ((macro == plandata) or (not hasmod)) and hasstock, bgColor = bgcolor, mouseOverText = mouseovertext, height = Helper.standardTextHeight }):setText(name, { color = color })
		if icon and (icon ~= "") then
			local iconsize = Helper.scaleX(Helper.standardTextHeight)
			row[1]:setIcon(icon, { color = overridecolor, width = iconsize, height = iconsize, x = menu.contextMode.width - iconsize, scaling = false })
		end
		if haslicence then
			if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
				row[1].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, macro, nil, nil, row.index) end
			else
				row[1].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(upgradetype.type, menu.contextData.slot, macro, nil, nil, row.index) end
			end
		end
	end

	local allowempty = upgradetype.allowempty
	if upgradetype.supertype == "macro" then
		allowempty = allowempty and (not C.IsSlotMandatory(menu.object, 0, menu.macro, false, upgradetype.type,  menu.contextData.slot))
	end
	if allowempty then
		local name = ReadText(1001, 7906)

		local mouseovertext = ""
		if hasmod then
			mouseovertext = ColorText["text_error"] .. ReadText(1026, 8009) .. "\27X"
		end

		local color = Color["text_normal"]
		if ("" == slotdata.currentmacro) and ("" ~= plandata) then
			color = Color["text_negative"]
		elseif ("" == plandata) then
			color = Color["text_positive"]
		end

		local row = ftable:addRow(true)
		row[1]:createButton({ active = canequip and (not hasmod), bgColor = bgcolor, mouseOverText = mouseovertext, height = Helper.standardTextHeight, helpOverlayID = "upgrade_empty", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(name, { color = color })
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			row[1].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, "", nil, nil, row.index) end
		else
			row[1].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(upgradetype.type, menu.contextData.slot, "", nil, nil, row.index) end
		end
	end

	ftable:setTopRow(menu.topRows.context)
	ftable:setSelectedRow(menu.selectedRows.context)
	menu.topRows.context = nil
	menu.selectedRows.context = nil

	menu.contextFrame:display()
end

function menu.createUserQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	if menu.contextData.mode == "removevolatile" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 8561), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 8562), { wordwrap = true })
	elseif menu.contextData.mode == "replacesingleshoppinglistentry" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 8574), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(ReadText(1001, 8575), { wordwrap = true })
	end

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	if menu.contextData.mode == "removevolatile" then
		row[2].handlers.onClick = function () return menu.buttonSelectUpgradeMacro(menu.contextData.type, menu.contextData.slot, menu.contextData.macro, menu.contextData.row, menu.contextData.col, false, true) end
	elseif menu.contextData.mode == "replacesingleshoppinglistentry" then
		row[2].handlers.onClick = function () return menu.buttonDiscardShoppingListAndEditGroup(menu.contextData.group, menu.contextData.shipid) end
	end
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu
	ftable:setSelectedCol(4)

	menu.contextFrame:display()
end

function menu.createEquipmentContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(menu.selectedUpgrade.name, menu.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = true, bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 2400), { color = Color["text_normal"] })
	row[1].handlers.onClick = function () return menu.buttonContextEncyclopedia(menu.selectedUpgrade) end

	menu.contextFrame:display()
end

function menu.checkLoadoutNameID()
	local canoverwrite = false
	local cansaveasnew = false
	if menu.loadout then
		local found = false
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				menu.setCustomShipName()
				break
			end
		end
		if not found then
			menu.loadout = nil
		end
	end
	if (not menu.loadout) and menu.loadoutName and (menu.loadoutName ~= "") then
		cansaveasnew = true
		for _, loadout in ipairs(menu.loadouts) do
			if (not loadout.preset) and (not loadout.mission) and (loadout.name == menu.loadoutName) then
				canoverwrite = true
				cansaveasnew = false
				menu.loadout = loadout.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew
end

function menu.createLoadoutSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 5, scaling = false, borderEnabled = false, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	menu.contextMode.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = menu.titleData.height, description = ReadText(1001, 9413) }):setText(menu.loadoutName or "", { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize) })
	row[1].handlers.onTextChanged = menu.editboxLoadoutNameUpdateText

	if menu.mode == "customgamestart" then
		local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(2):createText(ReadText(1026, 8021), { color = Color["text_warning"], wordwrap = true, scaling = true })
	end

	local row = ftable:addRow(true, { scaling = true, fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:createButton({ active = menu.checkLoadoutOverwriteActive, mouseOverText = ReadText(1026, 7908), helpOverlayID = "shipconfig_saveloadout_overwrite", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_saveloadout_overwrite" }):setText(ReadText(1001, 7908), {  })
	row[1].handlers.onClick = function () return menu.buttonSave(true) end
	row[2]:createButton({ active = menu.checkLoadoutSaveNewActive, mouseOverText = ReadText(1026, 7909), helpOverlayID = "shipconfig_saveloadout_saveasnew", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "shipconfig_saveloadout_saveasnew" }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSave(false) end

	menu.contextFrame:display()
end

function menu.checkLoadoutOverwriteActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return canoverwrite
end

function menu.checkLoadoutSaveNewActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return cansaveasnew
end

function menu.createEquipmentFilterContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(menu.checkAllRacesSelected, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = menu.checkboxSelectAllRaces
	row[2]:createText(ReadText(1001, 11912), Helper.headerRowCenteredProperties)

	local isgenericselected
	if menu.equipmentfilter_races.generic then
		isgenericselected = menu.equipmentfilter_races.generic.selected
	end
	-- remove generic and re-add it later after the sort
	menu.equipmentfilter_races.generic = nil
	local races = {}
	for id, racedata in pairs(menu.equipmentfilter_races) do
		racedata.id = id
		table.insert(races, racedata)
	end
	table.sort(races, Helper.sortName)
	menu.equipmentfilter_races.generic = { id = "generic", name = ReadText(1001, 8579), selected = isgenericselected }
	table.insert(races, 1, menu.equipmentfilter_races.generic)

	local color
	for _, racedata in ipairs(races) do
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.checkRacesSelected(racedata) end, { height = Helper.standardTextHeight })
		row[1].handlers.onClick = function(_, checked) menu.checkboxSelectRace(racedata, checked) end
		if racedata.id == "generic" or (menu.equipmentfilter_races[racedata.id].upgradeTypes and menu.equipmentfilter_races[racedata.id].upgradeTypes[menu.upgradetypeMode]) then
			color = Color["text_normal"]
		else
			color = Color["text_inactive"]
		end
		row[2]:createText(racedata.name, { color = color })
	end

	menu.contextFrame:display()
end

function menu.checkRacesSelected(race)
	for _, racedata in pairs(menu.equipmentfilter_races) do
		if racedata.id == race.id then
			return racedata.selected == true
		end
	end
	return false
end

function menu.checkAllRacesSelected()
	for i, racedata in pairs(menu.equipmentfilter_races) do
		if not racedata.selected then
			return false
		end
	end
	return true
end

function menu.checkboxSelectRace(race, checked)
	race.selected = checked
	local found = false
	for j, text in ipairs(menu.equipmentsearchtext) do
		if text.race == race.id then
			found = true
			if not checked then
				table.remove(menu.equipmentsearchtext, j)
			end
			break
		end
	end
	if checked and (not found) then
		table.insert(menu.equipmentsearchtext, { text = race.name, race = race.id })
	end
	menu.displayMenu()
end

function menu.checkboxSelectAllRaces(_, checked)
	for _, racedata in pairs(menu.equipmentfilter_races) do
		racedata.selected = checked
		local found = false
		for j, text in ipairs(menu.equipmentsearchtext) do
			if text.race == racedata.id then
				found = true
				if not checked then
					table.remove(menu.equipmentsearchtext, j)
				end
				break
			end
		end
		if checked and (not found) then
			table.insert(menu.equipmentsearchtext, { text = racedata.name, race = racedata.id })
		end
	end
	menu.displayMenu()
end

function menu.buttonRemoveSearchEntry(index)
	if menu.equipmentsearch_editboxrow > 0 then
		Helper.cancelEditBoxInput(menu.slottable, menu.equipmentsearch_editboxrow, 1)
	end

	if menu.equipmentsearchtext[index].race then
		for _, racedata in pairs(menu.equipmentfilter_races) do
			if racedata.id == menu.equipmentsearchtext[index].race then
				racedata.selected = nil
				break
			end
		end
	end
	table.remove(menu.equipmentsearchtext, index)

	menu.displayMenu()
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.map = ...

		if menu.activatemap == nil then
			menu.activatemap = true
		end
	elseif layer == config.infoLayer then
		if menu.upgradetypeMode == "paintmods" then
			menu.titlebartable, menu.leftbartable, menu.buttontable, menu.slottable, menu.plantable = ...
		else
			menu.titlebartable, menu.leftbartable, menu.slottable, menu.plantable = ...
		end

		if (menu.mode ~= "customgamestart") and (menu.mode ~= "comparison") then
			menu.updateMoney = GetCurRealTime()
		end
	elseif layer == config.contextLayer then
		menu.contexttable = ...
	end
end

menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = GetCurRealTime()

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.mapData.width / menu.mapData.height, 1)
			if (menu.usemacro and (menu.macro ~= "")) or (((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0)) then
				if menu.holomap and (menu.holomap ~= 0) then
					menu.currentIdx = menu.currentIdx + 1
					Helper.callLoadoutFunction(menu.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.object, 0, menu.macro, false, loadout, 0) end)
					if menu.selectedPaintMod then
						C.SetMapPaintMod(menu.holomap, menu.selectedPaintMod.ware)
					elseif menu.installedPaintMod then
						C.SetMapPaintMod(menu.holomap, menu.installedPaintMod.ware)
					end
					menu.selectMapMacroSlot()

					if menu.mapstate then
						C.SetMapState(menu.holomap, menu.mapstate)
						menu.mapstate = nil
					end
				end
			end

			menu.activatemap = false
		end
	end

	if menu.map and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.map)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end

	if menu.holomap and (menu.holomap ~= 0) then
		if menu.picking ~= menu.pickstate then
			menu.pickstate = menu.picking
			C.SetMapPicking(menu.holomap, menu.pickstate)
		end
	end

	if menu.contextMode and (type(menu.contextMode) == "table") and menu.contextMode.nameEditBox then
		ActivateEditBox(menu.contextMode.nameEditBox.id)
		menu.contextMode.nameEditBox = nil
	end

	if menu.noupdate then
		return
	end

	if (menu.object ~= 0) and (not IsValidComponent(ConvertStringTo64Bit(tostring(menu.object)))) then
		menu.object = 0
		menu.damagedcomponents = {}
		menu.selectableships = {}
		menu.selectableshipsbyclass = {}
		menu.modeparam[2] = {}
		menu.macro = ""
		menu.customshipname = ""
		menu.loadoutName = ""
		menu.clearUndoStack()
		menu.getDataAndDisplay()
		return
	end

	local refresh, newdatarefresh = false, false

	-- update player money
	if menu.updateMoney and (menu.updateMoney + 1 < curtime) then
		menu.updateMoney = curtime
		local currentplayermoney = GetPlayerMoney()
		if menu.shoppinglisttotal > currentplayermoney then
			if not menu.criticalerrors[1] then
				refresh = true
			end
		else
			if menu.criticalerrors[1] then
				refresh = true
			end
		end
	end
	-- update previous upgrades
	if (menu.mode == "upgrade") or (menu.mode == "modify") then
		if menu.object ~= 0 then
			menu.checkCurrentBuildTasks()
			if not menu.tasks[tostring(menu.object)] and menu.errors[3] then
				newdatarefresh = true
			end
		end
	end

	-- do this after the build task check, so there is no error for already finished tasks in menu.errors[3]
	menu.mainFrame:update()
	menu.infoFrame:update()
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if newdatarefresh then
		menu.getDataAndDisplay(menu.upgradeplan, menu.crew, nil, nil, true)
	elseif refresh then
		menu.displayMenu()
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if menu.mode == "modify" then
		if uitable == menu.slottable then
			if type(rowdata) == "table" then
				menu.currentSlot = rowdata[1]
				menu.selectMapMacroSlot()
			end
		end
	end
end

function menu.onSelectElement()
end

-- rendertarget selections
function menu.onRenderTargetSelect()
	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
	if menu.leftdown and (menu.leftdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.leftdown.position, offset, 2)) then
		menu.closeContextMenu()
		if (menu.usemacro and (menu.macro ~= "")) or ((menu.mode == "upgrade") and (menu.object ~= 0)) then
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)

				if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
					menu.upgradetypeMode, menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				else
					menu.upgradetypeMode = ffi.string(pickedslot.upgradetype)
					menu.currentSlot = tonumber(pickedslot.slot)
				end
				menu.selectMapMacroSlot()
				menu.displayMenu(true)
			end
		elseif ((menu.mode == "modify") and (menu.object ~= 0)) then
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
				local mode = menu.getModUpgradeMode(ffi.string(pickedslot.upgradetype))
				if mode then
					if next(menu.groups) and ((mode == "shieldmods") or (mode == "turretmods")) then
						local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)
						for i, entry in ipairs(menu.shieldgroups) do
							if ffi.string(groupinfo.group) == entry.group then
								menu.currentSlot = i
								break
							end
						end
					else
						menu.currentSlot = tonumber(pickedslot.slot)
					end
					menu.upgradetypeMode = mode
					menu.selectMapMacroSlot()
					menu.displayMenu()
				end
			end
		end
	end

	menu.leftdown = nil
end

function menu.selectMapMacroSlot()
	if menu.holomap and (menu.holomap ~= 0) then
		if (menu.upgradetypeMode == "enginegroup") or (menu.upgradetypeMode == "turretgroup") then
			local group = menu.groups[menu.currentSlot]
			if group then
				C.SetSelectedMapGroup(menu.holomap, menu.object, menu.macro, group.path, group.group)
			end
		elseif menu.upgradetypeMode == "repair" then
			if menu.repairslots then
				local group = math.ceil(menu.currentSlot / 3)
				local loccol = menu.currentSlot - ((group - 1) * 3)

				if menu.repairslots[group] and menu.repairslots[group][loccol] then
					local component = menu.repairslots[group][loccol][4]
					local macro = menu.repairslots[group][loccol][2]
					local slot = menu.repairslots[group][loccol][1]

					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if menu.slots[upgradetype.type] and menu.slots[upgradetype.type][slot] and menu.slots[upgradetype.type][slot].component == component then
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, macro, false, upgradetype.type, slot)
							break
						end
					end

				else
					C.ClearSelectedMapMacroSlots(menu.holomap)
				end
			else
				C.ClearSelectedMapMacroSlots(menu.holomap)
			end
		elseif menu.upgradetypeMode == "settings" then
			C.ClearSelectedMapMacroSlots(menu.holomap)
		elseif menu.upgradetypeMode == "paintmods" then
			C.ClearSelectedMapMacroSlots(menu.holomap)
		elseif menu.mode == "modify" then
			local entry = menu.getLeftBarEntry(menu.upgradetypeMode)
			if next(entry) then
				if (entry.upgrademode == "ship") or (entry.upgrademode == "paint") then
					C.ClearSelectedMapMacroSlots(menu.holomap)
				elseif next(menu.groups) and ((entry.upgrademode == "shield") or (entry.upgrademode == "turret")) then
					local shieldgroup = menu.shieldgroups[menu.currentSlot]
					if shieldgroup then
						C.SetSelectedMapGroup(menu.holomap, menu.object, menu.macro, "..", shieldgroup.group)
					end
				else
					local upgradetype = Helper.findUpgradeType(entry.upgrademode)
					if upgradetype.supertype == "macro" then
						if upgradetype.mergeslots then
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, entry.upgrademode, 0)
						else
							C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, entry.upgrademode, menu.currentSlot)
						end
					else
						C.ClearSelectedMapMacroSlots(menu.holomap)
					end
				end
			end
		elseif menu.upgradetypeMode and (menu.upgradetypeMode ~= "consumables") and (menu.upgradetypeMode ~= "crew") then
			local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
			if upgradetype.supertype == "macro" then
				if upgradetype.mergeslots then
					C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, menu.upgradetypeMode, 0)
				else
					C.SetSelectedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, menu.upgradetypeMode, menu.currentSlot)
				end
			else
				C.ClearSelectedMapMacroSlots(menu.holomap)
			end
		else
			C.ClearSelectedMapMacroSlots(menu.holomap)
		end
	end
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown()
	C.StartPanMap(menu.holomap)
	menu.leftdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
end

function menu.onRenderTargetMouseUp()
	C.StopPanMap(menu.holomap)
end

function menu.onRenderTargetRightMouseDown()
	C.StartRotateMap(menu.holomap)
	menu.rightdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
end

function menu.onRenderTargetRightMouseUp()
	C.StopRotateMap(menu.holomap)
	if not menu.isReadOnly then
		local offset = table.pack(GetLocalMousePosition())
		-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
		if (menu.rightdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.rightdown.position, offset, 2)) then
			menu.closeContextMenu()
			if (menu.usemacro and (menu.macro ~= "")) or (menu.mode == "upgrade") then
				local pickedslot = ffi.new("UILoadoutSlot")
				if C.GetPickedMapMacroSlot(menu.holomap, menu.object, 0, menu.macro, false, pickedslot) then
					local groupinfo = C.GetUpgradeSlotGroup(menu.object, menu.macro, pickedslot.upgradetype, pickedslot.slot)
					if (ffi.string(groupinfo.path) ~= "..") or (ffi.string(groupinfo.group) ~= "") then
						menu.upgradetypeMode, menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
					else
						menu.upgradetypeMode = ffi.string(pickedslot.upgradetype)
						menu.currentSlot = tonumber(pickedslot.slot)
					end
					menu.selectMapMacroSlot()
					menu.displayMenu()

					menu.contextData = { upgradetype = ffi.string(pickedslot.upgradetype), slot = tonumber(pickedslot.slot) }
					menu.displayContextFrame("slot", Helper.scaleX(300), offset[1] + Helper.viewWidth / 2, Helper.viewHeight / 2 - offset[2])
				end
			end
		end
	end
	menu.rightdown = nil
end

function menu.onRenderTargetCombinedScrollDown(step)
	C.ZoomMap(menu.holomap, step)
end

function menu.onRenderTargetCombinedScrollUp(step)
	C.ZoomMap(menu.holomap, -step)
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if (menu.mode ~= "modify") and (menu.mode ~= "customgamestart") then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
		if uitable == menu.slottable then
			if type(rowdata) == "table" then
				menu.selectedUpgrade = rowdata
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		end
	end
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
	end

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
	end
	return state
end

function menu.onRestoreState(state)
	if state.map then
		local offset = ffi.new("UIPosRot", {
			x = state.map.offset.x,
			y = state.map.offset.y,
			z = state.map.offset.z,
			yaw = state.map.offset.yaw,
			pitch = state.map.offset.pitch,
			roll = state.map.offset.roll
		})
		menu.mapstate = ffi.new("HoloMapState", {
			offset = offset,
			cameradistance = state.map.cameradistance
		})
	end

	local upgradeplan, crew
	for _, key in ipairs(config.stateKeys) do
		if key[1] == "upgradeplan" then
			upgradeplan = state[key[1]]
		elseif key[1] == "crew" then
			crew = state[key[1]]
		elseif key[1] == "shoppinglist" then
			menu.shoppinglist = state[key[1]]
			for i, entry in ipairs(menu.shoppinglist) do
				menu.shoppinglist[i].object = ffi.new("UniverseID", ConvertIDTo64Bit(entry.object))
				menu.shoppinglist[i].hasupgrades = entry.hasupgrades ~= 0
			end
		else
			if key[2] == "UniverseID" then
				menu[key[1]] = C.ConvertStringTo64Bit(tostring(state[key[1]]))
			elseif key[2] == "bool" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		end
	end

	return upgradeplan, crew
end

function menu.closeMenu(dueToClose)
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer)
	if menu.contextMode then
		menu.closeContextMenu()
		if (dueToClose == "back") or (layer == config.contextLayer) then
			return
		end
	end

	if menu.upgradetypeMode and (dueToClose == "back") and ((menu.mode ~= "modify") or (not menu.modeparam[1])) then
		menu.deactivateUpgradeMode()
		return
	end

	menu.closeMenu((menu.mode == "customgamestart") and "back" or dueToClose)
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextFrame = nil
	menu.contextMode = nil
end

function menu.getAmmoUsage(type)
	local capacity = 0
	if type == "missile" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetDefaultMissileStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				capacity = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "missilecapacity") or 0
			end
		end
		for slot, data in pairs(menu.upgradeplan.weapon) do
			local currentmacro = menu.slots.weapon[slot].currentmacro
			if currentmacro ~= data.macro then
				if currentmacro ~= "" then
					capacity = capacity - C.GetMacroMissileCapacity(currentmacro)
				end
				if data.macro ~= "" then
					capacity = capacity + C.GetMacroMissileCapacity(data.macro)
				end
			end
		end
		for slot, data in pairs(menu.upgradeplan.turret) do
			local currentmacro = menu.slots.turret[slot].currentmacro
			if currentmacro ~= data.macro then
				if currentmacro ~= "" then
					capacity = capacity - C.GetMacroMissileCapacity(currentmacro)
				end
				if data.macro ~= "" then
					capacity = capacity + C.GetMacroMissileCapacity(data.macro)
				end
			end
		end
		for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
			local currentmacro = menu.groups[slot].turret.currentmacro
			local currentoperational = menu.groups[slot].turret.operational
			if currentmacro ~= groupdata.macro then
				if currentmacro ~= "" then
					capacity = capacity - currentoperational * C.GetMacroMissileCapacity(currentmacro)
				end
				if groupdata.macro ~= "" then
					capacity = capacity + groupdata.count * C.GetMacroMissileCapacity(groupdata.macro)
				end
			end
		end
	elseif type == "drone" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = GetMacroUnitStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				if C.IsComponentClass(menu.object, "defensible") then
					capacity = GetUnitStorageData(ConvertStringTo64Bit(tostring(menu.object))).capacity
				else
					capacity = GetMacroUnitStorageCapacity(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
				end
			end
		end
	elseif type == "deployable" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetMacroDeployableCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				capacity = C.GetDefensibleDeployableCapacity(ConvertStringTo64Bit(tostring(menu.object)))
			end
		end
	elseif type == "countermeasure" then
		if menu.usemacro then
			if menu.macro ~= "" then
				capacity = C.GetDefaultCountermeasureStorageCapacity(menu.macro)
			end
		elseif menu.mode == "upgrade" then
			if menu.object ~= 0 then
				if C.IsComponentClass(menu.object, "defensible") then
					capacity = GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "countermeasurecapacity") or 0
				else
					capacity = C.GetDefaultCountermeasureStorageCapacity(GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "macro"))
				end
			end
		end
	end

	local total = 0
	for macro, amount in pairs(menu.upgradeplan[type]) do
		local volume = 1
		if type == "missile" then
			local ware = menu.upgradewares[type][menu.findUpgradeMacro(type, macro)]
			if ware.ware then
				volume = GetWareData(ware.ware, "volume")
			end
		end
		total = total + amount * volume
	end

	return total or 0, capacity or 0
end

function menu.isAmmoCompatible(type, ammomacro)
	if ammomacro ~= "" then
		if type == "missile" then
			for slot, data in pairs(menu.upgradeplan.weapon) do
				if data.macro ~= "" then
					if C.IsAmmoMacroCompatible(data.macro, ammomacro) then
						return true
					end
				end
			end
			for slot, data in pairs(menu.upgradeplan.turret) do
				if data.macro ~= "" then
					if C.IsAmmoMacroCompatible(data.macro, ammomacro) then
						return true
					end
				end
			end
			for slot, groupdata in pairs(menu.upgradeplan.turretgroup) do
				if groupdata.macro ~= "" then
					if C.IsAmmoMacroCompatible(groupdata.macro, ammomacro) then
						return true
					end
				end
			end
		elseif type == "drone" then
			return C.IsUnitMacroCompatible(menu.object, menu.macro, ammomacro)
		elseif type == "deployable" then
			return C.IsDeployableMacroCompatible(menu.object, menu.macro, ammomacro)
		elseif type == "countermeasure" then
			if menu.macro ~= "" then
				return (C.GetDefaultCountermeasureStorageCapacity(menu.macro) > 0)
			elseif menu.object ~= 0 then
				return (GetComponentData(ConvertStringTo64Bit(tostring(menu.object)), "countermeasurecapacity") > 0)
			end
		end
	end

	return false
end

function menu.filterUpgradeByText(mode, upgrade, texts)
	local hasracefilter, racematch = false, false
	if mode ~= "crew" and mode ~= "repair" and mode ~= "settings" and mode ~= "software" then
		for _, textentry in ipairs(texts) do
			if textentry.race then
				hasracefilter = true
				local makerraces = GetMacroData(upgrade, "makerraceid")
				if (textentry.race == "generic") and (#makerraces == 0) then
					racematch = true
				end
				for _, makerrace in ipairs(makerraces) do
					if makerrace == textentry.race then
						racematch = true
						break
					end
				end
				if racematch then
					break
				end
			end
		end
	end

	local hasadditionalfilter, filtermatch = false, false
	for _, textentry in ipairs(texts) do
		if not textentry.race then
			hasadditionalfilter = true
			text = utf8.lower(textentry.text)

			if mode == "software" then
				filtermatch = menu.filterSoftwareByText(upgrade, text)
			else
				local shortname, makerracenames = GetMacroData(upgrade, "shortname", "makerracename")
				if string.find(utf8.lower(shortname), text, 1, true) then
					filtermatch = true
				end
				for _, makerracename in ipairs(makerracenames) do
					if string.find(utf8.lower(makerracename), text, 1, true) then
						filtermatch = true
						break
					end
				end
			end
			if filtermatch then
				break
			end
		end
	end

	return ((not hasracefilter) or racematch) and ((not hasadditionalfilter) or filtermatch)
end

function menu.filterSoftwareByText(software, text)
	text = utf8.lower(text)

	local name = GetWareData(software, "name")
	if name and string.find(utf8.lower(name), text, 1, true) then
		return true
	end

	return false
end

function menu.findGroupIndex(path, group)
	for i, groupinfo in ipairs(menu.groups) do
		if (groupinfo.path == path) and (groupinfo.group == group) then
			local mode = "turretgroup"
			if groupinfo["engine"].total > 0 then
				mode = "enginegroup"
			end
			return mode, i
		end
	end
end

function menu.getLeftBarEntry(mode)
	local leftBar = config.leftBar
	if menu.mode == "modify" then
		leftBar = config.leftBarMods
	end

	for i, entry in ipairs(leftBar) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.prepareComponentUpgradeSlots(object, slots, ammo, software, changeupgradeplan)
	local canequip = menu.container and C.CanContainerEquipShip(menu.container, object)
	-- for all members of set upgradetypes,
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		-- with supertype "macro" (there should be 4)
		if upgradetype.supertype == "macro" then
			-- initialize an entry in table slots with key upgradetype.type
			slots[upgradetype.type] = {}
			-- and for all slots in the object,
			for j = 1, tonumber(C.GetNumUpgradeSlots(object, "", upgradetype.type)) do
				local groupinfo = C.GetUpgradeSlotGroup(object, "", upgradetype.type, j)
				if upgradetype.pseudogroup or ((ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "")) then
					slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetUpgradeSlotCurrentMacro(object, 0, upgradetype.type, j)), possiblemacros = {}, component = nil }
					if changeupgradeplan then
						local macro = slots[upgradetype.type][j].currentmacro
						local checkforeignmacro
						if canequip then
							if menu.objectgroup then
								local wareidx = menu.findUpgradeMacro(upgradetype.type, slots[upgradetype.type][j].currentmacro)
								if not wareidx then
									checkforeignmacro = true
								else
									local upgradeware = menu.upgradewares[upgradetype.type][wareidx]
									if not upgradeware.isFromShipyard then
										checkforeignmacro = true
									end
								end
							end
						end
						menu.upgradeplan[upgradetype.type][j] = { macro = macro, ammomacro = "", weaponmode = "", checkforeignmacro = checkforeignmacro }
					end
				else
					slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {}, component = nil }
					if changeupgradeplan then
						menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
					end
				end

				local currentcomponent = C.GetUpgradeSlotCurrentComponent(object, upgradetype.type, j)
				if currentcomponent ~= 0 then
					slots[upgradetype.type][j].component = currentcomponent
					if changeupgradeplan then
						if C.IsComponentClass(currentcomponent, "weapon") then
							menu.upgradeplan[upgradetype.type][j].weaponmode = ffi.string(C.GetWeaponMode(currentcomponent))
							if C.IsComponentClass(currentcomponent, "missilelauncher") then
								menu.upgradeplan[upgradetype.type][j].ammomacro = ffi.string(C.GetCurrentAmmoOfWeapon(currentcomponent))
							end
						end
					end
				end
			end
		elseif upgradetype.supertype == "ammo" then
			ammo[upgradetype.type] = {}

			local ammoentry = {}
			if upgradetype.type == "missile" then
				local n = C.GetNumAllMissiles(object)
				local buf = ffi.new("AmmoData[?]", n)
				n = C.GetAllMissiles(buf, n, object)
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "drone" then
				local n = C.GetNumAllUnits(object, false)
				local buf = ffi.new("UnitData[?]", n)
				n = C.GetAllUnits(buf, n, object, false)
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.category = ffi.string(buf[j].category)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "deployable" then
				local numlasertowers = C.GetNumAllLaserTowers(object)
				local lasertowers = ffi.new("AmmoData[?]", numlasertowers)
				numlasertowers = C.GetAllLaserTowers(lasertowers, numlasertowers, object)
				for j = 0, numlasertowers - 1 do
					local entry = {}
					entry.macro = ffi.string(lasertowers[j].macro)
					entry.amount = lasertowers[j].amount
					table.insert(ammoentry, entry)
				end

				local numsatellites = C.GetNumAllSatellites(object)
				local satellites = ffi.new("AmmoData[?]", numsatellites)
				numsatellites = C.GetAllSatellites(satellites, numsatellites, object)
				for j = 0, numsatellites - 1 do
					local entry = {}
					entry.macro = ffi.string(satellites[j].macro)
					entry.amount = satellites[j].amount
					table.insert(ammoentry, entry)
				end

				local nummines = C.GetNumAllMines(object)
				local mines = ffi.new("AmmoData[?]", nummines)
				nummines = C.GetAllMines(mines, nummines, object)
				for j = 0, nummines - 1 do
					local entry = {}
					entry.macro = ffi.string(mines[j].macro)
					entry.amount = mines[j].amount
					table.insert(ammoentry, entry)
				end

				local numnavbeacons = C.GetNumAllNavBeacons(object)
				local navbeacons = ffi.new("AmmoData[?]", numnavbeacons)
				numnavbeacons = C.GetAllNavBeacons(navbeacons, numnavbeacons, object)
				for j = 0, numnavbeacons - 1 do
					local entry = {}
					entry.macro = ffi.string(navbeacons[j].macro)
					entry.amount = navbeacons[j].amount
					table.insert(ammoentry, entry)
				end

				local numresourceprobes = C.GetNumAllResourceProbes(object)
				local resourceprobes = ffi.new("AmmoData[?]", numresourceprobes)
				numresourceprobes = C.GetAllResourceProbes(resourceprobes, numresourceprobes, object)
				for j = 0, numresourceprobes - 1 do
					local entry = {}
					entry.macro = ffi.string(resourceprobes[j].macro)
					entry.amount = resourceprobes[j].amount
					table.insert(ammoentry, entry)
				end
			elseif upgradetype.type == "countermeasure" then
				local n = C.GetNumAllCountermeasures(object)
				local buf = ffi.new("AmmoData[?]", n)
				n = C.GetAllCountermeasures(buf, n, object)
				local totalnumcountermeasures = 0
				for j = 0, n - 1 do
					local entry = {}
					entry.macro = ffi.string(buf[j].macro)
					entry.amount = buf[j].amount
					table.insert(ammoentry, entry)
				end
			end

			for _, item in ipairs(ammoentry) do
				local isexcluded = false
				for _, exclusion in ipairs(upgradetype.exclude) do
					if item.category == exclusion then
						isexcluded = true
						break
					end
				end
				if not isexcluded then
					ammo[upgradetype.type][item.macro] = item.amount
				end
				if changeupgradeplan then
					menu.upgradeplan[upgradetype.type][item.macro] = item.amount
				end
			end
		elseif upgradetype.supertype == "software" then
			software[upgradetype.type] = {}
			local n = C.GetNumSoftwareSlots(object, "")
			local buf = ffi.new("SoftwareSlot[?]", n)
			n = C.GetSoftwareSlots(buf, n, object, "")
			for j = 0, n - 1 do
				local entry = {}
				entry.maxsoftware = ffi.string(buf[j].max)
				entry.currentsoftware = ffi.string(buf[j].current)
				if changeupgradeplan then
					table.insert(menu.upgradeplan[upgradetype.type], entry.currentsoftware)
				end
				table.insert(software[upgradetype.type], entry)
			end
		elseif upgradetype.supertype == "virtualmacro" then
			slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumVirtualUpgradeSlots(object, "", upgradetype.type)) do
				-- convert index from lua to C-style
				slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetVirtualUpgradeSlotCurrentMacro(object, upgradetype.type, j)), possiblemacros = {} }
				if changeupgradeplan then
					local macro = slots[upgradetype.type][j].currentmacro
					local checkforeignmacro
					if canequip then
						if menu.objectgroup then
							local wareidx = menu.findUpgradeMacro(upgradetype.type, slots[upgradetype.type][j].currentmacro)
							if not wareidx then
								checkforeignmacro = true
							end
						end
					end
					menu.upgradeplan[upgradetype.type][j] = { macro = macro, ammomacro = "", weaponmode = "", checkforeignmacro = checkforeignmacro }
				end
			end
		end
	end

	-- add installed components in menu.upgradewares
	for type, slotsentry in pairs(slots) do
		for _, slot in ipairs(slotsentry) do
			if slot.currentmacro and (slot.currentmacro ~= "") then
				local ware = GetMacroData(slot.currentmacro, "ware")
				local i = menu.findUpgradeMacro(type, slot.currentmacro)
				if i then
					menu.upgradewares[type][i].objectamount = menu.upgradewares[type][i].objectamount + 1
				else
					table.insert(menu.upgradewares[type], { ware = ware, macro = slot.currentmacro, objectamount = 1, isFromShipyard = false })
				end
				menu.setMissingUpgrade(ware, 1, i == nil)
			end
		end
	end

	-- add installed ammo in menu.upgradewares
	for type, ammoentry in pairs(ammo) do
		for macro, amount in pairs(ammoentry) do
			local ware = GetMacroData(macro, "ware")
			local i = menu.findUpgradeMacro(type, macro)
			if i then
				menu.upgradewares[type][i].objectamount = menu.upgradewares[type][i].objectamount + amount
			else
				table.insert(menu.upgradewares[type], { ware = ware, macro = macro, objectamount = amount, isFromShipyard = false })
			end
			menu.setMissingUpgrade(ware, amount, i == nil)
		end
	end

	-- assemble possible ammo
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "ammo" then
			if ((menu.mode == "upgrade") or (menu.mode == "modify")) and (menu.object ~= 0) then
				if menu.upgradewares[upgradetype.type] then
					for _, upgradeware in ipairs(menu.upgradewares[upgradetype.type]) do
						if not ammo[upgradetype.type][upgradeware.macro] then
							ammo[upgradetype.type][upgradeware.macro] = 0
							if changeupgradeplan then
								menu.upgradeplan[upgradetype.type][upgradeware.macro] = 0
							end
						end
					end
				end
			end
		end
	end
end

function menu.prepareMacroUpgradeSlots(macro)
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			menu.slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumUpgradeSlots(0, macro, upgradetype.type)) do
				-- convert index from lua to C-style
				menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
				menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
			end
		elseif upgradetype.supertype == "ammo" then
			menu.ammo[upgradetype.type] = {}
		elseif upgradetype.supertype == "software" then
			menu.software[upgradetype.type] = {}
			local n = C.GetNumSoftwareSlots(0, macro)
			local buf = ffi.new("SoftwareSlot[?]", n)
			n = C.GetSoftwareSlots(buf, n, 0, macro)
			for j = 0, n - 1 do
				local entry = {}
				entry.maxsoftware = ffi.string(buf[j].max)
				entry.currentsoftware = ffi.string(buf[j].current)
				table.insert(menu.upgradeplan[upgradetype.type], entry.currentsoftware)
				table.insert(menu.software[upgradetype.type], entry)
			end
		elseif upgradetype.supertype == "virtualmacro" then
			menu.slots[upgradetype.type] = {}
			for j = 1, tonumber(C.GetNumVirtualUpgradeSlots(0, macro, upgradetype.type)) do
				-- convert index from lua to C-style
				menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
				menu.upgradeplan[upgradetype.type][j] = { macro = "", ammomacro = "", weaponmode = "" }
			end
		end
	end

	-- assemble possible ammo
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "ammo" then
			if menu.upgradewares[upgradetype.type] then
				for _, upgradeware in ipairs(menu.upgradewares[upgradetype.type]) do
					if not menu.ammo[upgradetype.type][upgradeware.macro] then
						menu.ammo[upgradetype.type][upgradeware.macro] = 0
						menu.upgradeplan[upgradetype.type][upgradeware.macro] = 0
					end
				end
			end
		end
	end
end

function menu.prepareComponentCrewInfo(object)
	local n = C.GetNumAllRoles()
	local buf = ffi.new("PeopleInfo[?]", n)
	n = C.GetPeople2(buf, n, object, true)
	local numhireable = 0
	for i = 0, n - 1 do
		if buf[i].canhire then
			numhireable = numhireable + 1
			menu.crew.roles[numhireable] = { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), total = buf[i].amount, wanted = buf[i].amount, tiers = {}, canhire = buf[i].canhire }
			menu.crew.total = menu.crew.total + buf[i].amount

			local numtiers = buf[i].numtiers
			local buf2 = ffi.new("RoleTierData[?]", numtiers)
			numtiers = C.GetRoleTiers(buf2, numtiers, object, menu.crew.roles[numhireable].id)
			for j = 0, numtiers - 1 do
				menu.crew.roles[numhireable].tiers[j + 1] = { skilllevel = buf2[j].skilllevel, name = ffi.string(buf2[j].name), total = buf2[j].amount, wanted = buf2[j].amount, npcs = {}, currentnpcs = {} }

				local numnpcs = buf2[j].amount
				local buf3 = ffi.new("NPCSeed[?]", numnpcs)
				numnpcs = C.GetRoleTierNPCs(buf3, numnpcs, object, menu.crew.roles[numhireable].id, menu.crew.roles[numhireable].tiers[j + 1].skilllevel)
				for k = 0, numnpcs - 1 do
					table.insert(menu.crew.roles[numhireable].tiers[j + 1].npcs, buf3[k])
					table.insert(menu.crew.roles[numhireable].tiers[j + 1].currentnpcs, buf3[k])
				end
			end
			if numtiers == 0 then
				menu.crew.roles[numhireable].tiers[1] = { skilllevel = 0, hidden = true, total = buf[i].amount, wanted = buf[i].amount, npcs = {}, currentnpcs = {} }
				local numnpcs = buf[i].amount
				local buf3 = ffi.new("NPCSeed[?]", numnpcs)
				numnpcs = C.GetRoleTierNPCs(buf3, numnpcs, object, menu.crew.roles[numhireable].id, 0)
				for k = 0, numnpcs - 1 do
					table.insert(menu.crew.roles[numhireable].tiers[1].npcs, buf3[k])
					table.insert(menu.crew.roles[numhireable].tiers[1].currentnpcs, buf3[k])
				end
			end
		end
	end

	menu.crew.capacity = C.GetPeopleCapacity(menu.object, menu.macro, false)
end

function menu.prepareMacroCrewInfo(macro)
	local n = C.GetNumAllRoles()
	local buf = ffi.new("PeopleInfo[?]", n)
	n = C.GetAllRoles(buf, n)
	local numhireable = 0
	for i = 0, n - 1 do
		if buf[i].canhire then
			numhireable = numhireable + 1
			menu.crew.roles[numhireable] = { id = ffi.string(buf[i].id), name = ffi.string(buf[i].name), desc = ffi.string(buf[i].desc), total = buf[i].amount, wanted = buf[i].amount, tiers = {}, canhire = buf[i].canhire }
			menu.crew.roles[numhireable].tiers[1] = { skilllevel = 0, hidden = true, total = buf[i].amount, wanted = buf[i].amount, npcs = {}, currentnpcs = {} }
			menu.crew.total = menu.crew.total + buf[i].amount
		end
	end

	menu.crew.capacity = C.GetPeopleCapacity(menu.object, menu.macro, false)
end

function menu.prepareModWares()
	menu.inventory = GetPlayerInventory()

	menu.modwares = {}
	menu.modwaresByWare = {}
	local n = C.GetNumAvailableEquipmentMods()
	local buf = ffi.new("UIEquipmentMod[?]", n)
	n = C.GetAvailableEquipmentMods(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.ware = ffi.string(buf[i].Ware)

		local modclass, modquality, rawresources = GetWareData(entry.ware, "modclass", "modquality", "resources")
		entry.quality = modquality

		entry.resources = {}
		for _, resource in ipairs(rawresources or {}) do
			local resourcedata = menu.inventory[resource.ware]
			if resourcedata then
				local isprimarymodpart = GetWareData(resource.ware, "isprimarymodpart")
				local maxcraftable = math.floor(resourcedata.amount / resource.amount)
				entry.craftableamount = entry.craftableamount and math.min(maxcraftable, entry.craftableamount) or maxcraftable
				if not isprimarymodpart then
					entry.normalcraftableamount = entry.normalcraftableamount and math.min(maxcraftable, entry.normalcraftableamount) or maxcraftable
				end
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcedata.name, amount = resourcedata.amount, price = resourcedata.price, needed = resource.amount } })
			else
				local resourcename, resourcebuyprice, isprimarymodpart = GetWareData(resource.ware, "name", "buyprice", "isprimarymodpart")
				entry.craftableamount = 0
				if not isprimarymodpart then
					entry.normalcraftableamount = 0
				end
				table.insert(entry.resources, isprimarymodpart and 1 or (#entry.resources + 1), { ware = resource.ware, data = { name = resourcename, amount = 0, price = resourcebuyprice, needed = resource.amount } })
			end
		end

		if menu.modwares[modclass] then
			table.insert(menu.modwares[modclass], entry)
		else
			menu.modwares[modclass] = { entry }
		end
		menu.modwaresByWare[entry.ware] = entry
	end

	n = C.GetNumInventoryPaintMods()
	buf = ffi.new("UIPaintMod[?]", n)
	n = C.GetInventoryPaintMods(buf, n);
	for i = 0, n - 1 do
		local entry = {}
		entry.name = ffi.string(buf[i].Name)
		entry.ware = ffi.string(buf[i].Ware)
		entry.quality = buf[i].Quality
		entry.amount = buf[i].Amount

		if menu.modwares["paint"] then
			table.insert(menu.modwares["paint"], entry)
		else
			menu.modwares["paint"] = { entry }
		end
		menu.modwaresByWare[entry.ware] = entry
	end
end

function menu.determineNeededRepairs(ship)
	local damagedcomponents = {}

	Helper.ffiVLA(damagedcomponents, "UniverseID", C.GetNumSubComponents, C.GetDamagedSubComponents, ship)

	local hullpercent = GetComponentData(ConvertStringToLuaID(tostring(ship)), "hullpercent")
	if hullpercent < 100 then
		-- NB: we want this to be the last entry so that it will appear first because we then go over damagedcomponents in reverse order.
		table.insert(damagedcomponents, ship)
	end

	return damagedcomponents
end

function menu.findWareIdx(array, ware)
	for i, v in ipairs(array) do
		if v.ware == ware then
			return i
		end
	end
end

function menu.insertWare(array, objectarray, category, ware, count, pricetype)
	local array2 = array
	if category then
		array[category] = array[category] or {}
		array2 = array[category]
	end
	local objectarray2 = objectarray
	if objectarray then
		if category then
			objectarray[category] = objectarray[category] or {}
			objectarray2 = objectarray[category]
		end
	end
	local price = 0
	local i = menu.findWareIdx(array2, ware)
	if i then
		array2[i].amount = array2[i].amount + count
	else
		if menu.container then
			if pricetype == "normal" then
				local isvolatile = GetWareData(ware, "volatile")
				price = isvolatile and 0 or tonumber(C.GetBuildWarePrice(menu.container, ware))
			elseif pricetype == "software" then
				price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringToLuaID(tostring(menu.container)), ware, false)
			elseif pricetype == "crew" then
				price = menu.crew.price
			end
		end
		table.insert(array2, { ware = ware, amount = count, price = price })
	end
	if objectarray then
		local i = menu.findWareIdx(objectarray2, ware)
		if i then
			objectarray2[i].amount = objectarray2[i].amount + count
		else
			if menu.container and (price == 0) then
				if pricetype == "normal" then
					local isvolatile = GetWareData(ware, "volatile")
					price = isvolatile and 0 or tonumber(C.GetBuildWarePrice(menu.container, ware))
				elseif pricetype == "software" then
					price = C.GetContainerBuildPriceFactor(menu.container) * GetContainerWarePrice(ConvertStringToLuaID(tostring(menu.container)), ware, false)
				elseif pricetype == "crew" then
					price = menu.crew.price
				end
			end
			table.insert(objectarray2, { ware = ware, amount = count, price = price })
		end
	end
end

function menu.insertComponent(array, objectarray, component, pricetype)
	local price
	if pricetype == "normal" then
		price = tonumber(C.GetRepairPrice(ConvertStringTo64Bit(component), menu.container)) * menu.repairdiscounts.totalfactor
	end
	table.insert(array, { component = component, price = price })
	table.insert(objectarray, { component = component, price = price })
end

function menu.getLoadoutSummary(upgradeplan, crew, repairplan, paintmodware)
	local wareAmounts = {}

	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(slots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if (upgradetype.supertype == "group") and (not upgradetype.pseudogroup) then
					local data = macro
					if data.macro ~= "" then
						local upgradeware = GetMacroData(data.macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, (upgradetype.mergeslots and #slots or data.count))
					end
				elseif (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") then
					local data = macro
					if data.macro ~= "" then
						local upgradeware = GetMacroData(data.macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, (upgradetype.mergeslots and #slots or 1))
					end
				elseif upgradetype.supertype == "ammo" then
					local new = macro
					local macro = slot
					if new > 0 then
						local upgradeware = GetMacroData(macro, "ware")
						menu.insertWare(wareAmounts, nil, nil, upgradeware, new)
					end
				elseif upgradetype.supertype == "software" then
					local newware = macro
					if newware ~= "" then
						menu.insertWare(wareAmounts, nil, nil, newware, 1)
					end
				end
			end
		end
	end

	-- Crew
	if (crew.total + crew.hired - #crew.fired) > 0 then
		menu.insertWare(wareAmounts, nil, nil, crew.ware, crew.total + crew.hired - #crew.fired)
	end

	local summary = ReadText(1001, 7935) .. ReadText(1001, 120)
	for _, entry in ipairs(wareAmounts) do
		summary = summary .. "\n" .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
	end

	-- Paint mod
	if paintmodware and menu.modwaresByWare[paintmodware] and (not menu.modwaresByWare[paintmodware].isdefault) then
		summary = summary .. "\n" .. ReadText(1026, 8030) .. ReadText(1001, 120) .. " " .. GetWareData(paintmodware, "name")
	end

	-- Repair
	if repairplan then
		for componentidstring in pairs(repairplan) do
			if componentidstring ~= "processed" then
				summary = summary .. "\n" .. ReadText(1001, 4217) .. ReadText(1001, 120) .. " " .. ffi.string(C.GetComponentName(ConvertStringTo64Bit(componentidstring))) .. " (" .. (100 - GetComponentData(ConvertStringTo64Bit(componentidstring), "hullpercent")) .. "% " .. ReadText(1001, 1) .. ")"
			end
		end
	end

	return summary
end

function menu.getModUpgradeMode(upgradetype)
	for i, entry in ipairs(config.leftBarMods) do
		if entry.upgrademode == upgradetype then
			return entry.mode
		end
	end
end

function menu.sortAmmo(a, b)
	local atype, btype = "", ""
	if IsMacroClass(a, "satellite") then
		atype = "satellite"
	elseif IsMacroClass(a, "navbeacon") then
		atype = "navbeacon"
	elseif IsMacroClass(a, "resourceprobe") then
		atype = "resourceprobe"
	elseif IsMacroClass(a, "mine") then
		atype = "mine"
	elseif GetMacroData(a, "islasertower") then
		atype = "lasertower"
	end
	if IsMacroClass(b, "satellite") then
		btype = "satellite"
	elseif IsMacroClass(b, "navbeacon") then
		btype = "navbeacon"
	elseif IsMacroClass(b, "resourceprobe") then
		btype = "resourceprobe"
	elseif IsMacroClass(b, "mine") then
		btype = "mine"
	elseif GetMacroData(b, "islasertower") then
		btype = "lasertower"
	end

	if atype == btype then
		return Helper.sortMacroName(a, b)
	end
	return config.deployableOrder[atype] < config.deployableOrder[btype]
end

function menu.findMacroIdx(array, macro)
	for i, v in ipairs(array) do
		if v.macro == macro then
			return i
		end
	end
end

function menu.setupGroupData(object, macro, groups, changeupgradeplan)
	local sizecounts = { engine = {}, turret = {} }
	local n = C.GetNumUpgradeGroups(object, macro)
	local buf = ffi.new("UpgradeGroup[?]", n)
	n = C.GetUpgradeGroups(buf, n, object, macro)
	for i = 0, n - 1 do
		if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
			table.insert(groups, { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
		end
	end
	table.sort(groups, function (a, b) return a.group < b.group end)
	for i, group in ipairs(groups) do
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local groupinfo = C.GetUpgradeGroupInfo(object, macro, group.path, group.group, upgradetype.grouptype)
				local currentmacro = ffi.string(groupinfo.currentmacro)
				local slotsize = ffi.string(groupinfo.slotsize)

				local compatibilities
				local n_comp = C.GetNumUpgradeGroupCompatibilities(object, macro, 0, group.path, group.group, upgradetype.grouptype)
				if n_comp > 0 then
					compatibilities = {}
					local buf_comp = ffi.new("EquipmentCompatibilityInfo[?]", n)
					n_comp = C.GetUpgradeGroupCompatibilities(buf_comp, n_comp, object, macro, 0, group.path, group.group, upgradetype.grouptype)
					for k = 0, n_comp - 1 do
						compatibilities[ffi.string(buf_comp[k].tag)] = ffi.string(buf_comp[k].name)
					end
				end

				groups[i][upgradetype.grouptype] = { count = groupinfo.count, operational = groupinfo.operational, total = groupinfo.total, slotsize = slotsize, compatibilities = compatibilities, currentcomponent = (groupinfo.currentcomponent ~= 0) and groupinfo.currentcomponent or nil, currentmacro = currentmacro, possiblemacros = {} }
				if upgradetype.grouptype ~= "shield" then
					groups[i].slotsize = slotsize
					groups[i].compatibilities = compatibilities

					if groups[i][upgradetype.grouptype].total > 0 then
						groups[i].groupname = i
						if slotsize ~= "" then
							if sizecounts[upgradetype.grouptype][slotsize] then
								sizecounts[upgradetype.grouptype][slotsize] = sizecounts[upgradetype.grouptype][slotsize] + 1
							else
								sizecounts[upgradetype.grouptype][slotsize] = 1
							end
							groups[i].groupname = upgradetype.shorttext[slotsize] .. sizecounts[upgradetype.grouptype][slotsize]
						end
					end
				end
				if changeupgradeplan then
					local weaponmode = ""
					if object ~= 0 then
						weaponmode = ffi.string(C.GetTurretGroupMode2(object, 0, group.path, group.group))
					end
					menu.upgradeplan[upgradetype.type][i] = { macro = currentmacro, count = groupinfo.count, path = group.path, group = group.group, ammomacro = "", weaponmode = weaponmode }
					if currentmacro ~= "" then
						local ware = GetMacroData(currentmacro, "ware")
						local k = menu.findUpgradeMacro(upgradetype.grouptype, currentmacro)
						if k then
							if menu.objectgroup then
								if not menu.upgradewares[upgradetype.grouptype][k].isFromShipyard then
									menu.upgradeplan[upgradetype.type][i].checkforeignmacro = true
								end
							end
							menu.upgradewares[upgradetype.grouptype][k].objectamount = menu.upgradewares[upgradetype.grouptype][k].objectamount + groupinfo.count
						else
							if menu.objectgroup then
								menu.upgradeplan[upgradetype.type][i].checkforeignmacro = true
							end
							table.insert(menu.upgradewares[upgradetype.grouptype], { ware = ware, macro = currentmacro, objectamount = groupinfo.count, isFromShipyard = false })
						end
						menu.setMissingUpgrade(ware, groupinfo.count, k == nil)
					end
				end
			end
		end
	end
end

function menu.setMissingUpgrade(ware, amount, allownewentry)
	for j, entry in ipairs(menu.missingUpgrades) do
		if entry.ware == ware then
			menu.missingUpgrades[j].amount = menu.missingUpgrades[j].amount + amount
			return
		end
	end
	if allownewentry then
		table.insert(menu.missingUpgrades, { ware = ware, name = GetWareData(ware, "name"), amount = amount })
	end
end

function menu.repairandupgrade(shoppinglistentry, object, macro, hasupgrades, haspaid, objectprice, objectcrewprice)
	local objectstring = tostring(object)
	if (object ~= 0) and menu.repairplan[objectstring] and next(menu.repairplan[objectstring]) and (not menu.repairplan[objectstring]["processed"]) then
		local skip = menu.checkCommanderRepairOrders(objectstring)
		if not skip then
			--print("pilot: " .. tostring(GetComponentData(ConvertStringTo64Bit(objectstring), "pilot")) .. ", cond: " .. tostring( (object == C.GetPlayerOccupiedShipID()) or not GetComponentData(ConvertStringTo64Bit(objectstring), "pilot") ) .. " cond1: " .. tostring(object == C.GetPlayerOccupiedShipID()) .. " cond2: " .. tostring(not GetComponentData(ConvertStringTo64Bit(objectstring), "pilot")))
			if (C.GetTopLevelContainer(object) == menu.container) then
				local damagedcomponents = {}
				for componentidstring, _ in pairs(menu.repairplan[objectstring]) do
					if componentidstring ~= "processed" and componentidstring ~= objectstring then
						table.insert(damagedcomponents, ConvertStringToLuaID(componentidstring))
					end
				end

				-- signal received in build.shiptrader
				-- param = "'repairs_initiate'", param2 = $shiptoberepaired, param3 = [hullpercent(int), damagedcomponents(list)]
				--print("signalling " .. ffi.string(C.GetComponentName(menu.container)) .. " to repair " .. ffi.string(C.GetComponentName(object)) .. " " .. objectstring)
				SignalObject(menu.container, "repairs_initiate", ConvertStringToLuaID(objectstring), {100, damagedcomponents})
			else
				local orderindex = C.CreateOrder(object, "Repair", false)
				if orderindex > 0 then
					menu.processRepairsFor(objectstring, orderindex)

					-- in this case, signal is sent from order.repair
					if not C.EnableOrder(object, orderindex) then
						print("ERROR: Order to initiate repairs for " .. ffi.string(C.GetComponentName(entry.object)) .. " was not enabled.")
					end
				end
			end
		end
	end

	if hasupgrades then
		for i = 1, shoppinglistentry.amount do
			local numblacklisttypes = 0
			for _ in pairs(shoppinglistentry.settings.blacklists) do
				numblacklisttypes = numblacklisttypes + 1
			end
			local blacklists = ffi.new("BlacklistTypeID[?]", numblacklisttypes)
			local i = 0
			for blacklisttype, id in pairs(shoppinglistentry.settings.blacklists) do
				blacklists[i].type = blacklisttype
				blacklists[i].id = id
				i = i + 1
			end

			local numfightruletypes = 0
			for _ in pairs(shoppinglistentry.settings.fightrules) do
				numfightruletypes = numfightruletypes + 1
			end
			local fightrules = ffi.new("FightRuleTypeID[?]", numfightruletypes)
			local i = 0
			for fightruletype, id in pairs(shoppinglistentry.settings.fightrules) do
				fightrules[i].type = fightruletype
				fightrules[i].id = id
				i = i + 1
			end

			local additionalinfo = ffi.new("AddBuildTask6Container", {
				blacklists = blacklists,
				numblacklists = numblacklisttypes,
				fightrules = fightrules,
				numfightrules = numfightruletypes,
				paintmodwareid = shoppinglistentry.paintmodware
			})

			local buildtaskid = Helper.callLoadoutFunction(shoppinglistentry.upgradeplan, shoppinglistentry.crew, function (loadout, crewtransfer) return C.AddBuildTask6(menu.container, object, macro, loadout, menu.isplayerowned and 0 or (objectprice or shoppinglistentry.price), crewtransfer, menu.immediate, shoppinglistentry.customshipname, additionalinfo) end, nil, "UILoadout2")
			if (buildtaskid ~= 0) and haspaid then
				C.SetBuildTaskTransferredMoney(buildtaskid, objectprice and (objectprice + objectcrewprice) or haspaid)
			end

            -- kuertee start: callback
			if menu.uix_callbacks["repairandupgrade_after_build_order_created"] then
				for uix_id, uix_callback in pairs(menu.uix_callbacks["repairandupgrade_after_build_order_created"]) do
					uix_callback(shoppinglistentry, object, buildtaskid)
				end
			end
			-- kuertee end: callback

		end
	end
end

function menu.upgradeSettingsVersion()
	local oldversion = __CORE_DETAILMONITOR_SHIPBUILD.version

	--[[ This caused backwards compatibility issues - see below
	if oldversion < 2 then
		__CORE_DETAILMONITOR_SHIPBUILD["showStats"] = __CORE_DETAILMONITOR_SHIPBUILD["showStats"] and "limited" or "hidden"
		__CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod"] = __CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod"] and "limited" or "hidden"
	end--]]
	if oldversion < 3 then
		if oldversion == 2 then
			-- was already patched, keep new settings, restore old ones
			__CORE_DETAILMONITOR_SHIPBUILD["showStats2"] = __CORE_DETAILMONITOR_SHIPBUILD["showStats"]
			__CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod2"] = __CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod"]
			__CORE_DETAILMONITOR_SHIPBUILD["showStats"] = true
			__CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod"] = false
		else
			-- patch to new fields to avoid backwards compatibility issue
			__CORE_DETAILMONITOR_SHIPBUILD["showStats2"] = __CORE_DETAILMONITOR_SHIPBUILD["showStats"] and "limited" or "hidden"
			__CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod2"] = __CORE_DETAILMONITOR_SHIPBUILD["showStatsPaintMod"] and "limited" or "hidden"
		end
	end

	__CORE_DETAILMONITOR_SHIPBUILD.version = config.persistentdataversion
end


-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- section == cArch_configureStation
-- param == { 0, 0, container }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t TradeID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* tag;
		const char* name;
	} EquipmentCompatibilityInfo;
	typedef struct {
		const char* id;
		const char* name;
		int32_t state;
		const char* requiredversion;
		const char* installedversion;
	} InvalidPatchInfo;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* name;
		const char* id;
		const char* source;
		bool deleteable;
	} UIConstructionPlan;
	typedef struct {
		const char* filename;
		const char* name;
		const char* id;
	} UIConstructionPlanInfo;
	typedef struct {
		const char* macro;
		uint32_t amount;
		bool optional;
	} UILoadoutAmmoData;
	typedef struct {
		const char* macro;
		const char* path;
		const char* group;
		uint32_t count;
		bool optional;
	} UILoadoutGroupData;
	typedef struct {
		const char* macro;
		const char* upgradetypename;
		size_t slot;
		bool optional;
	} UILoadoutMacroData;
	typedef struct {
		const char* ware;
	} UILoadoutSoftwareData;
	typedef struct {
		const char* macro;
		bool optional;
	} UILoadoutVirtualMacroData;
	typedef struct {
		uint32_t numweapons;
		uint32_t numturrets;
		uint32_t numshields;
		uint32_t numengines;
		uint32_t numturretgroups;
		uint32_t numshieldgroups;
		uint32_t numammo;
		uint32_t numunits;
		uint32_t numsoftware;
	} UILoadoutCounts;
	typedef struct {
		UILoadoutMacroData* weapons;
		uint32_t numweapons;
		UILoadoutMacroData* turrets;
		uint32_t numturrets;
		UILoadoutMacroData* shields;
		uint32_t numshields;
		UILoadoutMacroData* engines;
		uint32_t numengines;
		UILoadoutGroupData* turretgroups;
		uint32_t numturretgroups;
		UILoadoutGroupData* shieldgroups;
		uint32_t numshieldgroups;
		UILoadoutAmmoData* ammo;
		uint32_t numammo;
		UILoadoutAmmoData* units;
		uint32_t numunits;
		UILoadoutSoftwareData* software;
		uint32_t numsoftware;
		UILoadoutVirtualMacroData thruster;
	} UILoadout;
	typedef struct {
		const char* id;
		const char* name;
		const char* iconid;
		bool deleteable;
	} UILoadoutInfo;
	typedef struct {
		const char* upgradetype;
		size_t slot;
	} UILoadoutSlot;
	typedef struct {
		const char* macro;
		uint32_t amount;
	} UIMacroCount;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* path;
		const char* group;
	} UpgradeGroup;
	typedef struct {
		UniverseID currentcomponent;
		const char* currentmacro;
		const char* slotsize;
		uint32_t count;
		uint32_t operational;
		uint32_t total;
	} UpgradeGroupInfo;
	typedef struct {
		UniverseID reserverid;
		const char* ware;
		uint32_t amount;
		bool isbuyreservation;
		double eta;
		TradeID tradedealid;
		MissionID missionid;
		bool isvirtual;
		bool issupply;
	} WareReservationInfo2;

	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	void AddFloatingSequenceToConstructionPlan(UniverseID holomapid);
	void AddCopyToConstructionMap(UniverseID holomapid, size_t cp_idx, bool copysequence);
	void AddMacroToConstructionMap(UniverseID holomapid, const char* macroname, bool startdragging);
	bool AreConstructionPlanLoadoutsCompatible(const char* constructionplanid);
	bool CanBuildLoadout(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	bool CancelPlayerInvolvedTradeDeal(UniverseID containerid, TradeID tradeid, bool checkonly);
	bool CanOpenWebBrowser(void);
	bool CheckConstructionPlanForMacros(const char* constructionplanid, const char** macroids, uint32_t nummacroids);
	void ClearBuildMapSelection(UniverseID holomapid);
	bool CompareMapConstructionSequenceWithPlanned(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan);
	const char* ConvertInputString(const char* text, const char* defaultvalue);
	void DeselectMacroForConstructionMap(UniverseID holomapid);
	bool DoesConstructionSequenceRequireBuilder(UniverseID containerid);
	void ExportMapConstructionPlan(UniverseID holomapid, const char* filename, const char* id, bool overwrite, const char* name, const char* desc);
	void ForceBuildCompletion(UniverseID containerid);
	void GenerateModuleLoadout(UILoadout* result, UniverseID holomapid, size_t cp_idx, UniverseID defensibleid, float level);
	void GenerateModuleLoadoutCounts(UILoadoutCounts* result, UniverseID holomapid, size_t cp_idx, UniverseID defensibleid, float level);
	uint32_t GetAssignedConstructionVessels(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	size_t GetBuildMapConstructionPlan(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan, UIConstructionPlanEntry* result, uint32_t resultlen);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetCargo(UIWareInfo* result, uint32_t resultlen, UniverseID containerid, const char* tags);
	uint32_t GetConstructionPlanInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetConstructionPlans(UIConstructionPlan* result, uint32_t resultlen);
	void GetConstructionMapItemLoadout2(UILoadout* result, UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UniverseID moduleid);
	void GetConstructionMapItemLoadoutCounts2(UILoadoutCounts* result, UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UniverseID moduleid);
	size_t GetConstructionMapVenturePlatform(UniverseID holomapid, size_t venturedockidx);
	const char* GetContainerBuildMethod(UniverseID containerid);
	float GetContainerGlobalPriceFactor(UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	uint32_t GetContainerWareReservations2(WareReservationInfo2* result, uint32_t resultlen, UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	float GetCurrentBuildProgress(UniverseID containerid);
	void GetCurrentLoadout(UILoadout* result, UniverseID defensibleid, UniverseID moduleid);
	void GetCurrentLoadoutCounts(UILoadoutCounts* result, UniverseID defensibleid, UniverseID moduleid);
	float GetDefensibleLoadoutLevel(UniverseID defensibleid);
	int64_t GetEstimatedBuildPrice(UniverseID containerid, const char* macroname);
	const char* GetGameStartName();
	uint32_t GetImportableConstructionPlans(UIConstructionPlanInfo* result, uint32_t resultlen);
	void GetLoadout(UILoadout* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutCounts(UILoadoutCounts* result, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetLoadoutsInfo(UILoadoutInfo* result, uint32_t resultlen, UniverseID componentid, const char* macroname);
	const char* GetMissingConstructionPlanBlueprints3(UniverseID containerid, UniverseID holomapid, const char* constructionplanid, bool useplanned);
	const char* GetMissingLoadoutBlueprints(UniverseID containerid, UniverseID defensibleid, const char* macroname, const char* loadoutid);
	uint32_t GetNumAssignedConstructionVessels(UniverseID containerid);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	size_t GetNumBuildMapConstructionPlan(UniverseID holomapid, bool usestoredplan);
	uint32_t GetNumCargo(UniverseID containerid, const char* tags);
	uint32_t GetNumConstructionMapVenturePlatformDocks(UniverseID holomapid, size_t ventureplatformidx);
	uint32_t GetNumConstructionPlans(void);
	uint32_t GetNumContainerWareReservations2(UniverseID containerid, bool includevirtual, bool includemission, bool includesupply);
	uint32_t GetNumImportableConstructionPlans();
	uint32_t GetNumLoadoutsInfo(UniverseID componentid, const char* macroname);
	uint32_t GetNumPlannedLimitedModules(const char* constructionplanid);
	uint32_t GetNumRemovedConstructionPlanModules2(UniverseID holomapid, UniverseID defensibleid, uint32_t* newIndex, bool usestoredplan, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumUpgradeGroupCompatibilities(UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumUsedLimitedModules(UniverseID excludedstationid);
	uint32_t GetNumUsedLimitedModulesFromSubsequence(UniverseID holomapid, size_t cp_idx);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	const char* GetObjectIDCode(UniverseID objectid);
	bool GetPickedBuildMapEntry2(UniverseID holomapid, UniverseID defensibleid, UIConstructionPlanEntry* result, bool requirecomponentid);
	void SelectPickedBuildMapEntry(UniverseID holomapid);
	bool GetPickedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadoutSlot* result);
	uint32_t GetPlannedLimitedModules(UIMacroCount* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetRemovedConstructionPlanModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	size_t GetSelectedBuildMapEntry(UniverseID holomapid);
	uint32_t GetUpgradeGroupCompatibilities(EquipmentCompatibilityInfo* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname, UniverseID contextid, const char* path, const char* group, const char* upgradetypename);
	UpgradeGroupInfo GetUpgradeGroupInfo(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename);
	uint32_t GetUpgradeGroups(UpgradeGroup* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	const char* GetUpgradeSlotCurrentMacro(UniverseID objectid, UniverseID moduleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	uint32_t GetUsedLimitedModules(UIMacroCount* result, uint32_t resultlen, UniverseID excludedstationid);
	uint32_t GetUsedLimitedModulesFromSubsequence(UIMacroCount* result, uint32_t resultlen, UniverseID holomapid, size_t cp_idx);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasProductionModuleIllegalProducts(const char* macroname, const char* licencefactionid, const char* policefactionid);
	void ImportMapConstructionPlan(const char* filename, const char* id);
	bool IsBuildWaitingForSecondaryComponentResources(UniverseID containerid);
	bool IsConstructionPlanValid(const char* constructionplanid, uint32_t* numinvalidpatches);
	bool IsLoadoutCompatible(const char* macroname, const char* loadoutid);
	bool IsLoadoutValid(UniverseID defensibleid, const char* macroname, const char* loadoutid, uint32_t* numinvalidpatches);
	bool IsIconValid(const char* iconid);
	bool IsMasterVersion(void);
	bool IsNextStartAnimationSkipped(bool reset);
	bool IsPlayerTradeRuleDefault(TradeRuleID id, const char* ruletype);
	bool IsUpgradeGroupMacroCompatible(UniverseID destructibleid, const char* macroname, const char* path, const char* group, const char* upgradetypename, const char* upgrademacroname);
	bool IsUpgradeMacroCompatible(UniverseID objectid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot, const char* upgrademacroname);
	bool IsValidTrade(TradeID tradeid);
	bool IsVentureExtensionSupported(void);
	bool IsVentureSeasonSupported(void);
	void OpenWebBrowser(const char* url);
	void ReleaseConstructionMapState(void);
	bool RemoveConstructionPlan(const char* source, const char* id);
	void RemoveFloatingSequenceFromConstructionPlan(UniverseID holomapid);
	void RemoveItemFromConstructionMap2(UniverseID holomapid, size_t itemidx, bool removesequence);
	bool RemoveOrder2(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly, bool onlyimmediate);
	void ResetConstructionMapModuleRotation(UniverseID holomapid, size_t cp_idx);
	void ResetMapPlayerRotation(UniverseID holomapid);
	void SaveLoadout(const char* macroname, UILoadout uiloadout, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SaveMapConstructionPlan(UniverseID holomapid, const char* source, const char* id, bool overwrite, const char* name, const char* desc);
	void SelectBuildMapEntry(UniverseID holomapid, size_t cp_idx);
	void SetConstructionMapBuildAngleStep(UniverseID holomapid, float angle);
	void SetConstructionMapCollisionDetection(UniverseID holomapid, bool value);
	void SetConstructionMapRenderSectorBackground(UniverseID holomapid, bool value);
	void SetConstructionMapRenderTransformGizmo(UniverseID holomapid, bool value);
	void SetConstructionSequenceFromConstructionMap(UniverseID containerid, UniverseID holomapid);
	void SetContainerGlobalPriceFactor(UniverseID containerid, float value);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetFocusMapConstructionPlanEntry(UniverseID holomapid, size_t cp_idx, bool resetplayerpan);
	void SetMapPicking(UniverseID holomapid, bool enable);
	void SetSelectedMapGroup(UniverseID holomapid, UniverseID destructibleid, const char* macroname, const char* path, const char* group);
	void SetSelectedMapMacroSlot(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, const char* upgradetypename, size_t slot);
	void SetupConstructionSequenceModulesCache(UniverseID holomapid, UniverseID defensibleid, bool enable);
	void ShowConstructionMap(UniverseID holomapid, UniverseID stationid, const char* constructionplanid, bool restore);
	void ShowObjectConfigurationMap2(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout, size_t cp_idx);
	bool ShuffleMapConstructionPlan2(UniverseID holomapid, bool checkonly, const char* raceid);
	void StartPanMap(UniverseID holomapid);
	void StartRotateMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	bool StopRotateMap(UniverseID holomapid);
	void StoreConstructionMapState(UniverseID holomapid);
	void UpdateConstructionMapItemLoadout(UniverseID holomapid, size_t itemidx, UniverseID defensibleid, UILoadout uiloadout);
	void UpdateObjectConfigurationMap(UniverseID holomapid, UniverseID defensibleid, UniverseID moduleid, const char* macroname, bool ismodule, UILoadout uiloadout);
	void ZoomMap(UniverseID holomapid, float zoomstep);
	bool CanUndoConstructionMapChange(UniverseID holomapid);
	void UndoConstructionMapChange(UniverseID holomapid);
	bool CanRedoConstructionMapChange(UniverseID holomapid);
	void RedoConstructionMapChange(UniverseID holomapid);

	uint32_t PrepareBuildSequenceResources2(UniverseID holomapid, UniverseID stationid, bool useplanned);
	uint32_t GetBuildSequenceResources(UIWareInfo* result, uint32_t resultlen);
	uint32_t GetNumModuleRecycledResources(UniverseID moduleid);
	uint32_t GetModuleRecycledResources(UIWareInfo* result, uint32_t resultlen, UniverseID moduleid);
	uint32_t GetNumModuleNeededResources(UniverseID holomapid, size_t cp_idx);
	uint32_t GetModuleNeededResources(UIWareInfo* result, uint32_t resultlen, UniverseID holomapid, size_t cp_idx);
	void SetContainerBuildMethod(UniverseID containerid, const char* buildmethodid);
]]

local utf8 = require("utf8")

local menu = {
	name = "StationConfigurationMenu",
	newWareReservationWares = {},
	externalUsedLimitedModules = {},
	usedLimitedModules = {},
	currentConstructions = {},
	dirtyreservations = {},
	shuffleconnectionrace = "all",
}

local config = {
	mainLayer = 5,
	infoLayer = 4,
	contextLayer = 2,
	leftBar = {
		{ name = ReadText(1001, 2421),	icon = "stationbuildst_production",		mode = "moduletypes_production",	helpOverlayID = "stationbuildst_production",	helpOverlayText = ReadText(1028, 3250)  },
		{ name = ReadText(1001, 2439),	icon = "stationbuildst_buildmodule",	mode = "moduletypes_build",			helpOverlayID = "stationbuildst_buildmodule",	helpOverlayText = ReadText(1028, 3251)  },
		{ name = ReadText(1001, 2422),	icon = "stationbuildst_storage",		mode = "moduletypes_storage",		helpOverlayID = "stationbuildst_storage",		helpOverlayText = ReadText(1028, 3252)  },
		{ name = ReadText(1001, 2451),	icon = "stationbuildst_habitation",		mode = "moduletypes_habitation",	helpOverlayID = "stationbuildst_habitation",	helpOverlayText = ReadText(1028, 3253)  },
		{ name = ReadText(1001, 9620),	icon = "stationbuildst_welfare",		mode = "moduletypes_welfare",		helpOverlayID = "stationbuildst_welfare",		helpOverlayText = ReadText(1028, 3258)  },
		{ name = ReadText(1001, 2452),	icon = "stationbuildst_dock",			mode = "moduletypes_dock",			helpOverlayID = "stationbuildst_dock",			helpOverlayText = ReadText(1028, 3254)  },
		{ name = ReadText(1001, 2424),	icon = "stationbuildst_defense",		mode = "moduletypes_defence",		helpOverlayID = "stationbuildst_defense",		helpOverlayText = ReadText(1028, 3255)  },
		{ name = ReadText(1001, 9621),	icon = "stationbuildst_processing",		mode = "moduletypes_processing",	helpOverlayID = "stationbuildst_processing",	helpOverlayText = ReadText(1028, 3259)  },
		{ name = ReadText(1001, 2453),	icon = "stationbuildst_other",			mode = "moduletypes_other",			helpOverlayID = "stationbuildst_other",			helpOverlayText = ReadText(1028, 3256),		additionaltypes = { "moduletypes_radar" }  },
		{ name = ReadText(1001, 2454),	icon = "stationbuildst_venture",		mode = "moduletypes_venture",		helpOverlayID = "stationbuildst_venture",		helpOverlayText = ReadText(1028, 3257),		condition = C.IsVentureSeasonSupported },
	},
	leftBarLoadout = {
		{ name = ReadText(1001, 7901),	icon = "shipbuildst_turretgroups",		mode = "turretgroup" },
	},
	equipmentBlueprintGroups = {
		{ type = "turret", library = "weapons_turrets" },
		{ type = "turret", library = "weapons_missileturrets" },
		{ type = "shield", library = "shieldgentypes" },
	},
	dropDownTextProperties = {
		halign = "center",
		font = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Color["text_normal"],
		x = 0,
		y = 0
	},
	scaleSize = 2,
	stateKeys = {
		{ "container", "UniverseID" },
		{ "buildstorage", "UniverseID" },
		{ "loadoutModuleIdx" },
		{ "modulesMode", },
		-- { "upgradeplan" }, -- reserved for loadoutModuleIdx information
		{ "origDefaultLoadout", "bool" },
	},
	sizeSorting = {
		["small"] = 1,
		["medium"] = 2,
		["large"] = 3,
		["extralarge"] = 4,
	},
	maxSidePanelWidth = 800,
	maxCenterPanelWidth = 1600,
	fileExtension = ".xml",
	slotSizeOrder = {
		["extralarge"]	= 1,
		["large"]		= 2,
		["medium"]		= 3,
		["small"]		= 4,
	},
	compatibilityFontSize = 5,
	mapfilterversion = 2,
	discreteAngleSlider = {
		min = 5,
		max = 180,
		step = 5,
	},
	moduleFilterWidth = 300,
}

__CORE_DETAILMONITOR_STATIONBUILD = __CORE_DETAILMONITOR_STATIONBUILD or {
	version = config.mapfilterversion,
	["discreteanglestep"] = 15.,
	["moduleoverlap"] = false,
	["environment"] = true,
	["gizmo"] = true,
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end
	menu.extendedentries = {}
	menu.extendedresourceentries = {}

	if __CORE_DETAILMONITOR_STATIONBUILD.version < config.mapfilterversion then
		menu.upgradeSettingsVersion()
	end

	RegisterEvent("openmenu", function (_, menuname) return menu.openOtherMenu(menuname) end)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.openOtherMenu(menuname)
	if menu.shown then
		if menu.haschanges then
			menu.contextData = { othermenu = menuname }
			menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
		else
			Helper.closeMenuAndOpenNewMenu(menu, menuname, nil, true, true)
			menu.cleanup()
		end
	end
end

function menu.cleanup()
	UnregisterEvent("newWareReservation", menu.newWareReservationCallback)

	menu.container = nil
	menu.buildstorage = nil
	menu.modules = {}
	menu.modulesMode = nil
	menu.planMode = nil
	menu.searchtext = ""
	menu.modulesearchtext = {}
	menu.loadoutName = ""
	menu.loadout = nil
	menu.activatemap = nil
	menu.constructionplan = {}
	menu.constructionplans = {}
	menu.groupedmodules = {}
	menu.groupedupgrades = {}
	menu.groupedslots = {}
	menu.loadoutMode = nil
	menu.loadoutPlanMode = nil
	menu.loadoutModule = {}
	menu.upgradetypeMode = nil
	menu.currentSlot = nil
	menu.slots = {}
	menu.groups = {}
	menu.newAccountValue = nil
	menu.newWareReservation = nil
	menu.newWareReservationWares = {}
	menu.selectedModule = nil
	menu.newSelectedModule = nil
	menu.externalUsedLimitedModules = {}
	menu.usedLimitedModules = {}
	menu.haschanges = nil
	menu.hasconstructionchanges = nil
	menu.currentConstructions = {}
	menu.defaultLoadout = nil
	menu.origDefaultLoadout = nil

	menu.picking = true
	menu.cancelRequested = nil
	menu.noupdate = nil
	menu.allowpanning = nil
	menu.allowrotating = nil

	SetMouseOverOverride(menu.map, nil)

	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end

	menu.frameworkData = {}
	menu.modulesData = {}
	menu.planData = {}
	menu.titleData = {}
	menu.mapData = {}

	menu.leftbartable = nil
	menu.rightbartable = nil
	menu.titlebartable = nil
	menu.map = nil
	menu.moduletable = nil
	menu.plantable = nil
	menu.contextFrame = nil
	menu.contextMode = nil

	menu.currentCPID = nil
	menu.currentCPName = nil
	menu.canundo = nil
	menu.canredo = nil

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	UnregisterAddonBindings("ego_detailmonitor", "undo")

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

-- button scripts

function menu.buttonLeftBar(mode, row)
	menu.prevModulesMode = menu.modulesMode
	AddUITriggeredEvent(menu.name, mode, menu.modulesMode == mode and "off" or "on")
	if menu.modulesMode == mode then
		PlaySound("ui_negative_back")
		menu.modulesMode = nil
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.modulesMode = mode
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonLeftBarLoadout(mode, row)
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	AddUITriggeredEvent(menu.name, mode, menu.upgradetypeMode == mode and "off" or "on")
	if menu.upgradetypeMode == mode then
		PlaySound("ui_negative_back")
		menu.upgradetypeMode = nil
	else
		menu.setdefaulttable = true
		PlaySound("ui_positive_select")
		menu.upgradetypeMode = mode
	end
	menu.determineInitialSlot()

	if menu.upgradetypeMode == "turretgroup" then
		local group = menu.groups[menu.currentSlot]
		C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
	else
		C.ClearSelectedMapMacroSlots(menu.holomap)
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonLeftBarColor(mode)
	if menu.loadoutMode then
		return Color["icon_normal"]
	else
		local modules = menu.modules[mode] or {}
		for i, module in ipairs(modules) do
			if (#menu.modulesearchtext == 0) or menu.filterModuleByText(module, menu.modulesearchtext) then
				return Color["icon_normal"]
			end
		end
	end
	return Color["icon_inactive"]
end

function menu.deactivateModulesMode()
	menu.prevModulesMode = menu.modulesMode
	PlaySound("ui_negative_back")
	menu.modulesMode = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.deactivateUpgradetypeMode()
	menu.prevUpgradetypeMode = menu.upgradetypeMode
	PlaySound("ui_negative_back")
	menu.upgradetypeMode = nil
	menu.determineInitialSlot()
	C.ClearSelectedMapMacroSlots(menu.holomap)
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonRightBar(newmenu, params)
	menu.state = menu.onSaveState()
	Helper.registerStationEditorState(menu)

	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonRightBarSelf()
	if not menu.loadoutMode then
		if menu.planMode then
			menu.planMode = nil
		else
			menu.planMode = "construction"
		end
	else
		if menu.loadoutPlanMode then
			menu.loadoutPlanMode = nil
		else
			menu.loadoutPlanMode = "normal"
		end
	end
	menu.displayMenu()
end

function menu.buttonSelectSlot(slot, row, col)
	if menu.currentSlot ~= slot then
		menu.currentSlot = slot
	end

	if menu.upgradetypeMode == "turretgroup" then
		local group = menu.groups[menu.currentSlot]
		C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
	end

	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = row
	menu.selectedCols.modules = col
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonSelectGroupUpgrade(type, group, macro, row, col, keepcontext)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if macro ~= menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].macro then
			menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].macro = macro
			if (macro ~= "") and (menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count == 0) then
				menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = 1
			elseif (macro == "") and (menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count ~= 0) then
				menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = 0
			end

			menu.topRows.modules = GetTopRow(menu.moduletable)
			menu.selectedRows.modules = row
			menu.selectedCols.modules = col
			menu.storePlanTableState()
			menu.refreshPlan()
			menu.displayMenu()
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.buttonClearEditbox(row)
	Helper.cancelEditBoxInput(menu.moduletable, row, 1)
	menu.searchtext = ""

	menu.displayMenu()
end

function menu.buttonExtendEntry(index, row)
	menu.extendEntry(menu.container, index)

	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.selectedRows.plan = row
	menu.displayMenu()
end

function menu.buttonExtendResourceEntry(index, row)
	menu.extendResourceEntry(index)

	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.selectedRows.planresources = row
	menu.displayMenu()
end

function menu.buttonAddModule(macro, row, col)
	C.AddMacroToConstructionMap(menu.holomap, macro, true)
	menu.floatingNewModule = macro
	SetMouseCursorOverride("crossarrows")
	SelectRow(menu.moduletable, row)
	SelectColumn(menu.moduletable, col)
	AddUITriggeredEvent(menu.name, "moduleadded", macro)
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
end

function menu.buttonRemoveModule(module, removesequence)
	C.RemoveItemFromConstructionMap2(menu.holomap, module.idx, removesequence)
	menu.closeContextMenu()

	menu.topRows.modules = GetTopRow(menu.moduletable)
	menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
	menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
	menu.storePlanTableState()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonCopyModule(module, copysequence)
	C.AddCopyToConstructionMap(menu.holomap, module.idx, copysequence)
	menu.floatingCopyModule = module.macro
	menu.closeContextMenu()
end

function menu.buttonResetModuleRotation(module)
	C.ResetConstructionMapModuleRotation(menu.holomap, module.idx)
	menu.closeContextMenu()
end

function menu.determineInitialSlot()
	menu.currentSlot = 1
	if menu.upgradetypeMode == "turretgroup" then
		local curslotsizepriority
		for i, group in ipairs(menu.groups) do
			if group.slotsize and (group.slotsize ~= "") then
				local sizeorder = config.slotSizeOrder[group.slotsize] or 0
				if (not curslotsizepriority) or (sizeorder < curslotsizepriority) then
					curslotsizepriority = sizeorder
					menu.currentSlot = i
				end
			end
		end
	end
end

function menu.buttonEditLoadout(module)
	local found
	for i, entry in ipairs(menu.constructionplan) do
		if entry.idx == module.idx then
			found = i
		end
	end

	if found then
		if not menu.loadoutMode then
			menu.hasconstructionchanges = menu.haschanges
			C.StoreConstructionMapState(menu.holomap)
			menu.mapstate = ffi.new("HoloMapState")
			C.GetMapState(menu.holomap, menu.mapstate)
		end
		menu.loadoutMode = found
		menu.loadoutModule = module
		menu.extendEntry(menu.container, tonumber(module.idx) + 1, true)

		Helper.callLoadoutFunction(module.upgradeplan, nil, function (loadout, _) return C.ShowObjectConfigurationMap2(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout, module.idx) end)

		menu.getUpgradeData(module.upgradeplan)
		menu.upgradetypeMode = "turretgroup"

		menu.determineInitialSlot()

		if menu.groups[menu.currentSlot] then
			local group = menu.groups[menu.currentSlot]
			C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
		end

		menu.closeContextMenu()

		menu.displayMainFrame()
		menu.displayMenu()
	end
end

function menu.buttonConfirmMoney()
	if menu.newAccountValue then
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.buildstorage))
		local buildstoragemoney = GetComponentData(convertedComponent, "money")
		local amount = menu.newAccountValue - buildstoragemoney
		if amount > 0 then
			TransferPlayerMoneyTo(amount, convertedComponent)
		else
			TransferMoneyToPlayer(-amount, convertedComponent)
		end
		menu.newAccountValue = nil

		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.buttonSetMoneyToEstimate()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.buildstorage))
	local buildstoragemoney = GetComponentData(convertedComponent, "money")
	local amount = menu.totalprice - buildstoragemoney
	if amount > 0 then
		TransferPlayerMoneyTo(amount, convertedComponent)
	else
		TransferMoneyToPlayer(-amount, convertedComponent)
	end
	menu.newAccountValue = nil

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonConfirm()
	C.SetConstructionSequenceFromConstructionMap(menu.container, menu.holomap)
	menu.updatePlan = getElapsedTime() + 0.1
end

function menu.buttonCancel()
	if menu.haschanges then
		menu.cancelRequested = true
		menu.storePlanTableState()
		menu.displayMenu()
	else
		if not menu.loadoutMode then
			-- nothing to do
		else
			 menu.buttonCancelLoadout()
		end
	end
end

function menu.buttonForceBuild()
	C.ForceBuildCompletion(menu.container)
	menu.updatePlan = getElapsedTime() + 0.1
end

function menu.resetDefaultLoadout()
	if menu.origDefaultLoadout ~= menu.defaultLoadout then
		C.SetDefensibleLoadoutLevel(menu.container, menu.origDefaultLoadout)
		menu.defaultLoadout = menu.origDefaultLoadout
	end
end

function menu.buttonCancelConfirm()
	menu.resetDefaultLoadout()
	C.ShowConstructionMap(menu.holomap, menu.container, "", false)
	menu.applySettings()
	menu.refreshPlan()
	menu.cancelRequested = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.buttonCancelCancel()
	menu.cancelRequested = nil
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.showConstructionMap()
	C.ShowConstructionMap(menu.holomap, menu.container, "", true)
	menu.applySettings()
	if menu.mapstate then
		C.SetMapState(menu.holomap, menu.mapstate)
		menu.mapstate = nil
	end
end

function menu.buttonConfirmLoadout()
	menu.showConstructionMap()

	Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, menu.loadoutModule.idx, menu.container, loadout) end)
	menu.defaultLoadout = -1

	menu.loadoutMode = nil
	menu.loadoutModule = {}
	menu.loadout = nil
	menu.hasconstructionchanges = nil

	menu.closeContextMenu()

	menu.displayMainFrame()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonCancelLoadout()
	menu.cancelRequested = nil

	menu.showConstructionMap()

	menu.loadoutMode = nil
	menu.loadoutModule = {}
	menu.loadout = nil
	menu.hasconstructionchanges = nil

	menu.closeContextMenu()

	menu.displayMainFrame()
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.buttonContextEncyclopedia(selectedUpgrade)
	if selectedUpgrade.type == "module" then
		local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, "Stations", library, selectedUpgrade.macro })
		menu.cleanup()
	else
		local upgradetype = Helper.findUpgradeType(selectedUpgrade.type)

		if (upgradetype.supertype == "macro") or (upgradetype.supertype == "virtualmacro") or (upgradetype.supertype == "group") then
			local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
			Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
			menu.cleanup()
		elseif upgradetype.supertype == "software" then
			-- selectedUpgrade.software
		elseif upgradetype.supertype == "ammo" then
			local library = GetMacroData(selectedUpgrade.macro, "infolibrary")
			if upgradetype.emode then
				Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, upgradetype.emode, library, selectedUpgrade.macro })
				menu.cleanup()
			end
		end
	end
end

function menu.buttonInteract(selectedData, button, row, col, posx, posy)
	menu.selectedUpgrade = selectedData
	local x, y = GetLocalMousePosition()
	if x == nil then
		-- gamepad case
		x = posx
		y = -posy
	end
	menu.displayContextFrame("equipment", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
end

function menu.buttonConstructionCommunity()
	if C.CanOpenWebBrowser() then
		C.OpenWebBrowser(ReadText(1001, 7976))
	end
end

function menu.buttonEditTradeRule(traderuleid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "traderule", (traderuleid ~= 0) and traderuleid or nil } })
	menu.cleanup()
end

function menu.buttonCancelTradeActive(tradeid)
	if not C.IsValidTrade(tradeid) then
		menu.refresh = menu.refresh or getElapsedTime()
		return
	end
	return C.CancelPlayerInvolvedTradeDeal(menu.container, tradeid, true)
end

function menu.buttonCancelTrade(tradeid)
	if C.CancelPlayerInvolvedTradeDeal(menu.container, tradeid, false) then
		-- The ware reservation is only implicitly removed after the trade was purged which only happens with a delay in gametime. To avoid no change in the menu after pressing the button, we hide the reservation now.
		menu.dirtyreservations[tostring(tradeid)] = true
	end
	menu.displayMenu()
end

function menu.onDropDownActivated()
	menu.closeContextMenu()
end

function menu.dropdownLoad(_, id)
	if id ~= nil then
		C.ShowConstructionMap(menu.holomap, menu.container, id, false)
		menu.applySettings()
		menu.currentCPID = id
		menu.defaultLoadout = -1
		menu.closeContextMenu()

		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.topRows.plan = 1
		menu.selectedRows.plan = nil
		menu.refreshPlan()
		menu.displayMenu()
	end
	menu.noupdate = false
end

function menu.dropdownRemovedCP(_, id)
	if __CORE_DETAILMONITOR_USERQUESTION["deleteconstructionplan"] then
		C.RemoveConstructionPlan("local", id)
		if id == menu.currentCPID then
			menu.currentCPID = nil
			menu.currentCPName = nil
		end
		for i, plan in ipairs(menu.constructionplans) do
			if plan.id == id then
				table.remove(menu.constructionplans, i)
				break
			end
		end
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.contextData = { id = "deleteconstructionplan", cpid = id }
		menu.displayContextFrame("removeCP", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	end
end

function menu.dropdownLoadout(_, loadoutid)
	if loadoutid ~= nil then
		if menu.loadout ~= loadoutid then
			menu.loadout = loadoutid
			local preset
			for _, loadout in ipairs(menu.loadouts) do
				if loadout.id == menu.loadout then
					menu.loadoutName = loadout.name
					if loadout.preset then
						preset = loadout.preset
						menu.loadout = nil
						menu.loadoutName = ""
					end
					break
				end
			end
			local loadout
			if preset then
				loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, menu.loadoutModule.idx, menu.container, preset)
			else
				loadout = Helper.getLoadoutHelper(C.GetLoadout, C.GetLoadoutCounts, 0, menu.loadoutModule.macro, loadoutid)
			end
			local upgradeplan = Helper.convertLoadout(menu.loadoutModule.component, menu.loadoutModule.macro, loadout, nil)
			menu.getUpgradeData(upgradeplan)

			if menu.holomap and (menu.holomap ~= 0) then
				Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
			end

			menu.displayMenu()
		end
	end
end

function  menu.dropdownRemovedLoadout(_, loadoutid)
	local macro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.loadoutModule.component)), "macro")
	C.RemoveLoadout("local", macro, loadoutid)
	if loadoutid == menu.loadout then
		menu.loadout = nil
		menu.loadoutName = nil
	end
	for i, loadout in ipairs(menu.loadouts) do
		if loadout.id == loadoutid then
			table.remove(menu.loadouts, i)
			break
		end
	end
end

function menu.dropdownDefaultLoadout(_, level)
	menu.defaultLoadout = tonumber(level)
	C.SetDefensibleLoadoutLevel(menu.container, menu.defaultLoadout)

	if menu.defaultLoadout ~= -1 then
		C.SetupConstructionSequenceModulesCache(menu.holomap, menu.container, true)
		for i, entry in ipairs(menu.constructionplan) do
			local active = false
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				if upgradetype.supertype == "macro" then
					if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
						active = true
						break
					end
				end
			end
			if active then
				local loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, entry.idx, menu.container, menu.defaultLoadout)
				local upgradeplan = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)
				Helper.callLoadoutFunction(upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, entry.idx, menu.container, loadout) end)
			end
		end
		C.SetupConstructionSequenceModulesCache(menu.holomap, menu.container, false)
		menu.refreshPlan()
		menu.displayMenu()
	end
end

function  menu.dropdownTradeRule(container, type, id, ware, refresh)
	if type == "trade" then
		C.SetContainerTradeRule(container, tonumber(id), "buy",  ware or "", true)
		C.SetContainerTradeRule(container, tonumber(id), "sell", ware or "", true)
	else
		C.SetContainerTradeRule(container, tonumber(id), type, ware or "", true)
	end

	if refresh then
		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.buttonTitleSave()
	if menu.contextMode and (menu.contextMode.mode == "saveCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("saveCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleImport()
	if menu.contextMode and (menu.contextMode.mode == "importCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.contextData = {}
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleExport()
	if menu.contextMode and (menu.contextMode.mode == "exportCP") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("exportCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleSaveLoadout()
	if menu.contextMode and (menu.contextMode.mode == "saveLoadout") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("saveLoadout", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonTitleSettings()
	if menu.contextMode and (menu.contextMode.mode == "settings") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("settings", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonModuleFilter(offsety)
	if menu.contextMode and (menu.contextMode.mode == "modulefilter") then
		menu.closeContextMenu()
	else
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
		menu.displayContextFrame("modulefilter", Helper.scaleX(config.moduleFilterWidth), menu.modulesData.offsetX + menu.modulesData.width + Helper.borderSize, offsety)
	end
end

function menu.buttonSave(overwrite)
	local source, id
	if overwrite then
		_, _, source = menu.checkCPNameID()
		id = menu.currentCPID
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	C.SaveMapConstructionPlan(menu.holomap, source or "local", id or "player", id ~= nil, menu.currentCPName, "")
	menu.closeContextMenu()
	menu.refreshTitleBar()
end

function menu.buttonExport(checked)
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	if canoverwrite and (not checked) then
		menu.contextData = menu.contextData or {}
		menu.contextData.mode = "export"
		menu.displayContextFrame("overwritequestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		local id = menu.currentCPID
		local filename = utf8.gsub(menu.currentCPName, "[^%w_%-%() ]", "_")
		C.ExportMapConstructionPlan(menu.holomap, filename, id or "", id ~= nil, menu.currentCPName, "")
		menu.closeContextMenu()
		menu.refreshTitleBar()
	end
end

function menu.buttonImport(checked)
	local id = menu.contextData.selectedEntry.id
	if menu.constructionplansbyID[id] and (not checked) then
		menu.contextData = menu.contextData or {}
		menu.contextData.mode = "import"
		menu.displayContextFrame("overwritequestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		if menu.constructionplansbyID[id] then
			C.RemoveConstructionPlan("local", id)
		end
		local filename = utf8.gsub(menu.contextData.selectedEntry.filename, "[^%w_%-%() ]", "_")
		C.ImportMapConstructionPlan(filename, id)
		menu.refreshTitleBar()
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
	end
end

function menu.buttonReloadImportable()
	menu.getImportablePlans()
	menu.refreshTitleBar()
	menu.contextData = {}
	menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
end

function menu.buttonSaveLoadout(overwrite)
	local loadoutid
	if overwrite then
		loadoutid = menu.loadout
	end

	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)
	local macro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringToLuaID(tostring(menu.loadoutModule.component)), "macro")
	if macro ~= "" then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.SaveLoadout(macro, loadout, "local", loadoutid or "player", loadoutid ~= nil, menu.loadoutName, "") end)
		menu.getPresetLoadouts()
	end
	menu.closeContextMenu()
	menu.refreshTitleBar()
end

function menu.buttonAssignConstructionVessel()
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "selectCV", { ConvertStringToLuaID(tostring(menu.container)) } })
	menu.cleanup()
end

function menu.buttonFireConstructionVessel(builder, orderidx)
	C.RemoveOrder2(builder, orderidx, true, false, true)
	menu.displayMenu()
	menu.refresh = getElapsedTime() + 1.0
end

function menu.buttonRemoveSearchEntry(index)
	Helper.cancelEditBoxInput(menu.moduletable, 2, 1)

	if menu.modulesearchtext[index].race then
		for i, race in ipairs(menu.races) do
			if race.id == menu.modulesearchtext[index].race then
				menu.races[i].selected = nil
				break
			end
		end
	end
	table.remove(menu.modulesearchtext, index)

	menu.displayMenu()
end

-- editbox scripts
function menu.onEditBoxActivated(_, oldtext)
	menu.oldEditBoxContent = oldtext
end

function menu.editboxSearchUpdateText(_, text, textchanged)
	if textchanged then
		menu.searchtext = text
	end

	menu.displayMenu()
end

function menu.editboxModuleSearchUpdateText(widget, text, textchanged)
	if textchanged then
		table.insert(menu.modulesearchtext, { text = text })
	end

	C.SetEditBoxText(widget, "")
	menu.displayMenu()
end

function menu.editboxNameUpdateText(_, text, textchanged)
	if textchanged then
		local name = text
		if name == "" then
			name = menu.oldEditBoxContent
		end
		SetComponentName(ConvertStringToLuaID(tostring(menu.container)), name)
	end
	if text == "" then
		local desc = Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 1, nil, "editbox", nil, menu.editboxNameUpdateText)
	end
end

function menu.editboxCPNameUpdateText(_, text)
	menu.currentCPName = text
	menu.currentCPID = nil
end

function menu.editboxLoadoutNameUpdateText(_, text)
	menu.loadoutName = text
	menu.loadout = nil
end

function menu.slidercellSelectAmount(type, group, row, keepcontext, value)
	local oldcontextmode = Helper.tableCopy(menu.contextMode)
	if not keepcontext then
		menu.closeContextMenu()
	end

	local upgradetype = Helper.findUpgradeType(type)

	if (upgradetype.supertype == "group") then
		if value ~= menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count then
			menu.constructionplan[menu.loadoutMode].upgradeplan[type][group].count = value

			menu.selectedRows.modules = row
		end
	end

	if menu.holomap and (menu.holomap ~= 0) then
		Helper.callLoadoutFunction(menu.constructionplan[menu.loadoutMode].upgradeplan, nil, function (loadout, _) return C.UpdateObjectConfigurationMap(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, loadout) end)
	end

	if keepcontext then
		menu.topRows.context = GetTopRow(menu.contexttable)
		menu.selectedRows.context = keepcontext
		menu.displayContextFrame("slot", oldcontextmode.width, oldcontextmode.x, oldcontextmode.y)
	end
end

function menu.slidercellMoney(_, value)
	menu.newAccountValue = value
end

function menu.slidercellWarePriceOverride(ware, row, value)
	SetContainerWarePriceOverride(menu.buildstorage, ware, true, value)
	C.SetContainerGlobalPriceFactor(menu.buildstorage, -1)
	menu.storePlanTableState()
	menu.selectedRows.plan = row
end

function menu.slidercellGlobalWarePriceFactor(row, value)
	local modifier = Helper.round(value / 100, 2)
	C.SetContainerGlobalPriceFactor(menu.buildstorage, modifier)
	for _, ware in ipairs(menu.tradewares) do
		local newprice = ware.minprice + (ware.maxprice - ware.minprice) * modifier
		SetContainerWarePriceOverride(menu.buildstorage, ware.ware, true, newprice)
		if ware.row then
			Helper.setSliderCellValue(menu.plantable, ware.row, 3, newprice)
		end
	end
	menu.storePlanTableState()
	menu.selectedRows.plan = row
end

function menu.onSliderCellConfirm()
	if not menu.selectedRows.plan then
		menu.storePlanTableState()
	end
	menu.refreshPlan()
	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.checkboxToggleGlobalWarePriceModifier()
	C.SetContainerGlobalPriceFactor(menu.buildstorage, (menu.globalpricefactor >= 0) and -1 or 1)
	if menu.globalpricefactor < 0 then
		for _, ware in ipairs(menu.tradewares) do
			SetContainerWarePriceOverride(menu.buildstorage, ware.ware, true, ware.maxprice)
		end
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

function menu.checkboxSetTradeRuleOverride(container, type, checked, ware)
	if type == "trade" then
		if checked then
			C.SetContainerTradeRule(container, -1, "buy",  ware or "", false)
			C.SetContainerTradeRule(container, -1, "sell", ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, "buy", ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "buy",  ware or "", true)
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, "sell", ware or "", true)
		end
	else
		if checked then
			C.SetContainerTradeRule(container, -1, type, ware or "", false)
		else
			local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
			C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware or "", true)
		end
	end

	menu.storePlanTableState()
	menu.displayMenu()
end

-- Menu member functions

function menu.hotkey(action)
	if action == "INPUT_ACTION_ADDON_DETAILMONITOR_UNDO" then
		menu.undoHelper(true)
	elseif action == "INPUT_ACTION_ADDON_DETAILMONITOR_REDO" then
		menu.undoHelper(false)
	end
end

function menu.undoHelper(undo)
	if undo then
		C.UndoConstructionMapChange(menu.holomap)
	else
		C.RedoConstructionMapChange(menu.holomap)
	end
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.sorterModules(type, a, b)
	local aname, amakerrace, atier, asize, awaregroup = GetMacroData(a, "shortname", "makerrace", "tier", "size", "waregroup")
	local bname, bmakerrace, btier, bsize, bwaregroup = GetMacroData(b, "shortname", "makerrace", "tier", "size", "waregroup")
	atier = atier or 0
	btier = btier or 0
	if #amakerrace > 0 then
		amakerrace = amakerrace[1]
	else
		amakerrace = ""
	end
	if #bmakerrace > 0 then
		bmakerrace = bmakerrace[1]
	else
		bmakerrace = ""
	end

	if atier == btier then
		if type == "moduletypes_production" then
			if awaregroup == bwaregroup then
				if aname == bname then
					return amakerrace < bmakerrace
				end
				return aname < bname
			end
			return awaregroup < bwaregroup
		else
			if amakerrace == bmakerrace then
				local asizesort = config.sizeSorting[asize] or 0
				local bsizesort = config.sizeSorting[bsize] or 0
				if asizesort == bsizesort then
					return aname < bname
				end
				return asizesort < bsizesort
			end
			return amakerrace < bmakerrace
		end
	end
	return atier < btier
end

function menu.newWareReservationCallback(_, data)
	local containerid, ware, reserverid = string.match(data, "(.+);(.+);(.+)")
	if menu.buildstorage == ConvertStringTo64Bit(containerid) then
		PlaySound("notification_achievement")
		menu.newWareReservation = (menu.newWareReservation or 0) + 1
		if menu.newWareReservationWares[ware] then
			menu.newWareReservationWares[ware][reserverid] = true
		else
			menu.newWareReservationWares[ware] = { [reserverid] = true }
		end
		menu.storePlanTableState()
		menu.displayMenu()
	end
end

function menu.getModules(uitype, moduletype, races, connectionmoduleraces)
	local n = C.GetNumBlueprints(menu.set, moduletype, "")
	if n > 0 then
		local buf = ffi.new("UIBlueprint[?]", n)
		n = C.GetBlueprints(buf, n, menu.set, moduletype, "")
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			local makerrace, makerracename = GetMacroData(macro, "makerraceid", "makerracename")
			for i, race in ipairs(makerrace) do
				races[race] = makerracename[i]
				if IsMacroClass(macro, "connectionmodule") then
					connectionmoduleraces[race] = makerracename[i]
				end
			end
			table.insert(menu.modules[uitype], macro)
		end
	end

	return n
end

function menu.onShowMenu(state)
	-- layout
	menu.scaleSize = Helper.scaleX(config.scaleSize)
	menu.frameworkData = {
		sidebarWidth = Helper.scaleX(Helper.sidebarWidth),
		offsetX = Helper.frameBorder,
		offsetY = Helper.frameBorder + 20,
	}
	local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
	local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
	reservedSidePanelWidth = reservedSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize
	menu.modulesData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetX = menu.frameworkData.sidebarWidth + menu.frameworkData.offsetX + 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}
	menu.planData = {
		width = actualSidePanelWidth - menu.frameworkData.sidebarWidth - menu.frameworkData.offsetX - 2 * Helper.borderSize,
		offsetY = Helper.frameBorder + Helper.borderSize,
	}

	local reserverdCenterPanelWidth = Helper.viewWidth - 2 * menu.modulesData.offsetX - 2 * reservedSidePanelWidth - 4 * Helper.borderSize
	local actualCenterPanelWidth = math.min(reserverdCenterPanelWidth, Helper.scaleX(config.maxCenterPanelWidth))
	menu.statsData = {
		width = actualCenterPanelWidth / 2,
		offsetX = menu.modulesData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth / 2) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData = {
		width = actualCenterPanelWidth,
		height = Helper.scaleY(40),
		dropdownWidth = 6 * menu.frameworkData.sidebarWidth,
		offsetX = menu.modulesData.offsetX + reservedSidePanelWidth + 3 * Helper.borderSize + (reserverdCenterPanelWidth - actualCenterPanelWidth) / 2,
		offsetY = Helper.frameBorder,
	}
	menu.titleData.nameWidth = menu.titleData.width - 7 * (menu.titleData.height + Helper.borderSize) - menu.titleData.dropdownWidth - Helper.borderSize
	if menu.titleData.nameWidth < 200 then
		menu.titleData.height = math.floor(menu.titleData.height * 2 / 3)
		menu.titleData.dropdownWidth = 5 * menu.titleData.height
		menu.titleData.nameWidth = math.max(20, menu.titleData.width - 7 * (menu.titleData.height + Helper.borderSize) - menu.titleData.dropdownWidth - Helper.borderSize)
	end
	menu.planData.offsetX = Helper.viewWidth - actualSidePanelWidth + Helper.borderSize
	menu.mapData = {
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		offsetX = 0,
		offsetY = 0
	}
	menu.subHeaderRowHeight = Helper.scaleY(26)

	menu.headerTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		cellBGColor = Color["row_background"],
		titleColor = Color["row_title"],
	}

	menu.headerCenteredTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
		y = math.floor((menu.titleData.height - Helper.scaleY(Helper.headerRow1Height)) / 2 + Helper.scaleY(Helper.headerRow1Offsety)),
		minRowHeight = menu.titleData.height,
		scaling = false,
		halign = "center",
		cellBGColor = Color["row_background"],
		titleColor = Color["row_title"],
	}

	menu.slidercellTextProperties = {
		font = Helper.headerRow1Font,
		fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize),
		x = Helper.scaleX(Helper.headerRow1Offsetx),
	}

	menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)

	-- parameters
	menu.container = ConvertIDTo64Bit(menu.param[3])
	menu.buildstorage = ConvertIDTo64Bit(GetComponentData(menu.container, "buildstorage")) or 0

	menu.defaultLoadout = Helper.round(C.GetDefensibleLoadoutLevel(menu.container), 1)
	menu.origDefaultLoadout = menu.defaultLoadout

	RegisterEvent("newWareReservation", menu.newWareReservationCallback)

	menu.initExtendedEntry(menu.container)

	local sets = GetComponentData(menu.container, "modulesets")
	menu.set = sets[1] or ""

	-- prepare modules
	menu.modules = {}
	local races = {}
	local connectionmoduleraces = {}
	for _, entry in ipairs(config.leftBar) do
		menu.modules[entry.mode] = {}
		local n = menu.getModules(entry.mode, entry.mode, races, connectionmoduleraces)

		if entry.additionaltypes then
			for _, moduletype in ipairs(entry.additionaltypes) do
				n = n + menu.getModules(entry.mode, moduletype, races, connectionmoduleraces)
			end
		end

		table.sort(menu.modules[entry.mode], function (a, b) return menu.sorterModules(entry.mode, a, b) end)
		entry.active = n > 0
	end

	menu.races = {}
	for race, name in pairs(races) do
		table.insert(menu.races, { id = race, name = name })
	end
	table.sort(menu.races, Helper.sortName)
	table.insert(menu.races, 1, { id = "generic", name = ReadText(1001, 11916) })

	menu.connectionmoduleraces = {}
	for race, name in pairs(connectionmoduleraces) do
		table.insert(menu.connectionmoduleraces, { id = race, text = name, icon = "", displayremoveoption = false })
	end
	table.sort(menu.connectionmoduleraces, function (a, b) return a.text < b.text end)
	table.insert(menu.connectionmoduleraces, 1, { id = "all", text = ReadText(1001, 11922), icon = "", displayremoveoption = false })

	-- assemble possible upgrades (wares, macros)
	menu.upgradewares = {}
	for _, blueprintGroup in ipairs(config.equipmentBlueprintGroups) do
		local n = C.GetNumBlueprints(menu.set, blueprintGroup.library, "")
		local buf = ffi.new("UIBlueprint[?]", n)
		n = C.GetBlueprints(buf, n, menu.set, blueprintGroup.library, "")
		for i = 0, n - 1 do
			local entry = {}
			entry.macro = ffi.string(buf[i].macro)
			entry.ware = ffi.string(buf[i].ware)
			if menu.upgradewares[blueprintGroup.type] then
				table.insert(menu.upgradewares[blueprintGroup.type], entry)
			else
				menu.upgradewares[blueprintGroup.type] = { entry }
			end
		end
	end

	-- check for limited modules
	menu.externalUsedLimitedModules = {}
	local n = C.GetNumUsedLimitedModules(menu.container)
	if n > 0 then
		local buf = ffi.new("UIMacroCount[?]", n)
		n = C.GetUsedLimitedModules(buf, n, menu.container)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.externalUsedLimitedModules[macro] = buf[i].amount
		end
	end

	-- trade rules
	Helper.updateTradeRules()

	menu.searchtext = ""
	menu.modulesearchtext = {}
	menu.loadoutName = ""
	menu.modulesMode = "moduletypes_production"
	menu.upgradetypeMode = "turretgroup"
	menu.planMode = "construction"
	menu.loadoutPlanMode = "normal"

	menu.topRows = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	if state then
		menu.state = state
	end

	-- we are (again) in the station config menu, menu keeps track of changes itself
	Helper.unregisterStationEditorChanges()

	menu.displayMainFrame()

	RegisterAddonBindings("ego_detailmonitor", "undo")
	Helper.setKeyBinding(menu, menu.hotkey)
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_station_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.displayLeftBar(frame)
	local maxSlotWidth = math.floor((menu.modulesData.width - 8 * Helper.borderSize) / 9)

	local leftBar = config.leftBar
	local offsety = menu.frameworkData.offsetY
	if menu.loadoutMode then
		leftBar = config.leftBarLoadout
		offsety = menu.modulesData.offsetY + menu.titleData.height + 2 * Helper.borderSize + maxSlotWidth
	end

	local ftable = frame:addTable(1, { tabOrder = 2, width = menu.frameworkData.sidebarWidth, height = 0, x = menu.frameworkData.offsetX, y = offsety, scaling = false, borderEnabled = false, reserveScrollBar = false })

	local found = true
	for _, entry in ipairs(leftBar) do
		local active = true
		local selected = false
		local prevSelected = false
		local mouseovertext = entry.name
		if menu.loadoutMode then
			selected = entry.mode == menu.upgradetypeMode
			prevSelected = entry.mode == menu.prevUpgradetypeMode
			if entry.mode == "turretgroup" then
				active = active and (#menu.groups > 0)
			end
		else
			active = entry.active and ((not entry.condition) or entry.condition())
			if entry.mode == "moduletypes_venture" then
				if entry.condition and (not entry.condition()) then
					mouseovertext = mouseovertext .. "\n" .. ColorText["text_error"] .. ReadText(1026, 7930)
				end
			end
			selected = entry.mode == menu.modulesMode
			prevSelected = entry.mode == menu.prevModulesMode
		end
		local row = ftable:addRow(active, { fixed = true, bgColor = Color["row_background_blue"] })

		-- if nothing selected yet, select this one if active
		if (not found) and active then
			found = true
			menu.modulesMode = entry.mode
		end

		-- if selected, but not active, select next active entry
		if selected and (not active) then
			found = false
			selected = false
		end

		if selected then
			menu.selectedRows.left = row.index
		elseif prevSelected then
			menu.selectedRows.left = row.index
		end
		row[1]:createButton({ helpOverlayID = entry.helpOverlayID, helpOverlayText = entry.helpOverlayText,  active = active, height = menu.frameworkData.sidebarWidth, mouseOverText = mouseovertext, bgColor = selected and Color["row_background_selected"] or Color["button_background_default"] }):setIcon(entry.icon, { color = function () return menu.buttonLeftBarColor(entry.mode) end })
		if not menu.loadoutMode then
			row[1].handlers.onClick = function () return menu.buttonLeftBar(entry.mode, row.index) end
		else
			row[1].handlers.onClick = function () return menu.buttonLeftBarLoadout(entry.mode, row.index) end
		end
	end
	ftable:setTopRow(menu.topRows.left)
	ftable:setSelectedRow(menu.selectedRows.left)
	menu.topRows.left = nil
	menu.selectedRows.left = nil
end

function menu.updateConstructionPlans()
	menu.constructionplans = {}
	menu.constructionplansbyID = {}
	local n = C.GetNumConstructionPlans()
	local buf = ffi.new("UIConstructionPlan[?]", n)
	n = C.GetConstructionPlans(buf, n)
	local ischeatversion = IsCheatVersion()
	for i = 0, n - 1 do
		local source = ffi.string(buf[i].source)
		if (source == "local") or ischeatversion then
			local id = ffi.string(buf[i].id)
			local active = false
			local mouseovertext
			local numinvalidpatches = ffi.new("uint32_t[?]", 1)
			if not C.IsConstructionPlanValid(id, numinvalidpatches) then
				local numpatches = numinvalidpatches[0]
				local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
				numpatches = C.GetConstructionPlanInvalidPatches(patchbuf, numpatches, id)
				mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
				for j = 0, numpatches - 1 do
					if j > 3 then
						mouseovertext = mouseovertext .. "\n- ..."
						break
					end
					mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
					if patchbuf[j].state == 2 then
						mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
					elseif patchbuf[j].state == 3 then
						mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
					elseif patchbuf[j].state == 4 then
						mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
					end
				end
			elseif not C.AreConstructionPlanLoadoutsCompatible(id) then
				mouseovertext = ReadText(1026, 7929)
			else
				local result = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, id, false))
				active = result == ""
				if menu.set == "headquarters_player" then
					local macros = { "landmarks_player_hq_01_research_macro" }
					local hasmacros = Helper.textArrayHelper(macros, function (numtexts, texts) return C.CheckConstructionPlanForMacros(id, texts, numtexts) end)
					active = active and hasmacros
					if not hasmacros then
						mouseovertext = ReadText(1026, 7919)
					end
				end
				local missingmacros = {}
				if (not active) and (string.find(result, "error") ~= 1) then
					for macro in string.gmatch(result, "([^;]+);") do
						missingmacros[macro] = true
					end
				end
				local missingmacronames = {}
				for macro, v in pairs(missingmacros) do
					table.insert(missingmacronames, GetMacroData(macro, "name"))
				end
				table.sort(missingmacronames)
				local blueprinttext = ""
				for _, name in ipairs(missingmacronames) do
					blueprinttext = blueprinttext .. "\n· " .. name
				end

				local hasmissinglimitedmodules = false
				local hasmissinglimitedventuremodules = false
				local limitedmoduletext = ""
				local limitedventuremoduletext = ""
				local n = C.GetNumPlannedLimitedModules(id)
				local macrocounts = ffi.new("UIMacroCount[?]", n)
				n = C.GetPlannedLimitedModules(macrocounts, n, id)
				for j = 0, n - 1 do
					local macro = ffi.string(macrocounts[j].macro)
					local ware = GetMacroData(macro, "ware")
					local islimited = GetWareData(ware, "islimited")
					if islimited then
						if macrocounts[j].amount > Helper.getLimitedWareAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) then
							active = false
							hasmissinglimitedmodules = true
							limitedmoduletext = limitedmoduletext .. "\n· " .. GetMacroData(macro, "name")
						end
					else
						if macrocounts[j].amount > OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) then
							active = false
							hasmissinglimitedventuremodules = true
							limitedventuremoduletext = limitedventuremoduletext .. "\n· " .. GetMacroData(macro, "name")
						end
					end
				end

				if (not active) and (mouseovertext == nil) then
					mouseovertext = ReadText(1026, 7912) .. blueprinttext .. (hasmissinglimitedmodules and ("\n" .. ReadText(1026, 7934) .. limitedmoduletext) or "") .. (hasmissinglimitedventuremodules and ("\n" .. ReadText(1026, 7915) .. limitedventuremoduletext) or "")
				end
			end

			table.insert(menu.constructionplans, { id = id, name = ffi.string(buf[i].name), source = source, deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
			menu.constructionplansbyID[id] = { name = ffi.string(buf[i].name), source = source }
		end
	end
end

function menu.getImportablePlans()
	menu.importableplans = {}
	menu.importableplansbyfile = {}
	local n = C.GetNumImportableConstructionPlans()
	local buf = ffi.new("UIConstructionPlanInfo[?]", n)
	n = C.GetImportableConstructionPlans(buf, n)
	for i = 0, n - 1 do
		local filename = ffi.string(buf[i].filename)
		local id = ffi.string(buf[i].id)
		local name = ffi.string(buf[i].name)

		table.insert(menu.importableplans, { id = id, name = name, filename = filename, imported = menu.constructionplansbyID[id] ~= nil })
		menu.importableplansbyfile[filename] = { id = id, name = name }
	end
	table.sort(menu.importableplans, Helper.sortName)
end

function menu.createTitleBar(frame)
	menu.updateConstructionPlans()
	menu.getImportablePlans()

	local ftable = frame:addTable(9, { tabOrder = 5, height = 0, x = menu.titleData.offsetX, y = menu.titleData.offsetY, scaling = false, reserveScrollBar = false })
	ftable:setColWidth(1, menu.titleData.nameWidth)
	ftable:setColWidth(2, menu.titleData.dropdownWidth)
	ftable:setColWidth(3, menu.titleData.height)
	ftable:setColWidth(4, menu.titleData.height)
	ftable:setColWidth(5, menu.titleData.height)
	ftable:setColWidth(6, menu.titleData.height)
	ftable:setColWidth(7, menu.titleData.height)
	ftable:setColWidth(8, menu.titleData.height)
	ftable:setColWidth(9, menu.titleData.height)

	local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	if not menu.loadoutMode then
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		local loadOptions = {}
		for _, plan in ipairs(menu.constructionplans) do
			table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		end
		table.sort(loadOptions, function (a, b) return a.text < b.text end)
		row[2]:createDropDown(loadOptions, { textOverride = ReadText(1001, 7904), optionWidth = menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize }):setTextProperties(config.dropDownTextProperties)
		row[2].handlers.onDropDownActivated = function () menu.noupdate = true end
		row[2].handlers.onDropDownConfirmed = menu.dropdownLoad
		row[2].handlers.onDropDownRemoved = menu.dropdownRemovedCP
		-- save
		row[3]:createButton({ helpOverlayID = "save_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7901) }):setIcon("menu_save")
		row[3].handlers.onClick = menu.buttonTitleSave
		-- Import
		row[4]:createButton({ helpOverlayID = "import_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7916) }):setIcon("menu_import")
		row[4].handlers.onClick = menu.buttonTitleImport
		-- Export
		row[5]:createButton({ helpOverlayID = "export_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7917) }):setIcon("menu_export")
		row[5].handlers.onClick = menu.buttonTitleExport
		-- reset camera
		row[6]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[6].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
		-- undo
		menu.canundo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canundo = C.CanUndoConstructionMapChange(menu.holomap)
		end
		row[7]:createButton({ helpOverlayID = "undo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canundo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278) }):setIcon("menu_undo")
		row[7].handlers.onClick = function () return menu.undoHelper(true) end
		-- redo
		menu.canredo = false
		if menu.holomap and (menu.holomap ~= 0) then
			menu.canredo = C.CanRedoConstructionMapChange(menu.holomap)
		end
		row[8]:createButton({ helpOverlayID = "redo_constructionplan", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = menu.canredo, height = menu.titleData.height, mouseOverText = ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279) }):setIcon("menu_redo")
		row[8].handlers.onClick = function () return menu.undoHelper(false) end
		-- settings
		row[9]:createButton({ helpOverlayID = "settings", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height }):setIcon("menu_options")
		row[9].handlers.onClick = menu.buttonTitleSettings
	else
		-- name
		row[1]:createEditBox({ scaling = true }):setText(ffi.string(C.GetComponentName(menu.container)), { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
		row[1].handlers.onEditBoxDeactivated = menu.editboxNameUpdateText
		-- load
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end
		row[2]:setColSpan(6):createDropDown(loadoutOptions, { textOverride = ReadText(1001, 7905), optionWidth = menu.titleData.dropdownWidth + 6 * (menu.titleData.height + Helper.borderSize) }):setTextProperties(config.dropDownTextProperties)
		row[2].handlers.onDropDownConfirmed = menu.dropdownLoadout
		row[2].handlers.onDropDownRemoved = menu.dropdownRemovedLoadout
		-- save
		row[8]:createButton({ helpOverlayID = "save_loadout", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ReadText(1026, 7905) }):setIcon("menu_save")
		row[8].handlers.onClick = menu.buttonTitleSaveLoadout
		-- reset camera
		row[9]:createButton({ helpOverlayID = "reset_topview", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = true, height = menu.titleData.height, mouseOverText = ffi.string(C.ConvertInputString(ReadText(1026, 7911), ReadText(1026, 7902))) }):setIcon("menu_reset_view"):setHotkey("INPUT_STATE_DETAILMONITOR_RESET_VIEW", { displayIcon = false })
		row[9].handlers.onClick = function () return C.ResetMapPlayerRotation(menu.holomap) end
	end
end

function menu.refreshTitleBar()
	local text = {
		alignment = "center",
		fontname = Helper.standardFont,
		fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize),
		color = Color["text_normal"],
		x = 0,
		y = 0
	}

	menu.updateConstructionPlans()
	menu.getImportablePlans()

	if not menu.loadoutMode then
		text.override = ReadText(1001, 7904)
		local loadOptions = {}
		for _, plan in ipairs(menu.constructionplans) do
			table.insert(loadOptions, { id = plan.id, text = plan.name, icon = "", displayremoveoption = plan.deleteable, active = plan.active, mouseovertext = plan.mouseovertext })
		end
		table.sort(loadOptions, function (a, b) return a.text < b.text end)

		-- editbox
		local desc = Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 1, nil, "editbox", nil, menu.editboxNameUpdateText)
		-- dropdown
		local desc = Helper.createDropDown(loadOptions, "", text, nil, true, true, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + menu.titleData.height + Helper.borderSize)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 2, nil, "dropdown", nil, function () menu.noupdate = true end, menu.dropdownLoad, menu.dropdownRemovedCP)
		-- save
		local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7901))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 3, nil, "button", nil, menu.buttonTitleSave)
	else
		text.override = ReadText(1001, 7905)
		local loadoutOptions = {}
		if next(menu.loadouts) then
			for _, loadout in ipairs(menu.loadouts) do
				table.insert(loadoutOptions, { id = loadout.id, text = loadout.name, icon = "", displayremoveoption = loadout.deleteable, active = loadout.active, mouseovertext = loadout.mouseovertext })
			end
		end

		-- editbox
		local desc = Helper.createEditBox(Helper.createTextInfo(ffi.string(C.GetComponentName(menu.container)), "center", Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize), 255, 255, 255, 100), true, 0, 0, 0, 0, nil, nil, false)
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 1, nil, "editbox", nil, menu.editboxNameUpdateText)
		-- dropdown
		local desc = Helper.createDropDown(loadoutOptions, "", text, nil, true, next(menu.loadouts) ~= nil, 0, 0, 0, 0, nil, nil, "", menu.titleData.dropdownWidth + 4 * (menu.titleData.height + Helper.borderSize))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 2, nil, "dropdown", nil, nil, menu.dropdownLoadout, menu.dropdownRemovedLoadout)
		-- save
		local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_save", nil, 255, 255, 255, 100), true, true, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7905))
		Helper.setCellContent(menu, menu.titlebartable, desc, 1, 8, nil, "button", nil, menu.buttonTitleSaveLoadout)
	end
end

function menu.getPresetLoadouts()
	-- presets
	menu.loadouts = {}

	local currentmacro = (menu.loadoutModule.macro ~= "") and menu.loadoutModule.macro or GetComponentData(ConvertStringTo64Bit(tostring(menu.loadoutModule.component)), "macro")
	local n = C.GetNumLoadoutsInfo(menu.loadoutModule.component, menu.loadoutModule.macro)
	local buf = ffi.new("UILoadoutInfo[?]", n)
	n = C.GetLoadoutsInfo(buf, n, menu.loadoutModule.component, menu.loadoutModule.macro)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		local active = false
		local mouseovertext = ""
		local numinvalidpatches = ffi.new("uint32_t[?]", 1)
		if not C.IsLoadoutValid(0, menu.loadoutModule.macro, id, numinvalidpatches) then
			local numpatches = numinvalidpatches[0]
			local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
			numpatches = C.GetLoadoutInvalidPatches(patchbuf, numpatches, 0, menu.loadoutModule.macro, id)
			mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
			for j = 0, numpatches - 1 do
				if j > 3 then
					mouseovertext = mouseovertext .. "\n- ..."
					break
				end
				mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
				if patchbuf[j].state == 2 then
					mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
				elseif patchbuf[j].state == 3 then
					mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
				elseif patchbuf[j].state == 4 then
					mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
				end
			end
		elseif not C.IsLoadoutCompatible(currentmacro, id) then
			mouseovertext = ReadText(1026, 8024)
		else
			local result = ffi.string(C.GetMissingLoadoutBlueprints(menu.buildstorage, 0, menu.loadoutModule.macro, id))
			active = result == ""
			if not active then
				mouseovertext = ReadText(1026, 8011)

				local missingmacros = {}
				if string.find(result, "error") ~= 1 then
					for macro in string.gmatch(result, "([^;]+);") do
						missingmacros[macro] = true
					end
				end
				local missingmacronames = {}
				for macro, v in pairs(missingmacros) do
					table.insert(missingmacronames, GetMacroData(macro, "name"))
				end
				table.sort(missingmacronames)
				for _, name in ipairs(missingmacronames) do
					mouseovertext = mouseovertext .. "\n· " .. name
				end
			end
		end

		table.insert(menu.loadouts, { id = id, name = ffi.string(buf[i].name), icon = ffi.string(buf[i].iconid), deleteable = buf[i].deleteable, active = active, mouseovertext = mouseovertext })
	end
	table.sort(menu.loadouts, function (a, b) return a.name < b.name end)
	table.insert(menu.loadouts, 1, { id = "empty", name = ReadText(1001, 7990), icon = "", deleteable = false, preset = 0 })
	table.insert(menu.loadouts, 2, { id = "low", name = ReadText(1001, 7910), icon = "", deleteable = false, preset = 0.1 })
	table.insert(menu.loadouts, 3, { id = "medium", name = ReadText(1001, 7911), icon = "", deleteable = false, preset = 0.5 })
	table.insert(menu.loadouts, 4, { id = "high", name = ReadText(1001, 7912), icon = "", deleteable = false, preset = 1.0 })
end

function menu.getUpgradeData(upgradeplan)
	-- get preset loadouts
	menu.getPresetLoadouts()

	-- init upgradeplan
	menu.constructionplan[menu.loadoutMode].upgradeplan = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type] = {}
	end

	-- assemble available slots/ammo/software
	menu.slots = {}
	if menu.loadoutModule.component ~= 0 then
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				menu.slots[upgradetype.type] = {}
				for j = 1, tonumber(C.GetNumUpgradeSlots(menu.loadoutModule.component, "", upgradetype.type)) do
					-- convert index from lua to C-style
					menu.slots[upgradetype.type][j] = { currentmacro = ffi.string(C.GetUpgradeSlotCurrentMacro(menu.container, menu.loadoutModule.component, upgradetype.type, j)), possiblemacros = {} }
					menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][j] = menu.slots[upgradetype.type][j].currentmacro
				end
			end
		end
	else
		for i, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "macro" then
				menu.slots[upgradetype.type] = {}
				for j = 1, tonumber(C.GetNumUpgradeSlots(0, menu.loadoutModule.macro, upgradetype.type)) do
					-- convert index from lua to C-style
					menu.slots[upgradetype.type][j] = { currentmacro = "", possiblemacros = {} }
					menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][j] = ""
				end
			end
		end
	end

	menu.groups = {}
	local n = C.GetNumUpgradeGroups(menu.loadoutModule.component, menu.loadoutModule.macro)
	local buf = ffi.new("UpgradeGroup[?]", n)
	n = C.GetUpgradeGroups(buf, n, menu.loadoutModule.component, menu.loadoutModule.macro)
	for i = 0, n - 1 do
		table.insert(menu.groups, { path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) })
		local group = menu.groups[#menu.groups]
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local groupinfo = C.GetUpgradeGroupInfo(menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group, upgradetype.grouptype)
				local slotsize = ffi.string(groupinfo.slotsize)

				local compatibilities
				local n_comp = C.GetNumUpgradeGroupCompatibilities(menu.loadoutModule.component, menu.loadoutModule.macro, 0, group.path, group.group, upgradetype.grouptype)
				if n_comp > 0 then
					compatibilities = {}
					local buf_comp = ffi.new("EquipmentCompatibilityInfo[?]", n)
					n_comp = C.GetUpgradeGroupCompatibilities(buf_comp, n_comp, menu.loadoutModule.component, menu.loadoutModule.macro, 0, group.path, group.group, upgradetype.grouptype)
					for k = 0, n_comp - 1 do
						compatibilities[ffi.string(buf_comp[k].tag)] = ffi.string(buf_comp[k].name)
					end
				end

				menu.groups[#menu.groups][upgradetype.grouptype] = { count = groupinfo.count, total = groupinfo.total, slotsize = slotsize, compatibilities = compatibilities, currentmacro = ffi.string(groupinfo.currentmacro), possiblemacros = {} }
				if upgradetype.grouptype ~= "shield" then
					menu.groups[#menu.groups].slotsize = slotsize
					menu.groups[#menu.groups].compatibilities = compatibilities
				end
				menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][#menu.groups] = { macro = ffi.string(groupinfo.currentmacro), count = groupinfo.count, path = group.path, group = group.group }
			end
		end
	end

	-- assemble possible upgrades per slot
	for type, slots in pairs(menu.slots) do
		for i, slot in ipairs(slots) do
			local wares = menu.upgradewares[type] or {}
			for _, upgradeware in ipairs(wares) do
				if upgradeware.macro ~= "" then
					if C.IsUpgradeMacroCompatible(menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, type, i, upgradeware.macro) then
						table.insert(slot.possiblemacros, upgradeware.macro)
					end
				end
			end
			table.sort(slot.possiblemacros, Helper.sortMacroRaceAndShortname)
		end
	end

	for i, group in ipairs(menu.groups) do
		for j, upgradetype in ipairs(Helper.upgradetypes) do
			if upgradetype.supertype == "group" then
				local wares = menu.upgradewares[upgradetype.grouptype] or {}
				for _, upgradeware in ipairs(wares) do
					if upgradeware.macro ~= "" then
						if C.IsUpgradeGroupMacroCompatible(menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group, upgradetype.grouptype, upgradeware.macro) then
							table.insert(menu.groups[i][upgradetype.grouptype].possiblemacros, upgradeware.macro)
						end
					end
				end
				table.sort(menu.groups[i][upgradetype.grouptype].possiblemacros, Helper.sortMacroRaceAndShortname)
			end
		end
	end

	if upgradeplan then
		for type, upgradelist in pairs(menu.constructionplan[menu.loadoutMode].upgradeplan) do
			local upgradetype = Helper.findUpgradeType(type)
			for key, upgrade in pairs(upgradelist) do
				if upgradetype.supertype == "group" then
					local found = false
					for key2, upgrade2 in pairs(upgradeplan[type]) do
						if (upgrade2.path == upgrade.path) and (upgrade2.group == upgrade.group) then
							found = true
							menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].macro = upgrade2.macro or ""
							menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].count = upgrade2.count or 0
							break
						end
					end
					if not found then
						menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].macro = ""
						menu.constructionplan[menu.loadoutMode].upgradeplan[type][key].count = 0
					end
				else
					menu.constructionplan[menu.loadoutMode].upgradeplan[type][key] = upgradeplan[type][key] or ""
				end
			end
		end
	end
end

function menu.ventureModuleUnavailableMouseOverText()
	local mouseovertext = ColorText["text_error"] .. ReadText(1026, 7913)
	if not C.IsVentureExtensionSupported() then
		mouseovertext = ColorText["text_error"] .. ReadText(1026, 7930)
	elseif not OnlineHasSession() then
		mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7921)
	end
	return mouseovertext
end

function menu.sortSlots(a, b)
	local asize = config.slotSizeOrder[a[4]] or 0
	local bsize = config.slotSizeOrder[b[4]] or 0
	if asize == bsize then
		return a[1] < b[1]
	end
	return asize < bsize
end

function menu.displayModules(frame, firsttime)
	if firsttime then
		AddUITriggeredEvent(menu.name, menu.modulesMode, "on")
	end

	local count, rowcount, slidercount = 1, 0, 0
	local hasventureplatform = false
	if not menu.loadoutMode then
		local modules = menu.modules[menu.modulesMode] or {}
		menu.groupedmodules = {}
		local ventureplatformmacros = {}
		for i, module in ipairs(modules) do
			if menu.modulesMode == "moduletypes_venture" then
				if IsMacroClass(module, "ventureplatform") then
					table.insert(ventureplatformmacros, module)
				end
			end

			if (#menu.modulesearchtext == 0) or menu.filterModuleByText(module, menu.modulesearchtext) then
				local group = math.ceil(count / 3)
				menu.groupedmodules[group] = menu.groupedmodules[group] or {}
				table.insert(menu.groupedmodules[group], module)
				count = count + 1
			end
		end

		for _, macro in ipairs(ventureplatformmacros) do
			if (menu.usedLimitedModules[macro] or 0) > 0 then
				hasventureplatform = true
				break
			end
		end
	else
		if menu.upgradetypeMode == "turretgroup" then
			local upgradegroup = menu.groups[menu.currentSlot]

			menu.groupedupgrades = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				local upgradegroupcount = 1
				if upgradetype.supertype == "group" then
					menu.groupedupgrades[upgradetype.grouptype] = {}
					if upgradegroup then
						for i, macro in ipairs(upgradegroup[upgradetype.grouptype].possiblemacros) do
							if (menu.searchtext == "") or menu.filterUpgradeByText(macro, menu.searchtext) then
								local group = math.ceil(upgradegroupcount / 3)
								menu.groupedupgrades[upgradetype.grouptype][group] = menu.groupedupgrades[upgradetype.grouptype][group] or {}
								table.insert(menu.groupedupgrades[upgradetype.grouptype][group], { macro = macro, icon = (C.IsIconValid("upgrade_" .. macro) and ("upgrade_" .. macro) or "upgrade_notfound"), name = GetMacroData(macro, "name") })
								upgradegroupcount = upgradegroupcount + 1
							end
						end
					end

					if upgradetype.allowempty then
						local group = math.ceil(upgradegroupcount / 3)
						menu.groupedupgrades[upgradetype.grouptype][group] = menu.groupedupgrades[upgradetype.grouptype][group] or {}
						table.insert(menu.groupedupgrades[upgradetype.grouptype][group], { macro = "", icon = "upgrade_empty", name = ReadText(1001, 7906), helpOverlayID = "upgrade_empty", helpOverlayText = " ", helpOverlayHighlightOnly = true })
						upgradegroupcount = upgradegroupcount + 1
					end
				end
				count = count + upgradegroupcount - 1
				if upgradegroupcount > 1 then
					slidercount = slidercount + 1
				end
				rowcount = rowcount + math.ceil((upgradegroupcount - 1) / 3)
			end
			count = count + 1
		end
	end
	count = count - 1

	local editboxheight = math.max(23, Helper.scaleY(Helper.standardTextHeight))

	if not menu.loadoutMode then
		if menu.modulesMode then
			local maxColumnWidth = math.floor((menu.modulesData.width - 2 * Helper.borderSize) / 3)
			local columnWidth = maxColumnWidth - math.floor(((count / 3 > 6) and Helper.scrollbarWidth or 0) / 3)

			local ftable = frame:addTable(5, { tabOrder = 1, width = menu.modulesData.width, height = 0, x = menu.modulesData.offsetX, y = menu.modulesData.offsetY, scaling = false, reserveScrollBar = false, highlightMode = "column", backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			if menu.setdefaulttable then
				ftable.properties.defaultInteractiveObject = true
				menu.setdefaulttable = nil
			end
			ftable:setColWidth(1, columnWidth)
			ftable:setColWidth(2, columnWidth)
			ftable:setColWidth(4, editboxheight)
			ftable:setColWidth(5, editboxheight)
			ftable:setDefaultColSpan(3, 3)

			local name = menu.getLeftBarEntry(menu.modulesMode).name or ""
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(name, menu.headerTextProperties)

			local rowy = ftable:getFullHeight()
			local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(4):createEditBox({ defaultText = ReadText(1001, 3250), scaling = true }):setText("", { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
			row[1].handlers.onEditBoxDeactivated = menu.editboxModuleSearchUpdateText
			row[5]:createButton({ height = editboxheight }):setIcon("menu_filter")
			row[5].handlers.onClick = function () return menu.buttonModuleFilter(menu.modulesData.offsetY + rowy + Helper.borderSize) end

			local row = ftable:addRow((#menu.modulesearchtext > 0), { fixed = true })
			local searchindex = 0
			for i = 1, math.min(3, #menu.modulesearchtext) do
				local col = i
				searchindex = searchindex + 1
				local truncatedString = TruncateText(menu.modulesearchtext[i].text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), row[col]:getWidth() - 2 * Helper.scaleX(10))
				row[col]:setColSpan(1):createButton({ scaling = true, height = Helper.standardTextHeight, mouseOverText = (truncatedString ~= menu.modulesearchtext[i].text) and menu.modulesearchtext[i].text or "" }):setText(truncatedString, { halign = "center" }):setText2("X", { halign = "right" })
				if menu.modulesearchtext[i].race then
					row[col]:setIcon("menu_filter", { width = Helper.standardTextHeight, height = Helper.standardTextHeight })
				end
				row[col].handlers.onClick = function () return menu.buttonRemoveSearchEntry(i) end
			end
			if #menu.modulesearchtext > 3 then
				row[4]:setColSpan(2):createText(string.format("%+d", #menu.modulesearchtext - 3), { scaling = true })
			end

			local row = ftable:addEmptyRow(editboxheight / 2)
			row.properties.fixed = true

			if next(menu.groupedmodules) then
				local storagecounter_solid, dockareacounter, storagecounter_container, counter_shipyard, counter_wharf, counter_pier, counter_struct = 0, 0, 0, 0, 0, 0, 0
				for _, group in ipairs(menu.groupedmodules) do
					local row = ftable:addRow(true, { borderBelow = false })
					local row2 = ftable:addRow(false, {  })
					for i = 1, 3 do
						if group[i] then
							local name, shortname, makericon, infolibrary, canclaimownership = GetMacroData(group[i], "name", "shortname", "makericon", "infolibrary", "canclaimownership")
							AddKnownItem(infolibrary, group[i])
							local icon = C.IsIconValid("module_" .. group[i]) and ("module_" .. group[i]) or "module_notfound"
							local active = true
							local mouseovertext = name
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1001, 3601) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(tonumber(C.GetEstimatedBuildPrice(menu.buildstorage, group[i])), false, true, 0, true) .. " " .. ReadText(1001, 101)
							row[i]:createButton({ width = columnWidth, height = columnWidth, active = active, highlightColor = Color["button_highlight_bigbutton"], mouseOverText = mouseovertext, helpOverlayID = "stationbuildst_" .. group[i], helpOverlayText = " ", helpOverlayHighlightOnly = true }):setIcon(icon)

							-- Tutorial solar panels (shared)
							if group[i] == "prod_gen_energycells_macro" then
								row[i].properties.helpOverlayID = "stationbuildst_production_energycells"
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial solid storage (any race)
							if	(group[i] == "storage_arg_s_solid_01_macro") or (group[i] == "storage_arg_m_solid_01_macro") or (group[i] == "storage_arg_l_solid_01_macro") or
								(group[i] == "storage_par_s_solid_01_macro") or (group[i] == "storage_par_m_solid_01_macro") or (group[i] == "storage_par_l_solid_01_macro") or
								(group[i] == "storage_spl_s_solid_01_macro") or (group[i] == "storage_spl_m_solid_01_macro") or (group[i] == "storage_spl_l_solid_01_macro") or
								(group[i] == "storage_tel_s_solid_01_macro") or (group[i] == "storage_tel_m_solid_01_macro") or (group[i] == "storage_tel_l_solid_01_macro") or
								(group[i] == "storage_ter_s_solid_01_macro") or (group[i] == "storage_ter_m_solid_01_macro") or (group[i] == "storage_ter_l_solid_01_macro")
							then
								storagecounter_solid = storagecounter_solid + 1
								row[i].properties.helpOverlayID = "stationbuildst_storage_solid" .. storagecounter_solid
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial container storage (any race)
							if	(group[i] == "storage_arg_s_container_01_macro") or (group[i] == "storage_arg_m_container_01_macro") or (group[i] == "storage_arg_l_container_01_macro") or
								(group[i] == "storage_par_s_container_01_macro") or (group[i] == "storage_par_m_container_01_macro") or (group[i] == "storage_par_l_container_01_macro") or
								(group[i] == "storage_spl_s_container_01_macro") or (group[i] == "storage_spl_m_container_01_macro") or (group[i] == "storage_spl_l_container_01_macro") or
								(group[i] == "storage_tel_s_container_01_macro") or (group[i] == "storage_tel_m_container_01_macro") or (group[i] == "storage_tel_l_container_01_macro") or
								(group[i] == "storage_ter_s_container_01_macro") or (group[i] == "storage_ter_m_container_01_macro") or (group[i] == "storage_ter_l_container_01_macro")
							then
								storagecounter_container = storagecounter_container + 1
								row[i].properties.helpOverlayID = "stationbuildst_storage_container" .. storagecounter_container
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial shipyard buildmodules
							if	(group[i] == "buildmodule_gen_ships_l_macro") or (group[i] == "buildmodule_gen_ships_xl_macro") or (group[i] == "buildmodule_ter_ships_l_macro") or (group[i] == "buildmodule_ter_ships_xl_macro")
							then
								counter_shipyard = counter_shipyard + 1
								row[i].properties.helpOverlayID = "stationbuildst_build_shipyard" .. counter_shipyard
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial wharf buildmodules
							if	(group[i] == "buildmodule_gen_ships_m_dockarea_01_macro") or (group[i] == "buildmodule_ter_ships_m_dockarea_01_macro")
							then
								counter_wharf = counter_wharf + 1
								row[i].properties.helpOverlayID = "stationbuildst_build_wharf" .. counter_wharf
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial Dockarea (any race)
							if	(group[i] == "dockarea_arg_m_station_01_hightech_macro") or (group[i] == "dockarea_arg_m_station_01_lowtech_macro") or (group[i] == "dockarea_arg_m_station_01_macro") or
								(group[i] == "dockarea_arg_m_station_02_hightech_macro") or (group[i] == "dockarea_arg_m_station_02_lowtech_macro") or (group[i] == "dockarea_arg_m_station_02_macro") or
								(group[i] == "dockarea_int_m_station_01_macro") or (group[i] == "dockarea_par_m_station_01_macro") or (group[i] == "dockarea_tel_m_station_01_macro") or (group[i] == "dockarea_ter_m_station_01_hightech_macro")
							then
								dockareacounter = dockareacounter + 1
								row[i].properties.helpOverlayID = "stationbuildst_dock_dockarea" .. dockareacounter
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial Pier (any race)
							if	(group[i] == "pier_arg_harbor_01_macro") or (group[i] == "pier_arg_harbor_02_macro") or (group[i] == "pier_arg_harbor_03_macro") or
								(group[i] == "pier_par_harbor_01_macro") or (group[i] == "pier_par_harbor_02_macro") or (group[i] == "pier_par_harbor_03_macro") or
								(group[i] == "pier_spl_harbor_01_macro") or (group[i] == "pier_spl_harbor_02_macro") or (group[i] == "pier_spl_harbor_03_macro") or
								(group[i] == "pier_tel_harbor_01_macro") or (group[i] == "pier_tel_harbor_02_macro") or (group[i] == "pier_tel_harbor_03_macro") or
								(group[i] == "pier_ter_harbor_01_macro") or (group[i] == "pier_ter_harbor_02_macro") or (group[i] == "pier_ter_harbor_03_macro") or (group[i] == "pier_ter_harbor_04_macro")
							then
								counter_pier = counter_pier + 1
								row[i].properties.helpOverlayID = "stationbuildst_dock_pier" .. counter_pier
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							-- Tutorial Connections (any race)
							if	(group[i] == "struct_arg_base_01_macro")		or (group[i] == "struct_arg_base_02_macro")		or (group[i] == "struct_arg_base_03_macro")		or
								(group[i] == "struct_arg_cross_01_macro")		or (group[i] == "struct_arg_vertical_01_macro") or (group[i] == "struct_arg_vertical_02_macro") or
								(group[i] == "struct_par_base_01_macro")		or (group[i] == "struct_par_base_02_macro")		or (group[i] == "struct_par_base_03_macro")		or
								(group[i] == "struct_par_cross_01_macro")		or (group[i] == "struct_par_cross_02_macro")	or (group[i] == "struct_par_cross_03_macro")	or
								(group[i] == "struct_par_vertical_01_macro")	or (group[i] == "struct_spl_base_01_macro")		or (group[i] == "struct_spl_base_02_macro")		or
								(group[i] == "struct_spl_base_03_macro")		or (group[i] == "struct_spl_cross_01_macro")	or (group[i] == "struct_spl_vertical_01_macro") or
								(group[i] == "struct_spl_vertical_02_macro")	or (group[i] == "struct_tel_base_01_macro")		or (group[i] == "struct_tel_base_02_macro")		or
								(group[i] == "struct_tel_base_03_macro")		or (group[i] == "struct_tel_cross_01_macro")	or (group[i] == "struct_tel_vertical_01_macro") or
								(group[i] == "struct_tel_vertical_02_macro")	or (group[i] == "struct_ter_base_01_macro")		or (group[i] == "struct_ter_base_02_macro")		or
								(group[i] == "struct_ter_base_03_macro")		or (group[i] == "struct_ter_cross_01_macro")	or (group[i] == "struct_ter_vertical_01_macro") or
								(group[i] == "struct_ter_vertical_02_macro")
							then
								counter_struct = counter_struct + 1
								row[i].properties.helpOverlayID = "stationbuildst_other_struct" .. counter_struct
								row[i].properties.helpOverlayText = " "
								row[i].properties.helpOverlayHighlightOnly = true
							end

							if menu.modulesMode == "moduletypes_production" then
								local icon = GetMacroData(group[i], "waregroupicon")
								if icon ~= "" then
									row[i]:setIcon2(icon, { color = Color["slider_value"] })
								end
							elseif (menu.modulesMode == "moduletypes_storage") or (menu.modulesMode == "moduletypes_habitation") then
								local icon = "be_upgrade_size_" .. GetMacroData(group[i], "size")
								row[i]:setIcon2(icon, { color = Color["slider_value"] })
							elseif canclaimownership then
								row[i]:setIcon2("be_upgrade_claiming", { color = Color["slider_value"] })
							end
							if #makericon > 0 then
								local makertext = ""
								for i, icon in ipairs(makericon) do
									makertext = makertext .. ((i == 1) and "" or "\n") .. "\27[" .. icon .. "]"
								end
								local fontsize = Helper.scaleFont(Helper.standardFont, Helper.largeIconFontSize)
								local y = columnWidth / 2 - Helper.scaleY(Helper.largeIconTextHeight) / 2 - Helper.configButtonBorderSize
								row[i]:setText(makertext, { y = y, halign = "right", color = Color["slider_value"], fontsize = fontsize })
							end
							local ware = GetMacroData(group[i], "ware")
							local islimited = GetWareData(ware, "islimited")
							if islimited then
								local amount = math.max(0, Helper.getLimitedWareAmount(ware) - (menu.externalUsedLimitedModules[group[i]] or 0) - (menu.usedLimitedModules[group[i]] or 0))
								row[i]:setText2(amount and (ReadText(1001, 42) .. " " .. amount) or "", { x = Helper.scaleX(Helper.configButtonBorderSize), y = - maxColumnWidth / 2 + Helper.standardTextHeight / 2 + Helper.configButtonBorderSize, halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize) })
								active = (not amount) or (amount > 0)
								row[i].properties.active = active
								if not active then
									row[i].properties.mouseOverText = name .. "\n\n" .. ReadText(1026, 7933)
								end
							end
							if menu.modulesMode == "moduletypes_venture" then
								local amount
								local isventureplatform = IsMacroClass(group[i], "ventureplatform")
								if isventureplatform or IsMacroClass(group[i], "dockarea") then
									amount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[group[i]] or 0) - (menu.usedLimitedModules[group[i]] or 0))
								end
								row[i]:setText2(amount and (ReadText(1001, 42) .. " " .. amount) or "", { x = Helper.scaleX(Helper.configButtonBorderSize), y = - maxColumnWidth / 2 + Helper.standardTextHeight / 2 + Helper.configButtonBorderSize, halign = "right", fontsize = Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize) })
								active = ((not amount) or (amount > 0)) and (isventureplatform or hasventureplatform)
								row[i].properties.active = active
								if not active then
									if (not isventureplatform) and (not hasventureplatform) then
										row[i].properties.mouseOverText = name .. "\n\n" .. ReadText(1026, 7931)
									else
										row[i].properties.mouseOverText = name .. "\n\n" .. menu.ventureModuleUnavailableMouseOverText()
									end
								else
									if not isventureplatform then
										row[i].properties.mouseOverText = name .. "\n\n" .. ReadText(1026, 7922)
									end
								end
							end
							row[i].handlers.onClick = function () return menu.buttonAddModule(group[i], row.index, i) end
							if group[i] ~= "" then
								row[i].handlers.onRightClick = function (...) return menu.buttonInteract({ type = "module", name = GetMacroData(group[i], "name"), macro = group[i] }, ...) end
							end
							local extraText = TruncateText(shortname, Helper.standardFont, menu.extraFontSize, columnWidth - 2 * Helper.borderSize)
							row2[i]:createBoxText(extraText, { width = columnWidth, fontsize = menu.extraFontSize, boxColor = active and Color["button_background_default"] or Color["button_background_inactive"], mouseOverText = name })
						end
					end
				end
			end

			ftable:setTopRow(menu.topRows.modules)
			ftable:setSelectedRow(menu.selectedRows.modules)
			ftable:setSelectedCol(menu.selectedCols.modules or 0)
		end
		menu.topRows.modules = nil
		menu.selectedRows.modules = nil
		menu.selectedCols.modules = nil
	else
		if menu.upgradetypeMode then
			local upgradetype = Helper.findUpgradeType(menu.upgradetypeMode)
			local currentSlotInfo = {}

			if menu.upgradetypeMode == "turretgroup" then
				local groupcount = 1
				local sizecounts = {}
				local groupedslots = {}
				for i, upgradegroup in ipairs(menu.groups) do
					local groupname = groupcount
					local slotsize = upgradegroup[upgradetype.grouptype].slotsize
					if slotsize ~= "" then
						if sizecounts[slotsize] then
							sizecounts[slotsize] = sizecounts[slotsize] + 1
						else
							sizecounts[slotsize] = 1
						end
						groupname = upgradetype.shorttext[slotsize] .. sizecounts[slotsize]
					end

					local compatibilities = upgradegroup[upgradetype.grouptype].compatibilities

					if i == menu.currentSlot then
						currentSlotInfo.slotsize = slotsize
						currentSlotInfo.compatibilities = compatibilities
					end

					table.insert(groupedslots, { i, upgradegroup, groupname, slotsize, compatibilities = compatibilities })
					groupcount = groupcount + 1
				end
				table.sort(groupedslots, menu.sortSlots)
				menu.groupedslots = {}
				for i, entry in ipairs(groupedslots) do
					local group = math.ceil(i / 9)
					menu.groupedslots[group] = menu.groupedslots[group] or {}
					table.insert(menu.groupedslots[group], entry)
				end
			end
			
			menu.rowHeight = math.max(23, Helper.scaleY(Helper.standardTextHeight))
			menu.extraFontSize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)
			local maxSlotWidth = math.floor((menu.modulesData.width - 8 * Helper.borderSize) / 9)

			local hasScrollbar = false
			local headerHeight = menu.titleData.height + #menu.groupedslots * (maxSlotWidth + Helper.borderSize) + menu.rowHeight + 2 * Helper.borderSize
			local boxTextHeight = math.ceil(C.GetTextHeight(" \n ", Helper.standardFont, menu.extraFontSize, 0)) + 2 * Helper.borderSize
			--[[ Keep for simpler debugging
				print((Helper.viewHeight - 2 * menu.slotData.offsetY) .. " vs " .. (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)))
				print(headerHeight)
				print(boxTextHeight)
				print(rowcount .. " * " .. 3 * (maxSlotWidth + Helper.borderSize))
				print(slidercount .. " * " .. menu.subHeaderRowHeight + Helper.borderSize) --]]
			if (Helper.viewHeight - 2 * menu.modulesData.offsetY) < (headerHeight + rowcount * (3 * (maxSlotWidth + Helper.borderSize) + boxTextHeight) + slidercount * (menu.subHeaderRowHeight + Helper.borderSize)) then
				hasScrollbar = true
			end

			local slotWidth = maxSlotWidth - math.floor((hasScrollbar and Helper.scrollbarWidth or 0) / 9)
			local extraPixels = (menu.modulesData.width - 8 * Helper.borderSize) % 9
			local slotWidths = { slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth, slotWidth }
			if extraPixels > 0 then
				for i = 1, extraPixels do
					slotWidths[i] = slotWidths[i] + 1
				end
			end
			local columnWidths = {}
			local maxColumnWidth = 0
			for i = 1, 3 do
				columnWidths[i] = slotWidths[(i - 1) * 3 + 1] + slotWidths[(i - 1) * 3 + 2] + slotWidths[(i - 1) * 3 + 3] + 2 * Helper.borderSize
				maxColumnWidth = math.max(maxColumnWidth, columnWidths[i])
			end
			local slidercellWidth = menu.modulesData.width - math.floor(hasScrollbar and Helper.scrollbarWidth or 0)

			local ftable = frame:addTable(10, { tabOrder = 1, width = menu.modulesData.width, height = 0, x = menu.modulesData.offsetX, y = menu.modulesData.offsetY, scaling = false, reserveScrollBar = false, highlightMode = "column", backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			if menu.setdefaulttable then
				ftable.properties.defaultInteractiveObject = true
				menu.setdefaulttable = nil
			end
			for i = 1, 8 do
				ftable:setColWidth(i, slotWidths[i])
			end
			ftable:setColWidth(10, editboxheight)
			ftable:setDefaultColSpan(1, 3)
			ftable:setDefaultColSpan(4, 3)
			ftable:setDefaultColSpan(7, 4)

			local name = menu.getLeftBarLoadoutEntry(menu.upgradetypeMode).name or ""
			local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(10):createText(name, menu.headerTextProperties)

			for _, group in ipairs(menu.groupedslots) do
				local row = ftable:addRow(true, {  })
				for i = 1, 9 do
					if group[i] then
						local colspan = (i == 9) and 2 or 1

						local bgcolor = Color["row_title_background"]
						if group[i][1] == menu.currentSlot then
							bgcolor = Color["row_background_selected"]
						end

						local count, total = 0, 0
						if menu.upgradetypeMode == "turretgroup" then
							for _, upgradetype2 in ipairs(Helper.upgradetypes) do
								if upgradetype2.supertype == "group" then
									if menu.groups[group[i][1]][upgradetype2.grouptype].total > 0 then
										if upgradetype2.mergeslots then
											count = count + ((menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][group[i][1]].count > 0) and 1 or 0)
											total = total + 1
										else
											count = count + menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][group[i][1]].count
											total = total + menu.groups[group[i][1]][upgradetype2.grouptype].total
										end
									end
								end
							end
						end

						local mouseovertext = ""
						if upgradetype then
							mouseovertext = ReadText(1001, 66) .. " " .. group[i][1]
						else
							mouseovertext = ReadText(1001, 8023) .. " " .. group[i][1]
						end

						row[i]:setColSpan(colspan):createButton({ height = slotWidths[i], bgColor = bgcolor, mouseOverText = mouseovertext, width = slotWidths[i] }):setText(group[i][3], { halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
						if total > 0 then
							local width = math.max(1, math.floor(count * (slotWidths[i] - 2 * menu.scaleSize) / total))
							row[i]:setIcon("solid", { width = width + 2 * Helper.configButtonBorderSize, height = menu.scaleSize + 2 * Helper.configButtonBorderSize, x = menu.scaleSize - Helper.configButtonBorderSize, y = slotWidths[i] - 2 * menu.scaleSize - Helper.configButtonBorderSize })
						end
						if group[i].compatibilities then
							local compatibilitytext = ""
							local j = 0
							for _, entry in ipairs(Helper.equipmentCompatibilities) do
								if group[i].compatibilities[entry.tag] then
									compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. "\27[menu_weaponslot]"
									j = j + 1
								end
								if (j > 0) and (j % 4 == 0) then
									compatibilitytext = compatibilitytext .. "\n"
								end
							end
							-- slotwidth is based on Helper.viewWidth but limited, so we need to reflect that here
							local fontsize = math.floor(config.compatibilityFontSize * Helper.viewWidth / 1920)
							local reservedSidePanelWidth = math.floor(0.25 * Helper.viewWidth)
							local actualSidePanelWidth = math.min(reservedSidePanelWidth, Helper.scaleX(config.maxSidePanelWidth))
							fontsize = fontsize * actualSidePanelWidth / reservedSidePanelWidth

							local compatibilityTextHeight = math.ceil(C.GetTextHeight(compatibilitytext, Helper.standardFont, fontsize, 0)) + 2 * Helper.borderSize
							row[i]:setText2(compatibilitytext, { halign = "center", fontsize = fontsize, y = (slotWidths[i] - compatibilityTextHeight) / 2 })
						end
						row[i].handlers.onClick = function () return menu.buttonSelectSlot(group[i][1], row.index, i) end
					end
				end
			end

			if currentSlotInfo.compatibilities then
				local row = ftable:addRow(nil, { fixed = true, scaling = true })
				row[1]:setBackgroundColSpan(10):setColSpan(5):createText(ReadText(1001, 8548) .. ReadText(1001, 120))
				local compatibilitytext = ""
				for _, entry in ipairs(Helper.equipmentCompatibilities) do
					if currentSlotInfo.compatibilities[entry.tag] then
						compatibilitytext = compatibilitytext .. " " .. Helper.convertColorToText(entry.color) .. currentSlotInfo.compatibilities[entry.tag]
					end
				end
				row[6]:setColSpan(5):createText(compatibilitytext, { halign = "right" })
			end

			if next(menu.groupedupgrades) then
				if menu.upgradetypeMode == "turretgroup" then
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype.grouptype].total > 0) then
								local plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][menu.currentSlot]
								local slotsize = menu.groups[menu.currentSlot][upgradetype.grouptype].slotsize

								local name = upgradetype.headertext.default
								if slotsize ~= "" then
									name = upgradetype.headertext[slotsize]
								end

								local row = ftable:addRow(nil, { fixed = true, scaling = true })
								row[1]:setBackgroundColSpan(10):setColSpan(5):createText(name .. ReadText(1001, 120))
								row[6]:setColSpan(5):createText(plandata.count .. " / " .. menu.groups[menu.currentSlot][upgradetype.grouptype].total, { halign = "right" })
							end
						end
					end
				end
			end

			ftable:addEmptyRow(Helper.standardTextHeight / 2)

			local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(9):createEditBox({ defaultText = ReadText(1001, 3250), scaling = true }):setText(menu.searchtext, { x = Helper.standardTextOffsetx }):setHotkey("INPUT_STATE_DETAILMONITOR_0", { displayIcon = true })
			row[1].handlers.onEditBoxDeactivated = menu.editboxSearchUpdateText
			row[10]:createButton({ height = editboxheight }):setText("X", { halign = "center", font = Helper.standardFontBold })
			row[10].handlers.onClick = function () return menu.buttonClearEditbox(row.index) end

			if next(menu.groupedupgrades) then
				if menu.upgradetypeMode == "turretgroup" then
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "group" then
							if menu.groups[menu.currentSlot] and (menu.groups[menu.currentSlot][upgradetype.grouptype].total > 0) then
								local plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type][menu.currentSlot]
								local scale = {
									min       = 0,
									minSelect = (plandata.macro == "") and 0 or 1,
									max       = menu.groups[menu.currentSlot][upgradetype.grouptype].total,
								}
								scale.maxSelect = (plandata.macro == "") and 0 or scale.max
								scale.start = math.max(scale.minSelect, math.min(scale.maxSelect, plandata.count))

								local slotsize = menu.groups[menu.currentSlot][upgradetype.grouptype].slotsize

								local row = ftable:addRow(true, { bgColor = Color["row_background_blue"] })
								local name = upgradetype.text.default
								if plandata.macro == "" then
									if slotsize ~= "" then
										name = upgradetype.text[slotsize]
									end
								else
									name = GetMacroData(plandata.macro, "name")
								end

								local sizeicon
								if slotsize ~= "" then
									sizeicon = "be_upgrade_size_" .. slotsize
								end

								row[1]:setColSpan(10):createSliderCell({ width = slidercellWidth, height = Helper.headerRow1Height, valueColor = Color["slider_value"], min = scale.min, minSelect = scale.minSelect, max = scale.max, maxSelect = scale.maxSelect, start = scale.start }):setText(name, menu.slidercellTextProperties)
								row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectAmount(upgradetype.type, menu.currentSlot, row.index, false, ...) end
								row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
								row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

								for _, group in ipairs(menu.groupedupgrades[upgradetype.grouptype]) do
									local row = ftable:addRow(true, { borderBelow = false })
									local row2 = ftable:addRow(false, {  })
									for i = 1, 3 do
										if group[i] then
											local installicon, installcolor = (group[i].macro ~= "") and (sizeicon or "") or ""
											if (group[i].macro ~= "") then
												if (group[i].macro == menu.groups[menu.currentSlot][upgradetype.grouptype].currentmacro) and (group[i].macro ~= plandata.macro) then
													installicon = "be_upgrade_uninstalled"
													installcolor = Color["text_negative"]
												elseif (group[i].macro == plandata.macro) then
													installicon = "be_upgrade_installed"
													installcolor = Color["text_positive"]
												end
											end

											local weaponicon, compatibility = GetMacroData(group[i].macro, "ammoicon", "compatibility")
											if weaponicon and (weaponicon ~= "") and C.IsIconValid(weaponicon) then
												weaponicon = "\27[" .. weaponicon .. "]"
											else
												weaponicon = ""
											end
											if compatibility then
												local color = Color["text_normal"]
												for _, entry in ipairs(Helper.equipmentCompatibilities) do
													if entry.tag == compatibility then
														color = entry.color
														break
													end
												end
												weaponicon = Helper.convertColorToText(color) .. "\27[menu_weaponmount]\27X" .. weaponicon
											end

											local extraText = ""
											local untruncatedExtraText = ""
											if group[i].macro ~= "" then
												local name, shortname, makerrace, infolibrary = GetMacroData(group[i].macro, "name", "shortname", "makerrace", "infolibrary")
												extraText = TruncateText(shortname, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
												untruncatedExtraText = name
												for i, racestring in ipairs(makerrace) do
													extraText = extraText .. ((i == 1) and "\n" or " - ") .. racestring
													if #makerrace > 1 then
														untruncatedExtraText = untruncatedExtraText .. ((i == 1) and "\n" or " - ") .. racestring
													end
												end
												AddKnownItem(infolibrary, group[i].macro)
											else
												local truncatedtext = TruncateText(group[i].name, Helper.standardFont, menu.extraFontSize, columnWidths[i] - 2 * Helper.borderSize)
												extraText = truncatedtext .. "\n"
												untruncatedExtraText = group[i].name
											end

											-- start: mycu callback
											if menu.uix_callbacks ["displayModules_on_before_create_button_mouseovertext"] then
												for uix_id, uix_callback in pairs (menu.uix_callbacks ["displayModules_on_before_create_button_mouseovertext"]) do
													result = uix_callback (group[i].macro, plandata.macro, untruncatedExtraText)
													if result then
														untruncatedExtraText = result.mouseovertext
													end
												end
											end
											-- end: mycu callback

											local column = i * 3 - 2
											row[column]:createButton({ width = columnWidths[i], height = maxColumnWidth, mouseOverText = untruncatedExtraText, helpOverlayID = "groupedslot_" .. group[i].macro, helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "groupedslot_" .. group[i].macro }):setIcon(group[i].icon):setIcon2(installicon, { color = installcolor }):setText2(weaponicon, { x = 3, y = -maxColumnWidth / 2 + Helper.scaleY(Helper.standardTextHeight) / 2 + Helper.configButtonBorderSize, fontsize = Helper.scaleFont(Helper.standardFont, Helper.standardFontSize) })
											row[column].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype.type, menu.currentSlot, group[i].macro, row.index, column) end
											if group[i].macro ~= "" then
												row[column].handlers.onRightClick = function (...) return menu.buttonInteract({ type = upgradetype.type, name = group[i].name, macro = group[i].macro }, ...) end
											end
											row2[column]:createBoxText(extraText, { width = columnWidths[i], fontsize = menu.extraFontSize, mouseOverText = untruncatedExtraText })
										end
									end
								end
							end
						end
					end
				end
			end

			ftable:setTopRow(menu.topRows.modules)
			ftable:setSelectedRow(menu.selectedRows.modules)
			ftable:setSelectedCol(menu.selectedCols.modules or 0)
		end
		menu.topRows.modules = nil
		menu.selectedRows.modules = nil
		menu.selectedCols.modules = nil
	end
end

function menu.refreshPlan()
	-- do not refresh the plan while we are in loadout edit mode -> no construction map to get data from
	if not menu.loadoutMode then
		menu.neededresources = {}
		local numTotalResources = C.PrepareBuildSequenceResources2(menu.holomap, menu.container, true)
		if numTotalResources > 0 then
			local buf = ffi.new("UIWareInfo[?]", numTotalResources)
			numTotalResources = C.GetBuildSequenceResources(buf, numTotalResources)
			for i = 0, numTotalResources - 1 do
				table.insert(menu.neededresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
			end
		end
		table.sort(menu.neededresources, menu.wareNameSorter)

		menu.buildstorageresources = {}
		local n = C.GetNumCargo(menu.buildstorage, "stationbuilding")
		local buf = ffi.new("UIWareInfo[?]", n)
		n = C.GetCargo(buf, n, menu.buildstorage, "stationbuilding")
		for i = 0, n - 1 do
			table.insert(menu.buildstorageresources, { ware = ffi.string(buf[i].ware), amount = buf[i].amount })
		end

		C.PrepareBuildSequenceResources2(menu.holomap, menu.container, false)
		menu.constructionplan = {}
		menu.removedModules = {}
		if menu.holomap ~= 0 then
			local n = C.GetNumBuildMapConstructionPlan(menu.holomap, false)
			local buf = ffi.new("UIConstructionPlanEntry[?]", n)
			n = tonumber(C.GetBuildMapConstructionPlan(menu.holomap, menu.container, false, buf, n))
			for i = 0, n - 1 do
				local entry = {}
				entry.idx                   = buf[i].idx
				entry.macro                 = ffi.string(buf[i].macroid)
				entry.component             = buf[i].componentid
				entry.offset                = buf[i].offset
				entry.connection            = ffi.string(buf[i].connectionid)
				entry.predecessoridx        = buf[i].predecessoridx
				entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)
				entry.isfixed               = buf[i].isfixed

				local loadout = Helper.getLoadoutHelper(C.GetConstructionMapItemLoadout2, C.GetConstructionMapItemLoadoutCounts2, menu.holomap, entry.idx, menu.container, entry.component)
				entry.upgradeplan           = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)

				entry.resources = {}
				local numModuleResources = C. GetNumModuleNeededResources(menu.holomap, buf[i].idx)
				if numModuleResources > 0 then
					local resourceBuffer = ffi.new("UIWareInfo[?]", numModuleResources)
					numModuleResources = C.GetModuleNeededResources(resourceBuffer, numModuleResources, menu.holomap, buf[i].idx)
					for j = 0, numModuleResources - 1 do
						table.insert(entry.resources, { ware = ffi.string(resourceBuffer[j].ware), amount = resourceBuffer[j].amount })
					end
					table.sort(entry.resources, menu.wareNameSorter)
				end

				table.insert(menu.constructionplan, entry)
			end
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedConstructionPlanModules2(menu.holomap, menu.container, newIndex, false, numChangedIndices, true)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			menu.changedModulesIndices = {}
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedConstructionPlanModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringToLuaID(tostring(buf[i]))
					local loadout = Helper.getLoadoutHelper(C.GetCurrentLoadout, C.GetCurrentLoadoutCounts, menu.container, buf[i])

					local resources = {}
					local numModuleResources = C.GetNumModuleRecycledResources(buf[i])
					if numModuleResources > 0 then
						local resourceBuffer = ffi.new("UIWareInfo[?]", numModuleResources)
						numModuleResources = C.GetModuleRecycledResources(resourceBuffer, numModuleResources, buf[i])
						for j = 0, numModuleResources - 1 do
							table.insert(resources, { ware = ffi.string(resourceBuffer[j].ware), amount = -resourceBuffer[j].amount })
						end
						table.sort(resources, menu.wareNameSorter)
					end

					table.insert(menu.removedModules, { macro = GetComponentData(compID, "macro"), component = buf[i], upgradeplan = Helper.convertLoadout(buf[i], "", loadout, nil), resources = resources })
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end

			-- limited module check
			menu.usedLimitedModules = {}
			for _, entry in ipairs(menu.constructionplan) do
				local isventuremodule = IsMacroClass(entry.macro, "ventureplatform") or (IsMacroClass(entry.macro, "dockarea") and GetMacroData(entry.macro, "isventuremodule"))
				local ware = GetMacroData(entry.macro, "ware")
				local islimited = GetWareData(ware, "islimited")
				if isventuremodule or islimited then
					if menu.usedLimitedModules[entry.macro] then
						menu.usedLimitedModules[entry.macro] = menu.usedLimitedModules[entry.macro] + 1
					else
						menu.usedLimitedModules[entry.macro] = 1
					end
				end

				if menu.selectedModule and (entry.idx == menu.selectedModule.idx) then
					menu.selectedModule = entry
				end
			end

			-- errors & warnings
			menu.criticalmoduleerrors = {}
			menu.moduleerrors = {}
			menu.modulewarnings = {}
			menu.criticalerrors = {}
			menu.errors = {}
			menu.warnings = {}
			menu.haschanges = not C.CompareMapConstructionSequenceWithPlanned(menu.holomap, menu.container, false)

			if not GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned") then
				menu.moduleerrors[2] = ReadText(1001, 7962)
			end

			if (menu.newModulesIndex > 0) and (menu.newModulesIndex <= #menu.constructionplan) then
				local immediateresources = {}
				for i, resource in ipairs(menu.constructionplan[menu.newModulesIndex].resources) do
					immediateresources[i] = { ware = resource.ware, amount = resource.amount }
				end
				for i = #immediateresources, 1, -1 do
					local entry = immediateresources[i]
					local idx = menu.findWareIdx(menu.buildstorageresources, entry.ware)
					if idx then
						entry.amount = entry.amount - menu.buildstorageresources[idx].amount
						if entry.amount <= 0 then
							table.remove(immediateresources, i)
						end
					end
				end
				if #immediateresources > 0 then
					for i = #immediateresources, 1, -1 do
						local entry = immediateresources[i]
						for _, removedModule in ipairs(menu.removedModules) do
							local idx = menu.findWareIdx(removedModule.resources, entry.ware)
							if idx then
								entry.amount = entry.amount + removedModule.resources[idx].amount
								if entry.amount <= 0 then
									table.remove(immediateresources, i)
									break
								end
							end
						end
					end
					if #immediateresources > 0 then
						menu.warnings[1] = ReadText(1001, 7913)
					end
				end
			end

			menu.constructionvessels = {}
			Helper.ffiVLA(menu.constructionvessels, "UniverseID", C.GetNumAssignedConstructionVessels, C.GetAssignedConstructionVessels, menu.buildstorage)
			if #menu.constructionvessels == 0 then
				if C.DoesConstructionSequenceRequireBuilder(menu.container) then
					menu.errors[1] = ReadText(1001, 7914)
				end
			end

			local haspier, hasdock, ismissingventureplatform, ismissingventuredocks, haswaveprotection, hasillegalproductions = false, false, false, false, false, false
			
			local sector, sectorid = GetComponentData(menu.container, "sector", "sectorid")
			local policefaction, containsthewave = GetComponentData(sectorid, "policefaction", "containsthewave")
			for idx, entry in ipairs(menu.constructionplan) do
				local data = GetLibraryEntry(GetMacroData(entry.macro, "infolibrary"), entry.macro)
				if IsMacroClass(entry.macro, "pier") then
					haspier = true
				elseif IsMacroClass(entry.macro, "dockarea") then
					hasdock = true
					if GetMacroData(entry.macro, "isventuremodule") then
						ismissingventureplatform = ismissingventureplatform or (C.GetConstructionMapVenturePlatform(menu.holomap, idx) == 0)
					end
				elseif IsMacroClass(entry.macro, "ventureplatform") then
					ismissingventuredocks = ismissingventuredocks or (C.GetNumConstructionMapVenturePlatformDocks(menu.holomap, idx) == 0)
				elseif IsMacroClass(entry.macro, "buildmodule") then
					if (data.docks_m > 0) or (data.docks_s > 0) then
						hasdock = true
					end
				elseif IsMacroClass(entry.macro, "production") then
					if policefaction then
						hasillegalproductions = C.HasProductionModuleIllegalProducts(entry.macro, "player", policefaction)
					end
				end
				haswaveprotection = haswaveprotection or GetMacroData(entry.macro, "haswaveprotection")
			end

			local mapresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, menu.holomap, nil, false))
			local plannedresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, nil, true))

			local missingmapblueprints = {}
			for macro in string.gmatch(mapresult, "([%w_]*);") do
				missingmapblueprints[macro] = (missingmapblueprints[macro] or 0) + 1
			end
			local missingplannedblueprints = {}
			for macro in string.gmatch(plannedresult, "([%w_]*);") do
				missingplannedblueprints[macro] = (missingplannedblueprints[macro] or 0) + 1
			end

			local missingblueprintmodulemismatch = ""
			for k, v in pairs(missingmapblueprints) do
				if v < (missingplannedblueprints[k] or 0) then
					missingblueprintmodulemismatch = missingblueprintmodulemismatch .. "\n· " .. GetMacroData(k, "name")
				end
			end

			if (not haspier) and (not hasdock) then
				menu.moduleerrors[1] = ReadText(1001, 7958)
			elseif not hasdock then
				menu.modulewarnings[2] = ReadText(1001, 7916)
			elseif not haspier then
				menu.modulewarnings[3] = ReadText(1001, 7917)
			end
			if ismissingventureplatform then
				menu.modulewarnings[4] = ReadText(1001, 7960)
			end
			if ismissingventuredocks then
				menu.modulewarnings[5] = ReadText(1001, 7959)
			end
			if not haswaveprotection then
				if containsthewave then
					menu.modulewarnings[6] = ReadText(1001, 11917)
				end
			end
			if missingblueprintmodulemismatch ~= "" then
				menu.modulewarnings[7] = ReadText(1001, 11921) .. missingblueprintmodulemismatch
			end
			if hasillegalproductions then
				menu.modulewarnings[8] = ReadText(1001, 11926) .. ReadText(1001, 120) .. " " .. sector
			end
		end
	end
end

function menu.etaSorter(a, b)
	if (a.eta < 0) then
		return false
	elseif (b.eta < 0) then
		return true
	end
	return a.eta < b.eta
end

function menu.moduleSorter(a, b)
	local aname = GetMacroData(a.macro, "name")
	local bname = GetMacroData(b.macro, "name")
	return aname < bname
end

function menu.moduleHeightHelper(ftable, prevfullheight)
	if prevfullheight < ftable.properties.maxVisibleHeight then
		local fullheight = ftable:getFullHeight()
		if fullheight > ftable.properties.maxVisibleHeight then
			ftable.properties.maxVisibleHeight = prevfullheight
		end
		return fullheight
	end
	return prevfullheight
end

function menu.displayPlan(frame)
	if not menu.loadoutMode then
		local ftable, modulestatustable, resourcetable
		local statusBars = {}
		if menu.planMode == "construction" then
			-- MODULE CHANGES
			ftable = frame:addTable(5, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = 0.4 * Helper.viewHeight, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			ftable:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
			ftable:setColWidth(2, Helper.scaleY(Helper.standardTextHeight), false)
			ftable:setColWidth(4, 0.25 * menu.planData.width, false)
			ftable:setColWidth(5, Helper.scaleY(Helper.standardTextHeight), false)

			local prevfullheight = 0
			-- modules
			local row = ftable:addRow(false, { bgColor = Color["row_title_background"], fixed = true, bgColor = Color["row_background_blue"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7924), menu.headerTextProperties)
			-- unchanged modules
			local sortedModules = {}
			local changedCount = 0
			local habitationadded = 0
			local workforceneedadded = 0
			for i = 1, #menu.constructionplan do
				local infolibrary = GetMacroData(menu.constructionplan[i].macro, "infolibrary")
				if not menu.changedModulesIndices[i] then
					if sortedModules[infolibrary] then
						table.insert(sortedModules[infolibrary], menu.constructionplan[i])
					else
						sortedModules[infolibrary] = { menu.constructionplan[i] }
					end
				else
					changedCount = changedCount + 1
					if infolibrary == "moduletypes_habitation" then
						habitationadded = habitationadded + GetMacroData(menu.constructionplan[i].macro, "workforcecapacity")
					elseif infolibrary == "moduletypes_production" then
						workforceneedadded = workforceneedadded + GetMacroData(menu.constructionplan[i].macro, "maxworkforce")
					end
				end
			end
			for _, entry in ipairs(config.leftBar) do
				if sortedModules[entry.mode] then
					local isextended = menu.isEntryExtended(menu.container, entry.mode)

					local row = ftable:addRow(true, { bgColor = Color["row_title_background"] })
					row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
					row[1].handlers.onClick = function () return menu.buttonExtendEntry(entry.mode, row.index) end
					row[2]:setColSpan(2):setBackgroundColSpan(4):createText(entry.name, Helper.subHeaderTextProperties)
					row[4]:setColSpan(2):createText(#sortedModules[entry.mode], Helper.subHeaderTextProperties)
					row[4].properties.halign = "right"
					prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)

					if isextended then
						table.sort(sortedModules[entry.mode], menu.moduleSorter)
						for i = 1, #sortedModules[entry.mode] do
							local row = menu.displayModuleRow(ftable, i .. "entry.mode", sortedModules[entry.mode][i], false, false)
							prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
						end

						if entry.mode == "moduletypes_habitation" then
							local workforceinfo = C.GetWorkForceInfo(menu.container, "");

							ftable:addEmptyRow()
							local row = ftable:addRow(true, {  })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 9611))
							row[4]:createText(ConvertIntegerString(workforceinfo.capacity, true, 0, true, false) .. ((habitationadded > 0) and (" (" .. ConvertIntegerString(workforceinfo.capacity + habitationadded, true, 0, true, false) .. ")") or ""), { halign = "right" })
							local row = ftable:addRow(true, {  })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 8412))
							row[4]:createText(ConvertIntegerString(workforceinfo.current, true, 0, true, false), { halign = "right" })
							local row = ftable:addRow(true, {  })
							row[2]:setColSpan(2):createText("   " .. ReadText(1001, 8413))
							row[4]:createText(ConvertIntegerString(workforceinfo.optimal, true, 0, true, false) .. ((workforceneedadded > 0) and (" (" .. ConvertIntegerString(workforceinfo.optimal + workforceneedadded, true, 0, true, false) .. ")") or ""), { halign = "right" })
						end
					end
				end
			end
			-- removed modules
			if #menu.removedModules > 0 then
				local isextended = menu.isEntryExtended(menu.container, "removed")

				local row = ftable:addRow(true, { bgColor = Color["row_title_background"] })
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendEntry("removed", row.index) end
				row[2]:setColSpan(2):setBackgroundColSpan(4):createText(ReadText(1001, 7964), Helper.subHeaderTextProperties)
				row[2].properties.color = Color["text_negative"]
				row[4]:setColSpan(2):createText(#menu.removedModules, Helper.subHeaderTextProperties)
				row[4].properties.halign = "right"
				prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
				if isextended then
					for i, entry in ipairs(menu.removedModules) do
						menu.displayModuleRow(ftable, i, entry, false, true)
						prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
					end
				end
			end
			-- changed or new modules
			if changedCount > 0 then
				local isextended = menu.isEntryExtended(menu.container, "planned")

				local row = ftable:addRow(true, { bgColor = Color["row_title_background"] })
				row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendEntry("planned", row.index) end
				row[2]:setColSpan(2):setBackgroundColSpan(4):createText(ReadText(1001, 7963), Helper.subHeaderTextProperties)
				row[2].properties.color = Color["text_positive"]
				row[4]:setColSpan(2):createText(changedCount, Helper.subHeaderTextProperties)
				row[4].properties.halign = "right"
				prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
				if isextended then
					for i = 1, #menu.constructionplan do
						if menu.changedModulesIndices[i] then
							local row = menu.displayModuleRow(ftable, i, menu.constructionplan[i], true, false)
							if (not menu.selectedRows.plan) then
								menu.selectedRows.plan = row.index
							end
							prevfullheight = menu.moduleHeightHelper(ftable, prevfullheight)
						end
					end
				end
			end
			menu.totalprice = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "wantedmoney")

			if menu.selectedRows.plan == "last" then
				menu.selectedRows.plan = ftable.rows[#ftable.rows].index
			end
			if menu.selectedRows.plan == "first" then
				menu.selectedRows.plan = 2
			else
				local numdisplayedlines = math.floor((ftable:getVisibleHeight() - menu.titleData.height) / (Helper.scaleY(Helper.subHeaderHeight) + Helper.borderSize))
				if menu.topRows.plan and menu.selectedRows.plan then
					if menu.topRows.plan + numdisplayedlines - 1 < menu.selectedRows.plan then
						menu.topRows.plan = menu.selectedRows.plan - numdisplayedlines + 3
					elseif menu.selectedRows.plan < menu.topRows.plan then
						menu.topRows.plan = menu.selectedRows.plan
					end
				elseif menu.selectedRows.plan then
					menu.topRows.plan = menu.selectedRows.plan - numdisplayedlines + 3
				end
			end
			ftable:setTopRow(menu.topRows.plan)
			ftable:setSelectedRow(menu.selectedRows.plan)
			menu.topRows.plan = nil
			menu.selectedRows.plan = nil

			-- MODULE LOADOUTS & STATUS
			local yoffset = ftable.properties.y + ftable:getVisibleHeight() + 2 * Helper.borderSize
			modulestatustable = frame:addTable(6, { tabOrder = 4, width = menu.planData.width, x = menu.planData.offsetX, y = yoffset, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			local smallColWidth = Helper.scaleY(Helper.standardTextHeight)
			modulestatustable:setColWidth(1, smallColWidth, false)
			modulestatustable:setColWidth(2, smallColWidth, false)
			modulestatustable:setColWidth(3, 0.5 * menu.planData.width - 2 * smallColWidth, false)
			modulestatustable:setColWidth(5, 0.3 * menu.planData.width, false)
			modulestatustable:setColWidth(6, smallColWidth, false)

			-- station-wide loadout
			local row = modulestatustable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(6):createText(ReadText(1001, 7966), menu.headerTextProperties)
			-- selection
			local row = modulestatustable:addRow(true, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 7967) .. ReadText(1001, 120))
			local loadoutOptions = {
				{ id = 0,	text = ReadText(1001, 7990), icon = "", displayremoveoption = false },
				{ id = 0.1,	text = ReadText(1001, 7910), icon = "", displayremoveoption = false },
				{ id = 0.5,	text = ReadText(1001, 7911), icon = "", displayremoveoption = false },
				{ id = 1.0,	text = ReadText(1001, 7912), icon = "", displayremoveoption = false },
				{ id = -1,	text = ReadText(1001, 7968), icon = "", displayremoveoption = false },
			}
			row[5]:setColSpan(2):createDropDown(loadoutOptions, { startOption = function () return tostring(menu.defaultLoadout) end }):setTextProperties({ halign = "center" })
			row[5].handlers.onDropDownConfirmed = menu.dropdownDefaultLoadout

			-- preferred build method
			local row = modulestatustable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(6):createText(ReadText(1001, 11298), menu.headerTextProperties)

			local cursetting = ffi.string(C.GetContainerBuildMethod(menu.buildstorage))
			local curglobalsetting = ffi.string(C.GetPlayerBuildMethod())
			local foundcursetting = false
			local locresponses = {}
			local n = C.GetNumPlayerBuildMethods()
			if n > 0 then
				local buf = ffi.new("ProductionMethodInfo[?]", n)
				n = C.GetPlayerBuildMethods(buf, n)
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					-- check if the curglobalsetting (which can be the method of the player's race) is in the list of options
					if id == curglobalsetting then
						foundcursetting = true
					end
					table.insert(locresponses, { id = id, text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
				end
			end
			-- if the setting is not in the list, default to default (if the race method is not in the list, there is no ware that has this method and it will always use default)
			if not foundcursetting then
				curglobalsetting = "default"
			end
			local hasownsetting = cursetting ~= ""

			local rowdata = "info_buildrule_global"
			local row = modulestatustable:addRow({ rowdata }, {  })
			row[1]:setColSpan(5):createText(ReadText(1001, 8367))
			row[6]:createCheckBox(not hasownsetting, { width = config.mapRowHeight, height = config.mapRowHeight })
			row[6].handlers.onClick = function(_, checked) return menu.checkboxSetBuildRuleOverride(menu.buildstorage, checked, curglobalsetting) end

			local row = modulestatustable:addRow("info_buildrule", {  })
			row[1]:setColSpan(6):createDropDown(locresponses, { height = Helper.standardTextHeight, startOption = hasownsetting and cursetting or curglobalsetting, active = hasownsetting }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownBuildRule(menu.buildstorage, id) end
			row[1].handlers.onDropDownActivated = function () menu.noupdate = true end

			-- module status here
			local row = modulestatustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(6):createText(ReadText(1001, 7991), menu.headerTextProperties)

			local infoCount = 0
			local visibleHeight
			for _, errorentry in Helper.orderedPairs(menu.criticalmoduleerrors) do
				row = modulestatustable:addRow(true, {  })
				row[1]:setColSpan(6):createText(errorentry, { color = Color["text_criticalerror"], wordwrap = true })
			end
			for _, errorentry in Helper.orderedPairs(menu.moduleerrors) do
				row = modulestatustable:addRow(true, {  })
				row[1]:setColSpan(6):createText(errorentry, { color = Color["text_error"], wordwrap = true })
			end
			for _, warningentry in Helper.orderedPairs(menu.modulewarnings) do
				row = modulestatustable:addRow(true, {  })
				row[1]:setColSpan(6):createText(warningentry, { color = Color["text_warning"], wordwrap = true })
			end
			if (not next(menu.criticalmoduleerrors)) and (not next(menu.moduleerrors)) and (not next(menu.modulewarnings)) then
				row = modulestatustable:addRow(true, {  })
				row[1]:setColSpan(6):createText(ReadText(1001, 7923), { color = Color["text_success"] })
			end

			-- BUTTONS
			if menu.cancelRequested then
				local row = modulestatustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
				row[1]:setColSpan(6):createText(ReadText(1001, 9705), menu.headerTextProperties)

				local row = modulestatustable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
				row[1]:setColSpan(3):createButton({  }):setText(ReadText(1001, 2617), { halign = "center" })
				row[1].handlers.onClick = menu.buttonCancelConfirm
				row[4]:setColSpan(3):createButton({  }):setText(ReadText(1001, 2618), { halign = "center" })
				row[4].handlers.onClick = menu.buttonCancelCancel
			else
				local row = modulestatustable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
				if (ffi.string(C.GetGameStartName()) == "x4ep1_gamestart_workshop") and (not menu.confirmModuleChangesActive()) and ((C.GetCurrentBuildProgress(menu.container) >= 0) or C.IsBuildWaitingForSecondaryComponentResources(menu.container)) then
					row[1]:setColSpan(3):createButton({ helpOverlayID = "force_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = true }):setText(ReadText(1001, 11919), { halign = "center" })
					row[1].handlers.onClick = menu.buttonForceBuild
				else
					row[1]:setColSpan(3):createButton({ helpOverlayID = "confirm_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = menu.confirmModuleChangesActive }):setText(ReadText(1001, 7919), { halign = "center" })
					row[1].handlers.onClick = menu.buttonConfirm
					row[1].properties.uiTriggerID = "confirmmodulechanges"
				end
				row[4]:setColSpan(3):createButton({ helpOverlayID = "cancel_modulechanges", helpOverlayText = " ",  helpOverlayHighlightOnly = true, active = menu.haschanges }):setText(ReadText(1001, 7918), { halign = "center" })
				row[4].handlers.onClick = menu.buttonCancel
				row[4].properties.uiTriggerID = "cancelmodulechanges"
			end

			-- BUILD RESOURCES
			local yoffset = modulestatustable.properties.y + modulestatustable:getVisibleHeight() + 2 * Helper.borderSize
			resourcetable = frame:addTable(6, { tabOrder = 5, width = menu.planData.width, x = menu.planData.offsetX, y = yoffset, reserveScrollBar = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			resourcetable:setColWidth(1, smallColWidth, false)
			resourcetable:setColWidth(2, smallColWidth, false)
			resourcetable:setColWidth(3, 0.5 * menu.planData.width - 2 * smallColWidth, false)
			resourcetable:setColWidth(5, 0.3 * menu.planData.width, false)
			resourcetable:setColWidth(6, smallColWidth, false)

			menu.tradewares = {}
			local n = C.GetNumWares("stationbuilding", false, "", "")
			local buf = ffi.new("const char*[?]", n)
			n = C.GetWares(buf, n, "stationbuilding", false, "", "")
			for i = 0, n - 1 do
				table.insert(menu.tradewares, { ware = ffi.string(buf[i]) })
			end

			-- resources
			local row = resourcetable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(6):createText(ReadText(1001, 7925), menu.headerTextProperties)
			-- have
			local row = resourcetable:addRow(true, { bgColor = Color["row_title_background"] })
			if not menu.selectedRows.planresources then
				menu.selectedRows.planresources = row.index
			end
			local isextended = menu.isResourceEntryExtended("buildstorage")
			row[1]:createButton({ helpOverlayID = "plot_resources_available", helpOverlayText = " ",  helpOverlayHighlightOnly = true, uiTriggerID = "extendavailableresourcesentry" }):setText(isextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("buildstorage", row.index) end
			row[2]:setColSpan(5):createText(ReadText(1001, 7927) .. (menu.newWareReservation and " " .. ColorText["text_positive"] .. "[+" .. menu.newWareReservation .. "]" or ""), Helper.subHeaderTextProperties)

			if isextended then
				-- reservations
				local reservations = {}
				local n = C.GetNumContainerWareReservations2(menu.buildstorage, false, false, true)
				local buf = ffi.new("WareReservationInfo2[?]", n)
				n = C.GetContainerWareReservations2(buf, n, menu.buildstorage, false, false, true)
				for i = 0, n - 1 do
					local ware = ffi.string(buf[i].ware)
					local tradedeal = buf[i].tradedealid
					if not menu.dirtyreservations[tostring(tradedeal)] then
						if reservations[ware] then
							table.insert(reservations[ware], { reserver = buf[i].reserverid, amount = buf[i].isbuyreservation and -buf[i].amount or buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal })
						else
							reservations[ware] = { { reserver = buf[i].reserverid, amount = buf[i].isbuyreservation and -buf[i].amount or buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal } }
						end
					end
				end
				for _, data in pairs(reservations) do
					table.sort(data, menu.etaSorter)
				end

				local resources = {}
				for _, resource in ipairs(menu.neededresources) do
					if resource.amount > 0 then
						local current = 0
						local idx = menu.findWareIdx(menu.buildstorageresources, resource.ware)
						if idx then
							current =  menu.buildstorageresources[idx].amount
						end

						local reserved = 0
						if reservations[resource.ware] then
							for _, reservation in ipairs(reservations[resource.ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = resource.ware, name = GetWareData(resource.ware, "name"), needed = resource.amount, current = current, reserved = reserved })
					end
				end
				for _, resource in ipairs(menu.buildstorageresources) do
					local idx = menu.findWareIdx(resources, resource.ware)
					if not idx then
						local needed = 0
						local idx = menu.findWareIdx(menu.neededresources, resource.ware)
						if idx then
							needed =  menu.neededresources[idx].amount
						end

						local reserved = 0
						if reservations[resource.ware] then
							for _, reservation in ipairs(reservations[resource.ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = resource.ware, name = GetWareData(resource.ware, "name"), needed = needed, current = resource.amount, reserved = reserved })
					end
				end
				for ware, reservationentry in pairs(reservations) do
					local idx = menu.findWareIdx(resources, ware)
					if not idx then
						local current = 0
						local idx = menu.findWareIdx(menu.buildstorageresources, ware)
						if idx then
							current =  menu.buildstorageresources[idx].amount
						end

						local needed = 0
						local idx = menu.findWareIdx(menu.neededresources, ware)
						if idx then
							needed =  menu.neededresources[idx].amount
						end

						local reserved = 0
						if reservationentry then
							for _, reservation in ipairs(reservations[ware]) do
								reserved = reserved + reservation.amount
							end
						end

						table.insert(resources, { ware = ware, name = GetWareData(ware, "name"), needed = needed, current = current, reserved = reserved })
					end
				end
				table.sort(resources, Helper.sortName)

				for i, resource in ipairs(resources) do
					local row = resourcetable:addRow(true, {  })
					local xoffset = row[1]:getWidth() + row[2]:getWidth() + row[3]:getWidth() + 3 * Helper.borderSize
					statusBars[i] = row[1]:createStatusBar({ current = resource.current + resource.reserved, start = resource.current, max = resource.needed, cellBGColor = Color["row_background"], valueColor = Color["slider_value"], posChangeColor = Color["statusbar_diff_pos"], width = menu.planData.width - xoffset, x = xoffset, scaling = false })
					row[2]:setColSpan(2):createText(GetWareData(resource.ware, "name"))
					row[4]:setColSpan(3):createText(((resource.current < resource.needed) and ColorText["text_negative"] or "") .. ConvertIntegerString(resource.current, true, 0, true) .. "\27X" .. ((resource.reserved > 0) and (" (" .. ColorText["text_positive"] .. "+" .. ConvertIntegerString(resource.reserved, true, 0, true) .. "\27X)") or "") .. " / " .. ConvertIntegerString(resource.needed, true, 0, true), { halign = "right", cellBGColor = Color["row_background_unselectable"] })
				end

				menu.newWareReservation = nil
				if next(reservations) then
					local row = resourcetable:addRow(true, {  })
					row[1]:setColSpan(6):createText(ReadText(1001, 7946), Helper.subHeaderTextProperties)
					row[1].properties.halign = "center"
					for _, ware in ipairs(menu.tradewares) do
						if reservations[ware.ware] then
							local isextended = menu.isResourceEntryExtended("reservation" .. ware.ware, true)
							local titlerow = resourcetable:addRow(true, {  })
							titlerow[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
							titlerow[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("reservation" .. ware.ware, titlerow.index) end
							local color = Color["text_normal"]
							if menu.newWareReservationWares[ware.ware] then
								color = Color["text_positive"]
							end
							titlerow[2]:setColSpan(3):createText(GetWareData(ware.ware, "name"), { color = color })
							local total = 0
							for _, reservation in ipairs(reservations[ware.ware]) do
								total = total + reservation.amount
								if isextended then
									local row = resourcetable:addRow(true, {  })
									local reserverid = ConvertStringTo64Bit(tostring(reservation.reserver))
									local name = ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")"
									local colorprefix = GetComponentData(reserverid, "isplayerowned") and ColorText["text_player"] or ""

									-- kuertee start: callback
									-- row[2]:setColSpan(3):createText(function () return Helper.getETAString(colorprefix .. name, reservation.eta) end, { font = Helper.standardFontMono })
									if menu.uix_callbacks ["displayPlan_render_incoming_ware"] then
										for uix_id, uix_callback in pairs (menu.uix_callbacks ["displayPlan_render_incoming_ware"]) do
											isbreak = uix_callback (row, colorprefix, name, reservation)
											if isbreak then
												break
											end
										end
									else
										row[2]:setColSpan(3):createText(function () return Helper.getETAString(colorprefix .. name, reservation.eta) end, { font = Helper.standardFontMono })
									end
									-- kuertee end: callback

									local color = Color["text_normal"]
									if menu.newWareReservationWares[ware.ware] and menu.newWareReservationWares[ware.ware][tostring(reserverid)] then
										color = Color["text_positive"]
									end
									row[5]:createText(ConvertIntegerString(reservation.amount, true, 0, false), { halign = "right", color = color })
									row[6]:createButton({ active = function () return menu.buttonCancelTradeActive(reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
									row[6].handlers.onClick = function () return menu.buttonCancelTrade(reservation.tradedeal) end
								end
							end
							titlerow[5]:setColSpan(2):createText(ConvertIntegerString(total, true, 0, false), { halign = "right" })
						end
					end
				end
				resourcetable:addEmptyRow(Helper.standardTextHeight / 2)
				menu.newWareReservationWares = {}
			end

			-- config
			local row = resourcetable:addRow(true, { bgColor = Color["row_title_background"] })
			local isextended = menu.isResourceEntryExtended("resourceconfig")
			row[1]:createButton({ helpOverlayID = "plot_resources_buyoffers", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(isextended and "-" or "+", { halign = "center" })
			row[1].handlers.onClick = function () return menu.buttonExtendResourceEntry("resourceconfig", row.index) end
			row[1].properties.uiTriggerID = "extendresourceentry"
			row[2]:setColSpan(5):createText(ReadText(1001, 7928), Helper.subHeaderTextProperties)
			if isextended then
				local row = resourcetable:addRow(false, {  })
				row[2]:setColSpan(5):createText(ReadText(1001, 7944), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"

				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(menu.buildstorage, "buy", "") or C.HasContainerOwnTradeRule(menu.buildstorage, "sell", "")
				local traderuleid = C.GetContainerTradeRuleID(menu.buildstorage, "buy", "")
				if traderuleid ~= C.GetContainerTradeRuleID(menu.buildstorage, "sell", "") then
					DebugError("Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(menu.buildstorage, "sell", "")))
				end
				local row = resourcetable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1].properties.cellBGColor = Color["row_background"]
				row[2]:setColSpan(5):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = resourcetable:addRow("order_wares_global", {  })
				row[2]:setColSpan(4):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
				row[6]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
				row[6].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.buildstorage, "trade", checked) end
				-- current
				local row = resourcetable:addRow("order_wares_current", {  })
				row[2]:setColSpan(4):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[2].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.buildstorage, "trade", id, "", true) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				row[6]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[6].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(menu.buildstorage, "buy", "")) end

				resourcetable:addEmptyRow()

				-- global price modifier
				local row = resourcetable:addRow(true, {  })
				menu.globalpricefactor = C.GetContainerGlobalPriceFactor(menu.buildstorage)
				local hasvalidmodifier = menu.globalpricefactor >= 0
				row[2]:createCheckBox(hasvalidmodifier, { })
				row[2].handlers.onClick = menu.checkboxToggleGlobalWarePriceModifier
				row[3]:setColSpan(4):createText(ReadText(1001, 7945))
				local row = resourcetable:addRow(true, {  })
				local currentfactor = menu.globalpricefactor * 100
				row[2]:setColSpan(5):createSliderCell({ height = Helper.standardTextHeight, valueColor = hasvalidmodifier and Color["slider_value"] or Color["slider_value_inactive"], min = 0, max = 100, start = hasvalidmodifier and currentfactor or 100, suffix = "%", readOnly = not hasvalidmodifier, hideMaxValue = true }):setText(ReadText(1001, 2808))
				row[2].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellGlobalWarePriceFactor(row.index, ...) end
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				-- trade restrictions
				local row = resourcetable:addRow(false, {  })
				row[2]:setColSpan(5):createText(ReadText(1001, 7931), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"

				for i, ware in ipairs(menu.tradewares) do
					local isextended = menu.isResourceEntryExtended("resourceconfig" .. ware.ware)
					local row = resourcetable:addRow(true, {  })
					row[2]:createButton({ helpOverlayID = "plot_resources_resourceconfig" .. ware.ware, helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(isextended and "-" or "+", { halign = "center" })
					row[2].handlers.onClick = function () return menu.buttonExtendResourceEntry("resourceconfig" .. ware.ware, row.index) end
					row[2].properties.uiTriggerID = "extendresourceentry" .. ware.ware
					
					-- kuertee start: callback
					-- row[3]:setColSpan(2):createText(GetWareData(ware.ware, "name"))
					if menu.uix_callbacks ["displayPlan_getWareName"] then
						local name
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["displayPlan_getWareName"]) do
							name = uix_callback (ware.ware, name)
						end
						if name then
							row[3]:setColSpan(2):createText(name)
						else
							row[3]:setColSpan(2):createText(GetWareData(ware.ware, "name"))
						end
					else
						row[3]:setColSpan(2):createText(GetWareData(ware.ware, "name"))
					end
					-- kuertee end: callback

					if C.GetContainerTradeRuleID(menu.buildstorage, "buy", ware.ware) > 0 then
						row[5]:setColSpan(2):createText("\27[lso_error]", { halign = "right", color = Color["text_warning"], mouseOverText = ReadText(1026, 8404) })
					end

					ware.minprice, ware.maxprice = GetWareData(ware.ware, "minprice", "maxprice")
					if isextended then
						-- trade rule
						local hasownlist = C.HasContainerOwnTradeRule(menu.buildstorage, "buy", ware.ware) or C.HasContainerOwnTradeRule(menu.buildstorage, "sell", ware.ware)
						local traderuleid = C.GetContainerTradeRuleID(menu.buildstorage, "buy", ware.ware)
						if traderuleid ~= C.GetContainerTradeRuleID(menu.buildstorage, "sell", ware.ware) then
							DebugError("Mismatch between buy and sell trade rule on supply ship: " .. tostring(traderuleid) .. " vs " .. tostring(C.GetContainerTradeRuleID(menu.buildstorage, "sell", ware.ware)))
						end
						local row = resourcetable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
						row[1].properties.cellBGColor = Color["row_background"]
						row[2].properties.cellBGColor = Color["row_background"]
						row[3]:setColSpan(4):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
						-- global
						local row = resourcetable:addRow("order_wares_global", {  })
						row[3]:setColSpan(3):createText(ReadText(1001, 11033) .. ReadText(1001, 120), textproperties)
						row[6]:createCheckBox(not hasownlist, { height = config.mapRowHeight })
						row[6].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.buildstorage, "trade", checked, ware.ware) end
						-- current
						local row = resourcetable:addRow("order_wares_current", {  })
						row[3]:setColSpan(3):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
						row[3].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.buildstorage, "trade", id, ware.ware, true) end
						row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
						row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
						row[6]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
						row[6].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(menu.buildstorage, "buy", ware.ware)) end

						resourcetable:addEmptyRow(Helper.standardTextHeight / 2)

						local row = resourcetable:addRow(true, {  })
						ware.row = row.index
						local currentprice = math.max(ware.minprice, math.min(ware.maxprice, GetContainerWarePrice(menu.buildstorage, ware.ware, true, true)))
						row[3]:setColSpan(4):createSliderCell({ height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = ware.minprice, max = ware.maxprice, start = currentprice, suffix = ReadText(1001, 101), readOnly = restricted, hideMaxValue = true }):setText(ReadText(1001, 2808))
						row[3].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellWarePriceOverride(ware.ware, row.index, ...) end
						row[3].handlers.onSliderCellActivated = function() menu.noupdate = true end
						row[3].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

						if i ~= #menu.tradewares then
							resourcetable:addEmptyRow()
						end
					end
				end
				-- price
				local row = resourcetable:addRow(false, {  })
				row[2]:setColSpan(5):createText(ReadText(1001, 7929), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"
				local row = resourcetable:addRow(true, {  })
				row[2]:setColSpan(5):createText(ConvertMoneyString(menu.totalprice, false, true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
				-- account
				local row = resourcetable:addRow(false, {  })
				row[2]:setColSpan(5):createText(ReadText(1001, 7930), Helper.subHeaderTextProperties)
				row[2].properties.halign = "center"
				row[2].properties.helpOverlayID = "construction_available_funds"
				row[2].properties.helpOverlayText = " "
				row[2].properties.helpOverlayHighlightOnly = true
				local row = resourcetable:addRow(true, {  })
				local buildstoragemoney = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "money")
				local playermoney = GetPlayerMoney()
				local min = 0
				local max = buildstoragemoney + playermoney
				local start = math.max(min, math.min(max, menu.newAccountValue or buildstoragemoney))
				row[2]:setColSpan(5):createSliderCell({ height = Helper.standardTextHeight, valueColor = Color["slider_value"], min = min, max = max, start = start, suffix = ReadText(1001, 101), hideMaxValue = true })
				row[2].handlers.onSliderCellChanged = menu.slidercellMoney
				row[2].handlers.onSliderCellActivated = function() menu.noupdate = true end
				row[2].handlers.onSliderCellDeactivated = function() menu.noupdate = false end
				local row = resourcetable:addRow(true, {  })
				row[2]:setColSpan(3):createButton({ helpOverlayID = "confirm_credits", helpOverlayText = " ", helpOverlayHighlightOnly = true, active = function () return (menu.newAccountValue ~= nil) and (menu.newAccountValue ~= buildstoragemoney) and GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned") end }):setText(ReadText(1001, 2821), { halign = "center" })
				row[2].handlers.onClick = menu.buttonConfirmMoney
				row[2].properties.uiTriggerID = "confirmcredits"
				row[5]:setColSpan(2):createButton({ active = function () local money, isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "money", "isplayerowned"); return ((money + GetPlayerMoney()) > menu.totalprice) and isplayerowned end, helpOverlayID = "acceptestimate", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "acceptestimate" }):setText(ReadText(1001, 7965), { halign = "center" })
				row[5].handlers.onClick = menu.buttonSetMoneyToEstimate
			end

			-- CVs
			local row = resourcetable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(6):createText(ReadText(1001, 7932), menu.headerTextProperties)
			row[1].properties.halign = "center"
			row[1].properties.helpOverlayID = "construction_builders_header"
			row[1].properties.helpOverlayText = " "
			row[1].properties.helpOverlayHighlightOnly = true

			if #menu.constructionvessels > 0 then
				for _, component in ipairs(menu.constructionvessels) do
					row = resourcetable:addRow(true, {  })
					row[1]:setColSpan(6):createText(ffi.string(C.GetComponentName(component)) .. " (" .. ffi.string(C.GetObjectIDCode(component)) .. ")")
				end
			else
				row = resourcetable:addRow(true, {  })
				row[1]:setColSpan(6):createText(ReadText(1001, 7933))
			end
			row = resourcetable:addRow(true, {  })
			if #menu.constructionvessels == 0 then
				local active = C.DoesConstructionSequenceRequireBuilder(menu.container)
				row[1]:setColSpan(6):createButton({ active = active, helpOverlayID = "assign_hire_builder", helpOverlayText = " ",  helpOverlayHighlightOnly = true, mouseOverText = active and "" or ReadText(1026, 7923) }):setText(ReadText(1001, 7934), { halign = "center" })
				row[1].handlers.onClick = menu.buttonAssignConstructionVessel
				row[1].properties.uiTriggerID = "assignhirebuilder"
			else
				local deployorderidx
				local numorders = C.GetNumOrders(menu.constructionvessels[1])
				local currentorders = ffi.new("Order[?]", numorders)
				numorders = C.GetOrders(currentorders, numorders, menu.constructionvessels[1])
				for i = 1, numorders do
					if ffi.string(currentorders[i - 1].orderdef) == "DeployToStation" then
						deployorderidx = i
						break
					end
				end

				row[1]:setColSpan(5):createButton({ active = (deployorderidx ~= nil) and C.RemoveOrder2(menu.constructionvessels[1], deployorderidx, true, true, true) }):setText(ReadText(1001, 7961), { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonFireConstructionVessel(menu.constructionvessels[1], deployorderidx) end
				row[1].properties.uiTriggerID = "firebuilder"
			end

			resourcetable:setTopRow(menu.topRows.planresources)
			resourcetable:setSelectedRow(menu.selectedRows.planresources)
			menu.topRows.planresources = nil
			menu.selectedRows.planresources = nil
		end

		-- STATUS
		local statustable = frame:addTable(2, { tabOrder = 6, width = menu.planData.width, x = menu.planData.offsetX, y = 0, reserveScrollBar = false, highlightMode = "off", skipTabChange = true, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		statustable:setDefaultColSpan(1, 2)

		local row = statustable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
		row[1]:createText(ReadText(1001, 7922), menu.headerTextProperties)

		for _, errorentry in Helper.orderedPairs(menu.criticalerrors) do
			row = statustable:addRow(true, {  })
			row[1]:createText(errorentry, { color = Color["text_criticalerror"], wordwrap = true })
		end
		for _, errorentry in Helper.orderedPairs(menu.errors) do
			row = statustable:addRow(true, {  })
			row[1]:createText(errorentry, { color = Color["text_error"], wordwrap = true })
		end
		for _, warningentry in Helper.orderedPairs(menu.warnings) do
			row = statustable:addRow(true, {  })
			row[1]:createText(warningentry, { color = Color["text_warning"], wordwrap = true })
		end
		if (not next(menu.criticalerrors)) and (not next(menu.errors)) and (not next(menu.warnings)) then
			row = statustable:addRow(true, {  })
			row[1]:createText(ReadText(1001, 7923), { color = Color["text_success"] })
		end

		local row = statustable:addRow(true, {  })
		row[1]:setColSpan(1)
		row[2]:createButton({ helpOverlayID = "menu_close", helpOverlayText = " ",  helpOverlayHighlightOnly = true }):setText(ReadText(1001, 8035), { halign = "center" })
		row[2].handlers.onClick = function () menu.modulesMode = nil; return menu.onCloseElement("back") end

		statustable.properties.y = Helper.viewHeight - statustable:getFullHeight() - Helper.frameBorder
		if menu.planMode == "construction" then
			resourcetable.properties.maxVisibleHeight = statustable.properties.y - resourcetable.properties.y - 2 * Helper.borderSize
			if resourcetable.properties.maxVisibleHeight < resourcetable:getFullHeight() then
				for _, statusbar in ipairs(statusBars) do
					statusbar.properties.width = statusbar.properties.width - Helper.scrollbarWidth
				end
			end

			ftable:addConnection(1, 4, true)
			modulestatustable:addConnection(2, 4)
			resourcetable:addConnection(3, 4)
			statustable:addConnection(4, 4)
		else
			statustable:addConnection(1, 4, true)
		end

		-- guarantee 20% of height for resourcetable
		if menu.planMode == "construction" then
			local maxmoduletableheight = statustable.properties.y - ftable.properties.y - modulestatustable:getFullHeight() - 2 * Helper.borderSize - 0.2 * Helper.viewHeight
			if maxmoduletableheight < ftable.properties.maxVisibleHeight then
				ftable.properties.maxVisibleHeight = maxmoduletableheight
				modulestatustable.properties.y = ftable.properties.y + ftable:getVisibleHeight() + 2 * Helper.borderSize
				resourcetable.properties.y = modulestatustable.properties.y + modulestatustable:getVisibleHeight() + 2 * Helper.borderSize
				resourcetable.properties.maxVisibleHeight = statustable.properties.y - resourcetable.properties.y - 2 * Helper.borderSize
				if resourcetable.properties.maxVisibleHeight < resourcetable:getFullHeight() then
					for _, statusbar in ipairs(statusBars) do
						statusbar.properties.width = statusbar.properties.width - Helper.scrollbarWidth
					end
				end
			end
		end
	else
		-- BUTTONS
		local buttontable = frame:addTable(2, { tabOrder = 7, width = menu.planData.width, height = Helper.scaleY(Helper.standardButtonHeight), x = menu.planData.offsetX, y = Helper.viewHeight - Helper.scaleY(Helper.standardButtonHeight) - Helper.frameBorder, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
		if menu.cancelRequested then
			local row = buttontable:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:setColSpan(2):createText(ReadText(1001, 9705), menu.headerTextProperties)

			local row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:createButton({  }):setText(ReadText(1001, 2617), { halign = "center" })
			row[1].handlers.onClick = menu.buttonCancelLoadout
			row[2]:createButton({  }):setText(ReadText(1001, 2618), { halign = "center" })
			row[2].handlers.onClick = menu.buttonCancelCancel
		else
			local row = buttontable:addRow(true, { fixed = true, bgColor = Color["row_title_background"] })
			row[1]:createButton({ helpOverlayID = "stationconfig_confirmloadout", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "confirmloadout" }):setText(ReadText(1001, 7921), { halign = "center" })
			row[1].handlers.onClick = menu.buttonConfirmLoadout
			row[2]:createButton({  }):setText(ReadText(1001, 7920), { halign = "center" })
			row[2].handlers.onClick = menu.buttonCancel
		end
		buttontable.properties.y = Helper.viewHeight - buttontable:getFullHeight() - Helper.frameBorder

		if menu.loadoutPlanMode == "normal" then
			-- EQUIPMENT
			local ftable = frame:addTable(5, { tabOrder = 3, width = menu.planData.width, maxVisibleHeight = buttontable.properties.y - menu.planData.offsetY, x = menu.planData.offsetX, y = menu.planData.offsetY, reserveScrollBar = true, skipTabChange = true, highlightMode = "off", backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })
			ftable:setColWidth(1, Helper.standardTextHeight)
			ftable:setColWidth(2, Helper.standardTextHeight)
			ftable:setColWidth(4, 0.3 * menu.planData.width)
			ftable:setColWidth(5, Helper.standardTextHeight)

			local row = ftable:addRow(false, { bgColor = Color["row_title_background"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7935), menu.headerTextProperties)

			local removedEquipment = {}
			local currentEquipment = {}
			local newEquipment = {}
			for i, upgradetype in ipairs(Helper.upgradetypes) do
				local slots = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype.type]
				local first = true
				for slot, macro in pairs(slots) do
					if first or (not upgradetype.mergeslots) then
						first = false
						if upgradetype.supertype == "group" then
							local data = macro
							local oldslotdata = menu.groups[slot][upgradetype.grouptype]

							if data.macro ~= "" then
								local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
								if not i then
									break
								end
								local upgradeware = menu.upgradewares[upgradetype.grouptype][i]

								if oldslotdata.currentmacro ~= "" then
									local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
									if not j then
										break
									end
									local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

									if data.macro == oldslotdata.currentmacro then
										if upgradetype.mergeslots then
											menu.insertWare(currentEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
										else
											if oldslotdata.count < data.count then
												menu.insertWare(currentEquipment, upgradeware.ware, oldslotdata.count)
												menu.insertWare(newEquipment, upgradeware.ware, data.count - oldslotdata.count)
											elseif oldslotdata.count > data.count then
												menu.insertWare(currentEquipment, upgradeware.ware, data.count)
												menu.insertWare(removedEquipment, upgradeware.ware, oldslotdata.count - data.count)
											else
												menu.insertWare(currentEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
											end
										end
									else
										menu.insertWare(removedEquipment, oldupgradeware.ware, (upgradetype.mergeslots and #slots or oldslotdata.count))
										menu.insertWare(newEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
									end
								else
									menu.insertWare(newEquipment, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
								end
							elseif oldslotdata.currentmacro ~= "" then
								local j = menu.findUpgradeMacro(upgradetype.grouptype, oldslotdata.currentmacro)
								if not j then
									break
								end
								local oldupgradeware = menu.upgradewares[upgradetype.grouptype][j]

								menu.insertWare(removedEquipment, oldupgradeware.ware, (upgradetype.mergeslots and #slots or oldslotdata.count))
							end
						end
					end
				end
			end

			if (#removedEquipment > 0) or (#newEquipment > 0) then
				menu.haschanges = true
			else
				menu.haschanges = false
			end

			if (#removedEquipment > 0) or (#currentEquipment > 0) or (#newEquipment > 0) then
				for _, entry in ipairs(removedEquipment) do
					row = ftable:addRow(true, {  })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { color = Color["text_negative"] })
				end
				for _, entry in ipairs(currentEquipment) do
					row = ftable:addRow(true, {  })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"))
				end
				for _, entry in ipairs(newEquipment) do
					row = ftable:addRow(true, {  })
					row[1]:setColSpan(5):createText(entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name"), { color = Color["text_positive"] })
				end
			else
				row = ftable:addRow(true, {  })
				row[1]:setColSpan(5):createText("--- " .. ReadText(1001, 7936) .. " ---", { halign = "center" } )
			end

			ftable:addConnection(1, 4, true)
			buttontable:addConnection(2, 4)
		else
			buttontable:addConnection(1, 4, true)
		end
	end
end

function  menu.dropdownBuildRule(container, id)
	C.SetContainerBuildMethod(container, id)
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.checkboxSetBuildRuleOverride(container, checked, curglobal)
	if checked then
		C.SetContainerBuildMethod(container, "")
	else
		C.SetContainerBuildMethod(container, curglobal or "default")
	end
	menu.refreshPlan()
	menu.displayMenu()
end

function menu.confirmModuleChangesActive()
	local mapresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, menu.holomap, nil, false))
	local plannedresult = ffi.string(C.GetMissingConstructionPlanBlueprints3(menu.container, 0, nil, true))

	local missingmapblueprints = {}
	for macro in string.gmatch(mapresult, "([%w_]*);") do
		missingmapblueprints[macro] = (missingmapblueprints[macro] or 0) + 1
	end
	local missingplannedblueprints = {}
	for macro in string.gmatch(plannedresult, "([%w_]*);") do
		missingplannedblueprints[macro] = (missingplannedblueprints[macro] or 0) + 1
	end

	local mismatch = false
	for k, v in pairs(missingmapblueprints) do
		if v > (missingplannedblueprints[k] or 0) then
			mismatch = true
			break
		end
	end

	return (not mismatch) and (#menu.criticalerrors == 0) and menu.haschanges and GetComponentData(ConvertStringTo64Bit(tostring(menu.buildstorage)), "isplayerowned")
end

function menu.displayModuleInfo(frame)
	local ftable = frame:addTable(2, { tabOrder = 0, width = menu.statsData.width, x = menu.statsData.offsetX, y = 0, reserveScrollBar = false, backgroundID = "solid", backgroundColor = Color["table_background_3d_editor"] })

	local name, infolibrary = GetMacroData(menu.selectedModule.macro, "name", "infolibrary")

	local row = ftable:addRow(false, {  })
	row[1]:setColSpan(2):createText(name, menu.headerCenteredTextProperties)

	local data = GetLibraryEntry(infolibrary, menu.selectedModule.macro)

	ftable:addEmptyRow(Helper.standardTextHeight / 4)

	if (menu.selectedModule.component == 0) or IsComponentConstruction(ConvertStringToLuaID(tostring(menu.selectedModule.component))) then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 3601), { font = Helper.standardFontBold })
		row[2]:createText(ConvertMoneyString(tonumber(C.GetEstimatedBuildPrice(menu.buildstorage, menu.selectedModule.macro)), false, true, 0, true) .. " " .. ReadText(1001, 101), { font = Helper.standardFontBold })

		ftable:addEmptyRow(Helper.standardTextHeight / 4)
	end

	if ((infolibrary == "moduletypes_production") and data.allowproduction) or (infolibrary == "moduletypes_processing") then
		local queueduration = 0
		for i, proddata in ipairs(data.products) do
			queueduration = queueduration + proddata.cycle
		end
		-- products
		for i, proddata in ipairs(data.products) do
			local row = ftable:addRow(false, {  })
			local categoryname = ReadText(1001, 1624)
			if #data.products > 1 then
				categoryname = categoryname .. " " .. ReadText(20402, i)
			end
			row[1]:createText(categoryname)
			local amount = (queueduration > 0) and Helper.round(proddata.amount * 3600 / queueduration) or 0
			row[2]:createText(amount .. ReadText(1001, 42) .. " " .. GetWareData(proddata.ware, "name") .. " / " .. ReadText(1001, 102))
			-- resources
			local resources = proddata.resources
			if #resources > 0 then
				for j, resource in ipairs(resources) do
					local row = ftable:addRow(false, {  })
					if j == 1 then
						row[1]:createText("   " .. ReadText(1001, 7403))
					end
					local amount = (queueduration > 0) and Helper.round(resource.amount * 3600 / queueduration) or 0
					row[2]:createText(amount .. ReadText(1001, 42) .. " " .. GetWareData(resource.ware, "name") .. " / " .. ReadText(1001, 102))
				end
			else
				local row = ftable:addRow(false, {  })
				row[1]:createText("   " .. ReadText(1001, 7403))
				row[2]:createText("---")
			end
			ftable:addEmptyRow(Helper.standardTextHeight / 4)
		end

		if infolibrary == "moduletypes_production" then
			-- workforce
			local row = ftable:addRow(false, {  })
			row[1]:createText(ReadText(1001, 7992))
			row[2]:createText(ConvertIntegerString(data.maxworkforce, true, 0, true))
		end
	elseif infolibrary == "moduletypes_storage" then
		if data.storagecapacity > 0 then
			local row = ftable:addRow(false, {  })
			row[1]:createText(ReadText(1001, 9063))
			row[2]:createText(ConvertIntegerString(data.storagecapacity, true, 0, true) .. " " .. ReadText(1001, 110))
		end
	elseif infolibrary == "moduletypes_habitation" then
		if data.workforcecapacity > 0 then
			local row = ftable:addRow(false, {  })
			row[1]:createText(ReadText(1001, 9611))
			row[2]:createText(ConvertIntegerString(data.workforcecapacity, true, 0, true))
		end
		if #data.workforceresources > 0 then
			for i, resource in ipairs(data.workforceresources) do
				local row = ftable:addRow(false, {  })
				if i == 1 then
					row[1]:createText(string.format(ReadText(1001, 7957), ConvertIntegerString(data.workforcecapacity, true, 0, true, false)))
				end
				local amount = Helper.round(resource.amount * 3600 / resource.cycle * data.workforcecapacity / data.workforceproductamount)
				row[2]:createText(amount .. ReadText(1001, 42) .. " " .. resource.name .. " / " .. ReadText(1001, 102))
			end
		end
	end
	-- docks
	if (data.docks_xl > 0) or (data.docks_l > 0) or (data.docks_m > 0) or (data.docks_s > 0) then
		local first = true
		if data.docks_xl > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_xl .. ReadText(1001, 42) .. " " .. ReadText(1001, 7950))
		end
		if data.docks_l > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_l .. ReadText(1001, 42) .. " " .. ReadText(1001, 7951))
		end
		if data.docks_m > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_m .. ReadText(1001, 42) .. " " .. ReadText(1001, 7952))
		end
		if data.docks_s > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7949))
			end
			row[2]:createText(data.docks_s .. ReadText(1001, 42) .. " " .. ReadText(1001, 7953))
		end
	end
	-- launchtubes
	if (data.launchtubes_m > 0) or (data.launchtubes_s > 0) then
		local first = true
		if data.launchtubes_m > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7954))
			end
			row[2]:createText(data.launchtubes_m .. ReadText(1001, 42) .. " " .. ReadText(1001, 7955))
		end
		if data.launchtubes_s > 0 then
			local row = ftable:addRow(false, {  })
			if first then
				first = false
				row[1]:createText(ReadText(1001, 7954))
			end
			row[2]:createText(data.launchtubes_s .. ReadText(1001, 42) .. " " .. ReadText(1001, 7956))
		end
	end
	-- ship storage
	if data.shipstoragecapacity > 0 then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 9612))
		row[2]:createText(data.shipstoragecapacity)
	end

	local counts = {}
	for _, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "group" then
			counts[upgradetype.type] = 0
			if menu.selectedModule.upgradeplan then
				for slot, group in pairs(menu.selectedModule.upgradeplan[upgradetype.type]) do
					if upgradetype.mergeslots then
						counts[upgradetype.type] = counts[upgradetype.type] + ((menu.selectedModule.upgradeplan[upgradetype.type][slot].count > 0) and 1 or 0)
					else
						counts[upgradetype.type] = counts[upgradetype.type] + menu.selectedModule.upgradeplan[upgradetype.type][slot].count
					end
				end
			end
		end
	end

	-- turrets
	local numturrets = C.GetNumUpgradeSlots(menu.selectedModule.component, menu.selectedModule.macro, "turret")
	if numturrets > 0 then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 1319))

		row[2]:createText(counts.turretgroup .. " / " .. tonumber(numturrets))
	end

	-- shields
	local numshields = C.GetNumUpgradeSlots(menu.selectedModule.component, menu.selectedModule.macro, "shield")
	if numshields > 0 then
		local row = ftable:addRow(false, {  })
		row[1]:createText(ReadText(1001, 1317))

		row[2]:createText(counts.shieldgroup .. " / " .. tonumber(numshields))
	end

	ftable.properties.y = Helper.viewHeight - ftable:getVisibleHeight() - menu.statsData.offsetY
end

function menu.displayModuleRow(ftable, index, entry, added, removed)
	local isextended = menu.isEntryExtended(menu.container, (removed and "rem" or "") .. index)

	local color = Color["text_normal"]
	if removed then
		color = Color["text_negative"]
	elseif added then
		color = Color["text_positive"]
	end

	local row = ftable:addRow({ ismodule = true, idx = entry.idx, module = entry, removed = removed }, {  })
	if removed or added then
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(isextended and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonExtendEntry((removed and "rem" or "") .. index, row.index) end
	end
	local name = GetMacroData(entry.macro, "name")
	if entry.component ~= 0 then
		name = ffi.string(C.GetComponentName(entry.component))
	end
	row[2]:setColSpan(2):createText("   " .. name, { color = color, mouseOverText = menu.getLoadoutSummary(entry.upgradeplan) })
	local ismissingresources = false
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
		local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
		ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
	end
	row[4]:createText(function () return menu.getBuildProgress(entry.component, added, removed) end, { halign = "right", color = color, mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
	local active = false
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
				active = true
				break
			end
		end
	end
	if active and (not removed) then
		row[5]:createButton({ height = Helper.standardTextHeight }):setIcon("menu_edit")
		row[5].handlers.onClick = function () return menu.buttonEditLoadout(entry) end
	end
	if (not removed) and (not added) and (not active) then
		row[1]:setBackgroundColSpan(5)
	elseif (not removed) and (not added) then
		row[1]:setBackgroundColSpan(4)
	elseif (not active) or removed then
		row[2]:setBackgroundColSpan(4)
	else
		row[2]:setBackgroundColSpan(3)
	end

	local ware = GetMacroData(entry.macro, "ware")
	if not ware then
		DebugError("No ware defined for module macro '" .. entry.macro .. "'. [Florian]")
	else
		if removed or added then
			if isextended then
				for _, resource in ipairs(entry.resources) do
					local row = ftable:addRow(true, {  })
					row[2]:setColSpan(2):createText("      " .. GetWareData(resource.ware, "name"))
					row[4]:setColSpan(2):createText(resource.amount, { halign = "right" })
				end
			end
		end
	end

	return row
end

function menu.findWareIdx(array, ware)
	for i, v in ipairs(array) do
		if v.ware == ware then
			return i
		end
	end
end

function menu.insertWare(array, ware, count)
	local i = menu.findWareIdx(array, ware)
	if i then
		array[i].amount = array[i].amount + count
	else
		table.insert(array, { ware = ware, amount = count })
	end
end

function menu.getLoadoutSummary(upgradeplan)
	local wareAmounts = {}

	for i, upgradetype in ipairs(Helper.upgradetypes) do
		local slots = upgradeplan[upgradetype.type]
		local first = true
		for slot, macro in pairs(slots) do
			if first or (not upgradetype.mergeslots) then
				first = false
				if upgradetype.supertype == "group" then
					local data = macro
					if data.macro ~= "" then
						local i = menu.findUpgradeMacro(upgradetype.grouptype, data.macro)
						if not i then
							break
						end
						local upgradeware = menu.upgradewares[upgradetype.grouptype][i]
						menu.insertWare(wareAmounts, upgradeware.ware, (upgradetype.mergeslots and #slots or data.count))
					end
				end
			end
		end
	end

	local summary = (#wareAmounts > 0) and (ReadText(1001, 7935) .. ReadText(1001, 120)) or ""
	for _, entry in ipairs(wareAmounts) do
		summary = summary .. "\n" .. entry.amount .. ReadText(1001, 42) .. " " .. GetWareData(entry.ware, "name")
	end
	return summary
end

function menu.getBuildProgress(component, added, removed)
	local buildprogress = (removed or (not added)) and 100 or 0
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(menu.container))
		if removed then
			buildprogress = 100 - buildprogress
			menu.refresh = menu.refresh or (getElapsedTime() + 10.0)
		end

		local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
		local ismissingresources, buildcomponents, recyclingcomponents = GetComponentData(buildingprocessor, "ismissingresources", "buildcomponents", "recyclingcomponents")
		local found = false
		for _, buildcomponent in ipairs(removed and recyclingcomponents or buildcomponents) do
			if ConvertIDTo64Bit(buildcomponent) == component then
				found = true
				break
			end
		end
		if found then
			buildprogress = (ismissingresources and (ColorText["text_warning"] .. "\27[warning](") or "(") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(ConvertIDTo64Bit(buildingprocessor)), "%h:%M:%S") .. ")\27X  " .. buildprogress
		else
			buildprogress = "-"
		end
	elseif added then
		if C.IsComponentOperational(component) then
			buildprogress = 100
		else
			buildprogress = "-"
		end
	end

	return buildprogress .. " %"
end

function menu.wareNameSorter(a, b)
	local aname = GetWareData(a.ware, "name")
	local bname = GetWareData(b.ware, "name")

	return aname < bname
end

function menu.displayMainFrame()
	Helper.removeAllWidgetScripts(menu, config.mainLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		layer = config.mainLayer,
		standardButtons = { back = true, close = true, help = true  },
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	-- right sidebar
	Helper.createRightSideBar(menu.mainFrame, menu.container, true, "construction", menu.buttonRightBar, menu.buttonRightBarSelf)

	-- title bar
	menu.createTitleBar(menu.mainFrame)

	-- construction map
	menu.mainFrame:addRenderTarget({width = menu.mapData.width, height = menu.mapData.height, x = menu.mapData.offsetX, y = menu.mapData.offsetY, scaling = false, alpha = 100})

	menu.mainFrame:display()
end

function menu.displayContextFrame(mode, width, x, y)
	PlaySound("ui_positive_click")
	menu.contextMode = { mode = mode, width = width, x = x, y = y }
	if mode == "saveCP" then
		menu.createCPSaveContext()
	elseif mode == "removeCP" then
		menu.createCPRemoveContext()
	elseif mode == "importCP" then
		menu.createCPImportContext()
	elseif mode == "exportCP" then
		menu.createCPExportContext()
	elseif mode == "saveLoadout" then
		menu.createLoadoutSaveContext()
	elseif mode == "equipment" then
		menu.createEquipmentContext()
	elseif mode == "module" then
		menu.createModuleContext()
	elseif mode == "userquestion" then
		menu.createUserQuestionContext()
	elseif mode == "overwritequestion" then
		menu.createOverwriteQuestionContext()
	elseif mode == "settings" then
		menu.createSettingsContext()
	elseif mode == "modulefilter" then
		menu.createModuleFilterContext()
	elseif mode == "slot" then
		menu.createSlotContext()
	end
end

function menu.createSlotContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local upgradetype = Helper.findUpgradeType(menu.contextData.upgradetype)
	local upgradetype2 = Helper.findUpgradeTypeByGroupType(upgradetype.type)
	local slotdata
	if menu.upgradetypeMode == "turretgroup" then
		slotdata = menu.groups[menu.currentSlot][upgradetype2.grouptype]
	end
	local plandata
	if menu.upgradetypeMode == "turretgroup" then
		plandata = menu.constructionplan[menu.loadoutMode].upgradeplan[upgradetype2.type][menu.currentSlot]
	end
	local prefix = ""
	if upgradetype.mergeslots then
		prefix = #menu.slots[upgradetype.type] .. ReadText(1001, 42) .. " "
	end

	if menu.upgradetypeMode == "turretgroup" then
		local name = upgradetype2.text.default
		if plandata.macro == "" then
			if slotdata.slotsize ~= "" then
				name = upgradetype2.text[slotdata.slotsize]
			end
		else
			name = GetMacroData(plandata.macro, "name")
		end
		if not upgradetype2.mergeslots then
			local minselect = (plandata.macro == "") and 0 or 1
			local maxselect = (plandata.macro == "") and 0 or slotdata.total

			local scale = {
				min       = 0,
				minselect = minselect,
				max       = slotdata.total,
				maxselect = maxselect,
				start     = math.max(minselect, math.min(maxselect, plandata.count)),
				step      = 1,
				suffix    = "",
				exceedmax = false
			}

			local row = ftable:addRow(true)
			row[1]:createSliderCell({ height = Helper.headerRow1Height, valueColor = Color["slider_value"], min = scale.min, minSelect = scale.minselect, max = scale.max, maxSelect = scale.maxselect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedmax }):setText(name, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize })
			row[1].handlers.onSliderCellChanged = function (_, ...) return menu.slidercellSelectAmount(upgradetype2.type, menu.currentSlot, nil, row.index, ...) end
		else
			local row = ftable:addRow(nil)
			row[1]:createText(name)
		end
	end

	for k, macro in ipairs(slotdata.possiblemacros) do
		local name = prefix .. GetMacroData(macro, "name")

		local color = Color["text_normal"]
		if (macro == slotdata.currentmacro) and (macro ~= plandata.macro) then
			color = Color["text_negative"]
		elseif (macro == plandata.macro) then
			color = Color["text_positive"]
		end

		local row = ftable:addRow(true)
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(name, { color = color })
		if menu.upgradetypeMode == "turretgroup" then
			row[1].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, macro, nil, nil, row.index) end
		end
	end

	if upgradetype.allowempty then
		local name = ReadText(1001, 7906)

		local color = Color["text_normal"]
		if ("" == slotdata.currentmacro) and ("" ~= plandata) then
			color = Color["text_negative"]
		elseif ("" == plandata) then
			color = Color["text_positive"]
		end

		local row = ftable:addRow(true)
		row[1]:createButton({ height = Helper.standardTextHeight, helpOverlayID = "turretgroup_empty", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(name, { color = color })
		if menu.upgradetypeMode == "turretgroup" then
			row[1].handlers.onClick = function () return menu.buttonSelectGroupUpgrade(upgradetype2.type, menu.currentSlot, "", nil, nil, row.index) end
		end
	end

	ftable:setTopRow(menu.topRows.context)
	ftable:setSelectedRow(menu.selectedRows.context)
	menu.topRows.context = nil
	menu.selectedRows.context = nil

	menu.contextFrame:display()
end

function menu.createUserQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText(ReadText(1001, 8035), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText(ReadText(1001, 9705))

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true })
	row[2]:createButton():setText(ReadText(1001, 2617), { halign = "center" })
	row[2].handlers.onClick = menu.resetAndCloseMenu
	row[4]:createButton():setText(ReadText(1001, 2618), { halign = "center" })
	row[4].handlers.onClick = menu.closeContextMenu
	ftable:setSelectedCol(4)

	menu.contextFrame:display()
end

function menu.resetAndCloseMenu()
	menu.resetDefaultLoadout()
	if menu.contextData.dueToClose then
		menu.closeMenu(menu.contextData.dueToClose)
	elseif menu.contextData.othermenu then
		Helper.closeMenuAndOpenNewMenu(menu, menu.contextData.othermenu, nil, true, true)
		menu.cleanup()
	end
end

function menu.createOverwriteQuestionContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(5, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText((menu.contextData.mode == "export") and ReadText(1001, 7977) or ReadText(1001, 7985), Helper.headerRowCenteredProperties)

	if menu.contextData.mode == "export" then
		local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
		if canoverwrite then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7978), menu.currentCPName), { wordwrap = true })
		end
		local filename = utf8.gsub(menu.currentCPName, "[^%w_%-%() ]", "_")
		if menu.importableplansbyfile[filename] then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7984), filename), { wordwrap = true })
		end
	else
		local id = menu.contextData.selectedEntry.id
		if menu.constructionplansbyID[id] then
			local row = ftable:addRow(false, { fixed = true })
			row[1]:setColSpan(5):createText(string.format(ReadText(1001, 7978), menu.constructionplansbyID[id].name), { wordwrap = true })
		end
	end

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText("")

	local row = ftable:addRow(true, { fixed = true })
	row[2]:createButton():setText(ReadText(1001, 14), { halign = "center" })
	row[2].handlers.onClick = (menu.contextData.mode == "export") and function () menu.buttonExport(true) end or function () menu.buttonImport(true) end
	row[4]:createButton():setText(ReadText(1001, 64), { halign = "center" })
	row[4].handlers.onClick = function () return menu.displayContextFrame((menu.contextData.mode == "export") and "exportCP" or "importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize) end
	ftable:setSelectedCol(4)

	menu.contextFrame:display()
end

function menu.createModuleContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(GetMacroData(ffi.string(menu.contextData.item.macro), "name"), Helper.subHeaderTextProperties)

	local active = false
	for i, upgradetype in ipairs(Helper.upgradetypes) do
		if upgradetype.supertype == "macro" then
			if C.GetNumUpgradeSlots(menu.contextData.item.component, menu.contextData.item.macro, upgradetype.type) > 0 then
				active = true
				break
			end
		end
	end
	if active then
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ active = true, bgColor = Color["button_background_hidden"], helpOverlayID = "stationconfig_editloadout", helpOverlayText = " ",  helpOverlayHighlightOnly = true, uiTriggerID = "editloadout" }):setText(ReadText(1001, 7938))
		row[1].handlers.onClick = function () return menu.buttonEditLoadout(menu.contextData.item) end
	end

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 2400))
	row[1].handlers.onClick = function () return menu.buttonContextEncyclopedia({ type = "module", macro = menu.contextData.item.macro }) end

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Color["button_background_hidden"], helpOverlayID = "stationconfig_resetrotation", helpOverlayText = " ", helpOverlayHighlightOnly = true, uiTriggerID = "resetrotation" }):setText(ReadText(1001, 7999))
	row[1].handlers.onClick = function () return menu.buttonResetModuleRotation(menu.contextData.item) end

	local row = ftable:addRow(true, { fixed = true })
	local macro = menu.contextData.item.macro
	local active = not menu.contextData.item.isfixed
	local mouseovertext = ""
	if active then
		local ware = GetMacroData(macro, "ware")
		local islimited = GetWareData(ware, "islimited")
		if IsMacroClass(macro, "ventureplatform") or (IsMacroClass(macro, "dockarea") and GetMacroData(macro, "isventuremodule")) then
			local availableamount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			if availableamount < 1 then
				active = false
				mouseovertext = menu.ventureModuleUnavailableMouseOverText()
			end
		elseif islimited then
			local availableamount = math.max(0, Helper.getLimitedWareAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			if availableamount < 1 then
				active = false
				mouseovertext = ReadText(1026, 7933)
			end
		end
	end
	row[1]:createButton({ active = active, bgColor = Color["button_background_hidden"], mouseOverText = mouseovertext }):setText(ReadText(1001, 7947))
	row[1].handlers.onClick = function () return menu.buttonCopyModule(menu.contextData.item, false) end

	local row = ftable:addRow(true, { fixed = true })
	local active = not menu.contextData.item.isfixed
	local mouseovertext = ""
	if active then
		local usedLimitedModulesInSequence = {}
		local n = C.GetNumUsedLimitedModulesFromSubsequence(menu.holomap, menu.contextData.item.idx)
		if n > 0 then
			local buf = ffi.new("UIMacroCount[?]", n)
			n = C.GetUsedLimitedModulesFromSubsequence(buf, n, menu.holomap, menu.contextData.item.idx)
			for i = 0, n - 1 do
				local macro = ffi.string(buf[i].macro)
				usedLimitedModulesInSequence[macro] = buf[i].amount
			end
		end

		for macro, amount in pairs(usedLimitedModulesInSequence) do
			local ware = GetMacroData(macro, "ware")
			local islimited = GetWareData(ware, "islimited")
			local availableamount = 0
			if islimited then
				availableamount = math.max(0, Helper.getLimitedWareAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			else
				availableamount = math.max(0, OnlineGetUserItemAmount(ware) - (menu.externalUsedLimitedModules[macro] or 0) - (menu.usedLimitedModules[macro] or 0))
			end
			if amount > availableamount then
				active = false
				mouseovertext = menu.ventureModuleUnavailableMouseOverText()
				break
			end
		end
	end
	row[1]:createButton({ active = active, bgColor = Color["button_background_hidden"], mouseOverText = mouseovertext }):setText(ReadText(1001, 7948))
	row[1].handlers.onClick = function () return menu.buttonCopyModule(menu.contextData.item, true) end

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 7937))
	row[1].handlers.onClick = function () return menu.buttonRemoveModule(menu.contextData.item, false) end

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = not menu.contextData.item.isfixed, bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 7995))
	row[1].handlers.onClick = function () return menu.buttonRemoveModule(menu.contextData.item, true) end

	if ftable.properties.y + ftable:getFullHeight() > Helper.viewHeight - menu.contextFrame.properties.y then
		menu.contextFrame.properties.y = Helper.viewHeight - ftable.properties.y - ftable:getFullHeight() - Helper.frameBorder
	end

	menu.contextFrame:display()
end

function menu.createEquipmentContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 5, reserveScrollBar = false, highlightMode = "off" })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(menu.selectedUpgrade.name, Helper.subHeaderTextProperties)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = true, bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 2400))
	row[1].handlers.onClick = function () return menu.buttonContextEncyclopedia(menu.selectedUpgrade) end

	menu.contextFrame:display()
end

function menu.checkCPNameID()
	local ismasterversion = C.IsMasterVersion()
	local canoverwrite = false
	local cansaveasnew = false
	local source = ""
	if menu.currentCPID then
		local found = false
		for _, plan in ipairs(menu.constructionplans) do
			if plan.id == menu.currentCPID then
				found = true
				source = plan.source
				if (source == "local") or ((source == "library") and (not ismasterversion)) then
					canoverwrite = true
				end
				menu.currentCPName = plan.name
				break
			end
		end
		if not found then
			menu.currentCPID = nil
		end
	end
	if (not menu.currentCPID) and menu.currentCPName and (menu.currentCPName ~= "") then
		cansaveasnew = true
		for _, plan in ipairs(menu.constructionplans) do
			if plan.name == menu.currentCPName then
				source = plan.source
				if (source == "local") or ((source == "library") and (not ismasterversion)) then
					canoverwrite = true
				end
				cansaveasnew = false
				menu.currentCPID = plan.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew, source
end

function menu.createCPSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()

	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 7969), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true })
	menu.contextMode.nameEditBox = row[1]:setColSpan(3):createEditBox({ height = Helper.headerRow1Height, defaultText = ReadText(1001, 7979) }):setText(menu.currentCPName or "", { fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onTextChanged = menu.editboxCPNameUpdateText

	row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.checkOverwriteActive, mouseOverText = ReadText(1026, 7906) }):setText(ReadText(1001, 7907), {  })
	row[1].handlers.onClick = function () return menu.buttonSave(true) end
	row[2]:createButton({ active = menu.checkSaveNewActive, mouseOverText = ReadText(1026, 7907) }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSave(false) end
	row[3]:createButton({  }):setText(ReadText(1001, 64))
	row[3].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createCPRemoveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(6, { tabOrder = 5, defaultInteractiveObject = true })
	ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidthPercent(5, 25, false)
	ftable:setColWidthPercent(6, 25, false)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(6):createText(ReadText(1001, 11924), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(6):createText(ReadText(1001, 11925), { wordwrap = true })

	ftable:addEmptyRow()

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(function () return menu.contextData.saveOption == true end, { height = Helper.standardButtonHeight })
	row[1].handlers.onClick = function () menu.contextData.saveOption = not menu.contextData.saveOption end
	row[2]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 9711))
	row[2].handlers.onClick = function () menu.contextData.saveOption = not menu.contextData.saveOption end
	row[5]:createButton({  }):setText(ReadText(1001, 2821), { halign = "center" })
	row[5].handlers.onClick = menu.buttonCPRemoveConfirm
	row[6]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[6].handlers.onClick = menu.buttonCPRemoveCancel
	ftable:setSelectedCol(6)

	menu.contextFrame:display()
end

function menu.buttonCPRemoveConfirm()
	__CORE_DETAILMONITOR_USERQUESTION[menu.contextData.id] = menu.contextData.saveOption
	C.RemoveConstructionPlan("local", menu.contextData.cpid)
	if menu.contextData.cpid == menu.currentCPID then
		menu.currentCPID = nil
		menu.currentCPName = nil
	end
	for i, plan in ipairs(menu.constructionplans) do
		if plan.id == menu.contextData.cpid then
			table.remove(menu.constructionplans, i)
			break
		end
	end
	menu.refreshTitleBar()
	menu.closeContextMenu()
end

function menu.buttonCPRemoveCancel()
	menu.refreshTitleBar()
	menu.closeContextMenu()
end

function menu.createSettingsContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 50)
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })

	-- settings
	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11904), Helper.headerRowCenteredProperties)
	-- environment
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(__CORE_DETAILMONITOR_STATIONBUILD.environment, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function(_, checked) __CORE_DETAILMONITOR_STATIONBUILD.environment = checked; menu.applySettings() end
	row[2]:setColSpan(2):createText(ReadText(1001, 11905), { mouseOverText = ReadText(1026, 7927) })
	-- gizmo
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(__CORE_DETAILMONITOR_STATIONBUILD.gizmo, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function (_, checked) __CORE_DETAILMONITOR_STATIONBUILD.gizmo = checked; menu.applySettings() end
	row[2]:setColSpan(2):createText(ReadText(1001, 11920), { mouseOverText = ReadText(1026, 7932) })
	-- module overlap
	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(__CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function(_, checked) __CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap = checked; menu.applySettings() end
	row[2]:setColSpan(2):createText(ReadText(1001, 11907), { mouseOverText = ReadText(1026, 7928) })
	ftable:addEmptyRow(Helper.standardTextHeight / 2)
	-- rotation angle snap
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(3):createSliderCell({ min = 0, minSelect = config.discreteAngleSlider.min, max = config.discreteAngleSlider.max, start = math.max(config.discreteAngleSlider.min, math.min(config.discreteAngleSlider.max, __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep)), step = config.discreteAngleSlider.step, mouseOverText = ReadText(1026, 7926), height = Helper.standardTextHeight, suffix = ReadText(1001, 109), hideMaxValue = true }):setText(ReadText(1001, 7998))
	row[1].handlers.onSliderCellChanged = function (_, value) __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep = value; menu.applySettings() end
	row[1].handlers.onSliderCellActivated = function() menu.noupdate = true end
	row[1].handlers.onSliderCellDeactivated = function() menu.noupdate = false end

	ftable:addEmptyRow()

	-- options
	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 11914), Helper.headerRowCenteredProperties)
	-- shuffle
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 11923) .. ReadText(1001, 120))
	row[3]:createDropDown(menu.connectionmoduleraces, { startOption = menu.shuffleconnectionrace })
	row[3].handlers.onDropDownActivated = function() menu.noupdate = true end
	row[3].handlers.onDropDownConfirmed = function (_, id) menu.shuffleconnectionrace = id; menu.noupdate = false end
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createButton({ helpOverlayID = "shuffle_modules", helpOverlayText = " ", helpOverlayHighlightOnly = true, mouseOverText = ReadText(1026, 7910) }):setText(ReadText(1001, 11911), { halign = "center" })
	row[1].handlers.onClick = function () C.ShuffleMapConstructionPlan2(menu.holomap, false, (menu.shuffleconnectionrace == "all") and "" or menu.shuffleconnectionrace); menu.refreshPlan(); menu.displayMenu() end

	menu.contextFrame:display()
end

function menu.createModuleFilterContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setColWidth(1, Helper.standardTextHeight)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createCheckBox(menu.checkAllRacesSelected, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = menu.checkboxSelectAllRaces
	row[2]:createText(ReadText(1001, 11912), Helper.headerRowCenteredProperties)

	for i, race in ipairs(menu.races) do
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.checkRacesSelected(race) end, { height = Helper.standardTextHeight })
		row[1].handlers.onClick = function(_, checked) menu.checkboxSelectRace(i, race, checked) end
		row[2]:createText(race.name)
	end

	menu.contextFrame:display()
end

function menu.checkRacesSelected(race)
	for i, raceentry in ipairs(menu.races) do
		if raceentry.id == race.id then
			return raceentry.selected == true
		end
	end
	return false
end

function menu.checkAllRacesSelected()
	for i, race in ipairs(menu.races) do
		if not race.selected then
			return false
		end
	end
	return true
end

function menu.checkboxSelectRace(index, race, checked)
	menu.races[index].selected = checked
	local found = false
	for j, text in ipairs(menu.modulesearchtext) do
		if text.race == race.id then
			found = true
			if not checked then
				table.remove(menu.modulesearchtext, j)
			end
			break
		end
	end
	if checked and (not found) then
		table.insert(menu.modulesearchtext, { text = race.name, race = race.id })
	end
	menu.displayMenu()
end

function menu.checkboxSelectAllRaces(_, checked)
	for i, race in ipairs(menu.races) do
		menu.races[i].selected = checked
		local found = false
		for j, text in ipairs(menu.modulesearchtext) do
			if text.race == race.id then
				found = true
				if not checked then
					table.remove(menu.modulesearchtext, j)
				end
				break
			end
		end
		if checked and (not found) then
			table.insert(menu.modulesearchtext, { text = race.name, race = race.id })
		end
	end
	menu.displayMenu()
end

function menu.checkOverwriteActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return canoverwrite
end

function menu.checkSaveNewActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return cansaveasnew
end

function menu.checkExportActive()
	local canoverwrite, cansaveasnew, source = menu.checkCPNameID()
	return canoverwrite or cansaveasnew
end

function menu.checkLoadoutNameID()
	local canoverwrite = false
	local cansaveasnew = false
	if menu.loadout then
		local found = false
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.id == menu.loadout then
				menu.loadoutName = loadout.name
				break
			end
		end
		if not found then
			menu.loadout = nil
		end
	end
	if (not menu.loadout) and menu.loadoutName and (menu.loadoutName ~= "") then
		cansaveasnew = true
		for _, loadout in ipairs(menu.loadouts) do
			if loadout.name == menu.loadoutName then
				canoverwrite = true
				cansaveasnew = false
				menu.loadout = loadout.id
				break
			end
		end
	end

	return canoverwrite, cansaveasnew
end

function menu.createCPImportContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(4, { tabOrder = 6, reserveScrollBar = false, maxVisibleHeight = Helper.viewHeight / 2 })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })
	ftable:setColWidth(2, 0.25 * (menu.contextMode.width - Helper.borderSize), false)
	ftable:setColWidth(3, 0.25 * (menu.contextMode.width - Helper.borderSize) - Helper.scaleY(Helper.standardTextHeight), false)
	ftable:setColWidth(4, math.max(20, Helper.scaleY(Helper.standardTextHeight)), false)

	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 7971), Helper.headerRowCenteredProperties)
	row[4]:createButton({ width = Helper.standardTextHeight, y = Helper.headerRow1Height - Helper.standardTextHeight }):setIcon("menu_reload")
	row[4].handlers.onClick = menu.buttonReloadImportable

	menu.importableplans = menu.importableplans or {}
	for _, entry in ipairs(menu.importableplans) do
		local row = ftable:addRow(entry, {  })
		if entry.imported then
			row[1]:setColSpan(2):setBackgroundColSpan(4):createText(entry.name, { mouseOverText = entry.filename .. config.fileExtension })
			row[3]:setColSpan(2):createText("[" .. ReadText(1001, 7983) .. "]", { halign = "right", mouseOverText = entry.filename .. config.fileExtension })
		else
			row[1]:setColSpan(4):createText(entry.name, { mouseOverText = entry.filename .. config.fileExtension })
		end
	end

	ftable:setTopRow(menu.topRows.importCP)
	ftable:setSelectedRow(menu.selectedRows.importCP)
	menu.topRows.importCP = GetTopRow(menu.contexttable)
	menu.selectedRows.importCP = Helper.currentTableRow[menu.contexttable]

	local buttontable = menu.contextFrame:addTable(2, { tabOrder = 7, reserveScrollBar = false })
	buttontable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	buttontable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(" ")

	local row = buttontable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 7981), { wordwrap = true })

	if menu.contextData.selectedEntry and menu.contextData.selectedEntry.imported then
		buttontable:addEmptyRow(Helper.standardTextHeight / 2)

		local row = buttontable:addRow(nil, { fixed = true })
		row[1]:setColSpan(2):createText(ReadText(1001, 7982), { wordwrap = true })
	end

	local row = buttontable:addRow(true, { fixed = true })
	row[1]:createButton({ active = function () return menu.contextData.selectedEntry ~= nil end }):setText(ReadText(1001, 7980), {  })
	row[1].handlers.onClick = function () return menu.buttonImport(false) end
	row[2]:createButton({  }):setText(ReadText(1001, 64))
	row[2].handlers.onClick = menu.closeContextMenu

	local maxVisibleHeight = ftable.properties.maxVisibleHeight - buttontable:getFullHeight() - Helper.frameBorder
	buttontable.properties.y = buttontable.properties.y + math.min(maxVisibleHeight, ftable:getFullHeight())
	ftable.properties.maxVisibleHeight = buttontable.properties.y - ftable.properties.y

	ftable.properties.nextTable = buttontable.index
	buttontable.properties.prevTable = ftable.index

	menu.contextFrame:display()
end

function menu.createCPExportContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = {},
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(2, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 7972), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true })
	menu.contextMode.nameEditBox = row[1]:setColSpan(2):createEditBox({ height = Helper.headerRow1Height, defaultText = ReadText(1001, 7979) }):setText(menu.currentCPName or "", { fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onTextChanged = menu.editboxCPNameUpdateText

	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 7973), { wordwrap = true })

	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createButton({ active = C.CanOpenWebBrowser(), mouseOverText = ReadText(1026, 7918) }):setText(ReadText(1001, 7974)):setText2("\27[mm_externallink]", { halign = "right" })
	row[1].handlers.onClick = menu.buttonConstructionCommunity

	local row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.checkExportActive }):setText(ReadText(1001, 7975), {  })
	row[1].handlers.onClick = function () return menu.buttonExport(false) end
	row[2]:createButton({  }):setText(ReadText(1001, 64))
	row[2].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.createLoadoutSaveContext()
	Helper.removeAllWidgetScripts(menu, config.contextLayer)

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = menu.contextMode.width,
		x = menu.contextMode.x,
		y = menu.contextMode.y,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false })
	ftable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	-- magic
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()

	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 7970), Helper.headerRowCenteredProperties)

	local row = ftable:addRow(true, { fixed = true })
	menu.contextMode.nameEditBox = row[1]:setColSpan(3):createEditBox({ scaling = false, height = menu.titleData.height }):setText(menu.loadoutName or "", { halign = "center", font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize) })
	row[1].handlers.onTextChanged = menu.editboxLoadoutNameUpdateText

	row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.checkLoadoutOverwriteActive, mouseOverText = ReadText(1026, 7908) }):setText(ReadText(1001, 7908), {  })
	row[1].handlers.onClick = function () return menu.buttonSaveLoadout(true) end
	row[2]:createButton({ active = menu.checkLoadoutSaveNewActive, mouseOverText = ReadText(1026, 7909) }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonSaveLoadout(false) end
	row[3]:createButton({  }):setText(ReadText(1001, 64))
	row[3].handlers.onClick = menu.closeContextMenu

	menu.contextFrame:display()
end

function menu.checkLoadoutOverwriteActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return canoverwrite
end

function menu.checkLoadoutSaveNewActive()
	local canoverwrite, cansaveasnew = menu.checkLoadoutNameID()
	return cansaveasnew
end

function menu.displayMenu(firsttime)
	-- Remove possible button scripts from previous view
	Helper.removeAllWidgetScripts(menu, config.infoLayer)
	Helper.currentTableRow = {}
	Helper.closeDropDownOptions(menu.titlebartable, 1, 2)

	menu.infoFrame = Helper.createFrameHandle(menu, {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
	})

	menu.displayLeftBar(menu.infoFrame)

	menu.displayModules(menu.infoFrame, firsttime)

	menu.displayPlan(menu.infoFrame)

	if menu.selectedModule then
		menu.displayModuleInfo(menu.infoFrame)
	end

	menu.infoFrame:display()
end

function menu.viewCreated(layer, ...)
	if layer == config.mainLayer then
		menu.rightbartable, menu.titlebartable, menu.map = ...

		if menu.activatemap == nil then
			menu.activatemap = true
		end
	elseif layer == config.infoLayer then
		if not menu.loadoutMode then
			if menu.modulesMode then
				menu.leftbartable, menu.moduletable, menu.plantable, menu.planmodulestatus, menu.planresourcestable, menu.planstatus, menu.moduleinfotable = ...
			else
				menu.leftbartable, menu.plantable, menu.planmodulestatus, menu.planresourcestable, menu.planstatus, menu.moduleinfotable = ...
			end
		else
			if menu.upgradetypeMode then
				menu.leftbartable, menu.moduletable, menu.planbutton, menu.plantable, menu.moduleinfotable = ...
			else
				menu.leftbartable, menu.planbutton, menu.plantable, menu.moduleinfotable = ...
			end
		end
	elseif layer == config.contextLayer then
		menu.contexttable = ...
	end
end

menu.updateInterval = 0.01

function menu.onUpdate()
	local curtime = getElapsedTime()

	if menu.updatePlan and (menu.updatePlan < curtime) then
		menu.updatePlan = nil

		C.ShowConstructionMap(menu.holomap, menu.container, "", false)
		menu.applySettings()
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
	end

	if menu.activatemap then
		-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
		local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainLayer, menu.map)
		local rendertargetTexture = GetRenderTargetTexture(menu.map)
		if rendertargetTexture then
			menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.mapData.width / menu.mapData.height, 1)
			if menu.holomap ~= 0 then
				menu.showConstructionMap()
			end

			menu.activatemap = false
			menu.refreshPlan()
			local refresh = true
			if menu.state then
				refresh = not menu.onRestoreState(menu.state)
				menu.state = nil
			end
			if refresh then
				menu.displayMainFrame()
				menu.displayMenu(true)
			end
		end
	end

	if (menu.newSelectedModule and ((menu.selectedModule == nil) or (menu.newSelectedModule.idx ~= menu.selectedModule.idx))) or ((menu.newSelectedModule == "clear") and menu.selectedModule) then
		if menu.newSelectedModule == "clear" then
			menu.selectedModule = nil
		else
			menu.selectedModule = menu.newSelectedModule
		end
		menu.newSelectedModule = nil
		menu.refresh = curtime - 1
	end

	for i, entry in ipairs(menu.removedModules) do
		local component = tostring(entry.component)
		if IsComponentConstruction(ConvertStringTo64Bit(component)) then
			if not menu.currentConstructions[component] then
				-- was not in construction before, update menu
				menu.refresh = curtime - 1
			end
			menu.currentConstructions[component] = curtime
		end
	end
	for i = 1, #menu.constructionplan do
		local component = tostring(menu.constructionplan[i].component)
		if IsComponentConstruction(ConvertStringTo64Bit(component)) then
			if not menu.currentConstructions[component] then
				-- was not in construction before, update menu
				menu.refresh = curtime - 1
			end
			menu.currentConstructions[component] = curtime
		end
	end
	for key, timestamp in pairs(menu.currentConstructions) do
		if timestamp < curtime then
			-- no longer in construction, update menu
			menu.currentConstructions[key] = nil
			menu.refresh = curtime - 1
		end
	end

	if menu.contextData and menu.contextData.newSelectedEntry then
		menu.contextData.selectedEntry = menu.contextData.newSelectedEntry
		menu.topRows.importCP = GetTopRow(menu.contexttable)
		menu.selectedRows.importCP = Helper.currentTableRow[menu.contexttable]
		menu.displayContextFrame("importCP", menu.titleData.dropdownWidth + 7 * (menu.titleData.height + Helper.borderSize), menu.titleData.offsetX + menu.titleData.nameWidth + Helper.borderSize, menu.titleData.offsetY + menu.titleData.height + Helper.borderSize)
		menu.contextData.newSelectedEntry = nil
	end

	if menu.contextMode and (type(menu.contextMode) == "table") and menu.contextMode.nameEditBox then
		ActivateEditBox(menu.contextMode.nameEditBox.id)
		menu.contextMode.nameEditBox = nil
	end

	if menu.refresh and (menu.refresh < curtime) and (not menu.noupdate) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
		menu.refresh = nil
		return
	end

	menu.mainFrame:update()
	menu.infoFrame:update()
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if menu.holomap ~= 0 then
		if menu.picking ~= menu.pickstate then
			menu.pickstate = menu.picking
			C.SetMapPicking(menu.holomap, menu.pickstate)
		end

		if menu.map then
			local x, y = GetRenderTargetMousePosition(menu.map)
			C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
		end

		local pickedentry = ffi.new("UIConstructionPlanEntry")
		local haspick = false
		if (GetControllerInfo() ~= "gamepad") or C.IsMouseEmulationActive() then
			haspick = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
		end

		if menu.allowpanning and menu.leftdown then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.leftdown.position, offset, 2) then
				C.StartPanMap(menu.holomap)
				if haspick then
					if menu.selectedModule and (pickedentry.idx == menu.selectedModule.idx) then
						menu.keepcursor = true
					end
				end
				menu.allowpanning = nil
			end
		end
		if menu.allowrotating and menu.rightdown then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 2) then
				C.StartRotateMap(menu.holomap)
				menu.allowrotating = nil
			end
		end

		if menu.picking then
			if haspick then
				local macro = ffi.string(pickedentry.macroid)
				if macro ~= menu.mouseOverMacro then
					menu.mouseOverMacro = macro
					SetMouseOverOverride(menu.map, GetMacroData(macro, "name"))
					local selectedIdx = C.GetSelectedBuildMapEntry(menu.holomap)
					if ((pickedentry.idx == selectedIdx) or (pickedentry.idx == #menu.constructionplan)) and (not pickedentry.isfixed) then
						SetMouseCursorOverride("crossarrows")
					end
				end
			elseif menu.mouseOverMacro then
				menu.mouseOverMacro = nil
				SetMouseOverOverride(menu.map, nil)
				if not menu.keepcursor then
					SetMouseCursorOverride("default")
				end
			end
		end

		if not menu.loadoutMode then
			local canundo = C.CanUndoConstructionMapChange(menu.holomap)
			if canundo ~= menu.canundo then
				menu.canundo = canundo
				local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_undo", nil, 255, 255, 255, 100, nil, nil, 0, 0), true, canundo, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7903) .. Helper.formatOptionalShortcut(" (%s)", "action", 278))
				Helper.setCellContent(menu, menu.titlebartable, desc, 1, 7, nil, "button", nil, function () return menu.undoHelper(true) end)
			end

			local canredo = C.CanRedoConstructionMapChange(menu.holomap)
			if canredo ~= menu.canredo then
				menu.canredo = canredo
				local desc = Helper.createButton(nil, Helper.createButtonIcon("menu_redo", nil, 255, 255, 255, 100, nil, nil, 0, 0), true, canredo, 0, 0, 0, menu.titleData.height, nil, nil, nil, ReadText(1026, 7904) .. Helper.formatOptionalShortcut(" (%s)", "action", 279))
				Helper.setCellContent(menu, menu.titlebartable, desc, 1, 8, nil, "button", nil, function () return menu.undoHelper(false) end)
			end
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	if not menu.loadoutMode then
		if uitable == menu.plantable then
			if menu.holomap ~= 0 then
				if (source ~= "auto") or (menu.selectedModule == nil) then
					if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
						menu.newSelectedModule = rowdata.module
						C.SelectBuildMapEntry(menu.holomap, rowdata.idx)
					elseif menu.selectedModule ~= nil then
						menu.newSelectedModule = "clear"
						C.ClearBuildMapSelection(menu.holomap)
					end
				end
			end
		elseif uitable == menu.contexttable then
			if (source ~= "auto") or (menu.contextData and (menu.contextData.selectedEntry == nil)) then
				if (type(rowdata) == "table") then
					menu.contextData.newSelectedEntry = rowdata
				end
			end
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
	if uitable == menu.plantable then
		if menu.holomap ~= 0 then
			if (source ~= "auto") or (menu.selectedModule == nil) then
				local rowdata = Helper.getCurrentRowData(menu, uitable)
				if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
					C.SetFocusMapConstructionPlanEntry(menu.holomap, rowdata.idx, true)
				end
			end
		end
	end
end

function menu.closeMenu(dueToClose)
	if dueToClose == "back" then
		if menu.loadoutMode then
			menu.buttonCancelLoadout()
			return
		end
	end
	C.ReleaseConstructionMapState()
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer, showinganothermenu)
	if (not showinganothermenu) and menu.contextMode then
		if menu.contextMode.mode == "userquestion" then
			if dueToClose ~= "back" then
				menu.closeContextMenu()
				menu.resetDefaultLoadout()
				menu.closeMenu(dueToClose)
				return
			end
		else
			menu.closeContextMenu()
			if (dueToClose == "back") or (layer == config.contextLayer) then
				return
			end
		end
	end

	if menu.loadoutMode then
		if menu.upgradetypeMode and (dueToClose == "back") then
			menu.deactivateUpgradetypeMode()
			return
		end
	else
		if menu.modulesMode and (dueToClose == "back") then
			menu.deactivateModulesMode()
			return
		end
	end

	if (not showinganothermenu) and menu.haschanges then
		menu.contextData = { dueToClose = dueToClose }
		menu.displayContextFrame("userquestion", Helper.scaleX(400), (Helper.viewWidth - Helper.scaleX(400)) / 2, Helper.viewHeight / 2)
	else
		menu.closeMenu(dueToClose)
	end
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)

	-- REMOVE this block once the mouse out/over event order is correct -> This should be unnessecary due to the global tablemouseout event reseting the picking
	if menu.currentMouseOverTable and (
		(menu.currentMouseOverTable == menu.contexttable)
	) then
		menu.picking = true
		menu.currentMouseOverTable = nil
	end
	-- END

	menu.contextFrame = nil
	menu.contextMode = nil
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown()
	menu.leftdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()) }
	menu.allowpanning = true
end

function menu.onRenderTargetMouseUp()
	local refreshplan = false
	local display = false
	local applyDefaultLoadout

	menu.allowpanning = false
	SetMouseCursorOverride("default")
	menu.keepcursor = false
	if C.StopPanMap(menu.holomap) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		refreshplan = true
		display = true
	end

	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was not moved more than a distance of 2px
	if (menu.leftdown and menu.leftdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.leftdown.position, offset, 2)) then
		menu.closeContextMenu()
		Helper.closeDropDownOptions(menu.titlebartable, 1, 2)

		if not menu.loadoutMode then
			C.SelectPickedBuildMapEntry(menu.holomap)
			C.AddFloatingSequenceToConstructionPlan(menu.holomap)
			local addedNewModule = false
			if menu.floatingNewModule then
				applyDefaultLoadout = menu.floatingNewModule
				menu.floatingNewModule = nil
				addedNewModule = true
			elseif menu.floatingCopyModule then
				menu.floatingCopyModule = nil
				addedNewModule = true
			end
			menu.topRows.modules = GetTopRow(menu.moduletable)
			menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
			menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]

			local newplanrow
			local pickedentry = ffi.new("UIConstructionPlanEntry")
			if C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false) then
				if not pickedentry.isfixed then
					SetMouseCursorOverride("crossarrows")
				end
				local found = false
				for row, rowdata in pairs(menu.rowDataMap[menu.plantable]) do
					if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
						if rowdata.idx == pickedentry.idx then
							menu.selectedModule = rowdata.module
							newplanrow = row
							found = true
							break
						end
					end
				end
				if not found then
					for i, entry in ipairs(menu.constructionplan) do
						if entry.idx == pickedentry.idx then
							menu.selectedModule = entry
							found = true
							break
						end
					end
				end
				if not found then
					menu.selectedModule = { idx = pickedentry.idx, macro = ffi.string(pickedentry.macroid), component = pickedentry.componentid }
				end
				C.SelectBuildMapEntry(menu.holomap, pickedentry.idx)
			else
				menu.selectedModule = nil
				newplanrow = addedNewModule and "last" or "first"
				C.ClearBuildMapSelection(menu.holomap)
			end
			menu.storePlanTableState()
			menu.selectedRows.plan = newplanrow or Helper.currentTableRow[menu.plantable]

			refreshplan = true
			display = true
		else
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.loadoutModule.component, menu.loadoutModule.macro, pickedslot.upgradetype, pickedslot.slot)
				menu.upgradetypeMode = "turretgroup"
				menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				if menu.upgradetypeMode == "turretgroup" then
					local group = menu.groups[menu.currentSlot]
					C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
				end
				display = true
			end
		end
	end
	menu.leftdown = nil

	if refreshplan then
		menu.refreshPlan()
		if applyDefaultLoadout then
			if menu.defaultLoadout ~= -1 then
				local entry = menu.constructionplan[#menu.constructionplan]
				if entry.macro == applyDefaultLoadout then
					local active = false
					for i, upgradetype in ipairs(Helper.upgradetypes) do
						if upgradetype.supertype == "macro" then
							if C.GetNumUpgradeSlots(entry.component, entry.macro, upgradetype.type) > 0 then
								active = true
								break
							end
						end
					end
					if active then
						local loadout = Helper.getLoadoutHelper(C.GenerateModuleLoadout, C.GenerateModuleLoadoutCounts, menu.holomap, entry.idx, menu.container, menu.defaultLoadout)
						local upgradeplan = Helper.convertLoadout(entry.component, entry.macro, loadout, nil)
						Helper.callLoadoutFunction(upgradeplan, nil, function (loadout, _) return C.UpdateConstructionMapItemLoadout(menu.holomap, entry.idx, menu.container, loadout) end)
					end
					-- again for the new loadout
					menu.refreshPlan()
				end
			end
		end
	end
	if display then
		menu.displayMenu()
	end
end

function menu.onRenderTargetRightMouseDown()
	local pickedentry = ffi.new("UIConstructionPlanEntry")
	local valid = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
	local item = menu.findConstructionPlanEntry(pickedentry.idx)
	if not item then
		item = {}
		valid = false
	end
	menu.rightdown = { time = GetCurRealTime(), position = table.pack(GetLocalMousePosition()), item = item, itemvalid = valid }
	menu.allowrotating = true
end

function menu.onRenderTargetRightMouseUp()
	menu.allowrotating = false
	if C.StopRotateMap(menu.holomap) then
		menu.topRows.modules = GetTopRow(menu.moduletable)
		menu.selectedRows.modules = Helper.currentTableRow[menu.moduletable]
		menu.selectedCols.modules = Helper.currentTableCol[menu.moduletable]
		menu.storePlanTableState()
		menu.refreshPlan()
		menu.displayMenu()
	end

	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.2 seconds and the mouse was moved more than a distance of 2px
	if (menu.rightdown.time + 0.2 > GetCurRealTime()) and (not Helper.comparePositions(menu.rightdown.position, offset, 2)) then
		menu.closeContextMenu()

		if not menu.loadoutMode then
			if menu.floatingNewModule or menu.floatingCopyModule then
				C.RemoveFloatingSequenceFromConstructionPlan(menu.holomap)
				menu.floatingNewModule = nil
				menu.floatingCopyModule = nil
			elseif menu.rightdown.itemvalid then
				local x, y = GetLocalMousePosition()
				if x == nil then
					-- gamepad case
					x = posx
					y = -posy
				end
				menu.contextData = { item = menu.rightdown.item }
				menu.displayContextFrame("module", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
			end
		else
			local pickedslot = ffi.new("UILoadoutSlot")
			if C.GetPickedMapMacroSlot(menu.holomap, menu.container, menu.loadoutModule.component, menu.loadoutModule.macro, true, pickedslot) then
				local groupinfo = C.GetUpgradeSlotGroup(menu.loadoutModule.component, menu.loadoutModule.macro, pickedslot.upgradetype, pickedslot.slot)
				menu.upgradetypeMode = "turretgroup"
				menu.currentSlot = menu.findGroupIndex(ffi.string(groupinfo.path), ffi.string(groupinfo.group))
				if menu.upgradetypeMode == "turretgroup" then
					local group = menu.groups[menu.currentSlot]
					C.SetSelectedMapGroup(menu.holomap, menu.loadoutModule.component, menu.loadoutModule.macro, group.path, group.group)
				end
				menu.displayMenu()

				menu.contextData = { upgradetype = ffi.string(pickedslot.upgradetype), slot = tonumber(pickedslot.slot) }
				menu.displayContextFrame("slot", Helper.scaleX(300), offset[1] + Helper.viewWidth / 2, Helper.viewHeight / 2 - offset[2])
			end
		end
	end
	menu.rightdown = nil
end

function menu.onRenderTargetCombinedScrollDown(step)
	C.ZoomMap(menu.holomap, step)
end

function menu.onRenderTargetCombinedScrollUp(step)
	C.ZoomMap(menu.holomap, -step)
end

function menu.onRenderTargetDoubleClick(modified)
	local pickedentry = ffi.new("UIConstructionPlanEntry")
	local valid = C.GetPickedBuildMapEntry2(menu.holomap, menu.container, pickedentry, false)
	if valid then
		C.SetFocusMapConstructionPlanEntry(menu.holomap, pickedentry.idx, true)
	end
end

function menu.onSaveState()
	local state = {}

	if menu.holomap ~= 0 then
		if menu.haschanges or menu.hasconstructionchanges then
			Helper.registerStationEditorChanges()
		end
		if not menu.loadoutMode then
			C.StoreConstructionMapState(menu.holomap)
		end
		local mapstate = ffi.new("HoloMapState")
		C.GetMapState(menu.holomap, mapstate)
		state.map = { offset = { x = mapstate.offset.x, y = mapstate.offset.y, z = mapstate.offset.z, yaw = mapstate.offset.yaw, pitch = mapstate.offset.pitch, roll = mapstate.offset.roll,}, cameradistance = mapstate.cameradistance }
	end

	for _, key in ipairs(config.stateKeys) do
		if key[1] == "loadoutModuleIdx" then
			if menu.loadoutMode then
				state[key[1]] = tonumber(menu.loadoutModule.idx)
				state.upgradeplan = menu.constructionplan[menu.loadoutMode].upgradeplan
			end
		else
			state[key[1]] = menu[key[1]]
		end
	end
	return state
end

function menu.onRestoreState(state)
	local mapstate
	if state.map then
		local offset = ffi.new("UIPosRot", {
			x = state.map.offset.x,
			y = state.map.offset.y,
			z = state.map.offset.z,
			yaw = state.map.offset.yaw,
			pitch = state.map.offset.pitch,
			roll = state.map.offset.roll
		})
		mapstate = ffi.new("HoloMapState", {
			offset = offset,
			cameradistance = state.map.cameradistance
		})
	end

	local module
	for _, key in ipairs(config.stateKeys) do
		if key[1] == "loadoutModuleIdx" then
			if state[key[1]] then
				local idx = ConvertStringTo64Bit(tostring(state[key[1]]))
				for i, entry in ipairs(menu.constructionplan) do
					if entry.idx == state[key[1]] then
						entry.upgradeplan = state.upgradeplan
						module = entry
						break
					end
				end
			end
		else
			if key[2] == "UniverseID" then
				menu[key[1]] = ConvertIDTo64Bit(state[key[1]])
			elseif key[2] == "bool" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		end
	end

	local returnvalue
	if module then
		menu.buttonEditLoadout(module)
		returnvalue = true
	end

	if mapstate then
		C.SetMapState(menu.holomap, mapstate)
	end

	return returnvalue
end

-- table mouse input helper
function menu.onTableMouseOut(uitable, row)
	if menu.currentMouseOverTable and (uitable == menu.currentMouseOverTable) then
		menu.currentMouseOverTable = nil
		if menu.holomap ~= 0 then
			menu.picking = true
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	menu.currentMouseOverTable = uitable
	if menu.holomap ~= 0 then
		menu.picking = false
	end
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]
	if uitable == menu.plantable then
		if (type(rowdata) == "table") and rowdata.ismodule and (not rowdata.removed) then
			local x, y = GetLocalMousePosition()
			if x == nil then
				-- gamepad case
				x = posx
				y = -posy
			end
			menu.contextData = { item = rowdata.module }
			menu.displayContextFrame("module", Helper.scaleX(200), x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y)
		end
	end
end

function menu.filterModuleByText(module, texts)
	local hasracefilter, racematch = false, false
	for _, textentry in ipairs(texts) do
		if textentry.race then
			hasracefilter = true
			local makerraces = GetMacroData(module, "makerraceid")
			if (textentry.race == "generic") and (#makerraces == 0) then
				racematch = true
			end
			for _, makerrace in ipairs(makerraces) do
				if makerrace == textentry.race then
					racematch = true
					break
				end
			end
			if racematch then
				break
			end
		end
	end

	local hasadditionalfilter, filtermatch = false, false
	for _, textentry in ipairs(texts) do
		if not textentry.race then
			hasadditionalfilter = true
			text = utf8.lower(textentry.text)

			local name, shortname, makerracenames = GetMacroData(module, "name", "shortname", "makerracename")
			if string.find(utf8.lower(name), text, 1, true) then
				filtermatch = true
			end
			if string.find(utf8.lower(shortname), text, 1, true) then
				filtermatch = true
			end
			for _, makerracename in ipairs(makerracenames) do
				if string.find(utf8.lower(makerracename), text, 1, true) then
					filtermatch = true
					break
				end
			end
			if filtermatch then
				break
			end
		end
	end

	return ((not hasracefilter) or racematch) and ((not hasadditionalfilter) or filtermatch)
end

function menu.filterUpgradeByText(upgrade, text)
	text = utf8.lower(text)

	local name, shortname, makerracenames = GetMacroData(upgrade, "name", "shortname", "makerracename")
	if string.find(utf8.lower(name), text, 1, true) then
		return true
	end
	if string.find(utf8.lower(shortname), text, 1, true) then
		return true
	end
	for _, makerracename in ipairs(makerracenames) do
		if string.find(utf8.lower(makerracename), text, 1, true) then
			return true
		end
	end

	return false
end

function menu.isEntryExtended(container, index)
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			return entry.plan[index]
		end
	end
	return false
end

function menu.extendEntry(container, index, force, exclusive)
	local found = false
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			found = true
			if exclusive then
				entry.plan = {}
			end
			if (not force) and entry.plan[index] then
				entry.plan[index] = nil
			else
				entry.plan[index] = true
			end
			break
		end
	end
	if not found then
		table.insert(menu.extendedentries, {id = container, plan = { [index] = true } })
	end
end

function menu.initExtendedEntry(container)
	for i, entry in ipairs(menu.extendedentries) do
		if entry.id == container then
			-- nothing to do
			return
		end
	end
	table.insert(menu.extendedentries, {id = container, plan = { ["planned"] = true, ["removed"] = true } })
end

function menu.isResourceEntryExtended(id, default)
	if (default ~= nil) and (menu.extendedresourceentries[id] == nil) then
		menu.extendedresourceentries[id] = default
	end
	return menu.extendedresourceentries[id]
end

function menu.extendResourceEntry(id)
	menu.extendedresourceentries[id] = not menu.extendedresourceentries[id]
end

function menu.getLeftBarEntry(mode)
	for i, entry in ipairs(config.leftBar) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.getLeftBarLoadoutEntry(mode)
	for i, entry in ipairs(config.leftBarLoadout) do
		if entry.mode == mode then
			return entry
		end
	end

	return {}
end

function menu.findUpgradeMacro(type, macro)
	for i, upgradeware in ipairs(menu.upgradewares[type] or {}) do
		if upgradeware.macro == macro then
			return i
		end
	end
	DebugError("The equipment macro '" .. macro .. "' is not in the player's blueprint list. This should never happen. [Florian]")
end

function menu.findGroupIndex(path, group)
	for i, groupinfo in ipairs(menu.groups) do
		if (groupinfo.path == path) and (groupinfo.group == group) then
			return i
		end
	end
end

function menu.findConstructionPlanEntry(idx)
	for _, entry in ipairs(menu.constructionplan) do
		if entry.idx == idx then
			return entry
		end
	end
end

function menu.storePlanTableState()
	menu.topRows.plan = GetTopRow(menu.plantable)
	menu.selectedRows.plan = Helper.currentTableRow[menu.plantable]
	menu.topRows.planresources = GetTopRow(menu.planresourcestable)
	menu.selectedRows.planresources = Helper.currentTableRow[menu.planresourcestable]
end

function menu.upgradeSettingsVersion()
	local oldversion = __CORE_DETAILMONITOR_STATIONBUILD.version

	if oldversion < 2 then
		__CORE_DETAILMONITOR_STATIONBUILD.gizmo = true
	end

	__CORE_DETAILMONITOR_STATIONBUILD.version = config.mapfilterversion
end

function menu.applySettings()
	if menu.holomap and (menu.holomap ~= 0) then
		C.SetConstructionMapBuildAngleStep(menu.holomap, __CORE_DETAILMONITOR_STATIONBUILD.discreteanglestep)
		C.SetConstructionMapCollisionDetection(menu.holomap, not __CORE_DETAILMONITOR_STATIONBUILD.moduleoverlap)
		C.SetConstructionMapRenderSectorBackground(menu.holomap, __CORE_DETAILMONITOR_STATIONBUILD.environment)
		C.SetConstructionMapRenderTransformGizmo(menu.holomap, __CORE_DETAILMONITOR_STATIONBUILD.gizmo)
	end
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- param == { 0, 0, container }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef int32_t TradeRuleID;
	typedef uint64_t UniverseID;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		BuildTaskID id;
		UniverseID buildingcontainer;
		UniverseID component;
		const char* macro;
		const char* factionid;
		UniverseID buildercomponent;
		int64_t price;
		bool ismissingresources;
		uint32_t queueposition;
	} BuildTaskInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* shortname;
		const char* description;
		const char* icon;
	} RaceInfo;
	typedef struct {
		int64_t trade;
		int64_t defence;
		int64_t build;
		int64_t repair;
		int64_t missile;
	} SupplyBudget;
	typedef struct {
		const char* ware;
		int total;
		int current;
		const char* supplytypes;
	} SupplyResourceInfo;
	typedef struct {
		const char* macro;
		int amount;
	} SupplyOverride;
	typedef struct {
		double time;
		int64_t money;
	} UIAccountStatData;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		double time;
		uint64_t amount;
	} UICargoStatData;
	typedef struct {
		const char* wareid;
		UICargoStatData* data;
		uint32_t numdata;
	} UICargoStat;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		const char* id;
		const char* group;
		const char* name;
		const char* description;
		double duration;
		double repeatcooldown;
		uint32_t timescompleted;
		int32_t successchance;
		bool resilient;
		bool showalways;
		int64_t price;
		float payoutfactor;
		const char* requiredresearchid;
		const char* pricescale;
		const char* pricescaletext;
		bool anypredecessor;
		uint32_t numpredecessors;
		uint32_t numpredecessorgroups;
		uint32_t numblockingprojects;
		uint32_t numconditions;
		uint32_t numprimaryeffects;
		uint32_t numsideeffects;
		uint32_t numblockedprojects;
		uint32_t numblockedgroups;
		uint32_t numrebates;
		uint32_t numresources;
		uint32_t numremovedprojects;
	} UITerraformingProject2;
	typedef struct {
		double time;
		int64_t price;
		int amount;
		int limit;
	} UITradeOfferStatData;
	typedef struct {
		const char* wareid;
		bool isSellOffer;
		UITradeOfferStatData* data;
		uint32_t numdata;
	} UITradeOfferStat;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	typedef struct {
		const char* type;
		const char* name;
		float value;
		bool active;
	} UIWorkforceInfluence;
	typedef struct {
		uint32_t numcapacityinfluences;
		uint32_t numgrowthinfluences;
	} WorkforceInfluenceCounts;
	typedef struct {
		uint32_t numcapacityinfluences;
		UIWorkforceInfluence* capacityinfluences;
		uint32_t numgrowthinfluences;
		UIWorkforceInfluence* growthinfluences;
		float basegrowth;
		uint32_t capacity;
		uint32_t current;
		uint32_t sustainable;
		uint32_t target;
		int32_t change;
	} WorkforceInfluenceInfo;
	typedef struct {
		uint32_t current;
		uint32_t capacity;
		uint32_t optimal;
		uint32_t available;
		uint32_t maxavailable;
		double timeuntilnextupdate;
	} WorkForceInfo;

	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	void AddTradeWare(UniverseID containerid, const char* wareid);
	bool AreWaresWithinContainerProductionLimits(UniverseID containerid, UIWareAmount* wares, uint32_t numwares);
	void ClearContainerBuyLimitOverride(UniverseID containerid, const char* wareid);
	void ClearContainerSellLimitOverride(UniverseID containerid, const char* wareid);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAmmoStorage(AmmoData* result, uint32_t resultlen, UniverseID defensibleid, const char* ammotype);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	size_t GetBuildMapConstructionPlan(UniverseID holomapid, UniverseID defensibleid, bool usestoredplan, UIConstructionPlanEntry* result, uint32_t resultlen);
	uint32_t GetBuildModules(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	double GetBuildProcessorEstimatedTimeLeft(UniverseID buildprocessorid);
	uint32_t GetBuildTasks(BuildTaskInfo* result, uint32_t resultlen, UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetCargoStatistics(UICargoStat* result, uint32_t resultlen, size_t numdatapoints);
	float GetContainerBuildPriceFactor(UniverseID containerid);
	uint32_t GetContainerBuildResources(const char** result, uint32_t resultlen, UniverseID containerid);
	TradeRuleID GetContainerTradeRuleID(UniverseID containerid, const char* ruletype, const char* wareid);
	double GetContainerWareConsumptionPerProduct(UniverseID containerid, const char* wareid, const char* productid, bool ignorestate);
	double GetContainerWareProduction(UniverseID containerid, const char* wareid, bool ignorestate);
	void GetContainerWorkforceInfluence(WorkforceInfluenceInfo* result, UniverseID containerid, const char* raceid);
	float GetCurrentBuildProgress(UniverseID containerid);
	double GetCurrentGameTime(void);
	uint32_t GetNPCAccountStatistics(UIAccountStatData* result, size_t resultlen, UniverseID entityid, double starttime, double endtime);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAmmoStorage(UniverseID defensibleid, const char* ammotype);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	size_t GetNumBuildMapConstructionPlan(UniverseID holomapid, bool usestoredplan);
	uint32_t GetNumBuildModules(UniverseID containerid);
	uint32_t GetNumBuildTasks(UniverseID containerid, UniverseID buildmoduleid, bool isinprogress, bool includeupgrade);
	uint32_t GetNumCargoStatistics(UniverseID containerorspaceid, double starttime, double endtime, size_t numdatapoints);
	uint32_t GetNumContainerBuildResources(UniverseID containerid);
	WorkforceInfluenceCounts GetNumContainerWorkforceInfluence(UniverseID containerid, const char* raceid, bool force);
	size_t GetNumPlannedStationModules(UniverseID defensibleid, bool includeall);
	uint32_t GetNumRemovedConstructionPlanModules2(UniverseID holomapid, UniverseID defensibleid, uint32_t* newIndex, bool usestoredplan, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumRemovedStationModules2(UniverseID defensibleid, uint32_t* newIndex, uint32_t* numChangedIndices, bool checkupgrades);
	uint32_t GetNumResearchModules(UniverseID containerid);
	uint32_t GetNumStationModules(UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetNumStationOverviewGraphWares(UniverseID stationid, bool* initialized);
	uint32_t GetNumSupplyOrderResources(UniverseID containerid);
	uint32_t GetNumSupplyOrders(UniverseID containerid, bool defaultorders);
	uint32_t GetNumTerraformingProjects(UniverseID clusterid, bool useevents);
	uint32_t GetNumTradeOfferStatistics(UniverseID containerorspaceid, double starttime, double endtime, size_t numdatapoints);
	size_t GetPlannedStationModules(UIConstructionPlanEntry* result, uint32_t resultlen, UniverseID defensibleid, bool includeall);
	uint32_t GetRemovedConstructionPlanModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	uint32_t GetRemovedStationModules2(UniverseID* result, uint32_t resultlen, uint32_t* changedIndices, uint32_t* numChangedIndices);
	uint32_t GetResearchModules(UniverseID* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetStationModules(UniverseID* result, uint32_t resultlen, UniverseID stationid, bool includeconstructions, bool includewrecks);
	uint32_t GetStationOverviewGraphWares(const char** result, uint32_t resultlen, UniverseID stationid);
	int64_t GetSupplyBudget(UniverseID containerid);
	uint32_t GetSupplyOrderResources(SupplyResourceInfo* result, uint32_t resultlen, UniverseID containerid);
	uint32_t GetSupplyOrders(SupplyOverride* result, uint32_t resultlen, UniverseID containerid, bool defaultorders);
	const char* GetTerraformingActiveProject(UniverseID clusterid);
	uint32_t GetTerraformingProjects2(UITerraformingProject2* result, uint32_t resultlen, UniverseID clusterid, bool useevents);
	uint32_t GetTradeOfferStatistics(UITradeOfferStat* result, uint32_t resultlen, size_t numdatapoints);
	int64_t GetTradeWareBudget(UniverseID containerid);
	WorkForceInfo GetWorkForceInfo(UniverseID containerid, const char* raceid);
	bool HasContainerOwnTradeRule(UniverseID containerid, const char* ruletype, const char* wareid);
	bool HasEntityMoneyLogEntries(UniverseID entityid);
	bool IsComponentOperational(UniverseID componentid);
	bool IsContainerAmmoMacroCompatible(UniverseID containerid, const char* ammomacroname);
	bool IsHQ(UniverseID componentid);
	bool IsNextStartAnimationSkipped(bool reset);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
	bool IsSupplyManual(UniverseID containerid, const char* type);
	void PauseProductionModule(UniverseID productionmoduleid, bool pause);
	void PauseProcessingModule(UniverseID processingmoduleid, bool pause);
	void RemoveTradeWare(UniverseID containerid, const char* wareid);
	void SetContainerBuildPriceFactor(UniverseID containerid, float value);
	void SetContainerTradeRule(UniverseID containerid, TradeRuleID id, const char* ruletype, const char* wareid, bool value);
	void SetContainerWareIsBuyable(UniverseID containerid, const char* wareid, bool allowed);
	void SetContainerWareIsSellable(UniverseID containerid, const char* wareid, bool allowed);
	void SetContainerWorkforceFillCapacity(UniverseID containerid, bool value);
	bool SetStationOverviewGraphWare(UniverseID stationid, const char* wareid, bool value);
	void SetSupplyManual(UniverseID containerid, const char* type, bool onoff);
	bool ShouldContainerFillWorkforceCapacity(UniverseID containerid);
	void UpdateProductionTradeOffers(UniverseID containerid);
	void UpdateSupplyOverrides(UniverseID containerid, SupplyOverride* overrides, uint32_t numoverrides);
]]

local utf8 = require("utf8")

local menu = {
	name = "StationOverviewMenu",
	graphmode = "tradeofferprices",
	extendedGroups = {},
	showSingleProduction = {},
	showGraph = false,
}

local config = {
	mainFrameLayer = 5,
	expandedMenuFrameLayer = 4,
	contextFrameLayer = 2,
	nodeoffsetx = 30,
	nodewidth = 270,
	dronetypes = {
		{ type = "transport",	name = ReadText(1001, 7104),	autoname = ReadText(1001, 4207) },
		{ type = "defence",		name = ReadText(1001, 1310),	autoname = ReadText(1001, 4216) },
		{ type = "repair",		name = ReadText(1001, 3000),	autoname = ReadText(1001, 4232) },
		{ type = "build",		name = ReadText(1001, 7833),	autoname = ReadText(1001, 4233) },
	},
	missilestypes = {
		{ type = "missile",		name = ReadText(1001, 1304),	autoname = ReadText(1001, 4234) },
	},
	graph = {
		maxshowndata = 4,
		numdatapoints = 21,
		factors = { 0.2, 0.5, 1, 2, 5, 10, 20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000, 50000, 100000, 200000, 500000, 1000000, 2000000, 5000000, 10000000, 20000000, 50000000, 100000000 },
		datarecordcolors = {
			[1] = { buy = Color["graph_data_1"], sell = Color["graph_data_2"] },
			[2] = { buy = Color["graph_data_3"], sell = Color["graph_data_4"] },
			[3] = { buy = Color["graph_data_5"], sell = Color["graph_data_6"] },
			[4] = { buy = Color["graph_data_7"], sell = Color["graph_data_8"] },
		},
		point = {
			type = "square",
			size = 8,
			highlightSize = 8,
		},
		line = {
			type = "normal",
			size = 2,
			highlightSize = 4,
		},
	},
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	menu.title = nil
	menu.container = nil
	menu.containerid = nil
	menu.frame = nil
	menu.flowchart = nil
	menu.keyTable = nil
	menu.expandedNode = nil
	menu.expandedMenuFrame = nil
	if menu.wareReservationRegistered then
		UnregisterEvent("newWareReservation", menu.newWareReservationCallback)
		menu.wareReservationRegistered = nil
	end
	if menu.supplyUpdateRegistered then
		UnregisterEvent("supplyUpdate", menu.supplyUpdate)
		menu.supplyUpdateRegistered = nil
	end
	menu.expandedMenuTable = nil
	menu.noupdate = nil

	menu.restoreNode = nil
	menu.restoreNodeWare = nil
	menu.restoreNodeSupply = nil
	menu.restoreNodeSupplyWare = nil
	menu.restoreNodeBuildModule = nil

	menu.constructionplan = {}
	menu.newModulesIndex = nil
	menu.removedModules = {}
	menu.displayedgraphwares = {}
	menu.graphwaresinit = nil
	menu.productionnodes = { }
	menu.researchnodes = {}
	menu.showSingleProduction = {}
	menu.terraformingnodes = {}

	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedRowData = {}
	menu.selectedCols = {}

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

-- helpers to maintain row/column states while frame is re-created
function menu.saveFlowchartState(name, flowchart)
	menu.topRows[name], menu.firstCols[name] = GetFlowchartFirstVisibleCell(flowchart.id)
	menu.selectedRows[name], menu.selectedCols[name] = GetFlowchartSelectedCell(flowchart.id)
end

function menu.restoreFlowchartState(name, flowchart)
	flowchart.properties.firstVisibleRow = menu.topRows[name] or 1
	flowchart.properties.firstVisibleCol = menu.firstCols[name] or 1
	menu.topRows[name] = nil
	menu.firstCols[name] = nil
	flowchart.properties.selectedRow = menu.selectedRows[name] or 1
	flowchart.properties.selectedCol = menu.selectedCols[name] or 1
	menu.selectedRows[name] = nil
	menu.selectedRowData[name] = nil
	menu.selectedCols[name] = nil
end

function menu.saveTableState(name, ftable, row, col)
	menu.topRows[name] = GetTopRow(ftable.id)
	menu.selectedRows[name] = row or Helper.currentTableRow[ftable.id]
	menu.selectedRowData[name] = menu.rowDataMap[ftable.id] and menu.rowDataMap[ftable.id][menu.selectedRows[name]]
	menu.selectedCols[name] = col or Helper.currentTableCol[ftable.id]
end

function menu.restoreTableState(name, ftable)
	ftable:setTopRow(menu.topRows[name])
	ftable:setSelectedRow(menu.selectedRows[name])
	ftable:setSelectedCol(menu.selectedCols[name] or 0)

	menu.topRows[name] = nil
	menu.selectedRows[name] = nil
	menu.selectedRowData[name] = nil
	menu.selectedCols[name] = nil
end

-- Menu member functions

function menu.onShowMenu(state)
	menu.containerid = menu.param[3]
	menu.container = ConvertIDTo64Bit(menu.containerid)
	menu.displayedgraphwares = {}

	-- kuertee start: callback
	if menu.uix_callbacks ["onShowMenu_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onShowMenu_start"]) do
			uix_callback (menu.container)
		end
	end
	-- kuertee end: callback

	menu.isdummy = false
	if not menu.container then
		menu.isdummy = true
		menu.containerid = GetPlayerContextByClass("container")
		menu.container = ConvertIDTo64Bit(menu.containerid)
	else
		local boolbuf = ffi.new("bool[1]", 0)
		local n = C.GetNumStationOverviewGraphWares(menu.container, boolbuf)
		menu.graphwaresinit = boolbuf[0]
		if n > 0 then
			local buf = ffi.new("const char*[?]", n)
			n = C.GetStationOverviewGraphWares(buf, n, menu.container)
			for i = 0, n - 1 do
				local ware = ffi.string(buf[i])
				menu.displayedgraphwares[ware] = true
			end
		end
	end

	menu.title = ReadText(1001, 7903)

	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedRowData = {}
	menu.selectedCols = {}

	menu.numshowndata = 0
	menu.showndata = {}

	-- trade rules
	Helper.updateTradeRules()

	-- flowchart init
	menu.setupFlowchartData()

	-- graph init
	if not menu.graphmode then
		menu.graphmode = "tradeofferprices"
	end
	local curtime = C.GetCurrentGameTime()
	menu.timeframe = "hour"
	menu.xStart = math.max(0, curtime - 3600)
	menu.xEnd = curtime
	menu.xGranularity = 300
	if menu.xEnd > menu.xStart then
		while (menu.xEnd - menu.xStart) < menu.xGranularity do
			menu.xGranularity = menu.xGranularity / 2
		end
	end
	menu.xScale = 60
	menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"
	menu.yTitle = ReadText(1001, 6520) .. " [" .. ReadText(1001, 101) .. "]"

	menu.getData(config.graph.numdatapoints)

	if state then
		menu.onRestoreState(state)
	end

	menu.display()
end

function menu.onShowMenuSound()
	if not C.IsNextStartAnimationSkipped(false) then
		PlaySound("ui_config_station_open")
	else
		PlaySound("ui_menu_changed")
	end
end

function menu.onSaveState()
	local state = {}

	if menu.expandedNode and menu.expandedNode.customdata and menu.expandedNode.customdata.nodedata then
		if menu.expandedNode.customdata.nodedata[1].isstorage then
			state.restoreNodeWare = menu.expandedNode.customdata.nodedata.ware
		elseif menu.expandedNode.customdata.nodedata[1].issupplyresource then
			state.restoreNodeSupplyWare = menu.expandedNode.customdata.nodedata.ware
		elseif menu.expandedNode.customdata.nodedata[1].buildmodule then
			state.restoreNodeBuildModule = menu.expandedNode.customdata.nodedata[1].buildmodule
		elseif menu.expandedNode.customdata.nodedata.drones then
			state.restoreNodeSupply = "drones"
		elseif menu.expandedNode.customdata.nodedata.missiles then
			state.restoreNodeSupply = "missiles"
		end
	end

	state.flowchartTopRow, state.flowchartFirstCol = GetFlowchartFirstVisibleCell(menu.flowchart.id)
	state.flowchartSelectedRow, state.flowchartSelectedCol = GetFlowchartSelectedCell(menu.flowchart.id)

	return state
end

function menu.onRestoreState(state)
	menu.restoreNodeWare = state.restoreNodeWare
	menu.restoreNodeSupplyWare = state.restoreNodeSupplyWare
	menu.restoreNodeBuildModule = ConvertIDTo64Bit(state.restoreNodeBuildModule)
	menu.restoreNodeSupply = state.restoreNodeSupply

	menu.topRows.flowchart, menu.firstCols.flowchart = state.flowchartTopRow, state.flowchartFirstCol
	menu.selectedRows.flowchart, menu.selectedCols.flowchart = state.flowchartSelectedRow, state.flowchartSelectedCol
end

local function addFlowchartWareNode(nodes, warenodes, productiondata)
	if not warenodes[productiondata.ware] then
		local transporttype = GetWareData(productiondata.ware, "transport")
		local planned = false
		local hasstorage = false
		if C.IsComponentClass(menu.container, "container") then
			hasstorage = CheckSuitableTransportType(menu.containerid, productiondata.ware)
		end
		if hasstorage then
			if #menu.constructionplan > 0 then
				local found = false
				for i = 1, #menu.constructionplan do
					local entry = menu.constructionplan[i]
					if IsMacroClass(entry.macro, "storage") then
						local data = GetLibraryEntry("moduletypes_storage", entry.macro)
						if data.storagetags[transporttype] then
							if menu.changedModulesIndices[i] then
								planned = true
							end
							found = true
							break
						end
					end
				end
				if not found then
					hasstorage = false
				end
			end
		else
			if #menu.constructionplan > 0 then
				for i = menu.newModulesIndex, #menu.constructionplan do
					if menu.changedModulesIndices[i] then
						local entry = menu.constructionplan[i]
						if IsMacroClass(entry.macro, "storage") then
							local data = GetLibraryEntry("moduletypes_storage", entry.macro)
							if data.storagetags[transporttype] then
								planned = true
								hasstorage = true
								break
							end
						end
					end
				end
			end
		end

		local warenode = Helper.createLSOStorageNode(menu, menu.container, productiondata.ware, planned, hasstorage)
		table.insert(nodes, warenode)
		warenodes[productiondata.ware] = warenode
	end
	return warenodes[productiondata.ware]
end

local function addFlowchartEdge(node1, node2)
	if not node1 or not node2 then DebugError(TraceBack()) end
	node2.predecessors = node2.predecessors or { }
	node2.predecessors[node1] = (node1.type == "solid" and 3 or (node1.type == "liquid" and 2 or 1))
end

function menu.getFlowchartProductionNodes()
	if menu.isdummy then
		return menu.getFlowchartDummyProductionNodes()
	end

	local nodes = { }
	local warenodes = { }

	local workforcevisible =			C.IsInfoUnlockedForPlayer(menu.container, "efficiency_amount")
	local productioninfo_resources =	C.IsInfoUnlockedForPlayer(menu.container, "production_resources")

	local buildmodules = {}
	Helper.ffiVLA(buildmodules, "UniverseID", C.GetNumBuildModules, C.GetBuildModules, menu.container)
	for i, buildmodule in ipairs(buildmodules) do
		local docksizes = GetComponentData(ConvertStringToLuaID(tostring(buildmodule)), "docksizes")
		local buildclass = "ship_s"
		if docksizes.docks_xl > 0 then
			buildclass = "ship_xl"
		elseif docksizes.docks_l > 0 then
			buildclass = "ship_l"
		elseif docksizes.docks_m > 0 then
			buildclass = "ship_m"
		end
		buildmodules[i] = { component = buildmodule, class = buildclass }
	end
	table.sort(buildmodules, Helper.sortClass)

	local buildresources = {}
	local n = C.GetNumContainerBuildResources(menu.container)
	local buf = ffi.new("const char*[?]", n)
	n = C.GetContainerBuildResources(buf, n, menu.container)
	for i = 0, n - 1 do
		buildresources[ffi.string(buf[i])] = true
	end

	-- analyse construction plan (if any)
	menu.constructionplan = {}
	menu.newModulesIndex = 0
	menu.removedModules = {}
	if GetComponentData(menu.containerid, "isplayerowned") then
		local n = C.GetNumBuildMapConstructionPlan(0, true)
		local buf = ffi.new("UIConstructionPlanEntry[?]", n)
		n = tonumber(C.GetBuildMapConstructionPlan(0, menu.container, true, buf, n))
		for i = 0, n - 1 do
			local entry = {}
			entry.idx                   = buf[i].idx
			entry.macro                 = ffi.string(buf[i].macroid)
			entry.component             = buf[i].componentid
			entry.offset                = buf[i].offset
			entry.connection            = ffi.string(buf[i].connectionid)
			entry.predecessoridx        = buf[i].predecessoridx
			entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)

			table.insert(menu.constructionplan, entry)
		end
		if #menu.constructionplan > 0 then
			menu.changedModulesIndices = {}
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedConstructionPlanModules2(0, menu.container, newIndex, true, numChangedIndices, false)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedConstructionPlanModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringTo64Bit(tostring(buf[i]))
					menu.removedModules[tostring(compID)] = true
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end
		else
			local n = C.GetNumPlannedStationModules(menu.container, true)
			local buf = ffi.new("UIConstructionPlanEntry[?]", n)
			n = C.GetPlannedStationModules(buf, n, menu.container, true)
			for i = 0, tonumber(n) - 1 do
				local entry = {}
				entry.idx                   = buf[i].idx
				entry.macro                 = ffi.string(buf[i].macroid)
				entry.component             = buf[i].componentid
				entry.offset                = buf[i].offset
				entry.connection            = ffi.string(buf[i].connectionid)
				entry.predecessoridx        = buf[i].predecessoridx
				entry.predecessorconnection = ffi.string(buf[i].predecessorconnectionid)

				table.insert(menu.constructionplan, entry)
			end

			menu.changedModulesIndices = {}
			local newIndex = ffi.new("uint32_t[1]", 0)
			local numChangedIndices = ffi.new("uint32_t[1]", 0)
			local n = C.GetNumRemovedStationModules2(menu.container, newIndex, numChangedIndices, false)
			menu.newModulesIndex = tonumber(newIndex[0]) + 1
			local buf = ffi.new("UniverseID[?]", n)
			local changedIndicesBuf = ffi.new("uint32_t[?]", numChangedIndices[0])
			n = tonumber(C.GetRemovedStationModules2(buf, n, changedIndicesBuf, numChangedIndices))
			if n > 0 then
				for i = 0, n - 1 do
					local compID = ConvertStringTo64Bit(tostring(buf[i]))
					menu.removedModules[tostring(compID)] = true
				end
			end
			if numChangedIndices[0] > 0 then
				for i = 0, numChangedIndices[0] - 1 do
					menu.changedModulesIndices[changedIndicesBuf[i]] = true
				end
			end
		end
	end

	local productionmoduledata = {}
	-- production modules and processing modules (normal, wrecked and in construction)
	local n = C.GetNumStationModules(menu.container, true, true)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, menu.container, true, true)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		local component, destroyedcomponent
		local isproduction = C.IsRealComponentClass(module, "production")
		local isprocessingmodule = C.IsRealComponentClass(module, "processingmodule")
		if isproduction or isprocessingmodule then
			if not C.IsComponentOperational(module) then
				if C.IsComponentWrecked(module) then
					destroyedcomponent = module
				elseif menu.removedModules[tostring(module)] then
					component = module
				end
			else
				component = module
			end
		end
		if component or destroyedcomponent then
			local macro = GetComponentData(module, "macro")
			--print("existing: " .. macro)
			if productionmoduledata[macro] then
				if component then
					table.insert(productionmoduledata[macro].components, component)
				elseif destroyedcomponent then
					table.insert(productionmoduledata[macro].destroyedcomponents, destroyedcomponent)
				end
			else
				if component then
					productionmoduledata[macro] = { macro = macro, components = { component }, destroyedcomponents = {}, numplanned = 0, isprocessingmodule = isprocessingmodule }
				elseif destroyedcomponent then
					productionmoduledata[macro] = { macro = macro, components = {}, destroyedcomponents = { destroyedcomponent }, numplanned = 0, isprocessingmodule = isprocessingmodule }
				end
			end
		end
	end
	-- go through all new modules
	if #menu.constructionplan > 0 then
		for i = menu.newModulesIndex, #menu.constructionplan do
			if menu.changedModulesIndices[i] then
				local entry = menu.constructionplan[i]
				if (entry.component == 0) or IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
					local isproduction = IsMacroClass(entry.macro, "production")
					local isprocessingmodule = IsMacroClass(entry.macro, "processingmodule")
					if isproduction or isprocessingmodule then
						if productionmoduledata[entry.macro] then
							local skip = false
							if entry.component ~= 0 then
								for _, destroyedcomponent in ipairs(productionmoduledata[entry.macro].destroyedcomponents) do
									if destroyedcomponent == entry.component then
										skip = true
										break
									end
								end
							end
							if not skip then
								--print("new: " .. entry.macro)
								productionmoduledata[entry.macro].numplanned = productionmoduledata[entry.macro].numplanned + 1
							end
						else
							--print("new: " .. entry.macro)
							productionmoduledata[entry.macro] = { macro = entry.macro, components = {}, destroyedcomponents = {}, numplanned = 1, isprocessingmodule = isprocessingmodule }
						end
					end
				end
			end
		end
	end

	local cargo = GetComponentData(menu.containerid, "cargo")

	for macro, data in pairs(productionmoduledata) do
		local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
		for _, productdata in ipairs(macrodata.products) do
			productdata.cycletime = productdata.cycle
			productdata.cycle = productdata.amount
			productdata.amount = cargo[productdata.ware] or 0
			local warenode = addFlowchartWareNode(nodes, warenodes, productdata)
			local resources = { }
			local productresources = productdata.resources
			-- link from resource ware nodes to the product ware node (note: ignoring secondary resources)
			for i, resourcedata in ipairs(productresources) do
				resourcedata.name = GetWareData(resourcedata.ware, "name")
				resourcedata.cycletime = resourcedata.cycle
				resourcedata.cycle = resourcedata.amount
				resourcedata.amount = cargo[resourcedata.ware] or 0
				local resourcenode = addFlowchartWareNode(nodes, warenodes, resourcedata)
				addFlowchartEdge(resourcenode, warenode)
				resources[resourcedata.ware] = true
			end
			local modulenode = {
				productionmodules = data,
				properties = {
					shape = "stadium",
					helpOverlayID = "station_overview_production_" .. productdata.ware,
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
					uiTriggerID = "production_" .. productdata.ware,
				},
				resources = resources,
				expandedTableNumColumns = 3,
				expandHandler = data.isprocessingmodule and menu.onExpandProcessing or menu.onExpandProduction,
				-- handle colors in update function
			}
			-- insert before last element, which is the storage module
			table.insert(warenode, #warenode, modulenode)
		end
	end

	local buildmodulenodes = {}
	for _, buildmodule in ipairs(buildmodules) do
		local warenode = {
			text = Helper.unlockInfo(productioninfo_resources, ffi.string(C.GetComponentName(buildmodule.component))),
			type = "container",
			{
				buildmodule = buildmodule.component,
				properties = { shape = "stadium" },
				resources = buildresources,
				expandedTableNumColumns = 4,
				expandHandler = menu.onExpandBuildModule,
				color = menu.removedModules[tostring(ConvertStringTo64Bit(tostring(buildmodule.component)))] and Color["lso_node_removed"] or nil,
			}
		}

		table.insert(nodes, warenode)
		table.insert(buildmodulenodes, warenode)
	end

	-- destroyed build modules
	local n = C.GetNumStationModules(menu.container, false, true)
	local buf = ffi.new("UniverseID[?]", n)
	n = C.GetStationModules(buf, n, menu.container, false, true)
	for i = 0, n - 1 do
		local module = ConvertStringTo64Bit(tostring(buf[i]))
		if not C.IsComponentOperational(module) then
			if C.IsRealComponentClass(module, "buildmodule") then
				local macro = GetComponentData(module, "macro")
				local data = GetLibraryEntry("moduletypes_build", macro)
				for _, waredata in ipairs(data.buildresources) do
					buildresources[waredata.ware] = true
				end

				local warenode = {
					text = Helper.unlockInfo(productioninfo_resources, data.name),
					type = "container",
					{
						buildmodule = { module, macro },
						properties = { shape = "stadium" },
						resources = buildresources,
						expandHandler = menu.onExpandDestroyedModule,
						color = Color["lso_node_inactive"],
						textcolor = Color["lso_node_error"],
						statuscolor = Color["lso_node_error"],
						statusIcon = "lso_warning",
					}
				}

				table.insert(nodes, warenode)
				table.insert(buildmodulenodes, warenode)
			end
		end
	end

	-- go through new buildmodules
	if #menu.constructionplan > 0 then
		for i = menu.newModulesIndex, #menu.constructionplan do
			if menu.changedModulesIndices[i] then
				local entry = menu.constructionplan[i]
				if (entry.component == 0) or IsComponentConstruction(ConvertStringTo64Bit(tostring(entry.component))) then
					if IsMacroClass(entry.macro, "buildmodule") then
						local data = GetLibraryEntry("moduletypes_build", entry.macro)
						for _, waredata in ipairs(data.buildresources) do
							buildresources[waredata.ware] = true
						end

						local warenode = {
							text = Helper.unlockInfo(productioninfo_resources, data.name),
							type = "container",
							{
								buildmodule = { entry.component, entry.macro },
								properties = { shape = "stadium" },
								resources = buildresources,
								expandHandler = menu.onExpandPlannedBuildModule,
								color = Color["lso_node_inactive"],
							}
						}

						table.insert(nodes, warenode)
						table.insert(buildmodulenodes, warenode)
					end
				end
			end
		end
	end

	-- buildmodule resource edges
	local cargo = GetComponentData(menu.containerid, "cargo")
	for ware in pairs(buildresources) do
		local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = ware, name = GetWareData(ware, "name"), amount = cargo[ware] })
		for _, buildmodulenode in ipairs(buildmodulenodes) do
			addFlowchartEdge(resourcenode, buildmodulenode)
		end
	end

	-- workforce
	local workforcenode = {
		workforce = true,
		text = ReadText(1001, 9415),
		type = "container",
		halign = "left",
		{
			properties = {
				shape = "hexagon",
				value = workforcevisible and function () local workforceinfo = C.GetWorkForceInfo(menu.container, ""); local total = C.ShouldContainerFillWorkforceCapacity(menu.container) and math.max(workforceinfo.optimal, workforceinfo.capacity) or workforceinfo.optimal; return (total ~= 0) and math.min(100, math.floor(workforceinfo.current / total * 100)) or 0 end or 0,
				max = 100,
				helpOverlayID = "station_overview_workforce",
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				uiTriggerID = "workforce",
			},
			resources = { },
			expandedTableNumColumns = 4,
			expandHandler = menu.onExpandWorkforce
		}
	}
	table.insert(nodes, workforcenode)
	local workforceraces = {}
	if C.IsComponentClass(menu.container, "container") then
		workforceraces = GetWorkForceRaceResources(menu.containerid)
	end
	if #workforceraces == 0 then
		workforcenode[1].color = Color["lso_node_inactive"]
		-- TODO: set statusIcon
		-- TODO: Handle case of workforce bonus being non-zero, but no habitation modules present
	else
		-- show workforce bonus in percent
		if workforcevisible then
			if (#GetProductionModules(menu.containerid) > 0) or GetComponentData(menu.containerid, "canequipships") then
				workforcenode[1].statusText = Helper.unlockInfo(workforcevisible, function () local workforceinfo = C.GetWorkForceInfo(menu.container, ""); return ConvertIntegerString(workforceinfo.current, true, 3, true, true) .. "/" .. ConvertIntegerString(C.ShouldContainerFillWorkforceCapacity(menu.container) and math.max(workforceinfo.optimal, workforceinfo.capacity) or workforceinfo.optimal, true, 3, true, true) end)
			end
		end
		-- link from resource ware nodes to the workforce node
		for _, racedata in ipairs(workforceraces) do
			for _, resourcedata in ipairs(racedata.resources) do
				local resourcenode = addFlowchartWareNode(nodes, warenodes, resourcedata)
				addFlowchartEdge(resourcenode, workforcenode)
				workforcenode[1].resources[resourcedata.ware] = true
			end
		end
	end

	-- research
	local researchnode
	if GetComponentData(menu.containerid, "isplayerowned") then
		local researchmodules = {}
		Helper.ffiVLA(researchmodules, "UniverseID", C.GetNumResearchModules, C.GetResearchModules, menu.container)
		for _, researchmodule in ipairs(researchmodules) do
			local researchmodule64 = ConvertStringTo64Bit(tostring(researchmodule))
			local proddata = GetProductionModuleData(researchmodule64)
			if (proddata.state == "producing") or (proddata.state == "waitingforresources") then
				researchnode = {
					research = true,
					text = ReadText(1001, 7400),
					type = "container",
					halign = "left",
					{
						researchmodule = researchmodule64,
						properties = {
							shape = "stadium",
							value = function() return Helper.round(math.max(1, GetProductionModuleData(researchmodule64).cycleprogress or 0)) end,
							max = 100,
						},
						resources = { },
						expandHandler = menu.onExpandResearch
					}
				}
				table.insert(nodes, researchnode)

				local resources = GetWareData(proddata.blueprintware, "resources")
				for _, resourcedata in ipairs(resources) do
					local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = resourcedata.ware, name = GetWareData(resourcedata.ware, "name"), amount = cargo[resourcedata.ware] or 0 })
					addFlowchartEdge(resourcenode, researchnode)
					researchnode[1].resources[resourcedata.ware] = true
				end
			end
		end
	end

	-- terraforming
	local terraformingnode
	if GetComponentData(menu.containerid, "isplayerowned") and C.IsHQ(menu.container) then
		local cluster = C.GetContextByClass(menu.container, "cluster", false)
		if GetComponentData(ConvertStringTo64Bit(tostring(cluster)), "hasterraforming") then
			local activeprojectid = ffi.string(C.GetTerraformingActiveProject(cluster))
			if activeprojectid ~= "" then
				local activeproject
				local n = C.GetNumTerraformingProjects(cluster, false)
				local buf = ffi.new("UITerraformingProject2[?]", n)
				n = C.GetTerraformingProjects2(buf, n, cluster, false)
				for i = 0, n - 1 do
					local entry = Helper.getProjectEntry(cluster, buf[i], false)
					if entry.id == activeprojectid then
						activeproject = entry
						break
					end
				end
				if activeproject ~= nil then
					terraformingnode = {
						terraforming = true,
						text = ReadText(1001, 3800),
						type = "container",
						halign = "left",
						{
							terraformingproject = { cluster = cluster, project = activeproject },
							properties = {
								shape = "stadium",
								value = function () return menu.nodevalueProject(cluster, activeproject) end,
								max = 100,
							},
							resources = { },
							expandHandler = menu.onExpandTerraforming
						}
					}
					table.insert(nodes, terraformingnode)

					for _, resourcedata in ipairs(activeproject.resources) do
						local resourcenode = addFlowchartWareNode(nodes, warenodes, { ware = resourcedata.ware, name = GetWareData(resourcedata.ware, "name"), amount = cargo[resourcedata.ware] or 0 })
						addFlowchartEdge(resourcenode, terraformingnode)
						terraformingnode[1].resources[resourcedata.ware] = true
					end
				else
					DebugError("Active terraforming project '" .. activeprojectid .. "' not found in list of projects of cluster '" .. ffi.string(C.GetComponentName(cluster)) .. "'.")
				end
			end
		end
	end

	return nodes, warenodes, workforcenode, researchnode, terraformingnode
end

function menu.updateDeliveredWares(cluster, project)
	local curtime = getElapsedTime()
	if (not menu.lastDeliveryUpdateTime) or (curtime > menu.lastDeliveryUpdateTime) then
		menu.lastDeliveryUpdateTime = curtime
		menu.deliveredwares = {}
		local buf_deliveredwares = ffi.new("UIWareInfo[?]", #project.resources)
		local num_deliveredwares = C.GetTerraformingProjectDeliveredResources(buf_deliveredwares, #project.resources, cluster, project.id)
		for i = 0, num_deliveredwares - 1 do
			menu.deliveredwares[ffi.string(buf_deliveredwares[i].ware)] = buf_deliveredwares[i].amount
		end
	end
end

function menu.nodevalueProject(cluster, project)
	local value = 0
	local scale = (#project.resources > 0) and ((project.duration == 0) and 100 or 66) or 0

	if C.HasTerraformingProjectStarted(cluster, project.id) then
		value = scale + C.GetTerraformingProjectCompletionFraction(cluster, project.id) * (100 - scale)
	else
		menu.updateDeliveredWares(cluster, project)
		local sumdeliveries, sumresources = 0, 0
		for _, entry in ipairs(project.resources) do
			local volume = GetWareData(entry.ware, "volume")
			sumresources = sumresources + entry.amount * volume
			sumdeliveries = sumdeliveries + (menu.deliveredwares[entry.ware] or 0) * volume
		end
		value = sumdeliveries / sumresources * scale
	end

	return value
end

function menu.getMissileAmount(defenceinfo_high)
	local total = 0
	local n = C.GetNumAllMissiles(menu.container)
	local buf = ffi.new("AmmoData[?]", n)
	n = C.GetAllMissiles(buf, n, menu.container)
	for j = 0, n - 1 do
		total = total + buf[j].amount
	end

	return defenceinfo_high and total or 0
end

function menu.getSupplyResourceValue(ware)
	local curtime = getElapsedTime()
	if menu.supplyResourceTimeStamp ~= curtime then
		menu.supplyResourceTimeStamp = curtime

		menu.supplyResources = {}
		local n = C.GetNumSupplyOrderResources(menu.container)
		menu.numSupplyResources = n
		local buf = ffi.new("SupplyResourceInfo[?]", n)
		n = C.GetSupplyOrderResources(buf, n, menu.container)
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i].ware)
			local total = buf[i].total
			local current = buf[i].current
			menu.supplyResources[ware] = { value = current, max = total }
		end
	end

	return menu.supplyResources[ware] and menu.supplyResources[ware].value or 0
end

function menu.getSupplyResourceMax(ware, raw)
	local curtime = getElapsedTime()
	if menu.supplyResourceTimeStamp ~= curtime then
		menu.supplyResourceTimeStamp = curtime

		menu.supplyResources = {}
		local n = C.GetNumSupplyOrderResources(menu.container)
		menu.numSupplyResources = n
		local buf = ffi.new("SupplyResourceInfo[?]", n)
		n = C.GetSupplyOrderResources(buf, n, menu.container)
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i].ware)
			local total = buf[i].total
			local current = buf[i].current
			menu.supplyResources[ware] = { value = current, max = total }
		end
	end

	if raw then
		return menu.supplyResources[ware] and menu.supplyResources[ware].max or 0
	else
		return menu.supplyResources[ware] and math.max(menu.supplyResources[ware].value, menu.supplyResources[ware].max) or 0
	end
end

function menu.setupFlowchartData()
	-- kuertee start: callback
	if menu.uix_callbacks ["setupFlowchartData_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["setupFlowchartData_on_start"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback

	local nodes, warenodes, workforcenode, researchnode, terraformingnode = menu.getFlowchartProductionNodes()

	-- assign numrows and numcols
	for _, node in ipairs(nodes) do
		local nummodules = #node
		if nummodules > 1 then
			node.numrows = nummodules - 1			-- n-1 production modules
			node.numcols = 2						-- 1 storage module
		end
	end

	-- enable shuffle for testing more random inputs
	--local shuffle = true
	if shuffle then
		for i = 1, #nodes - 1 do
			local rnd = math.random(i, #nodes)
			nodes[i], nodes[rnd] = nodes[rnd], nodes[i]
		end
		local str = ""
		for _, node in ipairs(nodes) do
			str = str .. node.text .. ", "
		end
		print(str)
	end

	-- separate all nodes that are connected to workforce via edges
	local workforcenodes = { }
	if workforcenode then
		-- repeated two-step process to find workforce-related nodes - necessary since we only know a node's predecessors, not its successors
		workforcenode.workforceRelated = true
		local processingqueue = { workforcenode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as workforce-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.workforceRelated then
							predecessor.workforceRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.workforceRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.workforceRelated then
							node.workforceRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move workforce-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.workforceRelated then
				table.remove(nodes, nodeidx)
				table.insert(workforcenodes, 1, node)
			end
		end
	end

	-- separate all nodes that are connected to research via edges
	local researchnodes = { }
	if researchnode then
		-- repeated two-step process to find research-related nodes - necessary since we only know a node's predecessors, not its successors
		researchnode.researchRelated = true
		local processingqueue = { researchnode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as research-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.researchRelated then
							predecessor.researchRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.researchRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.researchRelated then
							node.researchRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move research-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.researchRelated then
				table.remove(nodes, nodeidx)
				table.insert(researchnodes, 1, node)
			end
		end
	end

	-- separate all nodes that are connected to terraforming via edges
	local terraformingnodes = { }
	if terraformingnode then
		-- repeated two-step process to find terraforming-related nodes - necessary since we only know a node's predecessors, not its successors
		terraformingnode.terraformingRelated = true
		local processingqueue = { terraformingnode }
		while #processingqueue > 0 do
			-- mark all nodes in the queue and their ancestors as terraforming-related
			while #processingqueue > 0 do
				local node = table.remove(processingqueue, 1)
				if node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if not predecessor.terraformingRelated then
							predecessor.terraformingRelated = true
							table.insert(processingqueue, predecessor)
						end
					end
				end
			end
			-- fill queue with unmarked successors of marked nodes
			for _, node in ipairs(nodes) do
				if not node.terraformingRelated and node.predecessors then
					for predecessor, _ in pairs(node.predecessors) do
						if predecessor.terraformingRelated then
							node.terraformingRelated = true
							table.insert(processingqueue, node)
							break
						end
					end
				end
			end
		end
		-- move terraforming-related nodes to other table
		for nodeidx = #nodes, 1, -1 do
			local node = nodes[nodeidx]
			if node.terraformingRelated then
				table.remove(nodes, nodeidx)
				table.insert(terraformingnodes, 1, node)
			end
		end
	end

	local flowchartsections = { }
	if #nodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(nodes)
		table.insert(flowchartsections, { nodes = nodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #researchnodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(researchnodes)
		table.insert(flowchartsections, { nodes = researchnodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #terraformingnodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(terraformingnodes)
		table.insert(flowchartsections, { nodes = terraformingnodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	if #workforcenodes > 0 then
		local numrows, numcols, junctions = Helper.setupDAGLayout(workforcenodes)
		table.insert(flowchartsections, { nodes = workforcenodes, junctions = junctions, numrows = numrows, numcols = numcols })
	end
	-- if one of the two production sections has a production module that doesn't require resources (e.g. Energy Cells production),
	-- the production module is located in the very first column and the associated storage module in the second column (in same node with numcols = 2).
	-- Within the same section, all storage modules in the first tier will be right-aligned and end up in the second column,
	-- but for all other sections in the flowchart we have to do this manually, so there are no storage modules in the first column.
	menu.startwithproduction = false
	for _, section in ipairs(flowchartsections) do
		for _, node in ipairs(section.nodes) do
			if node.col == 1 then
				local nummodules = #node
				if nummodules > 1 then
					section.startswithproduction = true
					menu.startwithproduction = true
					break
				end
			end
		end
	end

	-- protectyon section
	if not menu.isdummy then
		local condensateware = "condensate"
		local transporttype = GetWareData(condensateware, "transport")
		local sector, haswaveprotectionmodule = GetComponentData(menu.containerid, "sectorid", "haswaveprotectionmodule")
		local sectorcontainsthewave = GetComponentData(sector, "containsthewave")
		local hascondensatestorage = false
		if C.IsComponentClass(menu.container, "container") then
			hascondensatestorage = CheckSuitableTransportType(menu.containerid, condensateware)
		end
		if #menu.constructionplan > 0 then
			local found = false
			for i = 1, #menu.constructionplan do
				local entry = menu.constructionplan[i]
				if IsMacroClass(entry.macro, "storage") then
					local data = GetLibraryEntry("moduletypes_storage", entry.macro)
					if data.storagetags[transporttype] then
						found = true
						break
					end
				end
			end
			if not found then
				hascondensatestorage = false
			end
		end

		if sectorcontainsthewave and hascondensatestorage then
			local condensatenodes = {}

			local condensateshieldnode
			if haswaveprotectionmodule then
				local production_products =	C.IsInfoUnlockedForPlayer(menu.container, "production_products")
				-- add condensate shield node
				condensateshieldnode = {
					condensateshield = condensateware,
					text = Helper.unlockInfo(production_products, ReadText(20104, 92501)),
					type = transporttype,
					row = 1, col = 2, numrows = 1, numcols = 1,
					{
						properties = {
							value = 0,
							max = 0,
							shape = "hexagon",
						},
						expandedTableNumColumns = 2,
						expandHandler = menu.onExpandCondensateShield,
					}
				}
				table.insert(condensatenodes, condensateshieldnode)
			end

			-- add condensate storage node
			local node = Helper.createLSOStorageNode(menu, menu.container, condensateware, false, true, true)
			table.insert(condensatenodes, node)
			warenodes[condensateware] = node
			if condensateshieldnode then
				addFlowchartEdge(node, condensateshieldnode)
			end

			table.insert(flowchartsections, { nodes = condensatenodes, junctions = { }, numrows = 1, numcols = 2 })
		end
	end

	-- supply section
	local nodes = {}
	-- Add drone node
	local unitstoragedata = (menu.container and C.IsComponentClass(menu.container, "container")) and GetUnitStorageData(menu.containerid) or nil
	local unitinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "units_capacity")
	local unitinfo_amount =		C.IsInfoUnlockedForPlayer(menu.container, "units_amount")

	local supplynodecount = 0
	local dronesnode, missilesnode
	if unitstoragedata then
		local shownamount = unitinfo_amount and unitstoragedata.stored or 0
		local shownmax = unitinfo_capacity and math.max(shownamount, unitstoragedata.capacity) or shownamount
		dronesnode = {
			drones = true,
			text = Helper.unlockInfo(unitinfo_capacity, ReadText(1001, 8)),
			type = "container",
			row = 1, col = 2, numrows = 1, numcols = 1,
			{
				properties = {
					value = function () local data = GetUnitStorageData(menu.containerid); return unitinfo_amount and data.stored or 0 end,
					max = shownmax,
					shape = "hexagon",
					helpOverlayID = "station_overview_drones",
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
					uiTriggerID = "drones",
				},
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupply,
				collapseHandler = menu.onCollapseSupply,
			}
		}
		dronesnode[1].statusText = function () local data = GetUnitStorageData(menu.containerid); return string.format("%s/%s", Helper.unlockInfo(unitinfo_amount, data.stored), Helper.unlockInfo(unitinfo_capacity, unitstoragedata.capacity)) end
		table.insert(nodes, dronesnode)
		supplynodecount = supplynodecount + 1
	end

	-- Add missile node
	local missilecapacity = GetComponentData(menu.containerid, "missilecapacity") or 0
	if missilecapacity > 0 then
		local defenceinfo_low =		C.IsInfoUnlockedForPlayer(menu.container, "defence_level")
		local defenceinfo_high =	C.IsInfoUnlockedForPlayer(menu.container, "defence_status")
		local total = 0
		local n = C.GetNumAllMissiles(menu.container)
		local buf = ffi.new("AmmoData[?]", n)
		n = C.GetAllMissiles(buf, n, menu.container)
		for j = 0, n - 1 do
			total = total + buf[j].amount
		end

		local shownamount = defenceinfo_high and total or 0
		local shownmax = defenceinfo_low and math.max(shownamount, missilecapacity) or shownamount
		missilesnode = {
			missiles = true,
			text = Helper.unlockInfo(defenceinfo_low, ReadText(1001, 2800)),
			type = "container",
			row = #nodes + 1, col = 2, numrows = 1, numcols = 1,
			{
				properties = {
					value = function () return menu.getMissileAmount(defenceinfo_high) end,
					max = shownmax,
					shape = "hexagon",
				},
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupply,
				collapseHandler = menu.onCollapseSupply,
			}
		}
		missilesnode[1].statusText = function () return string.format("%s/%s", Helper.unlockInfo(defenceinfo_high, menu.getMissileAmount(defenceinfo_high)), Helper.unlockInfo(defenceinfo_low, shownmax)) end
		table.insert(nodes, missilesnode)
		supplynodecount = supplynodecount + 1
	end

	-- supply resources
	local supplyresources = {}
	local n = C.GetNumSupplyOrderResources(menu.container)
	menu.numSupplyResources = n
	local buf = ffi.new("SupplyResourceInfo[?]", n)
	n = C.GetSupplyOrderResources(buf, n, menu.container)
	for i = 0, n - 1 do
		local ware = ffi.string(buf[i].ware)
		local total = buf[i].total
		local current = buf[i].current
		table.insert(supplyresources, { ware = ware, name = GetWareData(ware, "name"), max = total, value = current, supplytypes = ffi.string(buf[i].supplytypes) })
	end
	table.sort(supplyresources, Helper.sortName)

	local storageinfo_warelist =	C.IsInfoUnlockedForPlayer(menu.container, "storage_warelist")
	for i, entry in ipairs(supplyresources) do
		local hasrestrictions = C.GetContainerTradeRuleID(menu.container, "supply", entry.ware) > 0
		local transporttype = GetWareData(entry.ware, "transport")

		local warenode = {
			ware = entry.ware,
			text = Helper.unlockInfo(storageinfo_warelist, entry.name),
			type = transporttype,
			row = i, col = 1, numrows = 1, numcols = 1,
			{
				properties = {
					value = entry.value,
					max = math.max(entry.value, entry.max),
				},
				issupplyresource = true,
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandSupplyResource,
				statuscolor = hasrestrictions and Color["icon_warning"] or nil,
				statusIcon = hasrestrictions and "lso_error" or nil,
			}
		}
		table.insert(nodes, warenode)

		for supplytype in string.gmatch(entry.supplytypes, "%a+") do
			if dronesnode and (supplytype == "unit") then
				addFlowchartEdge(warenode, dronesnode)
			elseif missilesnode and (supplytype == "missile") then
				addFlowchartEdge(warenode, missilesnode)
			end
		end
	end

	table.insert(flowchartsections, { nodes = nodes, junctions = { }, numrows = math.max(#supplyresources, supplynodecount), numcols = 2 })

	-- add account section
	if C.IsComponentClass(menu.container, "container") and GetComponentData(menu.containerid, "isplayerowned") then
		local nodes = {}
		local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
		local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
		local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
		local budget = math.floor(productionmoney + supplymoney + tradewaremoney)

		local shownamount = money
		local shownmax = math.max(shownamount, budget)
		local accountnode = {
			account = true,
			text = ReadText(1001, 7710),
			type = "container",
			row = #nodes + 1, col = 1, numrows = 1, numcols = 1,
			{
				properties = {
					value = shownamount,
					max = shownmax,
				},
				expandedTableNumColumns = 2,
				expandHandler = menu.onExpandAccount,
				statusText = string.format("%s/%s %s", ConvertMoneyString(money, false, true, 3, true, false), ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 3, true, false), ReadText(1001, 101))
			}
		}
		table.insert(nodes, accountnode)
		table.insert(flowchartsections, { nodes = nodes, junctions = { }, numrows = #nodes, numcols = 1 })
	end

	-- Add non-production section
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "storage_capacity")
	local storageinfo_warelist =	C.IsInfoUnlockedForPlayer(menu.container, "storage_warelist")

	local cargo, tradewares, isplayerowned, resources = GetComponentData(menu.containerid, "cargo", "tradewares", "isplayerowned", "pureresources")
	local cargoandtrade = {}
	for ware, amount in pairs(cargo) do
		if (amount > 0) and (not warenodes[ware]) then
			cargoandtrade[ware] = amount
		end
	end
	for _, ware in ipairs(tradewares) do
		if (not cargoandtrade[ware]) and (not warenodes[ware]) then
			cargoandtrade[ware] = 0 -- assuming 0 due to no entry in cargo
		end
	end
	for _, ware in ipairs(resources) do
		if (not cargoandtrade[ware]) and (not warenodes[ware]) then
			cargoandtrade[ware] = 0 -- assuming 0 due to no entry in cargo
		end
	end

	local remainingcargonodes = { }
	for ware, amount in pairs(cargoandtrade) do
		local transporttype = GetWareData(ware, "transport")
		local hasstorage = true -- ware is in the current cargo list
		if #menu.constructionplan > 0 then
			local found = false
			for i = 1, #menu.constructionplan do
				local entry = menu.constructionplan[i]
				if IsMacroClass(entry.macro, "storage") then
					local data = GetLibraryEntry("moduletypes_storage", entry.macro)
					if data.storagetags[transporttype] then
						found = true
						break
					end
				end
			end
			if not found then
				hasstorage = false
			end
		end

		local node = Helper.createLSOStorageNode(menu, menu.container, ware, false, hasstorage, true)
		table.insert(remainingcargonodes, node)
	end
	-- sort to get a consistent result
	table.sort(remainingcargonodes, function (a, b) return a.text < b.text end)
	if isplayerowned and C.IsComponentClass(menu.container, "container") then
		-- kuertee start: callback
		if menu.uix_callbacks ["setupFlowchartData_pre_trade_wares_button"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["setupFlowchartData_pre_trade_wares_button"]) do
				uix_callback (remainingcargonodes)
			end
		end
		-- kuertee end: callback

		-- add trade wares option
		local node = {
			cargo = true,
			text = ReadText(1001, 6900),
			row = 1,
			col = 1,
			numrows = 1,
			numcols = 1,
			{
				properties = {
					helpOverlayID = "station_overview_tradewares",
					helpOverlayText = " ",
					helpOverlayHighlightOnly = true,
					uiTriggerID = "tradewares",
				},
				expandedFrameNumTables = 2,
				expandedTableNumColumns = 3,
				expandHandler = menu.onExpandTradeWares,
			}
		}
		table.insert(remainingcargonodes, node)
	end

	-- add flowchart section with all remaining wares
	if #remainingcargonodes > 0 then
		for nodeidx, node in ipairs(remainingcargonodes) do
			node.row = nodeidx
		end
		table.insert(flowchartsections, { nodes = remainingcargonodes, junctions = { }, numrows = #remainingcargonodes, numcols = 1 })
	end

	-- Merge all sections into a single flowchart
	local numrows = 0
	local numcols = 0
	local allnodes = { }
	local alljunctions = { }

	local startrow = 1
	for _, section in ipairs(flowchartsections) do
		local startcol = (menu.startwithproduction and not section.startswithproduction) and 2 or 1
		for _, node in ipairs(section.nodes) do
			node.row = node.row + startrow - 1
			node.col = node.col + startcol - 1
			table.insert(allnodes, node)
		end
		for _, junction in ipairs(section.junctions) do
			junction.row = junction.row + startrow - 1
			junction.col = junction.col + startcol - 1
			table.insert(alljunctions, junction)
		end
		numrows = startrow + section.numrows - 1
		numcols = math.max(numcols, section.numcols + startcol - 1)
		startrow = numrows + 2
	end

	menu.flowchartNumRows = numrows
	menu.flowchartNumCols = numcols
	menu.flowchartNodes = allnodes
	menu.flowchartJunctions = alljunctions
end

function menu.getFlowchartDummyProductionNodes()
	local nodeEnergy = { text = "Energy Cells", type = "container",
		{ properties = { width = 250, value = 600, max = 1000, slider1 = 450, step = 1 } }
	}
	local nodeMethane = { text = "Methane", type = "liquid",
		{ properties = { width = 250, value = 350, max = 1000, slider1 = 450, step = 1 } }
	}
	local nodeHelium = { text = "Helium", type = "liquid",
		{ properties = { width = 220, value = 10, max = 100, step = 1 } }
	}
	local nodeSilicon = { text = "Silicon", type = "solid",
		{ properties = { width = 250, value = 120, max = 200, step = 1 } }
	}
	local nodeHydrogen = { text = "Hydrogen", type = "liquid",
		{ properties = { width = 250, value = 0, max = 100, slider1 = 50, step = 1 } }
	}

	local nodeGraphene = { text = "Graphene", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 40, max = 100, slider1 = 50, slider2 = 15, step = 1, mouseOverText = "Mouse-over test 1: With slider text", slider1MouseOverText = "Buy slider", slider2MouseOverText = "Sell slider" } }
	}
	addFlowchartEdge(nodeEnergy, nodeGraphene)
	addFlowchartEdge(nodeMethane, nodeGraphene)

	local nodeCoolant = { text = "Superfluid Coolant", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusText = "<!>", color = Color["lso_node_error"] },
		{ properties = { width = 250, value = 60, max = 100, slider1 = 75, slider2 = 100, step = 1, mouseOverText = "Mouse-over test 2: Without slider text" } }
	}
	addFlowchartEdge(nodeEnergy, nodeCoolant)
	addFlowchartEdge(nodeHelium, nodeCoolant)

	local nodeWafers = { text = "Silicon Wafers", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 15, max = 100, slider1 = 40, slider2 = 50, step = 1, slider1MouseOverText = "Mouse-over test 3: Buy slider", slider2MouseOverText = "Mouse-over test 3: Sell slider" } }
	}
	addFlowchartEdge(nodeEnergy, nodeWafers)
	addFlowchartEdge(nodeSilicon, nodeWafers)
	addFlowchartEdge(nodeHydrogen, nodeWafers)

	local nodeAntimatter = { text = "Antimatter Cells", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory", color = Color["lso_node_error"] },
		{ properties = { width = 250, value = 30, max = 100, slider2 = 45, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeAntimatter)
	addFlowchartEdge(nodeHydrogen, nodeAntimatter)

	local nodeTubes = { text = "Quantum Tubes", type = "container",
		{ properties = { shape = "stadium", width = 250 }, statusIcon = "menu_inventory" },
		{ properties = { width = 250, value = 80, max = 100, slider2 = 50, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeTubes)
	addFlowchartEdge(nodeGraphene, nodeTubes)
	addFlowchartEdge(nodeCoolant, nodeTubes)

	local nodeMicrochips = { text = "Microchips", type = "container",
		{ properties = { shape = "stadium", width = 250 } },
		{ properties = { width = 250, value = 25, max = 100, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeMicrochips)
	addFlowchartEdge(nodeWafers, nodeMicrochips)

	local nodeClaytronics = { text = "Claytronics", type = "container",
		{ properties = { shape = "stadium", width = 250 } },
		{ properties = { width = 250, value = 10, max = 100, slider2 = 25, step = 1 } }
	}
	addFlowchartEdge(nodeEnergy, nodeClaytronics)
	addFlowchartEdge(nodeTubes, nodeClaytronics)
	addFlowchartEdge(nodeMicrochips, nodeClaytronics)
	addFlowchartEdge(nodeAntimatter, nodeClaytronics)

	-- Workforce
	local nodeMedical = { text = "Medical Supplies", type = "container",
		{ properties = { width = 250, value = 60, max = 100, slider1 = 60, step = 1 } }
	}
	local nodeFood = { text = "Food Rations", type = "container",
		{ properties = { width = 250, value = 60, max = 100, slider1 = 60, step = 1 } }
	}
	local nodeWorkforce = { workforce = true, text = "Workforce", type = "container",
		{ properties = { shape = "hexagon", width = 270, value = 66, max = 100 }, statusText = "66%" }
	}
	addFlowchartEdge(nodeMedical, nodeWorkforce)
	addFlowchartEdge(nodeFood, nodeWorkforce)

	local nodes = { nodeEnergy, nodeMethane, nodeHelium, nodeGraphene, nodeCoolant, nodeTubes, nodeSilicon, nodeHydrogen, nodeWafers, nodeAntimatter, nodeMicrochips, nodeClaytronics, nodeMedical, nodeFood, nodeWorkforce }
	for _, node in ipairs(nodes) do
		for _, modulenode in ipairs(node) do
			modulenode.expandHandler = menu.onExpandDummy
			modulenode.collapseHandler = menu.onCollapseDummy
		end
	end
	local warenodes = { }
	return nodes, warenodes, nodeWorkforce
end

function menu.display()
	--print("Displaying Menu")

	-- remove old data
	Helper.clearDataForRefresh(menu)

	local framewidth = Helper.viewWidth
	local frameheight = Helper.viewHeight
	local xoffset = 0
	local yoffset = 0

	menu.sidebarWidth = Helper.scaleX(Helper.sidebarWidth)
	menu.rightBarX = Helper.viewWidth - menu.sidebarWidth - Helper.frameBorder

	menu.frame = Helper.createFrameHandle(menu, { layer = config.mainFrameLayer, height = frameheight, width = framewidth, x = xoffset, y = yoffset })
	menu.frame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local usablewidth = menu.frame.properties.width - 2 * Helper.frameBorder

	local ftable, row
	ftable = menu.frame:addTable(1, { tabOrder = 1, width = usablewidth, x = Helper.frameBorder })
	ftable:setDefaultCellProperties("text", { halign = "center" })

	row = ftable:addRow(false)
	row[1]:createText(menu.title, Helper.headerRow1Properties)
	row = ftable:addRow(false)

	-- row[1]:createText(menu.container and GetComponentData(menu.containerid, "name") or "Flowchart Test")
	-- kuertee start: callback
	if menu.uix_callbacks ["display_get_station_name_extras"] then
		local stationName = menu.container and GetComponentData(menu.containerid, "name") or "Flowchart Test"
		local extraNames = {}
		if menu.container then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_get_station_name_extras"]) do
				table.insert(extraNames, uix_callback(menu.container))
			end
			if #extraNames > 0 then
				for i, extraName in ipairs(extraNames) do
					if i == 1 then
						stationName = stationName .. " (" .. extraName
					else
						stationName = stationName .. ", " .. extraName
					end
				end
				stationName = stationName .. ")"
			end
		end
		row[1]:createText(stationName)
	else
		row[1]:createText(menu.container and GetComponentData(menu.containerid, "name") or "Flowchart Test")
	end
	-- kuertee end: callback

	--row = ftable:addRow(false)
	--row[1]:createText("Antigone Memorial")

	usablewidth = menu.rightBarX - Helper.borderSize - Helper.frameBorder

	menu.flowchart = menu.frame:addFlowchart(menu.flowchartNumRows, menu.flowchartNumCols, { borderHeight = 3, borderColor = Color["row_background_blue"], minRowHeight = 45, minColWidth = 80, x = Helper.frameBorder, y = ftable:getVisibleHeight() + Helper.borderSize, width = usablewidth })
	menu.flowchart:setDefaultNodeProperties({
		expandedFrameLayer = config.expandedMenuFrameLayer,
		expandedTableNumColumns = 2,
		x = config.nodeoffsetx,
		width = config.nodewidth,
		statusBgIconRotating = true,
	})
	for col = 1, menu.flowchartNumCols, 1 do
		if col % 2 == (menu.startwithproduction and 1 or 0) then
			menu.flowchart:setColBackgroundColor(col, Color["row_background_blue"])
			menu.flowchart:setColumnCaption(col, ReadText(1001, 1600))
		else
			menu.flowchart:setColumnCaption(col, ReadText(1001, 1400))
		end
	end
	--menu.flowchart:setDefaultTextProperties({ fontsize = 8 })

	local containerSlotColor = Color["lso_slot_container"]
	local liquidSlotColor = Color["lso_slot_liquid"]
	local solidSlotColor = Color["lso_slot_solid"]
	local condensateSlotColor = Color["lso_slot_condensate"]
	local containerProp = { sourceSlotColor = containerSlotColor, sourceSlotRank = 1, destSlotColor = containerSlotColor, destSlotRank = 1 }
	local liquidProp = { sourceSlotColor = liquidSlotColor, sourceSlotRank = 2, destSlotColor = liquidSlotColor, destSlotRank = 2 }
	local solidProp = { sourceSlotColor = solidSlotColor, sourceSlotRank = 3, destSlotColor = solidSlotColor, destSlotRank = 3 }
	local condensateProp = { sourceSlotColor = condensateSlotColor, sourceSlotRank = 1, destSlotColor = condensateSlotColor, destSlotRank = 1 }

	menu.productionnodes = { }
	menu.processingnodes = { }
	menu.researchnodes = { }
	menu.buildnodes = { }
	menu.storagenodes = { }
	menu.supplyresourcenodes = { }
	menu.terraformingnodes = { }
	menu.accountnodes = { }

	-- Production nodes
	for _, nodedata in ipairs(menu.flowchartNodes) do
		local nummodules = #nodedata
		for moduleidx, moduledata in ipairs(nodedata) do
			local row = nodedata.row + (moduleidx == nummodules and math.floor((math.max(1, nummodules - 1) - 1) / 2) or moduleidx - 1)
			local col = nodedata.col + (moduleidx > 1 and moduleidx == nummodules and 1 or 0)
			local node = menu.flowchart:addNode(row, col, { nodedata = nodedata, moduledata = moduledata }, moduledata.properties):setText(nodedata.text)
			if moduledata.color then
				node.properties.outlineColor = moduledata.color
				node.properties.text.color = moduledata.color
				node.properties.statusColor = moduledata.color
			end
			if moduledata.textcolor then
				node.properties.text.color = moduledata.textcolor
			end
			if moduledata.statuscolor then
				node.properties.statusColor = moduledata.statuscolor
			end
			if moduledata.statusText then
				node:setStatusText(moduledata.statusText)
			elseif moduledata.statusIcon then
				node:setStatusIcon(moduledata.statusIcon)
			end
			if moduledata.expandedFrameNumTables then
				node.properties.expandedFrameNumTables = moduledata.expandedFrameNumTables
			end
			if moduledata.expandedTableNumColumns then
				node.properties.expandedTableNumColumns = moduledata.expandedTableNumColumns
			end
			if moduledata.productionmodules then
				if moduledata.productionmodules.isprocessingmodule then
					table.insert(menu.processingnodes, node)
				else
					table.insert(menu.productionnodes, node)
				end
			end
			if moduledata.researchmodule then
				table.insert(menu.researchnodes, node)
			end
			if moduledata.buildmodule then
				table.insert(menu.buildnodes, node)
				if menu.restoreNodeBuildModule and menu.restoreNodeBuildModule == moduledata.buildmodule then
					menu.restoreNode = node
					menu.restoreNodeBuildModule = nil
				end
			end
			if moduledata.terraformingproject then
				table.insert(menu.terraformingnodes, node)
			end
			if moduledata.isstorage then
				table.insert(menu.storagenodes, node)
				if menu.restoreNodeWare and menu.restoreNodeWare == nodedata.ware then
					menu.restoreNode = node
					menu.restoreNodeWare = nil
				end
			end
			if moduledata.issupplyresource then
				table.insert(menu.supplyresourcenodes, node)
				if menu.restoreNodeSupplyWare and menu.restoreNodeSupplyWare == nodedata.ware then
					menu.restoreNode = node
					menu.restoreNodeSupplyWare = nil
				end
			end
			if nodedata.account then
				table.insert(menu.accountnodes, node)
			end
			if menu.restoreNodeSupply then
				if nodedata.drones and (menu.restoreNodeSupply == "drones") then
					menu.restoreNode = node
					menu.restoreNodeSupply = nil
				elseif nodedata.missiles and (menu.restoreNodeSupply == "missiles") then
					menu.restoreNode = node
					menu.restoreNodeSupply = nil
				end
			end
			node.handlers.onExpanded = menu.onFlowchartNodeExpanded
			node.handlers.onCollapsed = menu.onFlowchartNodeCollapsed
			if moduledata.sliderHandler then
				node.handlers.onSliderChanged = function (_, slideridx, value) return moduledata.sliderHandler(node, nodedata, slideridx, value) end
			end
			moduledata.node = node
		end
		if nummodules > 1 then
			local storagenode = nodedata[nummodules].node
			for moduleidx = 1, nummodules - 1 do
				local productionnode = nodedata[moduleidx].node
				local edgecolor = nodedata[moduleidx].color
				local edge = productionnode:addEdgeTo(storagenode, nodedata.type == "solid" and solidProp or (nodedata.type == "liquid" and liquidProp or containerProp))
				if edgecolor then
					edge.properties.color = edgecolor
				end
			end
		end
	end
	for _, junctiondata in ipairs(menu.flowchartJunctions) do
		junctiondata.junction = menu.flowchart:addJunction(junctiondata.row, junctiondata.col)
	end
	-- Production edges
	for _, nodedata in ipairs(menu.flowchartNodes) do
		if nodedata.predecessors then
			for predecessor, slot in pairs(nodedata.predecessors) do
				local predecessorcell = predecessor.junction or predecessor[#predecessor].node
				if nodedata.junction then
					predecessorcell:addEdgeTo(nodedata.junction, slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp))
				else
					local nummodules = math.max(1, #nodedata - 1)
					for moduleidx = 1, nummodules do
						local destnode = nodedata[moduleidx].node
						local edgevalid = true
						if nodedata[moduleidx].resources then
							-- only link from predecessorcell to destnode if predecessorcell is a required resource
							local realpredecessor = predecessor
							while realpredecessor.junction do
								realpredecessor = next(realpredecessor.predecessors)
							end
							if not nodedata[moduleidx].resources[realpredecessor.ware] then
								edgevalid = false
							end
						end
						if edgevalid then
							local edgecolor = nodedata[moduleidx].color
							local edgeProperties = slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp)
							if nodedata.condensateshield then
								edgeProperties = condensateProp
							end
							local edge = predecessorcell:addEdgeTo(destnode, edgeProperties)
							if edgecolor then
								edge.properties.color = edgecolor
							end
						end
					end
				end
			end
		end
	end
	for _, junctiondata in ipairs(menu.flowchartJunctions) do
		if junctiondata.predecessors then
			for predecessor, slot in pairs(junctiondata.predecessors) do
				local predecessorcell = predecessor.junction or predecessor[#predecessor].node
				predecessorcell:addEdgeTo(junctiondata.junction, slot == 3 and solidProp or (slot == 2 and liquidProp or containerProp))
			end
		end
	end

	-- Economy statistics
	-- title table
	titletable = menu.frame:addTable(5, { tabOrder = 5, width = usablewidth, x = Helper.frameBorder, y = 0, reserveScrollBar = false, skipTabChange = true })
	local title = string.format(ReadText(1001, 6500), GetComponentData(menu.containerid, "name"))
	local titlewidth = C.GetTextWidth(title, Helper.headerRow1Font, Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize)) + 2 * (Helper.headerRow1Offsetx + Helper.borderSize)
	local checkboxwidth = Helper.scaleY(Helper.headerRow1Height) - Helper.borderSize
	titletable:setColWidth(2, checkboxwidth, false)
	titletable:setColWidth(3, titlewidth, false)
	titletable:setColWidth(4, checkboxwidth, false)

	row = titletable:addRow(false, { fixed = true })
	row[1]:setColSpan(5):createText("")
	-- title
	row = titletable:addRow(true, { fixed = true, borderBelow = false })
	row[2]:setBackgroundColSpan(2):createCheckBox(menu.showGraph, { height = checkboxwidth, scaling = false })
	row[2].handlers.onClick = menu.buttonShowGraph
	row[3]:createButton({ bgColor = Color["button_background_hidden"], height = Helper.headerRow1Height }):setText(title, { font = Helper.headerRow1Font, fontsize = Helper.headerRow1FontSize, x = Helper.headerRow1Offsetx, y = Helper.headerRow1Offsety, halign = "center" })
	row[3].handlers.onClick = menu.buttonShowGraph
	if menu.showGraph then
		row = titletable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(5):createText(" ", { fontsize = 1, height = 2 })
	end

	-- flowchart size
	if menu.showGraph then
		menu.flowchart.properties.maxVisibleHeight = math.floor((menu.frame:getAvailableHeight() - menu.flowchart.properties.y) / 2) - Helper.borderSize
	else
		menu.flowchart.properties.maxVisibleHeight = math.floor(menu.frame:getAvailableHeight() - menu.flowchart.properties.y) - Helper.borderSize - titletable:getFullHeight() - Helper.frameBorder
	end
	titletable.properties.y = menu.flowchart.properties.y + menu.flowchart.properties.maxVisibleHeight + Helper.borderSize

	if menu.showGraph then
		-- graph table
		local graphWidth = 4 * (usablewidth) / 5
		ftable = menu.frame:addTable(10, { tabOrder = 2, width = graphWidth, x = Helper.frameBorder, y = titletable.properties.y + titletable:getVisibleHeight() + Helper.borderSize, reserveScrollBar = false })
		for i = 2, 9 do
			ftable:setColWidthPercent(i, 7)
		end

		local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
		local isplayerowned =			GetComponentData(menu.containerid, "isplayerowned")
		if not storageinfo_amounts then
			menu.graphmode = nil
		end
		if (menu.graphmode == "npcaccounts") and (not isplayerowned) then
			menu.graphmode = nil
		end

		-- mode buttons
		row = ftable:addRow(true, { fixed = true })
		row[2]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "tradeofferprices") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6504), { halign = "center" })
		row[2].handlers.onClick = function () return menu.buttonGraphMode("tradeofferprices") end
		row[4]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "tradeofferamounts") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6508), { halign = "center" })
		row[4].handlers.onClick = function () return menu.buttonGraphMode("tradeofferamounts") end
		row[6]:setColSpan(2):createButton({ active = storageinfo_amounts, bgColor = (menu.graphmode == "cargolevels") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6505), { halign = "center" })
		row[6].handlers.onClick = function () return menu.buttonGraphMode("cargolevels") end
		row[8]:setColSpan(2):createButton({ active = isplayerowned, bgColor = (menu.graphmode == "npcaccounts") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6506), { halign = "center" })
		row[8].handlers.onClick = function () return menu.buttonGraphMode("npcaccounts") end
		local buttonHeight = row:getHeight()
		-- graph cell
		row = ftable:addRow(false, { fixed = true })

		-- graph
		local graph = row[1]:setColSpan(10):createGraph({ height = menu.frame.properties.height - menu.frame:getUsedHeight() - 2 * buttonHeight - 3 * Helper.borderSize, scaling = false })

		local minY, maxY = 0, 1
		local hashighlight = false
		for i, entry in pairs(menu.showndata) do
			if menu.selectedrowdata == entry then
				hashighlight = true
				break
			end
		end
		for i, entry in pairs(menu.showndata) do
			if menu.graphmode == "cargolevels" then
				local highlight = menu.selectedrowdata == entry
				local color = config.graph.datarecordcolors[i].buy
				if hashighlight and (not highlight) then
					color.a = 50
				end
				local datarecord = graph:addDataRecord({
					markertype = config.graph.point.type,
					markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
					markercolor = color,
					linetype = config.graph.line.type,
					linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
					linecolor = color,
					mouseOverText = menu.graphdata[entry].text,
				})

				for i, point in pairs(menu.graphdata[entry].data) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
				end
			elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
				if next(menu.graphdata[entry].selldata) then
					local highlight = menu.selectedrowdata == entry
					local color = config.graph.datarecordcolors[i].sell
					if hashighlight and (not highlight) then
						color.a = 50
					end
					local datarecord = graph:addDataRecord({
						markertype = config.graph.point.type,
						markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
						markercolor = color,
						linetype = config.graph.line.type,
						linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
						linecolor = color,
						mouseOverText = ReadText(1001, 2917) .. ReadText(1001, 120) .. " " .. menu.graphdata[entry].text,
					})

					for i, point in pairs(menu.graphdata[entry].selldata) do
						minY = math.min(minY, point.y)
						maxY = math.max(maxY, point.y)
						datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
					end
				end

				if next(menu.graphdata[entry].buydata) then
					local highlight = menu.selectedrowdata == entry
					local color = config.graph.datarecordcolors[i].buy
					if hashighlight and (not highlight) then
						color.a = 50
					end
					local datarecord = graph:addDataRecord({
						markertype = config.graph.point.type,
						markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
						markercolor = color,
						linetype = config.graph.line.type,
						linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
						linecolor = color,
						mouseOverText = ReadText(1001, 2916) .. ReadText(1001, 120) .. " " .. menu.graphdata[entry].text,
					})

					for i, point in pairs(menu.graphdata[entry].buydata) do
						minY = math.min(minY, point.y)
						maxY = math.max(maxY, point.y)
						datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
					end
				end
			elseif menu.graphmode == "npcaccounts" then
				local highlight = menu.selectedrowdata == entry
				local color = config.graph.datarecordcolors[i].buy
				if hashighlight and (not highlight) then
					color.a = 50
				end
				local datarecord = graph:addDataRecord({
					markertype = config.graph.point.type,
					markersize = highlight and config.graph.point.highlightSize or config.graph.point.size,
					markercolor = color,
					linetype = config.graph.line.type,
					linewidth = highlight and config.graph.line.highlightSize or config.graph.line.size,
					linecolor = color,
					mouseOverText = menu.graphdata[entry].text,
				})

				for i, point in pairs(menu.graphdata[entry].data) do
					minY = math.min(minY, point.y)
					maxY = math.max(maxY, point.y)
					datarecord:addData((point.t - menu.xEnd) / menu.xScale, point.y, nil, nil)
				end
			end
		end

		local mingranularity = maxY / 12
		local maxgranularity = maxY / 8
		local granularity = 0.1
		for _, factor in ipairs(config.graph.factors) do
			local testgranularity = math.ceil(mingranularity / factor) * factor
			if testgranularity >= maxgranularity then
				break;
			end
			granularity = testgranularity
		end
		maxY = (math.ceil(maxY / granularity) + 0.5) * granularity

		local xRange = (menu.xEnd - menu.xStart) / menu.xScale
		local xGranularity = Helper.round(menu.xGranularity / menu.xScale, 3)
		local xOffset = xRange % xGranularity

		graph:setXAxis({ startvalue = -xRange, endvalue = 0, granularity = xGranularity, offset = xOffset, gridcolor = Color["graph_grid"] })
		graph:setXAxisLabel(menu.xTitle, { fontsize = 9 })
		graph:setYAxis({ startvalue = 0, endvalue = maxY, granularity = granularity, offset = 0, gridcolor = Color["graph_grid"] })
		graph:setYAxisLabel(menu.yTitle, { fontsize = 9 })

		-- time interval buttons
		row = ftable:addRow(true, { fixed = true })
		row[3]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "hour") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6501), { halign = "center" })
		row[3].handlers.onClick = function () return menu.buttonTimeFrame("hour") end
		row[5]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "day") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6502), { halign = "center" })
		row[5].handlers.onClick = function () return menu.buttonTimeFrame("day") end
		row[7]:setColSpan(2):createButton({ bgColor = (menu.timeframe == "week") and Color["row_background_selected"] or Color["row_title_background"] }):setText(ReadText(1001, 6503), { halign = "center" })
		row[7].handlers.onClick = function () return menu.buttonTimeFrame("week") end

		-- key table
		menu.keyTable = menu.frame:addTable(5, { tabOrder = 3, width = usablewidth - graphWidth - Helper.borderSize, x = Helper.frameBorder + graphWidth + Helper.borderSize, y = titletable.properties.y + titletable:getVisibleHeight() + Helper.borderSize })
		menu.keyTable:setColWidth(1, Helper.standardTextHeight)
		menu.keyTable:setColWidthPercent(3, 30)
		menu.keyTable:setColWidth(4, 1.5 * Helper.standardTextHeight)
		menu.keyTable:setColWidth(5, Helper.standardTextHeight)
		-- keys
		row = menu.keyTable:addRow(false, {  })
		row[1]:setColSpan(5):createText(ReadText(1001, 6523), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		for i = 1, config.graph.maxshowndata do
			local entry = menu.showndata[i]
			local color1 = config.graph.datarecordcolors[i].sell
			local color2 = config.graph.datarecordcolors[i].buy
			local data = menu.graphdata[entry]
			if entry then
				if (menu.graphmode == "cargolevels") or (menu.graphmode == "npcaccounts") then
					row = menu.keyTable:addRow(entry, {  })
					row[1]:setColSpan(3):createText(data.text, { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
					row[4]:createText(Helper.convertColorToText(config.graph.datarecordcolors[i].buy) .. "\27[solid]", { y = Helper.borderSize / 2 })
					row[5]:createButton({ height = 2 * Helper.standardTextHeight + Helper.borderSize }):setText("X", { halign = "center" })
					row[5].handlers.onClick = function () return menu.checkboxSelected(entry, row.index, 0) end
				elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
					row = menu.keyTable:addRow(entry, {  })
					row[1]:setColSpan(2):createText(data.text, { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
					row[3]:createText(ReadText(1001, 8309) .. ReadText(1001, 120) .. "\n" .. ReadText(1001, 8308) .. ReadText(1001, 120))
					row[4]:createText(Helper.convertColorToText(config.graph.datarecordcolors[i].buy) .. "\27[solid]\n" .. Helper.convertColorToText(config.graph.datarecordcolors[i].sell) .. "\27[solid]", { y = Helper.borderSize })
					row[5]:createButton({ height = 2 * Helper.standardTextHeight + Helper.borderSize }):setText("X", { halign = "center" })
					row[5].handlers.onClick = function () return menu.checkboxSelected(entry, row.index, 0) end
				end
			else
				row = menu.keyTable:addRow(false, {  })
				row[1]:setColSpan(5):createText("---", { minRowHeight = 2 * Helper.standardTextHeight + Helper.borderSize })
			end
		end
		-- data
		local row = menu.keyTable:addRow(false, {  })
		row[1]:setColSpan(5):createText(ReadText(1001, 6507), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		if storageinfo_amounts and ((menu.graphmode ~= "npcaccounts") or isplayerowned) then
			if menu.graphmode then
				if #menu.graphdata > 0 then
					--[[ No ware groups in X4 for now
					if menu.graphmode ~= "npcaccounts" then
						for i, group in ipairs(menu.groupedgraphdata) do
							local isextended = menu.isGroupExpanded(group.id)
							row = menu.keyTable:addRow(true, {  })
							row[1]:createButton({  }):setText(isextended and "-" or "+", { halign = "center" })
							row[1].handlers.onClick = function () return menu.buttonExtend(group.id, row.index) end
							row[2]:setColSpan(4):createText(group.name)
							if isextended then
								for j, dataIdx in ipairs(group) do
									local data = menu.graphdata[dataIdx]
									local row = menu.keyTable:addRow(true, {  })
									row[1]:createCheckBox(data.shown, { height = Helper.standardTextHeight, active = data.shown or (menu.numshowndata < config.graph.maxshowndata), mouseOverText = (data.shown or (menu.numshowndata < config.graph.maxshowndata)) and "" or ReadText(1026, 6500) })
									row[1].handlers.onClick = function () return menu.checkboxSelected(dataIdx, row.index, 1) end
									row[2]:setColSpan(4):createText(data.text)
								end
							end
						end
					else--]]
						for dataIdx, data in ipairs(menu.graphdata) do
							local row = menu.keyTable:addRow(dataIdx, {  })
							row[1]:createCheckBox(data.shown, { height = Helper.standardTextHeight, active = data.shown or (menu.numshowndata < config.graph.maxshowndata), mouseOverText = (data.shown or (menu.numshowndata < config.graph.maxshowndata)) and "" or ReadText(1026, 6500) })
							row[1].handlers.onClick = function () return menu.checkboxSelected(dataIdx, row.index, 1) end
							row[2]:setColSpan(4):createText(data.text)
						end
					--end
				else
					local row = menu.keyTable:addRow(dataIdx, {  })
					row[1]:setColSpan(5):createText(ReadText(1001, 6524))
				end
			else
				local row = menu.keyTable:addRow(dataIdx, {  })
				row[1]:setColSpan(5):createText(ReadText(1001, 6525))
			end
		else
			local row = menu.keyTable:addRow(dataIdx, {  })
			row[1]:setColSpan(5):createText(ReadText(1001, 6526))
		end

		menu.restoreTableState("keyTable", menu.keyTable)
	end

	menu.restoreFlowchartState("flowchart", menu.flowchart)

	Helper.createRightSideBar(menu.frame, menu.container, true, "logical", menu.buttonRightBar)

	-- display view/frame
	menu.frame:display()
end

function menu.isOptionSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedOptions) do
		if not menu.contextMenuData.origSelectedOptions[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedOptions) do
		if not menu.contextMenuData.selectedOptions[ware] then
			return true
		end
	end
	return false
end

function menu.onFlowchartNodeExpanded(node, frame, ftable, ftable2)
	node.flowchart:collapseAllNodes()
	local data = node.customdata
	local expandHandler = data.moduledata.expandHandler
	if expandHandler then
		menu.expandedNode = node
		menu.expandedMenuFrame = frame
		menu.expandedMenuTable = ftable
		expandHandler(frame, ftable, ftable2, data.nodedata, data.moduledata.productionmodules or data.moduledata.buildmodule or data.moduledata.researchmodule or data.moduledata.terraformingproject)
	end
end

function menu.onExpandTradeWares(frame, ftable, ftable2, nodedata)
	ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidthPercent(3, 50)
	ftable2:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable2:setColWidthPercent(3, 50)

	-- kuertee start: callback
	if menu.uix_callbacks ["onExpandTradeWares_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onExpandTradeWares_on_start"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback

	local excludedwares = {}, {}
	menu.selectedWares, menu.origSelectedWares = {}, {}
	local allresources, allproducts, cargo, rawtradewares = GetComponentData(menu.containerid, "allresources", "products", "cargo", "tradewares")
	for _, ware in ipairs(allresources) do
		excludedwares[ware] = true
	end
	for _, ware in ipairs(allproducts) do
		excludedwares[ware] = true
	end
	for ware in pairs(cargo) do
		excludedwares[ware] = true
	end
	for _, ware in ipairs(rawtradewares) do
		menu.origSelectedWares[ware] = true
		menu.selectedWares[ware] = true
	end

	local allwares = {}
	local n = C.GetNumWares("economy", false, "", "")
	local buf = ffi.new("const char*[?]", n)
	n = C.GetWares(buf, n, "economy", false, "", "")
	for i = 0, n - 1 do
		local ware = ffi.string(buf[i])
		if not excludedwares[ware] then

			-- kuertee start: callback
			if (not menu.uix_callbacks ["onExpandTradeWares_insert_ware_to_allwares"]) or (not next(menu.uix_callbacks ["onExpandTradeWares_insert_ware_to_allwares"])) then
				table.insert(allwares, { ware = ware, name = GetWareData(ware, "name") })
			elseif menu.uix_callbacks ["onExpandTradeWares_insert_ware_to_allwares"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["onExpandTradeWares_insert_ware_to_allwares"]) do
					uix_callback (allwares, ware)
				end
			end
			-- kuertee end: callback

		end
	end
	table.sort(allwares, Helper.sortName)

	for _, entry in ipairs(allwares) do
		local row = ftable:addRow(true, {  })
		row[1]:setBackgroundColSpan(3):createCheckBox(menu.selectedWares[entry.ware], { width = Helper.standardButtonHeight, height = Helper.standardButtonHeight, helpOverlayID = "station_overview_tradeware_option_" .. entry.ware, helpOverlayText = " ", helpOverlayHighlightOnly = true, helpOverlayUseBackgroundSpan = true, uiTriggerID = "tradeware_" .. entry.ware })
		row[1].handlers.onClick = function (_, checked) if checked then menu.selectedWares[entry.ware] = true else menu.selectedWares[entry.ware] = nil end end
		row[2]:setColSpan(2):createText(entry.name)
	end
	local row = ftable2:addRow(true, {  })
	row[1]:setColSpan(2):createButton({ active = function () return not menu.compareTradeWareSelection() end, uiTriggerID = "tradewares_confirm" }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.setTradeWares
	row[3]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[3].handlers.onClick = function () return menu.expandedNode:collapse() end

	local buttontableheight = ftable2:getFullHeight()
	local maxVisibleHeight = ftable:getFullHeight()
	if maxVisibleHeight + buttontableheight + Helper.borderSize > frame.properties.height then
		maxVisibleHeight = frame.properties.height - buttontableheight - Helper.borderSize
		ftable.properties.maxVisibleHeight = maxVisibleHeight
	end
	ftable2.properties.y = maxVisibleHeight + Helper.borderSize
end

function menu.onExpandSupplyResource(_, ftable, _, nodedata)
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(menu.container, "storage_capacity")
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")

	local reservations = {}
	local n = C.GetNumContainerWareReservations2(menu.container, false, false, true)
	local buf = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(buf, n, menu.container, false, false, true)
	for i = 0, n - 1 do
		local issupply = buf[i].issupply
		if issupply then
			local ware = ffi.string(buf[i].ware)
			local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
			local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
			local tradedeal = buf[i].tradedealid
			if not Helper.dirtyreservations[tostring(tradedeal)] then
				if reservations[ware] then
					table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal, issupply = issupply })
				else
					reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal, issupply = buf[i].issupply } }, [invbuyflag] = {} }
				end
			end
		end
	end
	for _, data in pairs(reservations) do
		table.sort(data.buyoffer, Helper.sortETA)
		table.sort(data.selloffer, Helper.sortETA)
	end

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row
	-- storage
	row = ftable:addRow(nil, {  })
	row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
	row[2]:setColSpan(2):createText(ReadText(1001, 11018), { halign = "right" })
	if C.IsComponentClass(menu.container, "container") then
		-- amount
		row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(
			function()
				local amount = menu.getSupplyResourceValue(nodedata.ware)
				local limit = menu.getSupplyResourceMax(nodedata.ware, true)
				return string.format("%s / %s", Helper.unlockInfo(storageinfo_amounts, ConvertIntegerString(amount, true, 3, true, true)), Helper.unlockInfo(storageinfo_capacity, ConvertIntegerString(limit, true, 3, true, true)))
			end,
			{ halign = "right" }
		)
		if GetComponentData(menu.containerid, "isplayerowned") then
			-- buy offer
			-- title
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 8309), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			-- automatic pricing
			local row = ftable:addRow("autobuypricecheckbox", {  })
			row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
			local avgprice, maxprice = GetWareData(nodedata.ware, "avgprice", "maxprice")
			row[2]:setColSpan(2):createText(RoundTotalTradePrice((avgprice + maxprice) / 2) .. " " .. ReadText(1001, 101), { halign = "right" })

			-- trade rule
			local hasownlist = C.HasContainerOwnTradeRule(menu.container, "supply", nodedata.ware)
			local traderuleid = C.GetContainerTradeRuleID(menu.container, "supply", nodedata.ware)
			local row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
			-- global
			local row = ftable:addRow("supplytraderule_global", {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
			row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
			row[3].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "supply", nodedata.ware, checked) end
			-- current
			local row = ftable:addRow("supplytraderule_current", {  })
			row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
			row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "supply", nodedata.ware, id) end
			row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
			row[3].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(menu.container, "supply", nodedata.ware)) end
			-- reservations
			if reservations[nodedata.ware] and (#reservations[nodedata.ware].buyoffer > 0) then
				-- title
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(string.format(ReadText(1001, 7994), GetWareData(nodedata.ware, "name")) .. ReadText(1001, 120), { wordwrap = true })
				for i, reservation in ipairs(reservations[nodedata.ware].buyoffer) do
					row = ftable:addRow("buyreservation" .. i, {  })
					if menu.selectedRowData["nodeTable"] == "buyreservation" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
					local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"
					row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					row[2]:createText(ConvertIntegerString(reservation.amount, true, 3, false), { halign = "right" })
					row[3]:createButton({ active = function () return Helper.buttonCancelTradeActive(menu, menu.container, reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
					row[3].handlers.onClick = function () return Helper.buttonCancelTrade(menu, menu.container, reservation.tradedeal) end
				end
			end
		end
	end

	if menu.selectedRowData["nodeTable"] then
		menu.selectedCols["nodeTable"] = nil
	end
	menu.restoreTableState("nodeTable", ftable)
end

function menu.compareTradeWareSelection()
	local tradewares = Helper.tableCopy(menu.origSelectedWares)
	for ware in pairs(menu.selectedWares) do
		if not tradewares[ware] then
			return false
		else
			tradewares[ware] = nil
		end
	end
	return next(tradewares) == nil
end

function menu.setTradeWares()
	local tradewares = Helper.tableCopy(menu.origSelectedWares)
	for ware in pairs(menu.selectedWares) do
		if not tradewares[ware] then
			-- add
			C.AddTradeWare(menu.container, ware)
		else
			-- nothing to do
			tradewares[ware] = nil
		end
	end
	for ware in pairs(tradewares) do
		-- remove
		C.ClearContainerBuyLimitOverride(menu.container, ware)
		C.SetContainerWareIsBuyable(menu.container, ware, false)
		ClearContainerWarePriceOverride(menu.containerid, ware, true)

		C.ClearContainerSellLimitOverride(menu.container, ware)
		C.SetContainerWareIsSellable(menu.container, ware, false)
		ClearContainerWarePriceOverride(menu.containerid, ware, false)

		ClearContainerStockLimitOverride(menu.containerid, ware)
		C.RemoveTradeWare(menu.container, ware)
	end

	menu.setupFlowchartData()
	menu.refresh = true
	menu.expandedNode:collapse()
end

function menu.onExpandProduction(_, ftable, _, nodedata, productionmodules)
	local productioninfo_products, productioninfo_rate, productioninfo_resources
	local isplayerowned = GetComponentData(menu.containerid, "isplayerowned")
	if isplayerowned then
		productioninfo_products, productioninfo_rate, productioninfo_resources = true, true, true
	end

	local nostorage, noresources, hacked, nonfunctional, destroyed, plannedremoval, planned, producing, paused, realpaused, queued = 0, 0, 0, 0, #productionmodules.destroyedcomponents, 0, productionmodules.numplanned, 0, 0, 0, 0
	local sunlight, workforce, hullefficiency
	for _, module in ipairs(productionmodules.components) do
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			productioninfo_products		= productioninfo_products	or C.IsInfoUnlockedForPlayer(module, "production_products")
			productioninfo_rate			= productioninfo_rate		or C.IsInfoUnlockedForPlayer(module, "production_rate")
			productioninfo_resources	= productioninfo_resources	or C.IsInfoUnlockedForPlayer(module, "production_resources")

			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				hullefficiency = hullefficiency or proddata.efficiency.efficiency
				sunlight = sunlight or proddata.efficiency.sunlight
				workforce = workforce or proddata.efficiency.work
			end
			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")

			local isqueued = true
			if proddata.state ~= "empty" then
				for _, product in ipairs(proddata.products) do
					if product.ware == nodedata.ware then
						isqueued = false
						break
					end
				end
			end

			if menu.removedModules[tostring(module)] then
				plannedremoval = plannedremoval + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ishacked then
				hacked = hacked + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ispausedmanually then
				paused = paused + 1
				realpaused = realpaused + 1
			elseif not isfunctional then
				nonfunctional = nonfunctional + 1
			elseif (proddata.state == "choosingitem") or (proddata.state == "waitingforstorage") then
				nostorage = nostorage + 1
			elseif proddata.state == "waitingforresources" then
				noresources = noresources + 1
			elseif isqueued then
				queued = queued + 1
			else
				producing = producing + 1
			end
		else
			plannedremoval = plannedremoval + 1
		end
	end

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidthPercent(3, 10)
	local row
	if productioninfo_rate then
		-- status
		local shown = false
		if destroyed > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8428) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(destroyed, { halign = "right", color = Color["text_error"] })
		end
		if nonfunctional > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8429) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(nonfunctional, { halign = "right", color = Color["text_error"] })
		end
		if hacked > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8430) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(hacked, { halign = "right", color = Color["text_error"] })
		end
		if paused > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8448) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_warning"] })
			row[3]:createText(paused, { halign = "right", color = Color["text_warning"] })
		end
		if queued > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8469) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_warning"] })
			row[3]:createText(queued, { halign = "right", color = Color["text_warning"] })
		end
		if noresources > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8431) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(noresources, { halign = "right", color = Color["text_error"] })
		end
		if nostorage > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8432) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_warning"] })
			row[3]:createText(nostorage, { halign = "right", color = Color["text_warning"] })
		end
		if planned > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8433) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(planned, { halign = "right" })
		end
		if plannedremoval > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8434) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(plannedremoval, { halign = "right" })
		end
		if shown then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText("")
		end
	end

	-- Pause
	if isplayerowned and (#productionmodules.components > 0) then
		row = ftable:addRow(true, {  })
		local allpaused = #productionmodules.components == realpaused
		row[1]:setColSpan(3):createButton({  }):setText(allpaused and ReadText(1001, 8450) or ReadText(1001, 8449), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonPauseProductionModules(productionmodules.components, not allpaused) end
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText("")
	end

	-- efficiency
	row = ftable:addRow(nil, {  })
	row[1]:createText(ReadText(1001, 1602) .. ReadText(1001, 120), { wordwrap = true })
	row[2]:setColSpan(2):createText(function() return menu.getProductionEfficiency(productionmodules.components) end, { halign = "right" })
	-- workforce
	if workforce then
		row = ftable:addRow(nil, {  })
		row[1]:createText("   " .. ReadText(1001, 9415) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(function() return menu.getProductionWorkforceEfficiency(productionmodules.components) end, { halign = "right" })
	end
	-- hull damage
	if hullefficiency then
		row = ftable:addRow(nil, {  })
		row[1]:createText("   " .. ReadText(1001, 8468) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(function() return menu.getProductionHullEfficiency(productionmodules.components) end, { halign = "right" })
	end
	-- sunlight
	if sunlight then
		row = ftable:addRow(nil, {  })
		row[1]:createText("   " .. ReadText(1001, 2412) .. ReadText(1001, 120), { wordwrap = true })
		row[2]:setColSpan(2):createText(sunlight.sunlight * 100 .. " %", { halign = "right" })
	end
	-- bonus products
	row = ftable:addRow(nil, {  })
	row[1]:createText(ReadText(1001, 8461) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120), { wordwrap = true })
	row[2]:setColSpan(2):createText(function() return menu.getProductionEfficiencyProducts(nodedata.ware, productionmodules.macro, producing) end, { halign = "right" })
	-- remaining cycle time
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(ReadText(1001, 8435) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(function() return menu.getProductionCycleTime(productionmodules.components) end, { halign = "right" })
	-- resource remaining time
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(ReadText(1001, 8409) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(function() return menu.getProductionRemainingTime(nodedata.ware, productionmodules.components, productionmodules.macro) end, { halign = "right" })
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText("")

	local macrodata = GetLibraryEntry(GetMacroData(productionmodules.macro, "infolibrary"), productionmodules.macro)
	local queueduration = 0
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == nodedata.ware then
			proddata = entry
		end
		queueduration = queueduration + entry.cycle
	end

	if proddata then
		local product = proddata.ware
		local baseamount = (queueduration > 0) and Helper.round(proddata.amount * 3600 / queueduration) or 0
		local currentamount = C.GetContainerWareProduction(menu.container, product, false)
		-- factor
		local factor = menu.showSingleProduction[productionmodules.macro] and 1 or producing
		row = ftable:addRow(true, {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 8462) .. ReadText(1001, 120))
		row[3]:createCheckBox(menu.showSingleProduction[productionmodules.macro], { width = Helper.standardButtonHeight, height = Helper.standardButtonHeight, active = (producing ~= 1) or (baseamount ~= currentamount) })
		row[3].handlers.onClick = function (_, checked) return menu.checkboxProductionSingle(productionmodules.macro, checked) end
		-- product
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
		row = ftable:addRow(nil, {  })
		row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(product, "name")))
		local amount = menu.showSingleProduction[productionmodules.macro] and baseamount or currentamount
		row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(amount, true, 0, true, false)), { halign = "right" })
		-- resources
		if #proddata.resources > 0 then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(proddata.resources) do
				row = ftable:addRow(nil, {  })
				local amount = menu.showSingleProduction[productionmodules.macro] and ((queueduration > 0) and Helper.round(factor * resourcedata.amount * 3600 / queueduration) or 0) or C.GetContainerWareConsumptionPerProduct(menu.container, resourcedata.ware, product, false)
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(resourcedata.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText("   ---")
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandProcessing(_, ftable, _, nodedata, processingmodules)
	local productioninfo_products, productioninfo_rate, productioninfo_resources
	local isplayerowned = GetComponentData(menu.containerid, "isplayerowned")
	if isplayerowned then
		productioninfo_products, productioninfo_rate, productioninfo_resources = true, true, true
	end

	local macrodata = GetLibraryEntry(GetMacroData(processingmodules.macro, "infolibrary"), processingmodules.macro)
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == nodedata.ware then
			proddata = entry
		end
	end

	local wares = ffi.new("UIWareAmount[?]", 1)
	wares[0].wareid = Helper.ffiNewString(nodedata.ware)
	wares[0].amount = proddata and proddata.amount or 1
	local isstoragefull = not C.AreWaresWithinContainerProductionLimits(menu.container, wares, 1)

	local rawproducts, rawresources = {}, {}
	local nostorage, noresources, hacked, nonfunctional, destroyed, plannedremoval, planned, producing, realpaused = 0, 0, 0, 0, #processingmodules.destroyedcomponents, 0, processingmodules.numplanned, 0, 0
	for _, module in ipairs(processingmodules.components) do
		local data = GetProcessingModuleData(module)
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			productioninfo_products		= productioninfo_products	or C.IsInfoUnlockedForPlayer(module, "production_products")
			productioninfo_rate			= productioninfo_rate		or C.IsInfoUnlockedForPlayer(module, "production_rate")
			productioninfo_resources	= productioninfo_resources	or C.IsInfoUnlockedForPlayer(module, "production_resources")

			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")

			if menu.removedModules[tostring(module)] then
				plannedremoval = plannedremoval + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ishacked then
				hacked = hacked + 1
				if ispausedmanually then
					realpaused = realpaused + 1
				end
			elseif ispausedmanually then
				realpaused = realpaused + 1
			elseif not isfunctional then
				nonfunctional = nonfunctional + 1
			elseif data.state == "waitingforstorage" then
				nostorage = nostorage + 1
			elseif data.state == "waitingforresources" then
				noresources = noresources + 1
			else
				producing = producing + 1

				for _, entry in ipairs(data.products) do
					rawproducts[entry.ware] = (rawproducts[entry.ware] or 0) + entry.amountperhour
				end
				for _, entry in ipairs(data.resources) do
					rawresources[entry.ware] = (rawresources[entry.ware] or 0) + entry.amountperhour
				end
			end
		else
			plannedremoval = plannedremoval + 1
		end
	end
	local products, resources = {}, {}
	for ware, amount in pairs(rawproducts) do
		table.insert(products, { ware = ware, amount = amount, name = GetWareData(ware, "name") })
	end
	table.sort(products, Helper.sortName)
	for ware, amount in pairs(rawresources) do
		table.insert(resources, { ware = ware, amount = amount, name = GetWareData(ware, "name") })
	end
	table.sort(resources, Helper.sortName)

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidthPercent(3, 10)
	local row
	if productioninfo_rate then
		-- status
		local shown = false
		if destroyed > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8428) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(destroyed, { halign = "right", color = Color["text_error"] })
		end
		if nonfunctional > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8429) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(nonfunctional, { halign = "right", color = Color["text_error"] })
		end
		if hacked > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8430) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(hacked, { halign = "right", color = Color["text_error"] })
		end
		if noresources > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8431) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_error"] })
			row[3]:createText(noresources, { halign = "right", color = Color["text_error"] })
		end
		if nostorage > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8432) .. ReadText(1001, 120), { wordwrap = true, color = Color["text_warning"] })
			row[3]:createText(nostorage, { halign = "right", color = Color["text_warning"] })
		end
		if planned > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8433) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(planned, { halign = "right" })
		end
		if plannedremoval > 0 then
			shown = true
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8434) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(plannedremoval, { halign = "right" })
		end
		if shown then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText("")
		end
	end

	-- Pause
	if isplayerowned and (#processingmodules.components > 0) then
		row = ftable:addRow(true, {  })
		local allpaused = #processingmodules.components == realpaused
		row[1]:setColSpan(3):createButton({  }):setText(allpaused and ReadText(1001, 8450) or ReadText(1001, 8449), { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonPauseProcessingModules(processingmodules.components, not allpaused) end
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText("")
	end

	-- remaining cycle time
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(ReadText(1001, 8435) .. ReadText(1001, 120), { wordwrap = true })
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(3):createText(function() return menu.getProcessingCycleTime(processingmodules.components) end, { halign = "right" })

	if next(products) then
		-- product
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
		for _, entry in ipairs(products) do
			row = ftable:addRow(nil, {  })
			row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(entry.ware, "name")))
			row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(entry.amount, true, 0, true, false)), { halign = "right" })
		end
		-- resources
		if #resources > 0 then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			for _, entry in ipairs(resources) do
				row = ftable:addRow(nil, {  })
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(entry.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(entry.amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText("   ---")
		end
	elseif proddata then
		-- product
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 1624) .. ReadText(1001, 120))
		row = ftable:addRow(nil, {  })
		row[1]:createText("   " .. Helper.unlockInfo(productioninfo_products, GetWareData(proddata.ware, "name")))
		row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(proddata.amount, true, 0, true, false)), { halign = "right" })
		-- resources
		if #proddata.resources > 0 then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(proddata.resources) do
				row = ftable:addRow(nil, {  })
				row[1]:createText("   " .. Helper.unlockInfo(productioninfo_resources, GetWareData(resourcedata.ware, "name")))
				row[2]:setColSpan(2):createText(Helper.unlockInfo(productioninfo_rate, ConvertIntegerString(resourcedata.amount, true, 0, true, false)), { halign = "right" })
			end
		else
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 7403) .. ReadText(1001, 120))
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText("   ---")
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getProductionEfficiency(modules)
	local efficiency, numproducing = 0, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					efficiency = efficiency + proddata.products.efficiency
				end
			end
		end
	end
	if numproducing > 0 then
		if efficiency > 0 then
			return Helper.round(efficiency / numproducing, 2) * 100 .. " %"
		else
			return ReadText(1001, 3210)
		end
	end
	return "- %"
end

function menu.getProductionEfficiencyProducts(ware, macro, producing)
	if producing > 0 then
		local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
		local proddata
		local queueduration = 0
		for _, entry in ipairs(macrodata.products) do
			if entry.ware == ware then
				proddata = entry
			end
			queueduration = queueduration + entry.cycle
		end

		if proddata then
			local product = proddata.ware
			local currentproduction = C.GetContainerWareProduction(menu.container, product, false)
			local baseproduction = (queueduration > 0) and (Helper.round(proddata.amount * 3600 / queueduration) * producing) or 0
			local diff = currentproduction - baseproduction
			return string.format("%s%d", (diff > 0) and (ColorText["text_positive"] .. "+") or ((diff < 0) and ColorText["text_negative"] or ""), diff)
		else
			return "-"
		end
	else
		return "-"
	end
end

function menu.getProductionWorkforceEfficiency(modules)
	local efficiency, numproducing, unlocked = 0, 0, false
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					unlocked = true
					efficiency = efficiency + proddata.efficiency.work.workforce * proddata.efficiency.work.product
				end
			end
		end
	end
	if numproducing > 0 then
		if not unlocked then
			return ReadText(1001, 3210)
		elseif efficiency > 0 then
			return Helper.round(1 + (efficiency / numproducing), 2) * 100 .. " %"
		end
	end
	return "- %"
end

function menu.getProductionHullEfficiency(modules)
	local efficiency, numproducing, unlocked = 0, 0, false
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_rate") then
					unlocked = true
					efficiency = efficiency + proddata.efficiency.efficiency.product
				end
			end
		end
	end
	if numproducing > 0 then
		if not unlocked then
			return ReadText(1001, 3210)
		elseif efficiency > 0 then
			return math.floor((efficiency / numproducing) * 100) .. " %"
		end
	end
	return "- %"
end

function menu.getProductionCycleTime(modules)
	local cycle, numproducing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "producing") then
				numproducing = numproducing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_time") then
					if cycle then
						cycle = math.min(cycle, proddata.remainingcycletime)
					else
						cycle = proddata.remainingcycletime
					end
				end
			end
		end
	end
	if numproducing > 0 then
		if cycle then
			return ConvertTimeString(cycle)
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.getProductionRemainingTime(ware, modules, macro)
	local storageinfo_amounts = C.IsInfoUnlockedForPlayer(menu.container, "storage_amounts")
	local remainingtime, numproducing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
				local isqueued = true
				for _, product in ipairs(proddata.products) do
					if product.ware == ware then
						isqueued = false
						break
					end
				end
				if (not ishacked) and isfunctional and (proddata.state == "producing") and (not isqueued) then
					numproducing = numproducing + 1
					if storageinfo_amounts then
						if remainingtime then
							remainingtime = math.max(remainingtime, proddata.remainingtime)
						else
							remainingtime = proddata.remainingtime
						end
					end
				end
			end
		end
	end
	if numproducing > 0 then
		if remainingtime then
			if remainingtime == 0 then
				return utf8.char(8734)
			else
				local macrodata = GetLibraryEntry(GetMacroData(macro, "infolibrary"), macro)
				local proddata
				for _, entry in ipairs(macrodata.products) do
					if entry.ware == ware then
						proddata = entry
						break
					end
				end
				if remainingtime < 2 * proddata.cycle then
					-- if we only have enough resources for one more production cycle, we don't need to consider the number of production modules
					return ConvertTimeString(remainingtime)
				else
					return ConvertTimeString(remainingtime / numproducing)
				end
			end
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.getProcessingCycleTime(modules)
	local cycle, numprocessing = nil, 0
	for _, module in ipairs(modules) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProcessingModuleData(module)
			local ishacked, isfunctional = GetComponentData(module, "ishacked", "isfunctional")
			if (not ishacked) and isfunctional and (proddata.state == "processing") then
				numprocessing = numprocessing + 1
				if C.IsInfoUnlockedForPlayer(module, "production_time") then
					if cycle then
						cycle = math.min(cycle, proddata.remainingcycletime)
					else
						cycle = proddata.remainingcycletime
					end
				end
			end
		end
	end
	if numprocessing > 0 then
		if cycle then
			return ConvertTimeString(cycle)
		else
			return ReadText(1001, 3210)
		end
	end
	return "-"
end

function menu.onExpandResearch(_, ftable, _, nodedata, researchmodule)
	local proddata = GetProductionModuleData(researchmodule)
	local researchtime, resources, precursors = 0, {}, {}
	if proddata.state ~= "empty" then
		researchtime, resources, precursors = GetWareData(proddata.blueprintware, "researchtime", "resources", "researchprecursors")
	end
	-- remaining time
	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(function () return menu.researchStateText(researchmodule) end)
	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(function () return menu.researchTimeText(researchmodule, researchtime) end, { halign = "right" })
	if proddata.state == "waitingforresources" then
		-- mission precursors
		local hasmissionprecursors = false
		for i, precursor in ipairs(precursors) do
			if GetWareData(precursor, "ismissiononly") and (not C.HasResearched(precursor)) then
				hasmissionprecursors = true
				break
			end
		end
		if (#precursors > 0) and hasmissionprecursors then
			local row = ftable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 7412) .. ReadText(1001, 120))
			for i, precursor in ipairs(precursors) do
				local name, ismissiononly = GetWareData(precursor, "name", "ismissiononly")
				if ismissiononly and (not C.HasResearched(precursor)) then
					local row = ftable:addRow(nil, { fixed = true })
					row[1]:setColSpan(2):createText("  " .. name)
				end
			end
		end
		-- resources
		if #resources > 0 then
			local row = ftable:addRow(nil, { fixed = true })
			row[1]:setColSpan(2):createText(ReadText(1001, 7411) .. ReadText(1001, 120))
			for _, resourcedata in ipairs(resources) do
				local locamount = C.GetAmountOfWareAvailable(resourcedata.ware, researchmodule)
				local color
				if locamount and (locamount < resourcedata.amount) then
					color = Color["text_warning"]
				end
				local row = ftable:addRow(nil, { fixed = true })
				local name = GetWareData(resourcedata.ware, "name")
				local resourcename = "  " .. name
				row[1]:createText(resourcename, { color = color })
				row[2]:createText((locamount and (locamount .. " / ") or "") .. resourcedata.amount, { halign = "right", color = color })
			end
		end
	end
end

function menu.researchStateText(researchmodule)
	local proddata = GetProductionModuleData(researchmodule)
	if proddata.state == "empty" then
		return ReadText(1001, 7408)
	elseif proddata.state == "waitingforresources" then
		return ReadText(1001, 4231) .. ReadText(1001, 120)
	end
	return ReadText(1001, 7409) .. ReadText(1001, 120)
end

function menu.researchTimeText(researchmodule, researchtime)
	local proddata = GetProductionModuleData(researchmodule)
	return (proddata.state == "waitingforresources") and ConvertTimeString(researchtime) or ConvertTimeString(researchmodule and (proddata.remainingcycletime or 0) or 0)
end

function menu.onExpandTerraforming(_, ftable, _, nodedata, project)
	ftable:setColWidthPercent(1, 66)
	ftable.properties.highlightMode = "grey"

	local shiptrader = GetComponentData(menu.containerid, "shiptrader")
	menu.updateDroneInfo(project.cluster, project.project)
	if (not project.project.isongoing) and ((shiptrader == nil) or ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) == 0)) then
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(2):createText(function () return menu.terraformingErrorText(project) end, { wordwrap = true, color = Color["text_error"] })

		ftable:addEmptyRow(Helper.standardTextHeight / 2)
	end

	-- queue
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 3804) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numbuildsinqueue), true, 0, true) end, { halign = "right" })
	-- progress
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 3803) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numbuildsinprogress), true, 0, true) end, { halign = "right" })
	-- in-flight
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 3805) .. ReadText(1001, 120))
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(function () menu.updateDroneInfo(project.cluster, project.project); return ConvertIntegerString(tonumber(menu.droneinfo.numcurrentdeliveries), true, 0, true) end, { halign = "right" })

	-- resources
	if #project.project.resources > 0 then
		ftable:addEmptyRow(Helper.standardTextHeight / 2)
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 3802) .. ReadText(1001, 120))
		for _, entry in ipairs(project.project.resources) do
			local row = ftable:addRow(true, {  })
			row[1]:createText("· " .. GetWareData(entry.ware, "name"))
			menu.updateDeliveredWares(project.cluster, project.project)
			row[2]:createText(function () menu.updateDeliveredWares(project.cluster, project.project); return ConvertIntegerString(menu.deliveredwares[entry.ware] or 0, true, 1, true) .. " / " .. ConvertIntegerString(entry.amount, true, 1, true) end, { halign = "right", mouseOverText = ConvertIntegerString(menu.deliveredwares[entry.ware] or 0, true, 0, true) .. " / " .. ConvertIntegerString(entry.amount, true, 0, true) })
		end
	end

	-- duration
	if project.project.duration > 0 then
		if not hasspacing then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
			hasspacing = true
		end
		local row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 3813) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 3800) })
		if project.project.isongoing then
			row[2]:createText(function () return ConvertTimeString(C.GetTerraformingProjectCompletionTime(project.cluster, project.project.id) - C.GetCurrentGameTime(), "%h:%M:%S") end, { halign = "right", mouseOverText = ReadText(1026, 3800) })
		else
			row[2]:createText(ConvertTimeString(project.project.duration, "%h:%M:%S"), { halign = "right", mouseOverText = ReadText(1026, 3800) })
		end
	end
end

function menu.terraformingErrorText(project)
	local name, shiptrader = GetComponentData(menu.containerid, "name", "shiptrader")
	if shiptrader then
		menu.updateDroneInfo(project.cluster, project.project)
		return ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) == 0) and ReadText(1001, 3845) or ""
	else
		return string.format(ReadText(1001, 11264), name)
	end
end

function menu.updateDroneInfo(cluster, project)
	local curtime = getElapsedTime()
	if (not menu.lastDroneInfoUpdateTime) or (curtime > menu.lastDroneInfoUpdateTime) then
		menu.lastDroneInfoUpdateTime = curtime
		menu.droneinfo = C.GetTerraformingProjectDroneStatus(cluster, project.id)
	end
end

function menu.onExpandDestroyedModule(_, ftable, _, nodedata, module)
	if GetComponentData(menu.containerid, "isplayerowned") then
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 8427), { color = Color["text_error"] })
	end
end

function menu.onExpandBuildModule(_, ftable, _, nodedata, buildmodule)
	local productioninfo_products =	C.IsInfoUnlockedForPlayer(buildmodule, "production_products")
	local productioninfo_time =		C.IsInfoUnlockedForPlayer(buildmodule, "production_time")

	local constructions = {}
	local n = C.GetNumBuildTasks(menu.container, buildmodule, true, true)
	local buf = ffi.new("BuildTaskInfo[?]", n)
	n = C.GetBuildTasks(buf, n, menu.container, buildmodule, true, true)
	for i = 0, n - 1 do
		table.insert(constructions, { id = buf[i].id, buildingcontainer = buf[i].buildingcontainer, component = buf[i].component, macro = ffi.string(buf[i].macro), factionid = ffi.string(buf[i].factionid), buildercomponent = buf[i].buildercomponent, price = buf[i].price, ismissingresources = buf[i].ismissingresources, queueposition = buf[i].queueposition, inprogress = true })
	end

	ftable:setColWidthPercent(1, 50)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidth(4, Helper.scaleY(Helper.standardButtonHeight), false)

	local ishacked = GetComponentData(ConvertStringTo64Bit(tostring(buildmodule)), "ishacked")
	if ishacked then
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(4):createText(ReadText(1001, 8426), { color = Color["text_error"], wordwrap = true })
	end

	if #constructions > 0 then
		for _, construction in ipairs(constructions) do
			local name = ReadText(20109, 5101)
			if construction.component ~= 0 then
				name = GetComponentName(ConvertStringTo64Bit(tostring(construction.component)), Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), config.nodewidth, nil, true)
			elseif construction.macro ~= "" then
				name = GetMacroData(construction.macro, "name")
			end
			local color = (productioninfo_products and (construction.factionid == "player")) and Color["text_player"] or Color["text_normal"]

			if construction.inprogress then
				local row = ftable:addRow(nil, {  })
				row[1]:setColSpan(4):createText(Helper.unlockInfo(productioninfo_products, name .. " (" .. ffi.string(C.GetObjectIDCode(construction.component)) .. ")"), { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
				local row = ftable:addRow(nil, {  })
				row[1]:createText(Helper.unlockInfo(productioninfo_time, function () return menu.getShipBuildProgress(construction.component, "") end), { color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
				row[2]:setColSpan(3):createText(Helper.unlockInfo(productioninfo_time, function () return (construction.ismissingresources and (ColorText["text_warning"] .. "\27[warning] ") or "") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(construction.buildercomponent), "%h:%M:%S") end), { halign = "right", color = color, mouseOverText = construction.ismissingresources and ReadText(1026, 3223) or "" })
			end
		end
	else
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(4):createText(Helper.unlockInfo(productioninfo_products, ReadText(1001, 8419)))
	end

	ftable:addEmptyRow()

	if GetComponentData(menu.containerid, "isplayerowned") then
		-- trade rule
		local hasownlist = C.HasContainerOwnTradeRule(menu.container, "build", "")
		local traderuleid = C.GetContainerTradeRuleID(menu.container, "build", "")
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(4):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
		-- global
		local row = ftable:addRow("buildtraderule_global", {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
		row[4]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
		row[4].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "build", "", checked) end
		-- current
		local row = ftable:addRow("buildtraderule_current", {  })
		row[1]:setColSpan(3):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "build", "", id) end
		row[4]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
		row[4].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(menu.container, "build", "")) end

		local row = ftable:addRow(false, {  })
		row[1]:setColSpan(4):createText("")

		-- price factor
		row = ftable:addRow(false, {  })
		row[1]:setColSpan(4):createText(ReadText(1001, 8425) .. ReadText(1001, 120), { wordwrap = true })
		row = ftable:addRow(true, {  })
		row[1]:setColSpan(4):createSliderCell({
			height = Helper.standardTextHeight,
			min = 50,
			max = 150,
			start = math.floor(C.GetContainerBuildPriceFactor(menu.container) * 100 + 0.5),
			hideMaxValue = true,
			suffix = "%",
		})
		row[1].handlers.onSliderCellChanged = function(_, value) return menu.slidercellBuildPriceFactor(menu.container, value) end
	end
end

function menu.onExpandPlannedBuildModule(_, ftable, _, nodedata, buildmodule)
	if GetComponentData(menu.containerid, "isplayerowned") then
		local data = GetLibraryEntry("moduletypes_build", buildmodule[2])

		local row
		-- build
		row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 8417) .. ReadText(1001, 120))
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(2):createText(function () return menu.getBuildProgress(menu.containerid, buildmodule[1]) end, { halign = "right" })
		if IsComponentConstruction(ConvertStringTo64Bit(tostring(buildmodule[1]))) then
			row = ftable:addRow(nil, {  })
			local buildingprocessor = GetComponentData(menu.container, "buildingprocessor")
			local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
			row[1]:setColSpan(2):createText(function () return menu.getBuildTime(buildmodule[1]) end, { halign = "right", mouseOverText = ismissingresources and ReadText(1026, 3223) or "" })
		end
	end
end

function menu.onExpandWorkforce(_, ftable, _, nodedata)
	ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
	ftable:setColWidthPercent(3, 30)
	ftable:setColWidth(4, Helper.scaleY(Helper.standardTextHeight), false)
	ftable.properties.highlightMode = "grey"

	local workforceinfo_all =	C.IsInfoUnlockedForPlayer(menu.container, "operator_name")

	local resourceinfos = {}
	if C.IsComponentClass(menu.container, "container") then
		resourceinfos = GetWorkForceRaceResources(menu.containerid)
	end

	local races = {}
	local n = C.GetNumAllRaces()
	local buf = ffi.new("RaceInfo[?]", n)
	n = C.GetAllRaces(buf, n)
	for i = 0, n - 1 do
		local entry = {}
		entry.id = ffi.string(buf[i].id)
		entry.name = ffi.string(buf[i].name)

		table.insert(races, entry)
	end
	table.sort(races, Helper.sortName)

	local row
	-- global
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 8412) .. ReadText(1001, 120), { wordwrap = true })
	row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").current, true, 0, true, false)) end, { halign = "right" })
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 9611) .. ReadText(1001, 120), { wordwrap = true })
	row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").capacity, true, 0, true, false)) end, { halign = "right" })
	-- optimal
	if (#GetProductionModules(menu.containerid) > 0) or GetComponentData(menu.containerid, "canequipships") then
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(4):createText(ReadText(1001, 8413) .. ReadText(1001, 120), { wordwrap = true })
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(4):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, "").optimal, true, 0, true, false)) end, { halign = "right" })
	end
	local shouldfill = C.ShouldContainerFillWorkforceCapacity(menu.container)
	if C.GetWorkForceInfo(menu.container, "").capacity > 0 then
		if GetComponentData(menu.containerid, "isplayerowned") then
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
			-- target
			row = ftable:addRow(true, {  })
			row[1]:createCheckBox(shouldfill, { height = Helper.standardButtonHeight })
			row[1].handlers.onClick = function(_, checked) return menu.checkboxSetWorkforceFill(menu.container) end
			row[2]:setColSpan(3):createText(ReadText(1001, 8453), { mouseOverText = ReadText(1026, 8406) })
			if shouldfill then
				-- employment target
				row = ftable:addRow(true, {  })
				row[1]:setColSpan(2):createText(ReadText(1001, 8455) .. ReadText(1001, 120), { wordwrap = true })
				row[3]:setColSpan(2):createText(function() local workforceinfo = C.GetWorkForceInfo(menu.container, ""); return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(workforceinfo.capacity, true, 0, true, false)) end, { halign = "right" })
			end
			ftable:addEmptyRow(Helper.standardTextHeight / 2)
		end
		-- efficiency
		row = ftable:addRow(true, {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 8464) .. ReadText(1001, 120), { wordwrap = true })
		row[3]:setColSpan(2):createText(function() return Helper.unlockInfo(workforceinfo_all, math.floor((GetComponentData(menu.containerid, "workforcebonus") or 0) * 100) .. " %") end, { halign = "right" })
		if GetComponentData(menu.containerid, "isplayerowned") then
			-- next update
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 8463), { wordwrap = true })
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(ReadText(1001, 8414) .. ReadText(1001, 120), { wordwrap = true })
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertTimeString(C.GetWorkForceInfo(menu.container, "").timeuntilnextupdate - C.GetCurrentGameTime())) end, { halign = "right" })
		end
	end
	for _, race in ipairs(races) do
		local workforceinfo = C.GetWorkForceInfo(menu.container, race.id)
		if workforceinfo.capacity > 0 then
			local workforceinfluencecounts = C.GetNumContainerWorkforceInfluence(menu.container, race.id, menu.forceNextWorkforceInfluenceUpdate or false)
			menu.forceNextWorkforceInfluenceUpdate = nil
			local buf = ffi.new("WorkforceInfluenceInfo")
			buf.capacityinfluences = Helper.ffiNewHelper("UIWorkforceInfluence[?]", workforceinfluencecounts.numcapacityinfluences)
			buf.numcapacityinfluences = workforceinfluencecounts.numcapacityinfluences
			buf.growthinfluences = Helper.ffiNewHelper("UIWorkforceInfluence[?]", workforceinfluencecounts.numgrowthinfluences)
			buf.numgrowthinfluences = workforceinfluencecounts.numgrowthinfluences
			C.GetContainerWorkforceInfluence(buf, menu.container, race.id)

			local workforceinfluences = {}
			workforceinfluences.capacityinfluences = {}
			for i = 0, buf.numcapacityinfluences - 1 do
				table.insert(workforceinfluences.capacityinfluences, {
					type = ffi.string(buf.capacityinfluences[i].type),
					name = ffi.string(buf.capacityinfluences[i].name),
					value = buf.capacityinfluences[i].value,
					active = buf.capacityinfluences[i].active,
				})
			end
			workforceinfluences.growthinfluences = {}
			for i = 0, buf.numgrowthinfluences - 1 do
				table.insert(workforceinfluences.growthinfluences, {
					type = ffi.string(buf.growthinfluences[i].type),
					name = ffi.string(buf.growthinfluences[i].name),
					value = buf.growthinfluences[i].value,
					active = buf.growthinfluences[i].active,
				})
			end
			workforceinfluences.basegrowth = buf.basegrowth
			workforceinfluences.capacity = buf.capacity
			workforceinfluences.current = buf.current
			workforceinfluences.sustainable = buf.sustainable
			workforceinfluences.target = buf.target
			workforceinfluences.change = buf.change

			-- title
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(4):createText(Helper.unlockInfo(workforceinfo_all, race.name), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			-- current
			row = ftable:addRow(true, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8412) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, race.id).current, true, 0, true, false)) end, { halign = "right", x = 0 })
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 9611) .. ReadText(1001, 120), { wordwrap = true })
			row[3]:createText(function() return Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(C.GetWorkForceInfo(menu.container, race.id).capacity, true, 0, true, false)) end, { halign = "right", x = 0 })
			-- sustainable
			row = ftable:addRow(true, {  })
			local mouseovertext = ""
			if workforceinfo_all then
				mouseovertext = ReadText(1026, 8405)
				local first = true
				for i, entry in ipairs(workforceinfluences.capacityinfluences) do
					if entry.active then
						if first then
							mouseovertext = ""
						else
							mouseovertext = mouseovertext .. "\n"
						end
						first = false
						mouseovertext = mouseovertext .. "· " .. entry.name .. ReadText(1001, 120) .. "  " .. Helper.convertColorToText((entry.value > 0) and Color["text_positive"] or ((entry.value < 0) and Color["text_negative"] or Color["text_normal"])) .. string.format("%+.0f%%", entry.value * 100) .. "\27X"
					end
				end
			end
			local icon = "widget_circle_01"
			local color = Color["icon_inactive"]
			if workforceinfluences.sustainable > workforceinfluences.capacity then
				icon = "widget_arrow_up_01"
				color = Color["text_positive"]
			elseif workforceinfluences.sustainable < workforceinfluences.capacity then
				icon = "widget_arrow_down_01"
				color = Color["text_negative"]
			end
			row[1]:setBackgroundColSpan(4):setColSpan(2):createText(ReadText(1001, 8454) .. ReadText(1001, 120), { mouseOverText = mouseovertext })
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(workforceinfluences.sustainable, true, 0, true, false)), { halign = "right", mouseOverText = mouseovertext, x = 0 })
			row[4]:createIcon(icon, { color = color, width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = mouseovertext })
			-- target
			row = ftable:addRow(true, {  })
			row[1]:setColSpan(2):createText(ReadText(1001, 8455) .. ReadText(1001, 120))
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, ConvertIntegerString(shouldfill and workforceinfluences.capacity or workforceinfluences.target, true, 0, true, false)), { halign = "right", x = 0 })
			-- change
			row = ftable:addRow(true, {  })
			local mouseovertext = ""
			if workforceinfo_all then
				mouseovertext = ReadText(20230, 1001) .. ReadText(1001, 120) .. "  " .. ColorText["text_positive"] .. string.format("%+.0f", workforceinfluences.basegrowth) .. "\27X"
				for i, entry in ipairs(workforceinfluences.growthinfluences) do
					if entry.active then
						mouseovertext = mouseovertext .. "\n· " .. entry.name .. ReadText(1001, 120) .. "  " .. Helper.convertColorToText((entry.value > 0) and Color["text_positive"] or ((entry.value < 0) and Color["text_negative"] or Color["text_normal"])) .. string.format("%+.0f%%", entry.value * 100) .. "\27X"
					end
				end
			end
			local icon = "widget_circle_01"
			local color = nil
			if workforceinfluences.change > 0 then
				icon = "widget_arrow_up_01"
				color = Color["text_positive"]
			elseif workforceinfluences.change < 0 then
				icon = "widget_arrow_down_01"
				color = Color["text_negative"]
			end
			row[1]:setBackgroundColSpan(4):setColSpan(2):createText(ReadText(1001, 8456) .. ReadText(1001, 120), { mouseOverText = mouseovertext })
			row[3]:createText(Helper.unlockInfo(workforceinfo_all, string.format("%+s", ConvertIntegerString(workforceinfluences.change, true, 0, true, false))), { halign = "right", color = color, mouseOverText = mouseovertext, x = 0 })
			row[4]:createIcon(icon, { color = color, width = Helper.standardTextHeight, height = Helper.standardTextHeight, mouseOverText = mouseovertext })

			-- resources
			if workforceinfo_all then
				local resourcedata
				for _, resourceinfo in ipairs(resourceinfos) do
					if resourceinfo.race == race.id then
						resourcedata = resourceinfo
					end
				end

				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(4):createText(ReadText(1001, 8451) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				for i, resource in ipairs(resourcedata.resources) do
					row = ftable:addRow(nil, {  })
					local amount = Helper.round(resource.cycle * 3600 / resource.cycleduration * workforceinfo.current / resourcedata.productamount)
					row[1]:setColSpan(2):createText("   " .. resource.name)
					row[3]:createText(ConvertIntegerString(amount, true, 0, true, false), { halign = "right", x = 0 })
				end
			end
		end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandCondensateShield(_, ftable, _, nodedata)
	local row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(20104, 92502), { wordwrap = true })

	ftable:addEmptyRow()

	local row = ftable:addRow(nil, {  })
	row[1]:createText(ReadText(30251, 1) .. ReadText(1001, 120))
	row[2]:createText("1" .. ReadText(1001, 42) .. " " .. GetWareData(nodedata.condensateshield, "name"), { halign = "right" })

	menu.restoreTableState("nodeTable", ftable)
end

function menu.onExpandSupply(_, ftable, _, nodedata)
	if nodedata.drones then
		AddUITriggeredEvent(menu.name, "expand_supply", "drones")
	end

	if not menu.supplyUpdateRegistered then
		RegisterEvent("supplyUpdate", menu.supplyUpdate)
		menu.supplyUpdateRegistered = true
	end

	local info_high =		nodedata.drones and C.IsInfoUnlockedForPlayer(menu.container, "units_amount") or C.IsInfoUnlockedForPlayer(menu.container, "defence_status")
	local info_low =		nodedata.drones and C.IsInfoUnlockedForPlayer(menu.container, "units_details") or C.IsInfoUnlockedForPlayer(menu.container, "defence_level")

	ftable:setColWidthPercent(2, 20)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row

	local supply_auto = {}
	menu.supplyoverride = {}
	menu.supplydefaults = {}
	local canequipships, isplayerowned = GetComponentData(menu.containerid, "canequipships", "isplayerowned")
	if isplayerowned then
		supply_auto["transport"]	= not C.IsSupplyManual(menu.container, "units_trade")
		supply_auto["defence"]		= not C.IsSupplyManual(menu.container, "units_defence")
		supply_auto["build"]		= not C.IsSupplyManual(menu.container, "units_build")
		supply_auto["repair"]		= not C.IsSupplyManual(menu.container, "units_repair")
		supply_auto["missile"]		= not C.IsSupplyManual(menu.container, "missiles")

		local n = C.GetNumSupplyOrders(menu.container, false)
		local buf = ffi.new("SupplyOverride[?]", n)
		n = C.GetSupplyOrders(buf, n, menu.container, false)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.supplyoverride[macro] = buf[i].amount
		end

		local n = C.GetNumSupplyOrders(menu.container, true)
		local buf = ffi.new("SupplyOverride[?]", n)
		n = C.GetSupplyOrders(buf, n, menu.container, true)
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macro)
			menu.supplydefaults[macro] = buf[i].amount
		end
	end

	menu.types = nodedata.drones and config.dronetypes or config.missilestypes
	local currentOrders = 0
	menu.supplies = {}
	for _, supplytypeentry in ipairs(menu.types) do
		menu.supplies[supplytypeentry.type] = {}
		if supplytypeentry.type == "missile" then
			local knownmacros = {}
			local n = C.GetNumBlueprints("", "missiletypes", "")
			local buf = ffi.new("UIBlueprint[?]", n)
			n = C.GetBlueprints(buf, n, "", "missiletypes", "")
			for i = 0, n - 1 do
				macro = ffi.string(buf[i].macro)

				if C.IsContainerAmmoMacroCompatible(menu.container, macro) then
					currentOrders = currentOrders + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					table.insert(menu.supplies[supplytypeentry.type], { name = GetMacroData(macro, "name"), macro = macro, stored = 0, compatible = true })
					knownmacros[macro] = #menu.supplies[supplytypeentry.type]
				end
			end

			local n = C.GetNumAllMissiles(menu.container)
			local buf = ffi.new("AmmoData[?]", n)
			n = C.GetAllMissiles(buf, n, menu.container)
			for j = 0, n - 1 do
				local macro = ffi.string(buf[j].macro)
				local amount = buf[j].amount

				if knownmacros[macro] then
					if not supply_auto[supplytypeentry.type] then
						currentOrders = currentOrders + amount
					end
					menu.supplies[supplytypeentry.type][knownmacros[macro]].stored = amount
				else
					if supply_auto[supplytypeentry.type] then
						currentOrders = currentOrders + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					else
						currentOrders = currentOrders + amount + (menu.supplyoverride[macro] or menu.supplydefaults[macro] or 0)
					end
					table.insert(menu.supplies[supplytypeentry.type], { name = GetMacroData(macro, "name"), macro = macro, stored = amount, compatible = false })
				end
			end
			menu.supplies[supplytypeentry.type].capacity = GetComponentData(menu.containerid, "missilecapacity")

			table.sort(menu.supplies[supplytypeentry.type], Helper.sortName)
		else
			local units = GetUnitStorageData(menu.containerid, supplytypeentry.type)
			for _, entry in ipairs(units) do
				if supply_auto[supplytypeentry.type] then
					currentOrders = currentOrders + (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)
				else
					currentOrders = currentOrders + entry.amount + (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)
				end
				table.insert(menu.supplies[supplytypeentry.type], { name = entry.name, macro = entry.macro, stored = entry.amount })
			end
			menu.supplies[supplytypeentry.type].capacity = units.capacity

			table.sort(menu.supplies[supplytypeentry.type], Helper.sortName)
		end
	end

	for _, supplytypeentry in ipairs(menu.types) do
		if (supplytypeentry.type ~= "build") or canequipships then
			if menu.supplies[supplytypeentry.type].capacity > 0 then
				-- title
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(Helper.unlockInfo(info_low, supplytypeentry.name), Helper.subHeaderTextProperties)
				row[1].properties.halign = "center"
				-- auto setting
				local auto
				if isplayerowned then
					auto = supply_auto[supplytypeentry.type]
					row = ftable:addRow(true, {  })
					row[1]:setColSpan(2):createText(supplytypeentry.autoname)
					row[3]:createCheckBox(auto, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return menu.checkboxSupplyAuto(menu.container, supplytypeentry.type, checked) end
				end
				-- available macros
				if #menu.supplies[supplytypeentry.type] > 0 then
					for i, entry in ipairs(menu.supplies[supplytypeentry.type]) do

						local limit = 0
						if auto then
							if menu.supplyoverride[entry.macro] then
								limit = menu.supplyoverride[entry.macro]
							else
								limit = menu.supplydefaults[entry.macro] or 0
							end
						end
						-- name
						row = ftable:addRow(true, {  })
						row[1]:createText(Helper.unlockInfo(info_low, entry.name))
						row[2]:setColSpan(2):createText(isplayerowned and function () return menu.supplies[supplytypeentry.type][i].stored .. menu.getManualOrder(entry.macro, auto) .. (auto and (" / " .. (menu.supplyoverride[entry.macro] or menu.supplydefaults[entry.macro] or 0)) or "") end or "", { halign = "right", color = (entry.compatible == false) and Color["text_inactive"] or Color["text_normal"] })
						-- amount
						local start = info_high and (auto and limit or (entry.stored + (menu.supplyoverride[entry.macro] or 0))) or 0
						local max = math.max(0, menu.supplies[supplytypeentry.type].capacity - currentOrders + start)
						local maxSelect = math.min(max, (entry.compatible == false) and entry.stored or max)
						start = math.min(maxSelect, math.max(0, start))
						row = ftable:addRow(true, {  })
						local slidercell = row[1]:setColSpan(3):createSliderCell({
							height = Helper.standardTextHeight,
							valueColor = Color["slider_value"],
							min = 0,
							maxSelect = maxSelect,
							max = max,
							start = start,
							hideMaxValue = true,
							readOnly = not isplayerowned,
						}):setText(ReadText(1001, 8415) .. ReadText(1001, 120), { color = (entry.compatible == false) and Color["text_inactive"] or Color["text_normal"] })
						row[1].handlers.onSliderCellChanged = function (_, value) menu.supplyoverride[entry.macro] = value - (auto and 0 or menu.supplies[supplytypeentry.type][i].stored) end
						row[1].handlers.onSliderCellConfirm = function (id, value) return menu.slidercellSupplyAmount(menu.container, entry.macro, auto, supplytypeentry.type, i, value) end
						row[1].handlers.onSliderCellActivated = function () return menu.slidercellSupplyAmountActivated(entry.macro) end
						row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end

						if entry.macro == menu.restoreSliderCellInput then
							menu.restoreSliderCellInput = slidercell
						end
					end
				else
					row = ftable:addRow(false, {  })
					row[1]:setColSpan(3):createText(ReadText(1001, 4235))
				end
			end
		end
	end

	if isplayerowned then
		-- trade rule
		local hasownlist = C.HasContainerOwnTradeRule(menu.container, "supply", "")
		local traderuleid = C.GetContainerTradeRuleID(menu.container, "supply", "")
		row = ftable:addRow(false, {  })
		row[1]:setColSpan(3):createText("")

		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(3):createText(ReadText(1001, 11030), Helper.subHeaderTextProperties)
		row[1].properties.halign = "center"
		-- global
		local row = ftable:addRow("supplytraderule_global", {  })
		row[1]:setColSpan(2):createText(ReadText(1001, 8367) .. ReadText(1001, 120), textproperties)
		row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
		row[3].handlers.onClick = function(_, checked) return menu.checkboxSetTradeRuleOverride(menu.container, "supply", "", checked) end
		-- current
		local row = ftable:addRow("supplytraderule_current", {  })
		row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
		row[1].handlers.onDropDownConfirmed = function (_, id) return menu.dropdownTradeRule(menu.container, "supply", "", id) end
		row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
		row[3].handlers.onClick = function () return menu.buttonEditTradeRule(C.GetContainerTradeRuleID(menu.container, "supply", "")) end
	end

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getManualOrder(macro, auto)
	local manualorder = ""
	if (not auto) and menu.supplyoverride[macro] then
		if menu.supplyoverride[macro] > 0 then
			manualorder = " " .. ColorText["text_positive"] .. "(+" .. menu.supplyoverride[macro] .. ")\27X"
		elseif menu.supplyoverride[macro] < 0 then
			manualorder = " " .. ColorText["text_negative"] .. "(" .. menu.supplyoverride[macro] .. ")\27X"
		end
	end

	return manualorder
end

function menu.slidercellSupplyAmountActivated(macro)
	if menu.refreshnode then
		-- We started slidercell input, but a menu update is pending. Let it update and re-activate input
		menu.restoreSliderCellInput = macro
	else
		menu.noupdate = true
	end
end

function menu.onExpandAccount(_, ftable, _, nodedata)
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = math.floor(productionmoney + supplymoney + trademoney)
	local playermoney = math.max(0, GetPlayerMoney())

	local row
	-- missing funds
	if money < budget then
		row = ftable:addRow(nil, {  })
		row[1]:setColSpan(2):createText(menu.getAccountWarningText, { color = menu.getAccountWarningColor, wordwrap = true })

		ftable:addEmptyRow(Helper.standardTextHeight / 2)
	end
	-- wanted money
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 1919) .. ReadText(1001, 120))
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ConvertMoneyString(budget, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- production and building
	row = ftable:addRow(nil, {  })
	local numproductionmodules = #GetProductionModules(menu.containerid)
	local numbuildmodules = C.GetNumBuildModules(menu.container)
	local text = ReadText(1001, 8420)
	if numbuildmodules > 0 then
		if numproductionmodules > 0 then
			text = ReadText(1001, 8422)
		else
			text = ReadText(1001, 8421)
		end
	end
	row[1]:setColSpan(2):createText(text .. ReadText(1001, 120))
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ConvertMoneyString(productionmoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- supplies
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 8423) .. ReadText(1001, 120))
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ConvertMoneyString(supplymoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	-- trade wares
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 8447) .. ReadText(1001, 120))
	row = ftable:addRow(nil, {  })
	row[1]:setColSpan(2):createText(ConvertMoneyString(trademoney, false, true, 0, true, false) .. " " .. ReadText(1001, 101), { halign = "right" })
	if row.index == menu.selectedRows.nodeTable then
		menu.selectedRows.nodeTable = menu.selectedRows.nodeTable + 1
	end
	-- current money
	row = ftable:addRow(true, {  })
	row[1]:setColSpan(2):createSliderCell({
		height = Helper.standardTextHeight,
		min = 0,
		max = playermoney + money,
		start = money,
		hideMaxValue = true,
		suffix = ReadText(1001, 101),
	}):setText(ReadText(1001, 7710))
	row[1].handlers.onSliderCellChanged = menu.slidercellAccount
	-- confirm
	row = ftable:addRow(true, {  })
	row[1]:createButton({ active = function () return (menu.newAccountValue ~= nil) and GetComponentData(menu.containerid, "isplayerowned") end }):setText(ReadText(1001, 2821), { halign = "center" })
	row[1].handlers.onClick = menu.buttonAccountConfirm
	row[2]:createButton({ active = function () local money, estimate, isplayerowned = GetComponentData(menu.containerid, "money", "productionmoney", "isplayerowned"); estimate = estimate + tonumber(C.GetSupplyBudget(menu.container)) / 100; estimate = estimate + tonumber(C.GetTradeWareBudget(menu.container)) / 100; return isplayerowned and ((money + GetPlayerMoney()) > estimate) end }):setText(ReadText(1001, 7965), { halign = "center" })
	row[2].handlers.onClick = menu.buttonAccountToEstimate

	menu.restoreTableState("nodeTable", ftable)
end

function menu.getAccountWarningText()
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = math.floor(productionmoney + supplymoney + trademoney)

	if money < budget then
		if money == 0 then
			return ReadText(1001, 8465)
		else
			return ReadText(1001, 8466)
		end
	end
	return ""
end

function menu.getAccountWarningColor()
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local trademoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = math.floor(productionmoney + supplymoney + trademoney)

	if money < budget then
		if money == 0 then
			return Color["text_error"]
		else
			return Color["text_warning"]
		end
	end
	return Color["text_normal"]
end

function menu.onExpandDummy(_, ftable, _, nodedata)
	local node = menu.expandedNode
	local maxcaptionlen = 100
	local maxstatuslen = 100

	-- caption and status
	menu.expandedDummyNodeText = node.properties.text.text
	local row = ftable:addRow(true)
	row[1]:createText("Caption length")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = maxcaptionlen, hideMaxValue = true, start = 10 })
	row[2].handlers.onSliderCellChanged = function(_, value)
		local str = ""
		for i = 1, value do
			str = str .. "-";
		end
		node:updateText(str)
	end

	local row = ftable:addRow(true)
	row[1]:createText("Status length")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = maxstatuslen, hideMaxValue = true, start = 10 })
	row[2].handlers.onSliderCellChanged = function(_, value)
		if value == maxstatuslen then
			node:updateStatus(nil, "lso_pie_09", "lso_progress")
		else
			local str = ""
			for i = 1, value do
				str = str .. "|";
			end
			node:updateStatus(str)
		end
	end

	if node.properties.max > 0 then
		-- separator
		local row = ftable:addRow(false)
		row[1]:setColSpan(2):createText("", { height = 1 })

		-- bar and sliders
		local row = ftable:addRow(true)
		row[1]:createText("Value")
		row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = node.properties.value })
		row[2].handlers.onSliderCellChanged = function(_, value) node:updateValue(math.min(value, node.properties.max)) end

		local row = ftable:addRow(true)
		row[1]:createText("Max")
		row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = node.properties.max, exceedMaxValue = true })
		row[2].handlers.onSliderCellChanged = function(_, value)
			if node.properties.value > value then node:updateValue(value) end
			if node.properties.slider1 > value then node:updateSlider1(value) end
			if node.properties.slider2 > value then node:updateSlider2(value) end
			node:updateMaxValue(value)
		end

		if node.properties.step > 0 then
			-- separator
			local row = ftable:addRow(false)
			row[1]:setColSpan(2):createText("", { height = 1 })

			local row = ftable:addRow(true)
			local sliderenabled = node.properties.slider1 >= 0
			local slidervalue = sliderenabled and node.properties.slider1 or 0
			row[1]:createText("Buy enabled")
			local checkbox = row[2]:createCheckBox(sliderenabled, { width = Helper.standardTextHeight })
			checkbox.handlers.onClick = function(_, checked) sliderenabled = checked; node:updateSlider1(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
			local row = ftable:addRow(true)
			row[1]:createText("Buy slider")
			row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = slidervalue })
			row[2].handlers.onSliderCellChanged = function(_, value) slidervalue = value; node:updateSlider1(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end

			local row = ftable:addRow(true)
			local sliderenabled = node.properties.slider2 >= 0
			local slidervalue = sliderenabled and node.properties.slider2 or 0
			row[1]:createText("Sell enabled")
			local checkbox = row[2]:createCheckBox(sliderenabled, { width = Helper.standardTextHeight })
			checkbox.handlers.onClick = function(_, checked) sliderenabled = checked; node:updateSlider2(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
			local row = ftable:addRow(true)
			row[1]:createText("Sell slider")
			row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = node.properties.max, start = slidervalue })
			row[2].handlers.onSliderCellChanged = function(_, value) slidervalue = value; node:updateSlider2(sliderenabled and math.min(slidervalue, node.properties.max) or -1) end
		end
	end

	-- separator
	local row = ftable:addRow(false)
	row[1]:setColSpan(2):createText("", { height = 1 })

	-- colors
	menu.expandedDummyNodeColor = node.properties.statusColor or node.properties.outlineColor
	local colorupdatefunc = function(value, colorprop)
		-- important: don't change elements of an existing color table, it may be referenced in several other places already, so always make a new copy first
		local color = { r = menu.expandedDummyNodeColor.r, g = menu.expandedDummyNodeColor.g, b = menu.expandedDummyNodeColor.b, a = menu.expandedDummyNodeColor.a }
		color[colorprop] = value
		menu.expandedDummyNodeColor = color
		node:updateOutlineColor(color)
		for _, edge in ipairs(node.incomingEdges) do
			menu.updateEdgeColorRecursively(edge, color)
		end
	end

	local color = menu.expandedDummyNodeColor
	local row = ftable:addRow(true)
	row[1]:createText("Red")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.r })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "r") end
	local row = ftable:addRow(true)
	row[1]:createText("Green")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.g })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "g") end
	local row = ftable:addRow(true)
	row[1]:createText("Blue")
	row[2]:createSliderCell({ height = Helper.standardTextHeight, min = 0, max = 255, hideMaxValue = true, start = color.b })
	row[2].handlers.onSliderCellChanged = function(_, value) colorupdatefunc(value, "b") end
end

function menu.onCollapseDummy(nodedata)
	menu.expandedNode:updateText(menu.expandedDummyNodeText)
	menu.expandedDummyNodeText = nil
end

function menu.onFlowchartNodeCollapsed(node, frame)
	if menu.expandedNode == node and menu.expandedMenuFrame == frame then
		local data = node.customdata
		local collapseHandler = data.moduledata.collapseHandler
		if collapseHandler then
			collapseHandler(data.nodedata)
		end
		Helper.clearFrame(menu, config.expandedMenuFrameLayer)
		menu.expandedMenuTable = nil
		menu.expandedMenuFrame = nil
		menu.expandedNode = nil
	end
end

function menu.onCollapseSupply(nodedata)
	if nodedata.drones then
		AddUITriggeredEvent(menu.name, "collapse_supply", "drones")
	end

	UnregisterEvent("supplyUpdate", menu.supplyUpdate)
	menu.supplyUpdateRegistered = nil

	menu.types = {}
end

function menu.buttonAccountConfirm()
	if menu.newAccountValue then
		local stationmoney, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
		local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
		local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
		local estimate = productionmoney + supplymoney + tradewaremoney
		local amount = menu.newAccountValue - stationmoney

		SetMaxBudget(menu.containerid, (menu.newAccountValue * 3) / 2)
		SetMinBudget(menu.containerid, menu.newAccountValue)

		if amount > 0 then
			TransferPlayerMoneyTo(amount, menu.containerid)
		else
			TransferMoneyToPlayer(-amount, menu.containerid)
		end

		local shownmax = math.max(menu.newAccountValue, estimate)
		if amount > 0 then
			menu.expandedNode:updateMaxValue(shownmax)
		end
		menu.expandedNode:updateValue(menu.newAccountValue)
		if amount < 0 then
			menu.expandedNode:updateMaxValue(shownmax)
		end
		menu.newAccountValue = nil
		menu.refreshnode = getElapsedTime() + 0.1
	end
end

function menu.buttonAccountToEstimate()
	local stationmoney, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local estimate = productionmoney + supplymoney + tradewaremoney
	local amount = estimate - stationmoney

	SetMaxBudget(menu.containerid, (estimate * 3) / 2)
	SetMinBudget(menu.containerid, estimate)

	if amount > 0 then
		TransferPlayerMoneyTo(amount, menu.containerid)
	else
		TransferMoneyToPlayer(-amount, menu.containerid)
	end

	menu.expandedNode:updateValue(estimate)
	menu.expandedNode:updateMaxValue(estimate)
	menu.newAccountValue = nil
	menu.refreshnode = getElapsedTime() + 0.1
end

function menu.buttonExtend(groupID, row)
	if menu.extendedGroups[groupID] then
		menu.extendedGroups[groupID] = nil
	else
		menu.extendedGroups[groupID] = true
	end

	menu.saveFlowchartState("flowchart", menu.flowchart)
	menu.saveTableState("keyTable", menu.keyTable)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonTimeFrame(type)
	menu.timeframe = type
	if type == "hour" then
		menu.xStart = math.max(0, menu.xEnd - 3600)
		menu.xGranularity = 300
		menu.xScale = 60
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 103) .. "]"
	elseif type == "day" then
		menu.xStart = math.max(0, menu.xEnd - (24 * 3600))
		menu.xGranularity = 7200
		menu.xScale = 3600
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 102) .. "]"
	elseif type == "week" then
		menu.xStart = math.max(0, menu.xEnd - (7 * 24 * 3600))
		menu.xGranularity = 12 * 3600
		menu.xScale = 24 * 3600
		menu.xTitle = ReadText(1001, 6519) .. " [" .. ReadText(1001, 104) .. "]"
	end
	if menu.xEnd > menu.xStart then
		while ((menu.xEnd - menu.xStart) < menu.xGranularity) and (menu.xGranularity >= (0.001 * menu.xScale)) do
			menu.xGranularity = menu.xGranularity / 2
		end
	end

	menu.getData(config.graph.numdatapoints)
	menu.saveFlowchartState("flowchart", menu.flowchart)
	menu.saveTableState("keyTable", menu.keyTable)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonGraphMode(mode)
	menu.graphmode = mode

	if mode == "tradeofferprices" then
		menu.yTitle = ReadText(1001, 6520) .. " [" .. ReadText(1001, 101) .. "]"
	elseif (mode == "tradeofferamounts") or (mode == "cargolevels") then
		menu.yTitle = ReadText(1001, 6521)
	elseif mode == "npcaccounts" then
		menu.yTitle = ReadText(1001, 6522) .. " [" .. ReadText(1001, 101) .. "]"
	end
	menu.getData(config.graph.numdatapoints)
	menu.saveFlowchartState("flowchart", menu.flowchart)
	if menu.expandedNode then
		menu.expandedNode:collapse()
	end
	menu.display()
end

function menu.buttonRightBar(newmenu, params)
	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonShowGraph()
	menu.showGraph = not menu.showGraph
	menu.refresh = true
end

function menu.buttonPauseProductionModules(productionmodules, pause)
	for _, module in ipairs(productionmodules) do
		C.PauseProductionModule(module, pause)
	end

	menu.refreshnode = getElapsedTime() + 0.1
end

function menu.buttonPauseProcessingModules(processingmodules, pause)
	for _, module in ipairs(processingmodules) do
		C.PauseProcessingModule(module, pause)
	end

	menu.refreshnode = getElapsedTime() + 0.1
end


function menu.buttonEditTradeRule(traderuleid)
	Helper.closeMenuAndOpenNewMenu(menu, "PlayerInfoMenu", { 0, 0, "globalorders", { "traderule", (traderuleid ~= 0) and traderuleid or nil } })
	menu.cleanup()
end

function menu.checkboxSelected(idx, row, col)
	if menu.graphdata[idx].shown or (menu.numshowndata < config.graph.maxshowndata) then
		menu.graphdata[idx].shown = not menu.graphdata[idx].shown
		menu.displayedgraphwares[menu.graphdata[idx].ware] = menu.graphdata[idx].shown or nil
		C.SetStationOverviewGraphWare(menu.container, menu.graphdata[idx].ware, menu.graphdata[idx].shown)
		if menu.graphdata[idx].shown then
			for i = 1, config.graph.maxshowndata do
				if not menu.showndata[i] then
					menu.showndata[i] = idx
					menu.numshowndata = menu.numshowndata + 1
					break
				end
			end
		else
			for i, entry in pairs(menu.showndata) do
				if entry == idx then
					menu.showndata[i] = nil
					menu.numshowndata = menu.numshowndata - 1
					break
				end
			end
		end

		menu.saveFlowchartState("flowchart", menu.flowchart)
		menu.saveTableState("keyTable", menu.keyTable, row, col)
		if menu.expandedNode then
			menu.expandedNode:collapse()
		end
		menu.display()
	end
end

function menu.checkboxSupplyAuto(container64, type, checked)
	if type == "transport" then
		C.SetSupplyManual(container64, "units_trade", not checked)
	elseif type == "defence" then
		C.SetSupplyManual(container64, "units_defence", not checked)
	elseif type == "build" then
		C.SetSupplyManual(container64, "units_build", not checked)
	elseif type == "repair" then
		C.SetSupplyManual(container64, "units_repair", not checked)
	elseif type == "missile" then
		C.SetSupplyManual(container64, "missiles", not checked)
	end

	for _, entry in ipairs(menu.supplies[type]) do
		if not checked then
			if menu.supplyoverride[entry.macro] then
				menu.supplyoverride[entry.macro] = menu.supplyoverride[entry.macro] - entry.stored
			end
		else
			if menu.supplyoverride[entry.macro] then
				menu.supplyoverride[entry.macro] = menu.supplyoverride[entry.macro] + entry.stored
			elseif entry.stored ~= 0 then
				menu.supplyoverride[entry.macro] = entry.stored
			end
		end
	end

	menu.updateOverride(container64)
	C.UpdateProductionTradeOffers(container64)

	if menu.numSupplyResources ~= C.GetNumSupplyOrderResources(menu.container) then
		menu.setupFlowchartData()
		menu.restoreNodeSupply = (type == "missile") and "missiles" or "drones"
		menu.refresh = true
	else
		menu.refreshnode = getElapsedTime() + 0.1
	end
end

function menu.checkboxProductionSingle(macro, checked)
	menu.showSingleProduction[macro] = checked or nil

	menu.updateExpandedNode()
end

function menu.checkboxMultiSelect(option, checked)
	menu.contextMenuData.selectedOptions[option] = checked or nil
end

function menu.checkboxToggleMultiSelect(checked)
	for _, entry in ipairs(menu.contextMenuData.options) do
		menu.contextMenuData.selectedOptions[entry.id] = checked or nil
	end
end

function menu.checkboxSetTradeRuleOverride(container, type, ware, checked)
	if checked then
		C.SetContainerTradeRule(container, -1, type, ware, false)
	else
		local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
		C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware, true)
	end

	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(menu.container, ware) and "lso_error" or nil, nil, Color["icon_warning"])
	end
	menu.updateExpandedNode()
end

function menu.checkboxSetWorkforceFill(container)
	C.SetContainerWorkforceFillCapacity(container, not C.ShouldContainerFillWorkforceCapacity(container))
	menu.forceNextWorkforceInfluenceUpdate = true
	menu.refreshnode = getElapsedTime()
end

function  menu.dropdownTradeRule(container, type, ware, id)
	C.SetContainerTradeRule(container, tonumber(id), type, ware, true)

	if (type == "buy") or (type == "sell") then
		menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(menu.container, ware) and "lso_error" or nil, nil, Color["icon_warning"])
	end
end

function menu.slidercellAccount(_, value)
	if value then
		menu.newAccountValue = value
	end
end

function menu.slidercellSupplyAmount(container64, macro, auto, type, idx, value)
	if value then
		menu.supplyoverride[macro] = value - (auto and 0 or menu.supplies[type][idx].stored)

		menu.updateOverride(container64)
		C.UpdateProductionTradeOffers(container64)

		if menu.numSupplyResources ~= C.GetNumSupplyOrderResources(menu.container) then
			menu.setupFlowchartData()
			menu.restoreNodeSupply = (type == "missile") and "missiles" or "drones"
			menu.refresh = true
		else
			menu.refreshnode = getElapsedTime() + 0.1
		end
	end
end

function menu.slidercellBuildPriceFactor(container64, value)
	if value then
		C.SetContainerBuildPriceFactor(container64, value / 100)
	end
end

function menu.updateOverride(container64)
	local numoverrides = 0
	for _, _ in pairs(menu.supplyoverride) do
		numoverrides = numoverrides + 1
	end
	local overrides = ffi.new("SupplyOverride[?]", numoverrides)

	local idx = 0
	for macro, amount in pairs(menu.supplyoverride) do
		overrides[idx].macro = Helper.ffiNewString(macro)
		overrides[idx].amount = amount
		idx = idx + 1
	end

	C.UpdateSupplyOverrides(container64, overrides, numoverrides)

	Helper.ffiClearNewHelper()
end

function menu.updateExpandedNode(row, col)
	if menu.expandedNode then
		-- kuertee start: callback
		if menu.uix_callbacks ["updateExpandedNode_at_start"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["updateExpandedNode_at_start"]) do
				uix_callback(row, col)
			end
		end
		-- kuertee end: callback

		menu.saveTableState("nodeTable", menu.expandedMenuTable, row, col)

		local node = menu.expandedNode
		node:collapse()
		node:expand()

		-- kuertee start: callback
		if menu.uix_callbacks ["updateExpandedNode_at_end"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["updateExpandedNode_at_end"]) do
				uix_callback(row, col)
			end
		end
		-- kuertee end: callback
	end
end

function menu.getPrimaryJunctionEdgeColor(edges)
	-- Determine incoming edge color based on color of all outgoing edges
	local colorprecedence = {
		Color["text_normal"],
		Color["text_warning"],
		Color["text_error"],
	}
	-- We choose the first color in colorprecedence table that appears on any outgoing edge (ignoring alpha)
	local colorindex = #colorprecedence + 1		-- special index denoting fallback color
	local color = Color["lso_node_inactive"]	-- remember last edge color as fallback color
	for _, edge in ipairs(edges) do
		color = edge.properties.color
		if type(color) == "function" then
			color = color(edge)
		end
		-- Try to set colorindex to a lower index
		for i = 1, colorindex - 1 do
			if color.r == colorprecedence[i].r and color.g == colorprecedence[i].g and color.b == colorprecedence[i].b then
				colorindex = i
				break
			end
		end
		if colorindex == 1 then break end
	end
	return (colorindex <= #colorprecedence) and colorprecedence[colorindex] or color
end

function menu.updateEdgeColorRecursively(edge, color)
	edge:updateColor(color)
	-- If edge source cell is a junction, update the junction's incoming edges as well, based on its outgoing edges
	local cell = edge.sourcecell
	if cell.type == "flowchartjunction" then
		local incomingcolor = menu.getPrimaryJunctionEdgeColor(cell.outgoingEdges)
		for _, incomingedge in ipairs(cell.incomingEdges) do
			menu.updateEdgeColorRecursively(incomingedge, incomingcolor)
		end
	end
end

function menu.getData(numdatapoints)
	menu.numshowndata = 0
	menu.showndata = {}

	local ffiHelper = {}

	menu.graphdata = {}
	if menu.graphmode == "cargolevels" then
		local numstats = 0
		if C.IsComponentClass(menu.container, "container") then
			numstats = C.GetNumCargoStatistics(menu.container, menu.xStart, menu.xEnd, numdatapoints)
		end
		if numstats > 0 then
			local result = ffi.new("UICargoStat[?]", numstats)
			for i = 0, numstats - 1 do
				table.insert(ffiHelper, 1, ffi.new("UICargoStatData[?]", numdatapoints))
				result[i].data = ffiHelper[1]
			end
			numstats = C.GetCargoStatistics(result, numstats, numdatapoints)
			for i = 0, numstats - 1 do
				local ware = ffi.string(result[i].wareid)
				local text = GetWareData(ware, "name")
				menu.graphdata[i + 1] = { shown = false, text = text, ware = ware, data = {} }
				for j = 0, result[i].numdata - 1 do
					menu.graphdata[i + 1].data[j + 1] = { t = tonumber(result[i].data[j].time), y = tonumber(result[i].data[j].amount) }
				end
			end
		end
	elseif (menu.graphmode == "tradeofferprices") or (menu.graphmode == "tradeofferamounts") then
		local numstats = 0
		if C.IsComponentClass(menu.container, "container") then
			numstats = C.GetNumTradeOfferStatistics(menu.container, menu.xStart, menu.xEnd, numdatapoints)
		end
		if numstats > 0 then
			local result = ffi.new("UITradeOfferStat[?]", numstats)
			for i = 0, numstats - 1 do
				table.insert(ffiHelper, 1, ffi.new("UITradeOfferStatData[?]", numdatapoints))
				result[i].data = ffiHelper[1]
			end
			numstats = C.GetTradeOfferStatistics(result, numstats, numdatapoints)
			for i = 0, numstats - 1 do
				local ware = ffi.string(result[i].wareid)
				local text = GetWareData(ware, "name")
				local dataIdx = menu.getDataIdxByWare(ware)
				if not dataIdx then
					table.insert(menu.graphdata, { shown = false, text = text, ware = ware, selldata = {}, buydata = {} })
					dataIdx = #menu.graphdata
				end
				for j = 0, result[i].numdata - 1 do
					local y = 0
					if menu.graphmode == "tradeofferprices" then
						y = tonumber(result[i].data[j].price) / 100
					elseif menu.graphmode == "tradeofferamounts" then
						y = tonumber(result[i].data[j].amount)
					end
					if result[i].isSellOffer then
						menu.graphdata[dataIdx].selldata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					else
						menu.graphdata[dataIdx].buydata[j + 1] = { t = tonumber(result[i].data[j].time), y = y }
					end
				end
			end
		end
	elseif menu.graphmode == "npcaccounts" then
		local npcs = Helper.getSuitableControlEntities(menu.containerid, false)
		for i = #npcs, 1, -1 do
			if not C.HasEntityMoneyLogEntries(ConvertIDTo64Bit(npcs[i])) then
				table.remove(npcs, i)
			end
		end
		for i, npc in ipairs(npcs) do
			local result = ffi.new("UIAccountStatData[?]", numdatapoints)
			local numdata = C.GetNPCAccountStatistics(result, numdatapoints, ConvertIDTo64Bit(npc), menu.xStart, menu.xEnd)
			local name, postname, post = GetComponentData(npc, "name", "postname", "poststring")
			local text = postname .. " " .. name
			menu.graphdata[i] = { shown = false, text = text, npc = npc, post = poststring, data = {} }
			-- select the 4 first data sets as default
			if #menu.graphdata <= 4 then
				menu.showndata[i] = npc
			end
			for j = 0, numdata - 1 do
				menu.graphdata[i].data[j + 1] = { t = tonumber(result[j].time), y = tonumber(result[j].money) / 100 }
			end
		end
	end

	table.sort(menu.graphdata, function (a, b) return a.text < b.text end)


	if menu.graphmode ~= "npcaccounts" then
		for ware in pairs(menu.displayedgraphwares) do
			local dataIdx = menu.getDataIdxByWare(ware)
			if not dataIdx then
				menu.displayedgraphwares[ware] = nil
				C.SetStationOverviewGraphWare(menu.container, ware, false)
			end
		end

		for i, entry in ipairs(menu.graphdata) do
			if not menu.graphwaresinit and not menu.isdummy then
				if #menu.showndata < 4 then
					-- default select the 4 first data sets
					table.insert(menu.showndata, entry.ware)
					menu.displayedgraphwares[entry.ware] = true
					C.SetStationOverviewGraphWare(menu.container, entry.ware, true)
				end
			elseif menu.displayedgraphwares[entry.ware] then
				if #menu.showndata < 4 then
					table.insert(menu.showndata, entry.ware)
				else
					menu.displayedgraphwares[entry.ware] = nil
					C.SetStationOverviewGraphWare(menu.container, entry.ware, false)
				end
			end
		end
		menu.graphwaresinit = true
	end

	for i = 1, config.graph.maxshowndata do
		local newdataidx
		if menu.showndata[i] then
			if menu.graphmode ~= "npcaccounts" then
				newdataidx = menu.getDataIdxByWare(menu.showndata[i])
			else
				newdataidx = menu.getDataIdxByNPC(menu.showndata[i])
			end
		end
		if newdataidx then
			menu.showndata[i] = newdataidx
			menu.graphdata[newdataidx].shown = true
			menu.numshowndata = menu.numshowndata + 1
		else
			menu.showndata[i] = nil
		end
	end

	local numgroupeddata = 0
	menu.groupedgraphdata = { }
	if menu.graphmode ~= "npcaccounts" then
		for i, data in ipairs(menu.graphdata) do
			local groupID, groupName = GetWareData(data.ware, "groupID", "groupName")
			local groupIdx = menu.getGroupIdxByID(groupID)
			if groupIdx then
				table.insert(menu.groupedgraphdata[groupIdx], i)
			else
				table.insert(menu.groupedgraphdata, { id = groupID, name = groupName, [1] = i })
			end
		end
	end

	table.sort(menu.groupedgraphdata, Helper.sortName)
end

function menu.getDataIdxByWare(ware)
	for i, data in ipairs(menu.graphdata) do
		if data.ware == ware then
			return i
		end
	end

	return nil
end

function menu.getDataIdxByNPC(npc)
	for i, data in ipairs(menu.graphdata) do
		if IsSameComponent(data.npc, npc) then
			return i
		end
	end

	return nil
end

function menu.getGroupIdxByID(id)
	for i, group in ipairs(menu.groupedgraphdata) do
		if group.id == id then
			return i
		end
	end

	return nil
end

function menu.isGroupExpanded(groupID)
	return menu.extendedGroups[groupID]
end

function menu.newWareReservationCallback(_, data)
	local containerid, ware, reserverid = string.match(data, "(.+);(.+);(.+)")
	if menu.container == ConvertStringTo64Bit(containerid) then
		if menu.expandedNode.customdata.nodedata.ware == ware then
			if not menu.refreshnode then
				menu.refreshnode = getElapsedTime()
			end
		end
	end
end

function menu.getBuildProgress(station, component)
	local buildprogress = 100
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		buildprogress = math.floor(C.GetCurrentBuildProgress(ConvertIDTo64Bit(station)))
	elseif component == 0 then
		buildprogress = "-"
	end

	if (buildprogress == 100) or (buildprogress == -1) then
		return ReadText(1001, 8418)
	else
		return buildprogress .. " %"
	end
end

function menu.getBuildTime(component)
	if IsComponentConstruction(ConvertStringTo64Bit(tostring(component))) then
		local buildingprocessor = GetComponentData(menu.containerid, "buildingprocessor")
		local ismissingresources = GetComponentData(buildingprocessor, "ismissingresources")
		return (ismissingresources and (ColorText["text_warning"] .. "\27[warning] (") or "(") .. ConvertTimeString(C.GetBuildProcessorEstimatedTimeLeft(ConvertIDTo64Bit(buildingprocessor)), "%h:%M:%S") .. ")"
	else
		return ""
	end
end

function menu.getShipBuildProgress(ship, name)
	local buildprogress = math.floor(C.GetCurrentBuildProgress(ship))
	if buildprogress == -1 then
		if not menu.refreshnode then
			menu.refreshnode = getElapsedTime()
		end
	end

	if (buildprogress == 100) or (buildprogress == -1) then
		return name
	else
		return name .. " (" .. buildprogress .. " %)"
	end
end

function menu.supplyUpdate(_, container)
	if menu.container == ConvertStringTo64Bit(tostring(container)) then
		if not menu.refreshnode then
			if not menu.noupdate then
				menu.refreshnode = getElapsedTime() + 0.1
			else
				for _, supplytypeentry in ipairs(menu.types) do
					if supplytypeentry.type == "missile" then
						local n = C.GetNumAllMissiles(menu.container)
						local buf = ffi.new("AmmoData[?]", n)
						n = C.GetAllMissiles(buf, n, menu.container)
						for j = 0, n - 1 do
							local macro = ffi.string(buf[j].macro)
							local amount = buf[j].amount

							local idx = menu.getSupplyIdx(menu.supplies[supplytypeentry.type], macro)
							if idx then
								menu.supplies[supplytypeentry.type][idx].stored = amount
							end
						end
					else
						local units = GetUnitStorageData(menu.containerid, supplytypeentry.type)
						for _, entry in ipairs(units) do
							local idx = menu.getSupplyIdx(menu.supplies[supplytypeentry.type], entry.macro)
							if idx then
								menu.supplies[supplytypeentry.type][idx].stored = entry.amount
							end
						end
					end
				end
			end
		end
	end
end

function menu.getSupplyIdx(array, macro)
	for i, entry in ipairs(array) do
		if entry.macro == macro then
			return i
		end
	end
	return nil
end

function menu.updateProductionNode(node, productionmodules)
	local text = node.customdata.nodedata.text
	local ware = node.customdata.nodedata.ware
	local textcolor = Color["text_normal"]
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Color["flowchart_node_default"]
	local outlinecolor = Color["flowchart_node_default"]

	local progress = 0

	local macrodata = GetLibraryEntry(GetMacroData(productionmodules.macro, "infolibrary"), productionmodules.macro)
	local makerrace = GetMacroData(productionmodules.macro, "makerrace")
	for i, racestring in ipairs(makerrace) do
		text = text .. " (" .. racestring .. ")"
	end

	local total = #productionmodules.destroyedcomponents + productionmodules.numplanned
	if #productionmodules.destroyedcomponents > 0 then
		statusicon = "lso_warning"
		statuscolor = Color["icon_error"]
		statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8428)
		textcolor = Color["text_error"]
		outlinecolor = Color["lso_node_inactive"]
	elseif (#productionmodules.components == 0) and (productionmodules.numplanned > 0) then
		statusicon = "lso_build"
		statuscolor = Color["icon_normal"]
		statusiconmouseovertext = ReadText(1001, 8433)
		textcolor = Color["text_inactive"]
		outlinecolor = Color["lso_node_inactive"]
	end
	local producing, queued = 0, 0
	local isknown = false
	for _, module in ipairs(productionmodules.components) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local proddata = GetProductionModuleData(module)
			if proddata.state ~= "empty" then
				local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")
				local isqueued = true
				for _, product in ipairs(proddata.products) do
					if product.ware == ware then
						isqueued = false
						break
					end
				end
				if ishacked then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Color["icon_error"]
						statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8430)
						textcolor = Color["text_error"]
						outlinecolor = Color["lso_node_error"]
					end
				elseif ispausedmanually then
					if not statusicon then
						statusicon = "lso_pause"
						statuscolor = Color["icon_warning"]
						statusiconmouseovertext = ColorText["text_warning"] .. ReadText(1001, 8448)
						textcolor = Color["text_warning"]
						outlinecolor = Color["lso_node_warning"]
					end
				elseif not isfunctional then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Color["icon_error"]
						statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8429)
						textcolor = Color["text_error"]
						outlinecolor = Color["lso_node_error"]
					end
				elseif (proddata.state == "choosingitem") or (proddata.state == "waitingforstorage") then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Color["icon_error"]
						statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8432)
					end

					for _, entry in ipairs(proddata.products) do
						menu.storagemissing[entry.ware] = true
					end
				elseif proddata.state == "waitingforresources" then
					if not statusicon then
						statusicon = "lso_warning"
						statuscolor = Color["icon_error"]
						statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8431)
						textcolor = Color["text_error"]
					end
				elseif isqueued then
					queued = queued + 1
				else
					producing = producing + 1
					progress = math.max(progress, math.floor((proddata.cycleprogress * 12 / 100) + 0.5))
				end
				if (not isknown) and C.IsInfoUnlockedForPlayer(module, "production_rate") then
					isknown = true
				end
			end
		end
		if not menu.removedModules[tostring(module)] then
			total = total + 1
		end
	end
	if queued == total then
		if not statusicon then
			statusicon = "lso_pause"
			statuscolor = Color["icon_warning"]
			statusiconmouseovertext = ColorText["text_warning"] .. ReadText(1001, 8469)
			textcolor = Color["text_warning"]
		end
	end
	if producing == total then
		text = "(" .. total .. ") " .. text
	else
		text = "(" .. producing .. "/" .. total .. ") " .. text
	end

	if not statusicon then
		if producing > 0 then
			statusicon = string.format("lso_pie_%02d", progress)
			statusiconmouseovertext = ReadText(1001, 1607)
			statusbgicon = "lso_progress"
		end
	end

	if not isknown then
		statusicon = nil
		statusbgicon = nil
	end

	node:updateText(text, textcolor)
	node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
	node:updateOutlineColor(outlinecolor)

	local cargo = GetComponentData(menu.containerid, "cargo")

	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == ware then
			proddata = entry
			break
		end
	end

	if #proddata.resources > 0 then
		for _, resourcedata in ipairs(proddata.resources) do
			if resourcedata.amount > (cargo[resourcedata.ware] or 0) then
				menu.resourcesmissing[resourcedata.ware] = true
			end
		end

		for _, edge in ipairs(node.incomingEdges) do
			local storagenode = menu.findStorageNode(edge)
			local edgecolor = Color["flowchart_edge_default"]
			if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
				edgecolor = Color["lso_node_error"]
			end
			menu.updateEdgeColorRecursively(edge, edgecolor)
		end
	end
end

function menu.updateProcessingNode(node, processingmodules)
	local text = node.customdata.nodedata.text
	local ware = node.customdata.nodedata.ware
	local textcolor = Color["text_normal"]
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Color["flowchart_node_default"]
	local outlinecolor = Color["flowchart_node_default"]

	local progress = 0

	local macrodata = GetLibraryEntry(GetMacroData(processingmodules.macro, "infolibrary"), processingmodules.macro)
	local makerrace = GetMacroData(processingmodules.macro, "makerrace")
	for i, racestring in ipairs(makerrace) do
		text = text .. " (" .. racestring .. ")"
	end
	local proddata
	for _, entry in ipairs(macrodata.products) do
		if entry.ware == ware then
			proddata = entry
			break
		end
	end

	local total = #processingmodules.destroyedcomponents + processingmodules.numplanned
	if #processingmodules.destroyedcomponents > 0 then
		statusicon = "lso_warning"
		statuscolor = Color["icon_error"]
		statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8428)
		textcolor = Color["text_error"]
		outlinecolor = Color["lso_node_inactive"]
	elseif (#processingmodules.components == 0) and (processingmodules.numplanned > 0) then
		statusicon = "lso_build"
		statuscolor = Color["icon_normal"]
		statusiconmouseovertext = ReadText(1001, 8433)
		textcolor = Color["text_inactive"]
		outlinecolor = Color["lso_node_inactive"]
	end

	local wares = ffi.new("UIWareAmount[?]", 1)
	wares[0].wareid = Helper.ffiNewString(ware)
	wares[0].amount = proddata and proddata.amount or 1
	local isstoragefull = not C.AreWaresWithinContainerProductionLimits(menu.container, wares, 1)

	local producing = 0
	local isknown = false
	for _, module in ipairs(processingmodules.components) do
		-- components that are already being recycled are in state construction
		if IsValidComponent(module) and (not IsComponentConstruction(module)) then
			local data = GetProcessingModuleData(module)
			local ishacked, isfunctional, ispausedmanually = GetComponentData(module, "ishacked", "isfunctional", "ispausedmanually")
			if ishacked then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Color["icon_error"]
					statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8430)
					textcolor = Color["text_error"]
					outlinecolor = Color["lso_node_error"]
				end
			elseif ispausedmanually then
				if not statusicon then
					statusicon = "lso_pause"
					statuscolor = Color["icon_warning"]
					statusiconmouseovertext = ColorText["text_warning"] .. ReadText(1001, 8448)
					textcolor = Color["text_warning"]
					outlinecolor = Color["lso_node_warning"]
				end
			elseif not isfunctional then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Color["icon_error"]
					statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8429)
					textcolor = Color["text_error"]
					outlinecolor = Color["lso_node_error"]
				end
			elseif data.state == "waitingforstorage" then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Color["icon_error"]
					statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8432)
				end

				menu.storagemissing[ware] = true
			elseif data.state == "waitingforresources" then
				if not statusicon then
					statusicon = "lso_warning"
					statuscolor = Color["icon_error"]
					statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8431)
					textcolor = Color["text_error"]
				end
			else
				producing = producing + 1
				progress = math.max(progress, math.floor((data.cycleprogress * 12 / 100) + 0.5))
			end
			if (not isknown) and C.IsInfoUnlockedForPlayer(module, "production_rate") then
				isknown = true
			end
		end
		if not menu.removedModules[tostring(module)] then
			total = total + 1
		end
	end
	if producing == total then
		text = "(" .. total .. ") " .. text
	else
		text = "(" .. producing .. "/" .. total .. ") " .. text
	end

	if not statusicon then
		if producing > 0 then
			statusicon = string.format("lso_pie_%02d", progress)
			statusiconmouseovertext = ReadText(1001, 7605)
			statusbgicon = "lso_progress"
		else
			statusicon = "mapob_recyclable"
		end
	end

	if not isknown then
		statusicon = nil
		statusbgicon = nil
	end

	node:updateText(text, textcolor)
	node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
	node:updateOutlineColor(outlinecolor)

	local cargo = GetComponentData(menu.containerid, "cargo")
	if #proddata.resources > 0 then
		for _, resourcedata in ipairs(proddata.resources) do
			local isprocessed = GetWareData(resourcedata.ware, "isprocessed")
			if (not isprocessed) and (resourcedata.amount > (cargo[resourcedata.ware] or 0)) then
				menu.resourcesmissing[resourcedata.ware] = true
			end
		end

		for _, edge in ipairs(node.incomingEdges) do
			local storagenode = menu.findStorageNode(edge)
			local edgecolor = Color["flowchart_edge_default"]
			if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
				edgecolor = Color["lso_node_error"]
			end
			menu.updateEdgeColorRecursively(edge, edgecolor)
		end
	end
end

function menu.updateResearchNode(node, researchmodule)
	local text = node.customdata.nodedata.text
	local textcolor = Color["text_normal"]
	local statusicon
	local statusiconmouseovertext = ""
	local statusbgicon
	local statuscolor = Color["flowchart_node_default"]
	local outlinecolor = Color["flowchart_node_default"]

	local proddata = GetProductionModuleData(researchmodule)
	if (proddata.state == "producing") or (proddata.state == "waitingforresources") then
		local progress = math.floor((proddata.cycleprogress * 12 / 100) + 0.5)

		if proddata.state == "waitingforresources" then
			statusicon = "lso_warning"
			statuscolor = Color["icon_warning"]
			statusiconmouseovertext = ColorText["text_warning"] .. ReadText(1026, 8412)
		else
			statusicon = string.format("lso_pie_%02d", progress)
			statusbgicon = "lso_progress"
			statusiconmouseovertext = ReadText(1026, 8411)
		end

		node:updateText(text, textcolor)
		node:updateStatus(nil, statusicon, statusbgicon, statuscolor, statusiconmouseovertext)
		node:updateOutlineColor(outlinecolor)

		if proddata.state == "waitingforresources" then
			local cargo = GetComponentData(menu.containerid, "cargo")
			local resources = GetWareData(proddata.blueprintware, "resources")
			for _, resourcedata in ipairs(resources) do
				if resourcedata.amount > (cargo[resourcedata.ware] or 0) then
					menu.resourcesmissing[resourcedata.ware] = true
				end
			end

			for _, edge in ipairs(node.incomingEdges) do
				local storagenode = menu.findStorageNode(edge)
				local edgecolor = Color["flowchart_edge_default"]
				if menu.resourcesmissing[storagenode.customdata.nodedata.ware] then
					edgecolor = Color["lso_node_error"]
				end
				menu.updateEdgeColorRecursively(edge, edgecolor)
			end
		end
	end
end

function menu.updateBuildNode(node, buildmodule)
	local ishacked = GetComponentData(ConvertStringTo64Bit(tostring(buildmodule)), "ishacked")
	if ishacked then
		node:updateStatus(nil, "lso_warning", nil, Color["icon_error"], ColorText["text_error"] .. ReadText(1001, 8426))
	else
		node:updateStatus(nil, nil, nil, nil, "")
	end
end

function menu.updateTerraformingNode(node, project)
	project.project.isongoing = C.IsTerraformingProjectOngoing(project.cluster, project.project.id)
	menu.updateDroneInfo(project.cluster, project.project)
	if project.project.isongoing or ((menu.droneinfo.numbuildsinprogress + menu.droneinfo.numcurrentdeliveries) > 0) then
		node:updateStatus(nil, "lso_pie_00", "lso_progress", Color["flowchart_node_default"], ReadText(1001, 3800))
	else
		node:updateStatus(nil, "lso_warning", nil, Color["icon_error"], ColorText["text_error"] .. menu.terraformingErrorText(project))
	end
end

function menu.updateSupplyResourceNode(node, ware)
	local value = menu.getSupplyResourceValue(ware)
	local max = menu.getSupplyResourceMax(ware)
	if max < node.properties.value then
		node:updateValue(value)
	end
	node:updateMaxValue(max)
	node:updateValue(value)

	local hasrestrictions = C.GetContainerTradeRuleID(menu.container, "supply", ware) > 0
	local statusicon = hasrestrictions and "lso_error" or nil
	local statuscolor = hasrestrictions and Color["icon_warning"] or nil
	local statusiconmouseovertext = hasrestrictions and (ColorText["text_warning"] .. ReadText(1026, 8404)) or ""
	node:updateStatus(nil, statusicon, nil, statuscolor, statusiconmouseovertext)
end

function menu.updateAccountNode(node)
	local money, productionmoney = GetComponentData(menu.containerid, "money", "productionmoney")
	local supplymoney = tonumber(C.GetSupplyBudget(menu.container)) / 100
	local tradewaremoney = tonumber(C.GetTradeWareBudget(menu.container)) / 100
	local budget = math.floor(productionmoney + supplymoney + tradewaremoney)

	local shownamount = money
	local shownmax = math.max(shownamount, budget)

	if shownamount ~= node.properties.value then
		menu.refreshnode = getElapsedTime()
	end
	if shownmax < node.properties.value then
		node:updateValue(shownamount)
	end
	node:updateMaxValue(shownmax)
	node:updateValue(shownamount)

	local statustext = string.format("%s/%s %s", ConvertMoneyString(money, false, true, 3, true, false), ConvertMoneyString(productionmoney + supplymoney + tradewaremoney, false, true, 3, true, false), ReadText(1001, 101))
	local statuscolor = (money < budget) and ((money == 0) and Color["lso_node_error"] or Color["lso_node_warning"]) or Color["flowchart_node_default"]
	node:updateStatus(statustext)
	node:updateOutlineColor(statuscolor)
end

function menu.findStorageNode(edge)
	if edge.sourcecell.customdata then
		return edge.sourcecell
	else
		for _, edge in ipairs(edge.sourcecell.incomingEdges) do
			local node = menu.findStorageNode(edge)
			if node then
				return node
			end
		end
	end
end

menu.updateInterval = 0.1

-- hook to update the menu while it is being displayed
function menu.onUpdate()
	if menu.restoreSliderCellInput then
		if type(menu.restoreSliderCellInput) == "table" then
			ActivateSliderCellInput(menu.restoreSliderCellInput.id)
			menu.restoreSliderCellInput = nil
		end
	end

	menu.frame:update()
	if menu.expandedMenuFrame then
		menu.expandedMenuFrame:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end

	if not menu.noupdate then
		menu.resourcesmissing = {}
		menu.storagemissing = {}
		for _, node in pairs(menu.productionnodes) do
			menu.updateProductionNode(node, node.customdata.moduledata.productionmodules)
		end
		for _, node in pairs(menu.processingnodes) do
			menu.updateProcessingNode(node, node.customdata.moduledata.productionmodules)
		end
		for _, node in pairs(menu.researchnodes) do
			menu.updateResearchNode(node, node.customdata.moduledata.researchmodule)
		end
		for _, node in pairs(menu.buildnodes) do
			if type(node.customdata.moduledata.buildmodule) ~= "table" then
				menu.updateBuildNode(node, node.customdata.moduledata.buildmodule)
			end
		end
		for _, node in pairs(menu.terraformingnodes) do
			menu.updateTerraformingNode(node, node.customdata.moduledata.terraformingproject)
		end
		for _, node in pairs(menu.storagenodes) do
			Helper.updateLSOStorageNode(menu, node, menu.container, node.customdata.nodedata.ware)
		end
		for _, node in pairs(menu.supplyresourcenodes) do
			menu.updateSupplyResourceNode(node, node.customdata.nodedata.ware)
		end
		for _, node in pairs(menu.accountnodes) do
			menu.updateAccountNode(node)
		end

		if menu.refresh then
			menu.refresh = nil

			menu.saveFlowchartState("flowchart", menu.flowchart)
			if menu.keyTable then
				menu.saveTableState("keyTable", menu.keyTable)
			end
			if menu.expandedNode then
				if menu.restoreNodeWare or menu.restoreNodeSupply or menu.restoreNodeSupplyWare or menu.restoreNodeBuildModule then
					menu.saveTableState("nodeTable", menu.expandedMenuTable)
				end
				menu.expandedNode:collapse()
			end
			menu.display()
			return
		end

		if menu.restoreNode and menu.restoreNode.id then
			menu.restoreNode:expand()
			menu.restoreNode = nil
		end

		local curtime = getElapsedTime()
		if menu.refreshnode and (menu.refreshnode < curtime) then
			menu.refreshnode = nil
			menu.updateExpandedNode()
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if menu.keyTable and (uitable == menu.keyTable.id) then
		if menu.selectedrowdata ~= rowdata then
			menu.selectedrowdata = rowdata
			menu.refresh = true
		end
	end
end

-- hook if the highlighted row is selected
function menu.onSelectElement(table, modified)
end

function menu.closeContextMenu()
	menu.contextTable = nil
	menu.contextFrame = nil
	Helper.clearFrame(menu, config.contextFrameLayer)
	menu.contextMenuData = {}
	menu.contextMenu = nil
end

-- hook if the menu is being closed
function menu.onCloseElement(dueToClose, layer)
	if menu.contextMenu then
		if layer == config.contextFrameLayer then
			menu.closeContextMenu()
		end
		return
	end
	if menu.expandedNode and (dueToClose == "back") then
		menu.expandedNode:collapse()
		return
	end
	if layer == config.expandedMenuFrameLayer then
		menu.expandedNode:collapse()
		return
	end

	if dueToClose == "back" then
		if Helper.checkDiscardStationEditorChanges(menu) then
			return
		end
	end

	if menu.param[3] then
		Helper.closeMenu(menu, dueToClose)
	else
		-- flowchart test through MD conversation
		Helper.closeMenuAndReturn(menu)
	end
	menu.cleanup()
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
]]

local menu = {
	name = "TopLevelMenu",
	mouseOutBox = {},
}

local config = {
	width = Helper.sidebarWidth,
	height = Helper.sidebarWidth,
	offsetY = 0,
	layer = 2,
	mouseOutRange = 100,
}

-- kuertee start:
menu.uix_callbacks = {}
-- end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	menu.init = true
	registerForEvent("gameplanchange", getElement("Scene.UIContract"), menu.onGamePlanChange)
	RegisterEvent("playerUndocked", menu.playerUndocked)

	-- kuertee start:
	menu.init_kuertee()
	kHUD.init()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.onGamePlanChange(_, mode)
	if menu.init then
		if (mode == "cockpit") or (mode == "external") then
			local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
			if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
				OpenMenu("TopLevelMenu", { 0, 0 }, nil)
			end
			menu.init = nil
		elseif (mode == "firstperson") or (mode == "externalfirstperson") then
			menu.init = nil
		end
	else
		if (mode == "firstperson") or (mode == "externalfirstperson") then
			if menu.shown then
				menu.close()
			end
		end
	end
end

function menu.playerUndocked()
	local occupiedship = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	if (occupiedship ~= 0) and (not GetComponentData(occupiedship, "isdocked")) then
		OpenMenu("TopLevelMenu", { 0, 0 }, nil)
	end
end

function menu.cleanup()
	menu.infoFrame = nil

	menu.showTabs = nil
	menu.over = nil
	menu.mouseOutBox = {}

	if menu.hasRegistered then
		unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
		menu.hasRegistered = nil
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback()
		end
	end
	-- kuertee end: callback
end

function menu.buttonShowTopLevel()
	menu.showTabs = true
	menu.refresh = getElapsedTime()
end

-- Menu member functions

function menu.onShowMenu()
	C.SetTrackedMenuFullscreen(menu.name, false)
	menu.width = Helper.scaleX(config.width)
	menu.height = Helper.scaleX(config.height)

	-- display info
	menu.createInfoFrame()
end

function menu.createInfoFrame()
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	-- kuertee custom HUD start:
	local isShowCustomHUD = kHUD.getIsOpenOrClose()
	-- kuertee custom HUD end

	local frameProperties = {
		standardButtons = {},
		width = menu.width + 2 * Helper.borderSize,
		x = (Helper.viewWidth - menu.width - 2 * Helper.borderSize) / 2,
		y = Helper.scaleY(config.offsetY),
		layer = config.layer,
		startAnimation = false,
		playerControls = true,
		-- kuertee custom HUD start:
		-- useMiniWidgetSystem = (not menu.showTabs) and (not menu.over),
		useMiniWidgetSystem = (not menu.showTabs) and (not menu.over) and (not isShowCustomHUD),
		-- kuertee custom HUD end

		enableDefaultInteractions = false,
	}

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)

	local tableProperties = {
		width = menu.width,
		x = Helper.borderSize,
		y = Helper.borderSize,
	}
	
	if menu.showTabs then
		if not menu.hasRegistered then
			menu.hasRegistered = true
			Helper.setTabScrollCallback(menu, menu.onTabScroll)
			registerForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
		end

		menu.infoFrame.properties.width = Helper.viewWidth
		menu.infoFrame.properties.x = 0
		menu.topLevelHeight, menu.topLevelWidth = Helper.createTopLevelTab(menu, "", menu.infoFrame, "", nil, nil, true)
		menu.infoFrame.properties.height = menu.topLevelHeight + Helper.borderSize

		menu.mouseOutBox = {
			x1 = - menu.topLevelWidth / 2                    - config.mouseOutRange,
			x2 =   menu.topLevelWidth / 2                    + config.mouseOutRange,
			y1 = Helper.viewHeight / 2,
			y2 = Helper.viewHeight / 2 - menu.topLevelHeight - config.mouseOutRange
		}
	else
		if menu.hasRegistered then
			Helper.removeAllTabScrollCallbacks(menu)
			unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
			menu.hasRegistered = nil
		end
		local ftable = menu.createTable(menu.infoFrame, tableProperties)

		-- kuertee custom HUD start:
		menu.infoFrame.properties.width = Helper.viewWidth
		menu.infoFrame.properties.x = 0
		ftable.properties.x = menu.infoFrame.properties.width / 2 - ftable.properties.width / 2
		-- menu.infoFrame.properties.height = ftable.properties.y + ftable:getVisibleHeight() + Helper.borderSize
		-- kuertee custom HUD end

		-- kuertee start: callback
		if menu.uix_callbacks ["createInfoFrame_on_add_table"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_on_add_table"]) do
				uix_callback (menu.infoFrame, ftable)
			end
		end
		-- kuertee end: callback

		-- kuertee start: callback
		if menu.uix_callbacks ["createInfoFrame_on_before_frame_display"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_on_before_frame_display"]) do
				uix_callback (menu.infoFrame)
			end
		end
		-- kuertee end: callback
	end

	menu.infoFrame:display()
end

function menu.createTable(frame, tableProperties)
	local ftable = frame:addTable(1, { tabOrder = menu.over and 1 or 0, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y })

	if menu.over then
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ width = config.width, height = config.height - 10, bgColor = Color["button_background_hidden"], highlightColor = Color["button_highlight_hidden"] }):setText("\27[tlt_arrow]", { color = Color["toplevel_arrow"], halign = "center", fontsize = Helper.scaleFont(Helper.standardFont, 18), x = 0, y = 2, scaling = false })
		row[1].handlers.onClick = menu.buttonShowTopLevel
	else
		local row = ftable:addRow(false, { fixed = true })
		row[1]:createText("\27[tlt_arrow]", { width = config.width, height = config.height, color = Color["toplevel_arrow_inactive"], halign = "center", fontsize = 18, x = 0, y = 0 })
	end

	return ftable
end

function menu.onTabScroll(direction)
	Helper.scrollTopLevel(menu, "playerinfo", 1)
end

function menu.onInputModeChanged(_, mode)
	menu.createInfoFrame()
end

function menu.viewCreated(layer, ...)
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.showTabs and next(menu.mouseOutBox) then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeTabs()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeTabs()
			end
		end
	end

	local curtime = getElapsedTime()

	-- kuertee start: callback
	if menu.uix_callbacks ["onUpdate_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onUpdate_start"]) do
			uix_callback(curtime)
		end
	end
	-- kuertee end: callback

	if menu.lock and (menu.lock + 0.11 < curtime) then
		menu.lock = nil
	end

	if menu.over and (not menu.lock) then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local mouseOutBox = {
				x1 = - menu.width / 2,
				x2 =   menu.width / 2,
				y1 = Helper.viewHeight / 2,
				y2 = Helper.viewHeight / 2 - menu.infoFrame.properties.height,
			}

			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < mouseOutBox.x1) or (curpos[1] > mouseOutBox.x2)) then
				menu.over = false
				menu.lock = getElapsedTime()
				menu.createInfoFrame()
				return
			elseif curpos[2] and ((curpos[2] > mouseOutBox.y1) or (curpos[2] < mouseOutBox.y2)) then
				menu.over = false
				menu.lock = getElapsedTime()
				menu.createInfoFrame()
				return
			end
		end
	end

	if menu.refresh and menu.refresh <= curtime then
		menu.createInfoFrame()
		menu.refresh = nil
		return
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["onUpdate_before_frame_update"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onUpdate_before_frame_update"]) do
			uix_callback (menu.infoFrame)
		end
	end
	-- kuertee end: callback

	menu.infoFrame:update()
end

-- kuertee custom HUD start:
local onTableMouseOver_uitable = nil
local onTableMouseOver_row = nil
-- kuertee custom HUD end

function menu.onTableMouseOut(uitable, row)
	-- kuertee custom HUD start:
	if uitable ~= onTableMouseOver_uitable or row ~= onTableMouseOver_row then
		return
	end
	-- kuertee custom HUD end

	if (not menu.showTabs) and (not menu.lock) then
		menu.over = false
		menu.lock = getElapsedTime()
		menu.createInfoFrame()
	end
end

function menu.onTableMouseOver(uitable, row)
	if (not menu.showTabs) and ((not menu.lock) or (not menu.over)) then
		-- kuertee custom HUD start:
		onTableMouseOver_uitable = uitable
		onTableMouseOver_row = row
		-- kuertee custom HUD end

		menu.over = true
		menu.lock = getElapsedTime()
		menu.createInfoFrame()
	end
end

function menu.onRowChanged(row, rowdata, uitable)
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.close()
	Helper.closeMenu(menu, "close", nil, false)
	menu.cleanup()
end

function menu.closeTabs()
	menu.showTabs = nil
	menu.over = nil
	menu.lock = getElapsedTime()
	menu.refresh = getElapsedTime()
end

function menu.onCloseElement(dueToClose, layer)
	if menu.showTabs then
		menu.closeTabs()
	elseif layer == nil then
		Helper.closeMenu(menu, dueToClose, nil, false)
		menu.cleanup()
	else
		Helper.closeMenuAndOpenNewMenu(menu, "OptionsMenu", nil)
		menu.cleanup()
	end
end

-- menu helpers

-- kuertee custom HUD start:
-- note that custom HUD elements are only shown when the TopLevelMenu is collapsed.
-- to add custom HUD elements, add these in your lua file:
-- as an example, review "ui\menu_toplevel_uix.lua" of the kuertee_alternatives_to_death mod
-- 1. topLevelMenu.registerCallback("kHUD_get_is_show_custom_hud", YourMenu.kHUD_get_is_show_custom_hud)
-- 2. function YourMenu.kHUD_get_is_show_custom_hud() return true|false depending on whether your custom HUD should be shown or not end
-- 3. topLevelMenu.registerCallback("kHUD_add_tables", YourMenu.kHUD_add_tables)
-- 4. function YourMenu.kHUD_add_tables(frame) local ftable = frame:addTable(); local row = ftable:addRow(); etc.; end
kHUD = {
	name = "kHUD",
	isDebug = nil,
}

function kHUD.init()
    Menus = Menus or {}
    table.insert(Menus, kHUD)
    if Helper then
        Helper.registerMenu(kHUD)
    end
	menu.registerCallback ("createInfoFrame_on_add_table", kHUD.OpenOrClose)
end

function kHUD.getIsOpenOrClose()
	local isCreateHUDFrame
	if isCreateHUDFrame ~= true then
		if menu.uix_callbacks["kHUD_get_is_show_custom_hud"] and next(menu.uix_callbacks["kHUD_get_is_show_custom_hud"]) then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["kHUD_get_is_show_custom_hud"]) do
				isCreateHUDFrame = uix_callback ()
				if isCreateHUDFrame == true then
					break
				end
			end
		end
	end
	if isCreateHUDFrame ~= true then
		isCreateHUDFrame = nil
	end
	return isCreateHUDFrame
end

function kHUD.OpenOrClose()
	if kHUD.getIsOpenOrClose() then
		kHUD.display()
	elseif kHUD.frame then
		kHUD.cleanup()
	end
end

function kHUD.display()
	if kHUD.isDebug then
		Helper.debugText_forced("kHUD.display")
	end
	kHUD.createFrame()
	kHUD.createTables()
end

function kHUD.cleanup()
	if kHUD.isDebug then
		Helper.debugText_forced("kHUD.cleanUp")
	end
	kHUD.frame = nil
end

function kHUD.createFrame()
	kHUD.frame = menu.infoFrame
	if kHUD.isDebug then
		Helper.debugText_forced("createFrame kHUD.frame", tostring(kHUD.frame))
	end
end

function kHUD.createTables()
	if kHUD.frame then
		local ftables_created = {}
		if menu.uix_callbacks["kHUD_add_tables"] and next(menu.uix_callbacks["kHUD_add_tables"]) then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["kHUD_add_tables"]) do
				local ftables = uix_callback (kHUD.frame)
				if ftables and type(ftables) == "table" and #ftables > 0 then
					for j, ftable in ipairs(ftables) do
						table.insert(ftables_created, ftable)
					end
				end
			end
		end
		if menu.uix_callbacks["kHUD_add_HUD_tables"] and next(menu.uix_callbacks["kHUD_add_HUD_tables"]) then
			-- kHUD_add_HUD_tables is for backward compatibility
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["kHUD_add_HUD_tables"]) do
				local ftables = uix_callback (kHUD.frame)
				if ftables and type(ftables) == "table" and #ftables > 0 then
					for j, ftable in ipairs(ftables) do
						table.insert(ftables_created, ftable)
					end
				end
			end
		end
		if kHUD.isDebug then
			Helper.debugText_forced("createTables #ftables_created", #ftables_created)
		end
		if kHUD.isDebug and #ftables_created < 1 then
			-- set to true to force a row for testing
			local ftable = kHUD.frame:addTable(1)
			local row = ftable:addRow()
			row[1]:createText("kHUD")
		end
		kHUD.updateFrameHeight()
	end
end

function kHUD.updateFrameHeight()
	local y_max = kHUD.getFrameHeight(kHUD.frame)
	if kHUD.isDebug then
		Helper.debugText_forced("updateFrameHeight kHUD.frame.properties.height (pre set)", kHUD.frame.properties.height)
	end
	if kHUD.frame.properties.height ~= y_max then
		kHUD.frame.properties.height = y_max + Helper.borderSize
	end
	if kHUD.isDebug then
		Helper.debugText_forced("updateFrameHeight kHUD.frame.properties.height", kHUD.frame.properties.height)
	end
end

function kHUD.getFrameHeight(frame)
	local y_max = 0
	local y_tableBottom = 0
	local ftable
	for i = 1, #frame.content do
		if frame.content [i].type == "table" then
			ftable = frame.content [i]
			local visibleHeight = ftable:getVisibleHeight ()
			Helper.debugText("ftable.properties.x", ftable.properties.x)
			Helper.debugText("ftable.properties.width", ftable.properties.width)
			Helper.debugText("ftable.properties.y", ftable.properties.y)
			Helper.debugText("visibleHeight", visibleHeight)
			y_tableBottom = ftable.properties.y + visibleHeight
			Helper.debugText("y_tableBottom", y_tableBottom)
			if y_tableBottom > y_max then
				y_max = y_tableBottom
				Helper.debugText("y_max", y_max)
			end
		end
	end
	return y_max
end

function kHUD.getNextY()
	return kHUD.getFrameHeight(menu.infoFrame)
end
-- kuertee custom HUD end

-- kuertee start:
function menu.requestUpdate (adj)
	Helper.debugText("menu.requestUpdate")
	if adj == nil then
		adj = 0
	end
	if menu.refresh == nil then
		menu.refresh = getElapsedTime () + adj
	end
end

menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- param == { 0, 0, traderentity, mode }

-- modes:	- "blueprint"
--			- "licence"

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t UniverseID;
	typedef struct {
		const char* name;
		const char* icon;
	} LicenceInfo;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetBlueprints(UIBlueprint* result, uint32_t resultlen, const char* set, const char* category, const char* macroname);
	bool GetLicenceInfo(LicenceInfo* result, const char* factionid, const char* licenceid);
	const char* GetMacroClass(const char* macroname);
	uint32_t GetNumBlueprints(const char* set, const char* category, const char* macroname);
	UniverseID GetPlayerComputerID(void);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	void LearnBlueprint(const char* wareid);
]]

-- menu variable - used by Helper and used for dynamic variables (e.g. inventory content, etc.)
local menu = {
	name = "BlueprintOrLicenceTraderMenu"
}

-- config variable - put all static setup here
local config = {
	deployableOrder = {
		["satellite"]		= 1,
		["navbeacon"]		= 2,
		["resourceprobe"]	= 3,
		["lasertower"]		= 4,
		["mine"]			= 5,
		[""]				= 6,
	},
	blueprintorder = {
		["module"] = {
			{ key = "moduletypes_production" },
			{ key = "moduletypes_build" },
			{ key = "moduletypes_storage" },
			{ key = "moduletypes_habitation" },
			{ key = "moduletypes_welfare" },
			{ key = "moduletypes_defence" },
			{ key = "moduletypes_dock" },
			{ key = "moduletypes_processing" },
			{ key = "moduletypes_other", additionalcategories = { "moduletypes_radar" } },
			{ key = "moduletypes_venture" },
		},
		["ship"] = {
			{ key = "ship_xl" },
			{ key = "ship_l" },
			{ key = "ship_m" },
			{ key = "ship_s" },
		},
	},
	categorynames = {
		["moduletypes_production"]		= ReadText(1001, 2421),
		["moduletypes_build"]			= ReadText(1001, 2439),
		["moduletypes_storage"]			= ReadText(1001, 2422),
		["moduletypes_habitation"]		= ReadText(1001, 2451),
		["moduletypes_welfare"]			= ReadText(1001, 9620),
		["moduletypes_defence"]			= ReadText(1001, 2424),
		["moduletypes_dock"]			= ReadText(1001, 2452),
		["moduletypes_processing"]		= ReadText(1001, 9621),
		["moduletypes_other"]			= ReadText(1001, 2453),
		["moduletypes_venture"]			= ReadText(1001, 2454),
		["ship_xl"]						= ReadText(1001, 11003),
		["ship_l"]						= ReadText(1001, 11002),
		["ship_m"]						= ReadText(1001, 11001),
		["ship_s"]						= ReadText(1001, 11000),
	}
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

-- init menu and register with Helper
local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

-- cleanup variables in menu, no need for the menu variable to keep all the data while the menu is not active
function menu.cleanup()
	menu.playermoney = nil
	menu.totalprice = nil

	menu.blueprintstopurchase = {}
	menu.equipmenttagnames = {}
	menu.equipmenttags = {}
	menu.equipmentnumwares = {}
	menu.licencestopurchase = {}
	menu.licences = {}
	menu.primarytagnames = {}
	menu.primarytags = {}
	menu.tradecontainer = nil
	menu.traderfaction = nil
	menu.trader = nil

	menu.title = nil
	menu.header = nil
	menu.uirelations = nil
	menu.selectedrowdata = nil

	menu.table_top = {}
	menu.table_wares = {}

	menu.expanded = {}
	menu.queueupdate = nil
	menu.selectedrow = nil
	menu.toprow = nil

	menu.frame = nil
end

function menu.onShowMenu()
	menu.trader = C.GetPlayerComputerID()
	if menu.param[3] then
		menu.trader = ConvertIDTo64Bit(menu.param[3])
	end
	menu.traderfaction = GetComponentData(menu.trader, "owner")
	menu.tradecontainer = GetContextByClass(menu.trader, "container", false)
	--print("trader: " .. tostring(GetComponentData(menu.trader, "name")) .. " container: " .. tostring(GetComponentData(menu.tradecontainer, "name")))
	menu.playermoney = GetPlayerMoney()
	menu.totalprice = 0
	menu.mode = "blueprint"
	if menu.param[4] then
		menu.mode = menu.param[4]
	end

	if menu.mode == "licence" then
		menu.title = ReadText(1001, 62)		-- Licences
		menu.header = ReadText(1001, 61)		-- Licence
		menu.uirelation = GetUIRelation(menu.traderfaction)
		menu.licences = GetOwnLicences(menu.traderfaction)
	else
		menu.title = ReadText(1001, 98)		-- "Blueprints"
		menu.header = ReadText(1001, 97)		-- "Blueprint"
		menu.primarytags = {"module", "ship", "equipment"}
		menu.primarytagnames = {ReadText(1001, 7924), ReadText(1001, 6), ReadText(1001, 7935)}	-- Modules, Ships, Equipment
		menu.equipmenttags = { "weapon", "turret", "shield", "engine", "thruster", "missile", "drone", "consumables", "countermeasure" }
		menu.consumabletags = { "lasertower", "satellite", "mine", "navbeacon", "resourceprobe" }
		menu.equipmenttagnames = { ReadText(1001, 1301), ReadText(1001, 1319), ReadText(1001, 1317), ReadText(1001, 1103), ReadText(1001, 8001), ReadText(1001, 1304), ReadText(1001, 8), ReadText(1001, 8003), ReadText(1001, 8063) }	-- Weapons, Turrets, Shields, Engines, Thrusters, Missiles, Drones, Consumables, Countermeasures
		menu.equipmentnumwares = { 0, 0, 0, 0, 0, 0, 0, 0, 0 }
	end

	menu.table_top = {}
	menu.expanded = {}

	menu.initData()

	-- add content
	menu.display(true)
end

function menu.onShowMenuSound()
	-- no sound
end

function menu.initData()
	menu.blueprintstopurchase = {}
	menu.licencestopurchase = {}

	if menu.mode == "licence" then

	else
		menu.table_wares = {}

		local numblueprints = C.GetNumBlueprints("", "", "")
		local blueprints = ffi.new("UIBlueprint[?]", numblueprints)
		numblueprints = C.GetBlueprints(blueprints, numblueprints, "", "", "")
		menu.blueprintlist = {}
		for i = 0, numblueprints-1 do
			menu.blueprintlist[ffi.string(blueprints[i].ware)] = true
		end

		for _, tag in ipairs(menu.primarytags) do
			if not menu.table_wares[tag] then
				menu.table_wares[tag] = {}
			end
			if tag == "equipment" then
				for i, equipmenttag in ipairs(menu.equipmenttags) do
					if not menu.table_wares[tag][equipmenttag] then
						menu.table_wares[tag][equipmenttag] = {}
					end
					local concattag = equipmenttag
					if equipmenttag == "consumables" then
						concattag = ""
						for _, tag in ipairs(menu.consumabletags) do
							concattag = concattag .. " " .. tag
						end
					end
					--print("tag: " .. tostring(concattag))
					local numwares = C.GetNumWares(concattag, false, menu.traderfaction, "noplayerblueprint missiononly")
					local wares = ffi.new("const char*[?]", numwares)
					numwares = C.GetWares(wares, numwares, concattag, false, menu.traderfaction, "noplayerblueprint missiononly")
					for j = 0, numwares - 1 do
						local locware = ffi.string(wares[j])
						local avgprice, macro = GetWareData(locware, "avgprice", "component")
						local hasinfoalias = (macro ~= "") and GetMacroData(macro, "hasinfoalias")
						local locprice = avgprice * 10
						if not hasinfoalias then
							menu.table_wares[tag][equipmenttag][locware] = locprice
							menu.equipmentnumwares[i] = menu.equipmentnumwares[i] + 1
						end
					end
				end
			else
				--print("tag: " .. tostring(tag))
				local numwares = C.GetNumWares(tag, false, menu.traderfaction, "noplayerblueprint missiononly")
				local wares = ffi.new("const char*[?]", numwares)
				numwares = C.GetWares(wares, numwares, tag, false, menu.traderfaction, "noplayerblueprint missiononly")
				for i = 0, numwares-1 do
					local locware = ffi.string(wares[i])
					local avgprice, maxprice, hasblueprint = GetWareData(locware, "avgprice", "maxprice", "hasblueprint")
					--print(locware .. (hasblueprint and ": hasblueprint" or ": no blueprint"))
					if hasblueprint then
						local locprice = avgprice * 10
						if tag == "module" then
							locprice = maxprice
						end
						menu.table_wares[tag][locware] = locprice
					end
				end
			end
		end
	end
end

function menu.display(firsttime)
	Helper.removeAllWidgetScripts(menu)

	menu.skiprowchange = not firsttime

	local width = Helper.viewWidth / 2
	local height = Helper.viewHeight / 2
	local xoffset = width / 2
	local yoffset = height / 2

	menu.frame = Helper.createFrameHandle(menu, { width = width + 2 * Helper.borderSize, height = height + 2 * Helper.borderSize, x = xoffset - Helper.borderSize, y = yoffset - Helper.borderSize })
	menu.frame:setBackground("solid", { color = Color["frame_background_semitransparent"] })
	local table_bottom, row

	-- we need table_bottom first because we need the y offset of table_bottom to figure out the height of table_top
	table_bottom = menu.frame:addTable(2, { tabOrder = 2, width = width / 2 - Helper.borderSize, x = width / 2 + 2 * Helper.borderSize })

	local row = table_bottom:addRow(false, {fixed = true})
	row[1]:setColSpan(2):createText(ReadText(1001, 2006), Helper.subHeaderTextProperties)		-- Transaction Details
	row[1].properties.halign = "center"

	row = table_bottom:addRow(false, {fixed = true})
	row[1]:createText((ReadText(1001, 2005) .. ReadText(1001, 120)))		-- Transaction Value:
	row[2]:createText(function() return (ConvertMoneyString(tostring(-menu.totalprice), false, true, nil, true) .. " " .. ReadText(1001, 101)) end, {halign = "right"})
	row[2].properties.color = function() return menu.totalprice < 0 and Color["text_positive"] or Color["text_negative"] end

	local row = table_bottom:addRow(false, {fixed = true})
	row[1]:createText((ReadText(1001, 2003) .. ReadText(1001, 120)))		-- Current Balance
	row[2]:createText(function() return (ConvertMoneyString(tostring(GetPlayerMoney()), false, true, nil, true) .. " " .. ReadText(1001, 101)) end, {halign = "right"})

	local row = table_bottom:addRow(false, {fixed = true})
	row[1]:createText((ReadText(1001, 2004) .. ReadText(1001, 120)))		-- Final Balance
	row[2]:createText(function() return (ConvertMoneyString(tostring(GetPlayerMoney() - menu.totalprice), false, true, nil, true) .. " " .. ReadText(1001, 101)) end, {halign = "right"})

	local row = table_bottom:addRow("buttonrow", { fixed = true })
	row[1]:createButton({ active = function() return (menu.totalprice ~= 0) and (GetPlayerMoney() >= menu.totalprice) end, helpOverlayID = "trader_purchase_confirm" , helpOverlayText = " ",  helpOverlayHighlightOnly = true })
	row[1]:setText(ReadText(1001, 2821), { halign = "center" })		-- Confirm
	row[1].handlers.onClick = function() return menu.buttonConfirm() end
	row[2]:createButton({ active = true, helpOverlayID = "trader_purchase_cancel", helpOverlayText = " ",  helpOverlayHighlightOnly = true })
	--row[2]:createButton({ active = function() return menu.totalprice ~= 0 end })
	row[2]:setText(ReadText(1001, 64), {halign = "center"})		-- Cancel
	row[2].handlers.onClick = function() return menu.buttonCancel() end

	table_bottom.properties.y = height - table_bottom:getVisibleHeight() + Helper.borderSize

	menu.table_top = menu.frame:addTable(5, { tabOrder = 1, maxVisibleHeight = table_bottom.properties.y - Helper.borderSize, x = Helper.borderSize, y = Helper.borderSize, width = width})
	menu.table_top:setColWidth(1, Helper.scaleY(Helper.standardTextHeight), false)
	menu.table_top:setColWidth(2, Helper.scaleY(Helper.standardTextHeight), false)
	menu.table_top:setColWidthPercent(4, 25)
	menu.table_top:setColWidthPercent(5, 25)

	-- standard header
	row = menu.table_top:addRow(false, { fixed = true, bgColor = Color["row_title_background"] })
	row[1]:setColSpan(5):createText(menu.title, Helper.titleTextProperties)

	row = menu.table_top:addRow(false, { fixed = true, bgColor = Color["row_background_unselectable"] })
	row[1]:setBackgroundColSpan(5)
	row[3]:createText(menu.header, { font = Helper.standaradFontBold })
	row[4]:createText(ReadText(1001, 2808), { font = Helper.standaradFontBold, halign = "center" })		-- Price

	row = menu.table_top:addRow(false, { fixed = true, bgColor = Color["row_separator"] })
	row[1]:setColSpan(5):createText("", { height = 1 })

	if menu.mode == "licence" then
		for _, licence in ipairs(menu.licences) do
			if licence.issellable then
				local haslicence = HasLicence("player", licence.type, menu.traderfaction)
				local precursorname = ""
				local canpurchase = not haslicence
				--print("canpurchase: " .. tostring(canpurchase))
				if canpurchase then
					if licence.precursor ~= nil then
						local hasprecursor = HasLicence("player", licence.precursor, menu.traderfaction)
						local licenceinfo = ffi.new("LicenceInfo")
						C.GetLicenceInfo(licenceinfo, menu.traderfaction, licence.precursor)
						precursorname = ffi.string(licenceinfo.name)
						--print("hasprecursor: " .. tostring(hasprecursor) .. ", precursor: " .. tostring(precursorname))
						if (licence.minrelation > menu.uirelation) or (not hasprecursor) then
							canpurchase = false
						end
					elseif licence.minrelation > menu.uirelation then
						canpurchase = false
					end
				end

				row = menu.table_top:addRow({ "entry", licence.id }, {  })

				row[1]:setColSpan(3):createText(licence.name, {color = function() return menu.licencestopurchase[licence.id] and Color["text_positive"] or Color["text_normal"] end})

				if not haslicence then
					row[4]:createText((ConvertMoneyString(tostring(licence.price), false, true, nil, true) .. " " .. ReadText(1001, 101)), {halign = "right", color = function() return menu.licencestopurchase[licence.id] and Color["text_positive"] or Color["text_normal"] end})
				end

				--print("available cash: " .. tostring(menu.playermoney - menu.totalprice) .. " price: " .. tostring(price) .. " active? " .. tostring((menu.playermoney - menu.totalprice) > price) .. " total cash: " .. tostring(menu.playermoney) .. " total price: " .. tostring(menu.totalprice))
				--print("licence: " .. tostring(licence) .. " canpurchase: " .. tostring(canpurchase))
				if haslicence then
					row[5]:createText(ReadText(1001, 84), { halign = "center", color = Color["text_player"], x = 0 })
				else
					row[5]:createButton({ active = (menu.licencestopurchase[licence.id] and true) or (canpurchase and (menu.playermoney - menu.totalprice) > licence.price) or false })
					row[5]:setText(function() return (HasLicence("player", licence.type, menu.traderfaction) and ReadText(1001, 84)) or (menu.licencestopurchase[licence.id] and ReadText(1001, 17)) or ReadText(1001, 3102) end, {halign = "center"})		-- Owned, Selected, Select
					row[5].handlers.onClick = function() return menu.buttonSelectLicence(licence, licence.price) end	-- TODO
					row[5].properties.bgColor = function() return menu.licencestopurchase[licence.id] and Color["row_background_selected"] or Color["button_background_default"] end
					row[5].properties.mouseOverText = row[5].properties.active and "" or (canpurchase and ReadText(1026, 8101) or string.format(ReadText(1026, 8103), ColorText["licence"] .. precursorname .. "\27X", licence.minrelation))	-- "You cannot afford this licence.", "Requires the %s($LICENCE_NAME$) ceremony \(Relation: %s\)."
				end
				AddKnownItem("licences", licence.id)
			end
		end
	else
		for tagindex, tag in ipairs(menu.primarytags) do
			row = menu.table_top:addRow({ "category", tag }, {  })
			row[1]:createButton({ active = true, height = Helper.scaleY(Helper.standardTextHeight), scaling = false, helpOverlayID = "trader_purchase_" .. tag, helpOverlayText = " ",  helpOverlayHighlightOnly = true })
			row[1]:setText(function() return menu.expanded[tag] and "-" or "+" end, {halign = "center"})
			row[1].handlers.onClick = function() return menu.buttonExpand(tag) end
			row[2]:setBackgroundColSpan(4)
			row[3]:createText(menu.primarytagnames[tagindex])

			if menu.expanded[tag] then
				if tag == "equipment" then
					for equipmenttagindex, equipmenttag in ipairs(menu.equipmenttags) do
						row = menu.table_top:addRow({ "category", equipmenttag }, {  })
						row[2]:createButton({ active = (menu.equipmentnumwares[equipmenttagindex] > 0), height = Helper.scaleY(Helper.standardTextHeight), scaling = false })
						row[2]:setText(function() return menu.expanded[equipmenttag] and "-" or "+" end, {halign = "center"})
						row[2].handlers.onClick = function() return menu.buttonExpand(equipmenttag) end
						row[3]:setBackgroundColSpan(3)
						row[3]:createText(menu.equipmenttagnames[equipmenttagindex], {x = Helper.standardTextOffsetx + Helper.standardIndentStep})

						if menu.expanded[equipmenttag] then
							local sortedwares = Helper.orderedKeys(menu.table_wares[tag][equipmenttag], (equipmenttag == "consumables") and menu.sortAmmo or Helper.sortWareName)
							for i = 1, #sortedwares do
								local ware = sortedwares[i]
								local price = menu.table_wares[tag][equipmenttag][ware]
								local tradelicence, ishiddenwithoutlicence = GetWareData(ware, "tradelicence", "ishiddenwithoutlicence")
								local licenced = HasLicence("player", tradelicence, menu.traderfaction)

								if (not ishiddenwithoutlicence) or licenced then
									local licencename, precursorname = "", ""
									local licencedata = GetLibraryEntry("licences", menu.traderfaction .. "." .. tradelicence)
									licencename = licencedata.name
									if licencedata.precursor ~= nil then
										local licenceinfo = ffi.new("LicenceInfo")
										C.GetLicenceInfo(licenceinfo, menu.traderfaction, licencedata.precursor)
										precursorname = ffi.string(licenceinfo.name)
									end
									row = menu.table_top:addRow({ "entry", ware }, {  })

									row[3]:createText(GetWareData(ware, "name"), {color = function() return menu.blueprintstopurchase[ware] and Color["text_positive"] or Color["text_normal"] end, x = Helper.standardTextOffsetx + Helper.standardIndentStep * 2})

									-- start: mycu callback
									if menu.uix_callbacks ["display_on_after_create_equipment_text"] then
										for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_create_equipment_text"]) do
											local name, macro = GetWareData(ware, "name", "component")
											result = uix_callback (macro, macro, name)
											if result then
												row[3].properties.mouseOverText = result.mouseovertext
											end
										end
									end
									-- end: mycu callback
									if not menu.blueprintlist[ware] then
										row[4]:createText((ConvertMoneyString(tostring(price), false, true, nil, true) .. " " .. ReadText(1001, 101)), {halign = "right", color = function() return menu.blueprintstopurchase[ware] and Color["text_positive"] or Color["text_normal"] end})
									end

									if menu.blueprintlist[ware] then
										row[5]:createText(ReadText(1001, 84), { halign = "center", color = Color["text_player"], x = 0 })
									else
										row[5]:createButton({ active = menu.blueprintstopurchase[ware] and true or (licenced and (menu.playermoney - menu.totalprice) > price) })
										row[5]:setText(function() return menu.blueprintstopurchase[ware] and ReadText(1001, 17) or ReadText(1001, 3102) end, {halign = "center"})		-- Selected, Select
										row[5].handlers.onClick = function() return menu.buttonSelectBlueprint(ware, price) end
										row[5].properties.bgColor = function() return menu.blueprintstopurchase[ware] and Color["row_background_selected"] or Color["button_background_default"] end
										row[5].properties.mouseOverText = row[5].properties.active and "" or (licenced and ReadText(1026, 8111) or string.format(ReadText(1026, 8104), ColorText["licence"] .. licencename .. "\27X", ColorText["licence"] .. precursorname .. "\27X", licencedata.minrelation))		-- "You cannot afford this blueprint.", "Requires the %s($LICENCE_NAME$) awarded in the %s($OTHER_LICENCE_NAME$) ceremony \(Relation: %s\)."
									end
								end
							end
						end
					end
				else
					local wares = {}
					for ware in pairs(menu.table_wares[tag]) do
						local name, macro = GetWareData(ware, "name", "component")
						local icon, class, purpose, infolibrary = ""
						if tag == "ship" then
							class = ffi.string(C.GetMacroClass(macro))
							local shipicon, primarypurpose = GetMacroData(macro, "icon", "primarypurpose")
							icon = "\27[" .. shipicon .. "] "
							purpose = primarypurpose
							infolibrary = class
						elseif tag == "module" then
							local moduleinfolibrary = GetMacroData(macro, "infolibrary")
							infolibrary = moduleinfolibrary
						end
						if infolibrary then
							if wares[infolibrary] then
								table.insert(wares[infolibrary], { ware = ware, name = icon .. name, class = class, purpose = purpose, objectid = "" })
							else
								wares[infolibrary] = { { ware = ware, name = icon .. name, class = class, purpose = purpose, objectid = "" } }
							end
						else
							table.insert(wares, { ware = ware, name = icon .. name, class = class, purpose = purpose, objectid = "" }) -- objectid used by Helper.sortShipsByClassAndPurpose
						end
					end
					if tag == "ship" then
						for _, data in pairs(wares) do
							table.sort(data, Helper.sortShipsByClassAndPurpose)
						end
					else
						if #wares > 0 then
							table.sort(wares, Helper.sortName)
						else
							for _, data in pairs(wares) do
								table.sort(data, Helper.sortName)
							end
						end
					end
					if config.blueprintorder[tag] then
						for _, key in ipairs(config.blueprintorder[tag]) do
							if wares[key.key] then
								row = menu.table_top:addRow({ "category", key.key }, {  })
								row[2]:createButton({ height = Helper.scaleY(Helper.standardTextHeight), scaling = false })
								row[2]:setText(function() return menu.expanded[key.key] and "-" or "+" end, {halign = "center"})
								row[2].handlers.onClick = function() return menu.buttonExpand(key.key) end
								row[3]:setBackgroundColSpan(3)
								row[3]:createText(config.categorynames[key.key], { x = Helper.standardTextOffsetx + Helper.standardIndentStep })
								if menu.expanded[key.key] then
									for _, entry in ipairs(wares[key.key]) do
										menu.showEntry(entry, tag, 2)
									end
									if key.additionalcategories then
										for _, additionalcategory in ipairs(key.additionalcategories) do
											for _, entry in ipairs(wares[additionalcategory]) do
												menu.showEntry(entry, tag, 2)
											end
										end
									end
								end
							end
						end
					else
						for _, entry in ipairs(wares) do
							menu.showEntry(entry, tag, 1)
						end
					end
				end
			end
		end
	end

	if menu.selectedrow then
		menu.table_top:setSelectedRow(menu.selectedrow)
		menu.selectedrow = nil
		if menu.toprow then
			menu.table_top:setTopRow(menu.toprow)
			menu.toprow = nil
		end
	end

	local table_desc = menu.frame:addTable(1, { width = width / 2, x = Helper.borderSize, tabOrder = 3, highlightMode = "off", skipTabChange = true })

	local row = table_desc:addRow(false, { fixed = true })
	row[1]:createText(ReadText(1001, 2404), Helper.subHeaderTextProperties)
	row[1].properties.halign = "center"

	local text = ""
	if menu.selectedrowdata then
		if menu.mode == "licence" then
			for _, licence in ipairs(menu.licences) do
				if licence.id == menu.selectedrowdata then
					text = licence.desc
					break
				end
			end
		else
			text = GetWareData(menu.selectedrowdata, "description")
		end
	end
	local textwidth = width / 2 - 2 * Helper.standardTextOffsetx
	local description = GetTextLines(text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), textwidth)
	if #description > 4 then
		description = GetTextLines(text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), textwidth - Helper.scrollbarWidth)
	end
	for i, line in ipairs(description) do
		local row = table_desc:addRow(true, {  })
		row[1]:createText(line)
		if i == 4 then
			table_desc.properties.maxVisibleHeight = table_desc:getFullHeight()
		end
	end

	local yoffset = math.max(table_bottom:getVisibleHeight(), table_desc:getVisibleHeight()) --+ Helper.borderSize
	table_bottom.properties.y = height - yoffset
	table_desc.properties.y = height - yoffset
	menu.table_top.properties.maxVisibleHeight = table_bottom.properties.y - Helper.borderSize

	menu.table_top:addConnection(1, 1, true)
	table_bottom:addConnection(2, 1)

	menu.frame:display()
end

function menu.showEntry(entry, tag, indent)
	local ware = entry.ware
	local price = menu.table_wares[tag][ware]
	local tradelicence, ishiddenwithoutlicence = GetWareData(ware, "tradelicence", "ishiddenwithoutlicence")
	local licenced = HasLicence("player", tradelicence, menu.traderfaction)
	if ishiddenwithoutlicence and (not licenced) then
		-- don't show hidden 
		return
	end

	local licenceinfo = ffi.new("LicenceInfo")
	local licencename, precursorname, minrelation = "", ""
	local licencedata = GetLibraryEntry("licences", menu.traderfaction .. "." .. tradelicence)
	licencename = licencedata.name or ""
	if licencedata.precursor ~= nil then
		local licenceinfo = ffi.new("LicenceInfo")
		C.GetLicenceInfo(licenceinfo, menu.traderfaction, licencedata.precursor)
		precursorname = ffi.string(licenceinfo.name)
	end

	row = menu.table_top:addRow({ "entry", ware }, {})
	row[3]:createText(entry.name, { color = function() return menu.blueprintstopurchase[ware] and Color["text_positive"] or Color["text_normal"] end, x = Helper.standardTextOffsetx + Helper.standardIndentStep * indent })

	if not menu.blueprintlist[ware] then
		row[4]:createText((ConvertMoneyString(tostring(price), false, true, nil, true) .. " " .. ReadText(1001, 101)), {halign = "right", color = function() return menu.blueprintstopurchase[ware] and Color["text_positive"] or Color["text_normal"] end})
	end

	--print("available cash: " .. tostring(menu.playermoney - menu.totalprice) .. " price: " .. tostring(price) .. " active? " .. tostring((menu.playermoney - menu.totalprice) > price) .. " total cash: " .. tostring(menu.playermoney) .. " total price: " .. tostring(menu.totalprice))
	--print("ware: " .. tostring(ware) .. " trade licence: " .. tostring(GetWareData(ware, "tradelicence")) .. " player has licence: " .. tostring(HasLicence("player", GetWareData(ware, "tradelicence"), menu.traderfaction)))
	if menu.blueprintlist[ware] then
		row[5]:createText(ReadText(1001, 84), { halign = "center", color = Color["text_player"], x = 0 })
	else
		row[5]:createButton({ active = menu.blueprintstopurchase[ware] and true or (licenced and (menu.playermoney - menu.totalprice) > price) })
		row[5].properties.helpOverlayID = "trader_purchase_" .. tostring(ware)
		row[5].properties.helpOverlayText = " "
		row[5].properties.helpOverlayHighlightOnly = true
		row[5]:setText(function() return menu.blueprintstopurchase[ware] and ReadText(1001, 17) or ReadText(1001, 3102) end, { halign = "center" })		-- Selected, Select
		row[5].properties.mouseOverText = row[5].properties.active and "" or (licenced and ReadText(1026, 8111) or string.format(ReadText(1026, 8104), ColorText["licence"] .. licencename .. "\27X", ColorText["licence"] .. precursorname .. "\27X", licencedata.minrelation))		-- "You cannot afford this blueprint.", "Requires the %s($LICENCE_NAME$) awarded in the %s($OTHER_LICENCE_NAME$) ceremony \(Relation: %s\)."
		row[5].handlers.onClick = function() return menu.buttonSelectBlueprint(ware, price) end
		row[5].properties.bgColor = function() return menu.blueprintstopurchase[ware] and Color["row_background_selected"] or Color["button_background_default"] end
	end
end

-- widget scripts
function menu.buttonExpand(tag)
	if menu.expanded[tag] then
		menu.expanded[tag] = nil
	else
		menu.expanded[tag] = true
	end

	menu.toprow = GetTopRow(menu.table_top.id)
	menu.selectedrow = Helper.currentTableRow[menu.table_top.id]
	menu.queueupdate = true
end

function menu.buttonConfirm()
	if GetPlayerMoney() >= menu.totalprice then
		if menu.mode == "licence" then
			for licenceid, licenceinfo in pairs(menu.licencestopurchase) do
				--print("adding licence " .. tostring(licenceid) .. " from " .. tostring(menu.traderfaction))
				AddLicence("player",  licenceinfo.type, menu.traderfaction)
			end
		else
			for ware, _ in pairs(menu.blueprintstopurchase) do
				C.LearnBlueprint(ware)
			end
		end
		TransferPlayerMoneyTo(menu.totalprice, menu.tradecontainer)
	end
	menu.initData()
	menu.tallyTotalPrice()
	-- activate this and remove Helper.closeMenuAndReturn() and menu.cleanup if we later decide to keep the menu open.
	--[[
	-- NB: doing this here rather than in onUpdate so that hitting Cancel resets your position in the menu. remove here and activate in onUpdate if we prefer that the menu position is never reset.
	menu.toprow = GetTopRow(menu.table_top.id)
	menu.selectedrow = Helper.currentTableRow[menu.table_top.id]
	-- NB: we only need to refresh the menu here because we cannot set button.properties.active to a function and run those functions upon frame:update()
	menu.queueupdate = true
	]]
	Helper.closeMenuAndReturn(menu)
	menu.cleanup()
end

function menu.buttonCancel()
	menu.blueprintstopurchase = {}
	menu.licencestopurchase = {}
	menu.tallyTotalPrice()
	-- activate this and remove Helper.closeMenuAndReturn() and menu.cleanup if we later decide to keep the menu open.
	--[[
	menu.expanded = {}
	-- NB: we only need to refresh the menu here because we cannot set button.properties.active to a function and run those functions upon frame:update()
	menu.queueupdate = true
	]]
	Helper.closeMenuAndReturn(menu)
	menu.cleanup()
end

function menu.buttonSelectLicence(licence, price)
	if not menu.licencestopurchase[licence.id] then
		menu.licencestopurchase[licence.id] = { type = licence.type, price = price }
	else
		menu.licencestopurchase[licence.id] = nil
	end
	AddUITriggeredEvent(menu.name,  "trader_purchase_" .. licence.name, menu.licencestopurchase[licence.id] and true or false)
	-- NB: doing this here rather than in onUpdate so that hitting Cancel resets your position in the menu. remove here and activate in onUpdate if we prefer that the menu position is never reset.
	menu.toprow = GetTopRow(menu.table_top.id)
	menu.selectedrow = Helper.currentTableRow[menu.table_top.id]
	menu.tallyTotalPrice()
	menu.queueupdate = true
end

function menu.buttonSelectBlueprint(ware, price)
	if not menu.blueprintstopurchase[ware] then
		menu.blueprintstopurchase[ware] = price
	else
		menu.blueprintstopurchase[ware] = nil
	end
	AddUITriggeredEvent(menu.name,  "trader_purchase_" .. tostring(ware), menu.blueprintstopurchase[ware] and true or false)
	-- NB: doing this here rather than in onUpdate so that hitting Cancel resets your position in the menu. remove here and activate in onUpdate if we prefer that the menu position is never reset.
	menu.toprow = GetTopRow(menu.table_top.id)
	menu.selectedrow = Helper.currentTableRow[menu.table_top.id]
	menu.tallyTotalPrice()
	menu.queueupdate = true
end

-- helper functions
function menu.tallyTotalPrice()
	menu.totalprice = 0
	if menu.mode == "licence" then
		for licenceid, licenceinfo in pairs(menu.licencestopurchase) do
			menu.totalprice = menu.totalprice + licenceinfo.price
		end
	else
		for ware, price in pairs(menu.blueprintstopurchase) do
			menu.totalprice = menu.totalprice + price
		end
	end
end

function menu.sortAmmo(a, b)
	local amacro = GetWareData(a, "component")
	local bmacro = GetWareData(b, "component")

	local atype, btype = "", ""
	if IsMacroClass(amacro, "satellite") then
		atype = "satellite"
	elseif IsMacroClass(amacro, "navbeacon") then
		atype = "navbeacon"
	elseif IsMacroClass(amacro, "resourceprobe") then
		atype = "resourceprobe"
	elseif IsMacroClass(amacro, "mine") then
		atype = "mine"
	elseif GetMacroData(amacro, "islasertower") then
		atype = "lasertower"
	end
	if IsMacroClass(bmacro, "satellite") then
		btype = "satellite"
	elseif IsMacroClass(bmacro, "navbeacon") then
		btype = "navbeacon"
	elseif IsMacroClass(bmacro, "resourceprobe") then
		btype = "resourceprobe"
	elseif IsMacroClass(bmacro, "mine") then
		btype = "mine"
	elseif GetMacroData(bmacro, "islasertower") then
		btype = "lasertower"
	end

	if atype == btype then
		return Helper.sortMacroName(amacro, bmacro)
	end
	return config.deployableOrder[atype] < config.deployableOrder[btype]
end

menu.updateInterval = 0.1

function menu.onUpdate()
	menu.frame:update()

	if menu.queueupdate then
		menu.queueupdate = nil
		menu.refreshMenu()
	end
end

function menu.refreshMenu()
	menu.toprow = GetTopRow(menu.table_top.id)
	menu.selectedrow = Helper.currentTableRow[menu.table_top.id]
	menu.display()
end

function menu.onRowChanged(row, rowdata, uitable)
	if uitable == menu.table_top.id then
		if (type(rowdata) == "table") and (rowdata[1] == "entry") then
			menu.selectedrowdata = rowdata[2]
		else
			menu.selectedrowdata = nil
		end
		if not menu.skiprowchange then
			menu.queueupdate = true
		end
		menu.skiprowchange = nil
	end
end

function menu.onCloseElement(dueToClose)
	Helper.closeMenuAndReturn(menu)
	menu.cleanup()
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- param == { 0, 0, container }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	bool IsComponentOperational(UniverseID componentid);
	bool IsMouseEmulationActive(void);
	bool IsRealComponentClass(UniverseID componentid, const char* classname);
]]

local menu = {
	name = "TransactionLogMenu",
	lastRefreshTime = 0,
}

local config = {
	infoLayer = 4,
	contextLayer = 2,
	mouseOutRange = 100,
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.cleanup()
	menu.infoFrame = nil
	menu.sidebar = nil

	-- start: kuertee call-back
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback ()
		end
	end
	-- end: kuertee call-back
end

-- widget scripts

function menu.buttonRightBar(newmenu, params)
	Helper.closeMenuAndOpenNewMenu(menu, newmenu, params, true)
	menu.cleanup()
end

function menu.buttonContainerInfo(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", controllable } })
	menu.cleanup()
end

function menu.buttonTransactionLog(controllable)
	Helper.closeMenuAndOpenNewMenu(menu, "TransactionLogMenu", { 0, 0, controllable });
	menu.cleanup()
end

-- Menu member functions

function menu.onShowMenu()
	-- Init
	menu.containerid = menu.param[3]
	menu.container = ConvertIDTo64Bit(menu.containerid)

	menu.isstation = C.IsRealComponentClass(menu.container, "station")

	menu.selectedRows = {}

	-- display main frame
	menu.createFrame()
end

function menu.createFrame(toprow, selectedrow)
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	local frameProperties = {
		layer = config.infoLayer,
		standardButtons = {},
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		x = 0,
		y = 0,
		standardButtons = { back = true, close = true, help = true  }
	}
	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)
	menu.infoFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.sidebarWidth = Helper.scaleX(Helper.sidebarWidth)

	if menu.isstation then
		local rightbartable = Helper.createRightSideBar(menu.infoFrame, menu.container, true, "transactions", menu.buttonRightBar)
		rightbartable:addConnection(1, 4, true)
	end

	local tableProperties = {
		width = Helper.playerInfoConfig.width * 5 / 4,
		height = Helper.viewHeight - 2 * Helper.frameBorder,
		x = Helper.frameBorder,
		y = Helper.frameBorder,
		x2 = menu.isstation and (menu.sidebarWidth + Helper.borderSize + Helper.frameBorder) or Helper.frameBorder,
	}
	local selection = {}
	if menu.infoTable then
		selection = { toprow = toprow or GetTopRow(menu.infoTable), selectedrow = selectedrow or Helper.currentTableRow[menu.infoTable] }
	end
	Helper.createTransactionLog(menu.infoFrame, menu.container, tableProperties, menu.createFrame, selection)

	-- start: kuertee call-back
	if menu.uix_callbacks ["createFrame_on_create_transaction_log"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createFrame_on_create_transaction_log"]) do
				uix_callback ()
			end
		end
	-- end: kuertee call-back

	menu.infoFrame:display()
	menu.lastRefreshTime = getElapsedTime()
end

function menu.createContextFrame(data, x, y, width, nomouseout)
	Helper.removeAllWidgetScripts(menu, config.contextLayer)
	PlaySound("ui_positive_click")

	local contextmenuwidth = width or menu.contextMenuWidth

	menu.contextFrame = Helper.createFrameHandle(menu, {
		layer = config.contextLayer,
		standardButtons = { close = true },
		width = contextmenuwidth,
		x = x,
		y = 0,
		autoFrameHeight = true,
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local ftable = menu.contextFrame:addTable(1, { tabOrder = 4, highlightMode = "off" })
	local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[data]
	if entryIdx == nil then
		return
	end
	local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
	local active = (entry.partner ~= 0) and C.IsComponentOperational(entry.partner)

	local row = ftable:addRow(false, { fixed = true })
	local text = TruncateText(entry.partnername, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), contextmenuwidth - 2 * Helper.scaleX(Helper.standardButtonWidth))
	row[1]:createText(text, Helper.headerRowCenteredProperties)
	row[1].properties.mouseOverText = entry.partnername

	row = ftable:addRow(true, { fixed = true })
	row[1]:createButton({ active = active, bgColor = active and Color["button_background_default"] or Color["button_background_inactive"] }):setText(ReadText(1001, 2427), { color = active and Color["text_normal"] or Color["text_inactive"] })
	row[1].handlers.onClick = function () return menu.buttonContainerInfo(entry.partner) end

	if active and GetComponentData(ConvertStringTo64Bit(tostring(entry.partner)), "isplayerowned") then
		row = ftable:addRow(true, { fixed = true })
		row[1]:createButton({ active = active, bgColor = active and Color["button_background_default"] or Color["button_background_inactive"] }):setText(ReadText(1001, 7702), { color = active and Color["text_normal"] or Color["text_inactive"] })
		row[1].handlers.onClick = function () return menu.buttonTransactionLog(entry.partner) end
	end

	if menu.contextFrame.properties.x + contextmenuwidth > Helper.viewWidth then
		menu.contextFrame.properties.x = Helper.viewWidth - contextmenuwidth - Helper.frameBorder
	end
	local height = menu.contextFrame:getUsedHeight()
	if y + height > Helper.viewHeight then
		menu.contextFrame.properties.y = Helper.viewHeight - height - Helper.frameBorder
	else
		menu.contextFrame.properties.y = y
	end

	menu.contextFrame:display()

	if not nomouseout then
		menu.mouseOutBox = {
			x1 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2                    - config.mouseOutRange,
			x2 =   menu.contextFrame.properties.x -  Helper.viewWidth / 2 + contextmenuwidth + config.mouseOutRange,
			y1 = - menu.contextFrame.properties.y + Helper.viewHeight / 2                    + config.mouseOutRange,
			y2 = - menu.contextFrame.properties.y + Helper.viewHeight / 2 - height           - config.mouseOutRange
		}
	end
end

function menu.viewCreated(layer, ...)
	if menu.isstation then
		menu.sidebar, menu.infoTable = ...
	else
		menu.infoTable = ...
	end
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	Helper.onTransactionLogUpdate()

	-- kuertee start: in case onUpdate is called without the menu being opened. i.e. from kuertee_trade_analytics mod.
	if not menu.infoFrame then
		return
	end
	-- kuertee end: in case onUpdate is called without the menu being opened. i.e. from kuertee_trade_analytics mod.

	menu.infoFrame:update()

	if not Helper.transactionLogData.noupdate then
		local curtime = getElapsedTime()
		if curtime > menu.lastRefreshTime + 10 then
			menu.createFrame()
		end
	end

	if menu.mouseOutBox then
		if (GetControllerInfo() ~= "gamepad") or (C.IsMouseEmulationActive()) then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.closeContextMenu()
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.closeContextMenu()
			end
		end
	end
end

function menu.onRowChanged(row, rowdata, uitable)
	if uitable == menu.infoTable then
		Helper.onTransactionLogRowChanged(rowdata)
	end
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onEditBoxActivated(widget)
	Helper.onTransactionLogEditBoxActivated(widget)
end

function menu.onTableRightMouseClick(uitable, row, posx, posy)
	if uitable == menu.infoTable then
		local rowdata = menu.rowDataMap[uitable] and menu.rowDataMap[uitable][row]

		local entryIdx = Helper.transactionLogData.transactionsByIDUnfiltered[rowdata]
		if entryIdx == nil then
			return
		end
		local entry = Helper.transactionLogData.accountLogUnfiltered[entryIdx]
		if entry.partnername ~= "" then
			local x, y = GetLocalMousePosition()
			if x == nil then
				-- gamepad case
				x = posx
				y = -posy
			end
			menu.contextMenuMode = "transactionlog"
			menu.createContextFrame(rowdata, x + Helper.viewWidth / 2, Helper.viewHeight / 2 - y, Helper.scaleX(260))
		end
	end
end

function menu.closeContextMenu()
	Helper.clearFrame(menu, config.contextLayer)
	menu.contextMenuMode = nil
	menu.mouseOutBox = nil
end

function menu.onCloseElement(dueToClose)
	if dueToClose == "back" then
		if menu.contextMenuMode then
			menu.closeContextMenu()
			return
		end

		if Helper.checkDiscardStationEditorChanges(menu) then
			return
		end
	end

	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- param == { 0, 0, transporter, transporterconnection }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef struct {
		const char* factionID;
		const char* factionName;
		const char* factionIcon;
	} FactionDetails;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	typedef uint64_t UniverseID;
	const char* GetActiveObjectiveType(void);
	const char* GetComponentClass(UniverseID componentid);
	const char* GetComponentName(UniverseID componentid);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	UniverseID GetContextForTransporterCheck(UniverseID positionalid);
	UniverseID GetSlotComponent(UIComponentSlot slot);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumValidTransporterTargets2(UniverseID componentid, UIComponentSlot currentlocation);
	const char* GetObjectIDCode(UniverseID objectid);
	FactionDetails GetOwnerDetails(UniverseID componentid);
	UniverseID GetRoomForTransporter(UIComponentSlot transporter);
	UniverseID GetTransporterLocationComponent(UIComponentSlot transporter);
	const char* GetTransporterLocationName(UIComponentSlot transporter);
	uint32_t GetValidTransporterTargets2(UIComponentSlot* result, uint32_t resultlen, UniverseID componentid, UIComponentSlot currentlocation);
	bool IsComponentClass(UniverseID componentid, const char* classname);
	bool IsShipAtExternalDock(UniverseID shipid);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	void TransportPlayerToTarget(UIComponentSlot target);
]]

local menu = {
	name = "TransporterMenu",
	extendedcategories = {
		["ships"] = true,
		["npcs"] = true,
	},
}

local config = {
	sortOrder = {
		["dyninterior"] = 1,
		["cockpit"] = 2,
		["shipinterior"] = 3,
		["walkablemodule"] = 4,
		["ship"] = 5,
		["parent"] = 6,
		["zone"] = 7,
	},
	roomClassSortOrder = {
		["room"] = 1,
		["dockingbay"] = 2,
	},
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.cleanup()
	menu.transportercomponent = nil
	menu.transporterconnection = nil
	menu.targets = {}
	menu.currentselection = nil
	menu.npcs = {}
	menu.extendInfo = nil
	
	menu.refresh = nil
	
	menu.pretoprow = nil
	menu.preselectrow = nil

	menu.infotable = nil
	menu.selecttable = nil
end

-- Menu member functions

function menu.buttonGoTo()
	if (not menu.currentselection.hassubentries) or menu.currentselection.target then
		if (menu.transportercomponent ~= menu.currentselection.target.component) or (menu.transporterconnection ~= menu.currentselection.target.connection) then
			if C.IsComponentClass(menu.currentselection.target.component, "zone") then
				-- space suit case
				Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "transporter", { menu.currentselection.target.component, menu.currentselection.target.connection } })
			else
				C.TransportPlayerToTarget(menu.currentselection.target)
				Helper.closeMenuAndReturn(menu)
			end
			menu.cleanup()
		end
	end
end

function menu.buttonExtendCategory(category)
	if menu.extendedcategories[category] then
		menu.extendedcategories[category] = nil
	else
		menu.extendedcategories[category] = true
	end
	menu.pretoprow = GetTopRow(menu.selecttable)
	menu.preselectrow = Helper.currentTableRow[menu.selecttable]
	menu.display()
end

function menu.buttonExpand(category)
	menu.extendInfo = not menu.extendInfo
	menu.pretoprow = GetTopRow(menu.selecttable)
	menu.preselectrow = Helper.currentTableRow[menu.selecttable]
	menu.display()
end

function menu.onShowMenu()
	C.SetTrackedMenuFullscreen(menu.name, false)
	menu.transportercomponent = ConvertIDTo64Bit(menu.param[3])
	menu.transporterconnection = ffi.string(menu.param[4])

	menu.extendInfo = false

	menu.topcontext = menu.transportercomponent
	while true do
		if C.IsComponentClass(menu.topcontext, "ship_m") or C.IsComponentClass(menu.topcontext, "ship_s") then
			break
		end
		local context = C.GetContextByClass(menu.topcontext, "container", false)
		if context ~= 0 then
			menu.topcontext = context
		else
			break
		end
	end

	menu.targets = {}
	local targets = {}
	if menu.transportercomponent ~= 0 then
		local curLocationSlot = ffi.new("UIComponentSlot")
		curLocationSlot.component = menu.transportercomponent
		curLocationSlot.connection = menu.transporterconnection

		local n = C.GetNumValidTransporterTargets2(menu.transportercomponent, curLocationSlot)
		local buf = ffi.new("UIComponentSlot[?]", n)
		n = C.GetValidTransporterTargets2(buf, n, menu.transportercomponent, curLocationSlot)
		local found = false
		for i = 0, n - 1 do
			local component = buf[i].component
			local connection = ffi.string(buf[i].connection)
			table.insert(targets, { component = component, connection = connection })
			if (component == menu.transportercomponent) and (connection == menu.transporterconnection) then
				found = true
			end
		end
		if not found then
			table.insert(targets, { component = menu.transportercomponent, connection = menu.transporterconnection })
		end
	end

	for _, target in ipairs(targets) do
		local iscurrent
		if menu.transportercomponent == target.component and menu.transporterconnection == target.connection then
			iscurrent = true
		end
		local parent, roomtype = GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "parent", "roomtype")
		parent = ConvertIDTo64Bit(parent)
		if C.IsComponentClass(parent, "walkablemodule") then
			local containercontext = C.GetContextByClass(parent, "container", false)
			if containercontext == menu.topcontext then
				local i = menu.findArrayEntry(menu.targets, parent)
				if i == nil then
					table.insert(menu.targets, { type = "walkablemodule", component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent, hasshiptradercorner = roomtype == "shiptradercorner", hastradercorner = roomtype == "tradercorner" })
					menu.extendedcategories[tostring(parent)] = true
				else
					if iscurrent then
						menu.targets[i].iscurrent = iscurrent
					end
					if roomtype == "shiptradercorner" then
						menu.targets[i].hasshiptradercorner = true
					end
					if roomtype == "tradercorner" then
						menu.targets[i].hastradercorner = true
					end
					table.insert(menu.targets[i].subtargets, target)
				end
			else
				local i = menu.findArrayEntry(menu.targets, containercontext)
				if i == nil then
					table.insert(menu.targets, { type = "walkablemodule", component = containercontext, subtargets = {}, subcomponents = { { component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent } } })
					menu.extendedcategories[tostring(containercontext)] = true
				else
					local subcomponents = menu.targets[i].subcomponents
					local j = menu.findArrayEntry(subcomponents, parent)
					if j == nil then
						table.insert(subcomponents, { type = "walkablemodule", component = parent, directtarget = target, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
						menu.extendedcategories[tostring(parent)] = true
					else
						if iscurrent then
							subcomponents[j].iscurrent = iscurrent
						end
						table.insert(subcomponents[j].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "ship") then
			local iscockpit, isexit = false, false
			local room = C.GetRoomForTransporter(target)
			if room ~= 0 then
				if C.IsComponentClass(room, "cockpit") then
					iscockpit = true
				elseif C.GetContextByClass(room, "container", false) ~= parent then
					isexit = true
				end
			end
			if isexit then
				-- If ship is mission target, the exit should not be highlighted as mission target
				local shipismissiontarget = GetComponentData(ConvertStringTo64Bit(tostring(parent)), "ismissiontarget")
				table.insert(menu.targets, { type = "parent", component = C.GetContextByClass(parent, "container", false), directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent, nomissiontarget = shipismissiontarget })
			else
				local i = menu.findArrayEntry(menu.targets, parent)
				if i == nil then
					if iscockpit then
						local type = "ship"
						local subtarget = target
						if parent == menu.topcontext then
							type = "cockpit"
							subtarget = nil
						end
						table.insert(menu.targets, { type = type, component = parent, directtarget = target, subtargets = { subtarget }, subcomponents = {}, iscurrent = iscurrent })
					else
						table.insert(menu.targets, { type = "ship", component = parent, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
					end
					menu.extendedcategories[tostring(parent)] = true
				else
					if iscurrent then
						menu.targets[i].iscurrent = iscurrent
					end
					if iscockpit then
						if parent == menu.topcontext then
							menu.targets[i].type = "cockpit"
						else
							table.insert(menu.targets[i].subtargets, target)
						end
						menu.targets[i].directtarget = target
					else
						table.insert(menu.targets[i].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "navcontext") then
			local containercontext = C.GetContextByClass(parent, "container", true)
			if containercontext == menu.topcontext then
				table.insert(menu.targets, { type = "dyninterior", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
			else
				local i = menu.findArrayEntry(menu.targets, containercontext)
				if i == nil then
					table.insert(menu.targets, { type = "ship", component = containercontext, subtargets = {}, subcomponents = { { component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent } } })
					menu.extendedcategories[tostring(containercontext)] = true
				else
					local subcomponents = menu.targets[i].subcomponents
					local j = menu.findArrayEntry(subcomponents, parent)
					if j == nil then
						table.insert(subcomponents, { type = "ship", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
						menu.extendedcategories[tostring(parent)] = true
					else
						if iscurrent then
							subcomponents[j].iscurrent = iscurrent
						end
						table.insert(subcomponents[j].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(parent, "ventureplatform") or C.IsComponentClass(parent, "connectionmodule") then
			table.insert(menu.targets, { type = "dyninterior", component = parent, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
		elseif C.IsComponentClass(target.component, "ship") then
			local iscockpit, isexit = false, false
			local room = C.GetRoomForTransporter(target)
			if room ~= 0 then
				if C.IsComponentClass(room, "cockpit") then
					iscockpit = true
				elseif C.GetContextByClass(room, "container", false) ~= parent then
					isexit = true
				end
			end
			if isexit then
				-- If ship is mission target, the exit should not be highlighted as mission target
				local shipismissiontarget = GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "ismissiontarget")
				table.insert(menu.targets, { type = "parent", component = C.GetContextByClass(parent, "container", false), directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent, nomissiontarget = shipismissiontarget })
			else
				local i = menu.findArrayEntry(menu.targets, target.component)
				if i == nil then
					if iscockpit then
						local subtarget = target
						if target.component == menu.topcontext then
							subtarget = nil
						end
						table.insert(menu.targets, { type = "cockpit", component = target.component, directtarget = target, subtargets = { subtarget }, subcomponents = {}, iscurrent = iscurrent })
					else
						table.insert(menu.targets, { type = "shipinterior", component = target.component, subtargets = { target }, subcomponents = {}, iscurrent = iscurrent })
					end
					menu.extendedcategories[tostring(target.component)] = true
				else
					if iscockpit then
						menu.targets[i].type = "cockpit"
						menu.targets[i].directtarget = target
						if target.component ~= menu.topcontext then
							table.insert(menu.targets[i].subtargets, target)
						end
					else
						table.insert(menu.targets[i].subtargets, target)
					end
				end
			end
		elseif C.IsComponentClass(target.component, "zone") then
			table.insert(menu.targets, { type = "zone", component = menu.topcontext, directtarget = target, subtargets = {}, subcomponents = {}, iscurrent = iscurrent })
		end
	end
	table.sort(menu.targets, menu.sortTargets)

	for _, target in ipairs(menu.targets) do
		table.sort(target.subtargets, menu.sortSubTargets)
	end
	menu.currentselection = {}
	menu.currentselection.target = ffi.new("UIComponentSlot")
	menu.currentselection.target.component = menu.transportercomponent
	menu.currentselection.target.connection = menu.transporterconnection

	menu.display()
end

function menu.onShowMenuSound()
	-- no sound
end

function menu.sortTargets(a, b)
	if config.sortOrder[a.type] == config.sortOrder[b.type] then
		if a.directtarget and b.directtarget then
			if a.iscurrent ~= b.iscurrent then
				return a.iscurrent and (not b.iscurrent)
			end
			if a.hasshiptradercorner ~= b.hasshiptradercorner then
				return a.hasshiptradercorner and (not b.hasshiptradercorner)
			end
			if a.hastradercorner ~= b.hastradercorner then
				return a.hastradercorner and (not b.hastradercorner)
			end
			return ffi.string(C.GetTransporterLocationName(a.directtarget)) < ffi.string(C.GetTransporterLocationName(b.directtarget))
		end
		return a.directtarget and not b.directtarget
	end
	return config.sortOrder[a.type] < config.sortOrder[b.type]
end

function menu.sortSubTargets(a, b)
	local aroom = ffi.string(C.GetComponentClass(C.GetRoomForTransporter(a)))
	local broom = ffi.string(C.GetComponentClass(C.GetRoomForTransporter(b)))
	if aroom == broom then
		return menu.getSubTargetName(a) < menu.getSubTargetName(b)
	end
	return (config.roomClassSortOrder[aroom] or 0) < (config.roomClassSortOrder[broom] or 0)
end

function menu.getSubTargetName(subtarget)
	local display = true
	local name = ffi.string(C.GetTransporterLocationName(subtarget))
	local objectid, icon, isship
	local room = C.GetRoomForTransporter(subtarget)
	if room ~= 0 then
		local dockedships = {}
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
			if #dockedships > 0 then
				name = ffi.string(C.GetComponentName(dockedships[1]))
				objectid = ffi.string(C.GetObjectIDCode(dockedships[1]))
				icon = GetComponentData(ConvertStringTo64Bit(tostring(dockedships[1])), "icon")
				isship = true
			else
				name = ffi.string(C.GetComponentName(room))
				display = GetComponentData(ConvertStringTo64Bit(tostring(room)), "ismissiontarget")
			end
		end
	end

	return name, objectid, display, icon, isship
end

function menu.hasShipOrRoomMissionTarget(subtarget)
	local room = C.GetRoomForTransporter(subtarget)
	if room ~= 0 then
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			local dockedships = {}
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
			if #dockedships > 0 then
				return GetComponentData(ConvertStringTo64Bit(tostring(dockedships[1])), "ismissiontarget")
			end
		end
		return GetComponentData(ConvertStringTo64Bit(tostring(room)), "ismissiontarget")
	end
end

function menu.findArrayEntry(array, component)
	for i, entry in ipairs(array) do
		if entry.component == component then
			return i
		end
	end
end

function menu.addEntry(ftable, target, indent, parentcomponent)
	local componentIndent = ""
	local subtargetIndent = "   "
	for i = 1, indent do
		componentIndent = componentIndent .. "   "
		subtargetIndent = subtargetIndent .. "   "
	end

	local displaysubtargets = false
	for _, subtarget in ipairs(target.subtargets) do
		local display = true
		local room = C.GetRoomForTransporter(subtarget)
		if room ~= 0 then
			local dockedships = {}
			if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, "player")
				if #dockedships == 0 then
					display = false
				end
			end
		end
		if display then
			displaysubtargets = true
			break
		end
	end

	local row = ftable:addRow({ target = target.directtarget, issubtarget = false, hassubentries = (#target.subcomponents > 0) or displaysubtargets }, {  })
	local name = ffi.string(C.GetComponentName(target.component))

	local font = Helper.standardFont
	local color = Color["text_normal"]
	if GetComponentData(ConvertStringTo64Bit(tostring(target.component)), "isplayerowned") then
		color = Color["text_player"]
	end
	local objectid
	if C.IsComponentClass(target.component, "ship") then
		objectid = ffi.string(C.GetObjectIDCode(target.component))
	end
	if target.component == menu.topcontext then
		name = ffi.string(C.GetTransporterLocationName(target.directtarget))
		if menu.checkPlayerProperty(target.directtarget) then
			color = Color["text_player"]
		end
	end
	local current = ""
	if target.iscurrent then
		current = " [" .. ReadText(1001, 6301) .. "]"
		if not menu.preselectrow then
			menu.preselectrow = row.index
		end
	end
	if target.directtarget then
		local ismissiontarget = false
		if ffi.string(C.GetActiveObjectiveType()) == "usespacesuit" then
			ismissiontarget = target.type == "zone"
		else
			local locationcomponent = C.GetTransporterLocationComponent(target.directtarget) -- Note: context can be NULL if the component is a zone, which is the case for the space suit target
			ismissiontarget = (locationcomponent ~= 0) and (not target.nomissiontarget) and GetComponentData(ConvertStringTo64Bit(tostring(locationcomponent)), "ismissiontarget")
		end
		if ismissiontarget then
			font = Helper.standardFontBold
			color = Color["text_mission"]
		end
		if (menu.currentselection.target == target.directtarget) then
			menu.buttontext = ReadText(1001, 6303)
			if (target.type == "ship") or (target.type == "cockpit") then
				if C.IsComponentClass(target.component, "ship_m") or C.IsComponentClass(target.component, "ship_s") then
					menu.infotext = string.format(ReadText(1001, 6308), ffi.string(C.GetComponentName(target.component)))
				elseif C.IsComponentClass(target.component, "navcontext") then
					menu.infotext = string.format(ReadText(1001, 6306), name)
				else
					menu.infotext = string.format(ReadText(1001, 6307), ffi.string(C.GetComponentName(target.component)))
				end
			elseif target.type == "parent" then
				menu.infotext = ReadText(1001, 6309)
			elseif target.type == "zone" then
				menu.infotext = ReadText(1001, 6311)
				menu.buttontext = ReadText(1001, 6312)
			elseif target.type == "dyninterior" then
				menu.infotext = string.format(ReadText(1001, 6306), name)
			elseif target.type == "walkablemodule" then
				menu.infotext = string.format(ReadText(1001, 6305), ffi.string(C.GetComponentName(parentcomponent)))
			end
		end
	end
	--[[ collapsing support disabled for now for better controller support
	if (#target.subcomponents > 0) or displaysubtargets then
		row[1]:createButton({ height = Helper.standardTextHeight }):setText(menu.extendedcategories[tostring(target.component)] and "-" or "+", { halign = "center" })
		row[1].handlers.onClick = function () return menu.buttonExtendCategory(tostring(target.component)) end
	end --]]

	-- kuertee start: callback
	if menu.uix_callbacks ["addEntry_on_set_room_name"] then
		local result
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addEntry_on_set_room_name"]) do
			result = uix_callback (name, target)
			if result then
				-- DebugError ("kuertee_menu_transporter.addEntry_on_set_room_name name pre " .. tostring (name))
				name = result.name
				-- DebugError ("kuertee_menu_transporter.addEntry_on_set_room_name name post " .. tostring (name))
			end
		end
	end
	-- kuertee end: callback

	if objectid then
		row[2]:createText(componentIndent .. name .. current, { color = color, font = font })
		row[3]:createText(objectid, { color = color, font = font, halign = "right" })
	else
		row[2]:setColSpan(2):createText(componentIndent .. name .. current, { color = color, font = font })
	end

	if menu.extendedcategories[tostring(target.component)] then
		local hasmissionshipsubtarget = false
		for _, subtarget in ipairs(target.subtargets) do
			if menu.hasShipOrRoomMissionTarget(subtarget) then
				hasmissionshipsubtarget = true
				break
			end
		end

		for _, subtarget in ipairs(target.subtargets) do
			local name, objectid, display, icon, isship = menu.getSubTargetName(subtarget)

			local font = Helper.standardFont
			local color = Color["text_normal"]
			if menu.checkPlayerProperty(subtarget) then
				color = Color["text_player"]
			end
			if hasmissionshipsubtarget then
				if menu.hasShipOrRoomMissionTarget(subtarget) then
					font = Helper.standardFontBold
					color = Color["text_mission"]
				end
			else
				if isship then
					local context = C.GetContextForTransporterCheck(subtarget.component) -- Note by Matthias: context can be NULL if the component is a zone, which is the case for the space suit target
					if (context ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(context)), "ismissiontarget") then
						font = Helper.standardFontBold
						color = Color["text_mission"]
					end
				else
					local locationcomponent = C.GetTransporterLocationComponent(subtarget) -- Note: context can be NULL if the component is a zone, which is the case for the space suit target
					if (locationcomponent ~= 0) and GetComponentData(ConvertStringTo64Bit(tostring(locationcomponent)), "ismissiontarget") then
						font = Helper.standardFontBold
						color = Color["text_mission"]
					end
				end
			end

			if display then
				local row = ftable:addRow({ target = subtarget, issubtarget = true }, {  })
				local current = ""
				if menu.transportercomponent == subtarget.component and menu.transporterconnection == subtarget.connection then
					current = " [" .. ReadText(1001, 6301) .. "]"
					if not menu.preselectrow then
						menu.preselectrow = row.index
					end
				end
				if (menu.currentselection.target == subtarget) and (menu.currentselection.issubtarget == true) then
					menu.infotext = string.format(ReadText(1001, 6310), name)
				end

				if objectid then
					row[2]:createText(subtargetIndent .. string.format("\027[%s] %s", icon, name) .. current, { color = color, font = font })
					row[3]:createText(objectid, { color = color, font = font, halign = "right" })
				else
					row[2]:setColSpan(2):createText(subtargetIndent .. name .. current, { color = color, font = font })
				end
			end
		end

		for _, subcomponent in ipairs(target.subcomponents) do
			menu.addEntry(ftable, subcomponent, indent + 1, target.component)
		end
	end
end

function menu.display()
	-- remove old data
	Helper.clearDataForRefresh(menu)

	local width = Helper.scaleX(720)
	local height = Helper.scaleY(400)

	local frame = Helper.createFrameHandle(menu, {
		width = (menu.extendInfo and 1 or 0.5) * width + 2 * Helper.borderSize,
		height = height + 2 * Helper.borderSize,
		x = (Helper.viewWidth - 0.5 * width) / 2,
		y = (Helper.viewHeight - height) / 2,
	})
	frame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	menu.infotext = ""

	local ftable = frame:addTable(3, { tabOrder = 1, width = 0.5 * width, x = Helper.borderSize, y = Helper.borderSize })
	ftable:setColWidth(1, Helper.standardTextHeight)
	ftable:setColWidthPercent(3, 20)

	local row = ftable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(3):createText(ReadText(1001, 6302), Helper.headerRow1Properties)

	local row = ftable:addRow(false, { bgColor = Color["row_background_blue"] })
	row[1]:setColSpan(3):createText(ffi.string(C.GetComponentName(menu.topcontext)), Helper.subHeaderTextProperties)

	for _, target in ipairs(menu.targets) do
		menu.addEntry(ftable, target, 0, menu.topcontext)
	end

	ftable:setTopRow(menu.pretoprow)
	ftable:setSelectedRow(menu.preselectrow)
	menu.pretoprow = nil
	menu.preselectrow = nil

	local buttontable = frame:addTable(3, { tabOrder = 3, width = 0.5 * width, x = Helper.borderSize, skipTabChange = true })
	buttontable:setColWidth(1, 0.25 * width, false)
	local iconsize = Helper.scaleY(2 * Helper.standardTextHeight)
	buttontable:setColWidth(3, iconsize, false)

	local buttonrow = buttontable:addRow(true, { fixed = true, bgColor = Color["row_background_blue"] })
	buttonrow[1]:setColSpan(2):createText(menu.infotext, { minRowHeight = 2 * Helper.standardTextHeight, wordwrap = true })
	local textheight = buttonrow[1]:getMinTextHeight(true)
	buttonrow[3]:createButton({ height = textheight, scaling = false }):setIcon(menu.extendInfo and "widget_arrow_left_01" or "widget_arrow_right_01", { width = iconsize, height = iconsize, y = (textheight - iconsize) / 2 })
	buttonrow[3].handlers.onClick = menu.buttonExpand

	local buttonrow = buttontable:addRow(true, { fixed = true })
	local active = ((not menu.currentselection.hassubentries) or menu.currentselection.target) and ((menu.transportercomponent ~= menu.currentselection.target.component) or (menu.transporterconnection ~= menu.currentselection.target.connection))

	-- kuertee start: callback
	if menu.uix_callbacks ["display_on_set_room_active"] then
		local activeCount = 0
		local callbacksCount = 0
		local result
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_set_room_active"]) do
			callbacksCount = callbacksCount + 1
			result = uix_callback (active)
			if result and result.active then
				activeCount = activeCount + 1
			end
		end
		active = activeCount == callbacksCount
	end
	-- kuertee end: callback

	buttonrow[2]:setColSpan(2):createButton({ active = active, height = Helper.standardTextHeight }):setText(menu.buttontext, { halign = "center" })
	buttonrow[2].handlers.onClick = menu.buttonGoTo

	-- kuertee start: callback
	if menu.uix_callbacks ["display_on_set_buttontable"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_set_buttontable"]) do
			uix_callback (buttontable)
		end
	end
	-- kuertee end: callback

	buttontable.properties.y = height + Helper.borderSize - buttontable:getFullHeight()
	ftable.properties.maxVisibleHeight = buttontable.properties.y

	if menu.extendInfo then
		local infotable = frame:addTable(4, { tabOrder = 2, width = width - ftable.properties.width - Helper.borderSize, x = ftable.properties.x + ftable.properties.width + Helper.borderSize, y = Helper.borderSize, highlightMode = "off", skipTabChange = true })
		infotable:setColWidth(1, Helper.standardTextHeight)
		infotable:setColWidthPercent(3, 25)
		infotable:setColWidthPercent(4, 30)

		local row = infotable:addRow(false, { fixed = true, bgColor = Color["row_background_blue"] })
		row[1]:setColSpan(4):createText(ReadText(1001, 2427), Helper.headerRow1Properties)

		menu.room = C.GetRoomForTransporter(menu.currentselection.target)
		if menu.room ~= 0 then
			--- SHIPS ---
			local internalstoragecontext
			if not menu.currentselection.issubtarget then
				internalstoragecontext = C.GetContextByClass(menu.room, "container", false)
			end
			local dockedships = {}
			if menu.currentselection.issubtarget then
				if ffi.string(C.GetComponentClass(menu.room)) == "dockingbay" then
					Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.room, "player")
					if #dockedships > 0 then
						internalstoragecontext = dockedships[1]
					end
				end
			end

			dockedships = {}
			if internalstoragecontext then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, internalstoragecontext, "player")
				for i = #dockedships, 1, -1 do
					if C.IsShipAtExternalDock(dockedships[i]) then
						table.remove(dockedships, i)
					end
				end
			end
			
			if #dockedships > 0 then
				local row = infotable:addRow(true, {  })
				row[1]:createButton():setText(menu.extendedcategories["ships"] and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendCategory("ships") end
				row[2]:setColSpan(3):createText(ReadText(1001, 6304), Helper.subHeaderTextProperties)
				if menu.extendedcategories["ships"] then
					table.sort(dockedships, Helper.sortUniverseIDName)
					for _, ship in ipairs(dockedships) do
						local ship64 = ConvertStringTo64Bit(tostring(ship))
						local font = Helper.standardFont
						local color = Color["text_normal"]
						local shiptext = ffi.string(C.GetComponentName(ship))
						local objectid = ffi.string(C.GetObjectIDCode(ship))
						local ismissiontarget, isplayerowned = GetComponentData(ship64, "ismissiontarget", "isplayerowned")

						if ismissiontarget then
							font = Helper.standardFontBold
							color = Color["text_mission"]
						elseif isplayerowned then
							color = Color["text_player"]
						end
						local row = infotable:addRow(true, {  })
						row[2]:setColSpan(2):createText(shiptext, { color = color, font = font })
						row[4]:createText(objectid, { color = color, font = font, halign = "right" })
					end
				end
			end

			--- NPCS ---
			dockedships = {}
			if ffi.string(C.GetComponentClass(menu.room)) == "dockingbay" then
				Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.room, nil)
			end
			menu.npcs = menu.getNPCs(menu.room, dockedships, menu.currentselection.issubtarget)
			if #menu.npcs > 0 then
				local row = infotable:addRow(true, {  })
				row[1]:createButton():setText(menu.extendedcategories["npcs"] and "-" or "+", { halign = "center" })
				row[1].handlers.onClick = function () return menu.buttonExtendCategory("npcs") end
				row[2]:setColSpan(3):createText(ReadText(1001, 6300), Helper.subHeaderTextProperties)
				if menu.extendedcategories["npcs"] then
					for _, npc in ipairs(menu.npcs) do
						local name, typestring, typeicon, typename, isenemy, isplayerowned, ismissiontarget, postname, rolename = GetComponentData(npc, "name", "typestring", "typeicon", "typename", "isenemy", "isplayerowned", "ismissiontarget", "postname", "rolename")
						local font = Helper.standardFont
						local color = Color["text_normal"]
						if ismissiontarget then
							font = Helper.standardFontBold
							color = Color["text_mission"]
						elseif isenemy then
							color = Color["text_enemy"]
						elseif isplayerowned then
							color = Color["text_player"]
						end
						local title = postname
						if title == "" then
							title = rolename
							if title == "" then
								title = typename
							end
						end
						local row = infotable:addRow(true, {  })
						row[2]:createText(title, { color = color, font = font })
						row[3]:setColSpan(2):createText(name, { color = color, font = font })
					end
				end
			end
		end

		infotable.properties.maxVisibleHeight = buttontable.properties.y
	end

	frame:display()
end

function menu.viewCreated(layer, ...)
	menu.selecttable, menu.infotable, menu.buttontable = ...
end

menu.updateInterval = 0.1

function menu.onUpdate()
	if menu.refresh and (menu.refresh < getElapsedTime()) then
		menu.display()
		menu.refresh = nil
	end
end

function menu.onRowChanged(row, rowdata)
	rowdata = Helper.getCurrentRowData(menu, menu.defaulttable)
	if type(rowdata) == "table" then
		if (menu.currentselection.target ~= rowdata.target) or (menu.currentselection.issubtarget ~= rowdata.issubtarget) then
			menu.currentselection = rowdata
			menu.pretoprow = GetTopRow(menu.selecttable)
			menu.preselectrow = Helper.currentTableRow[menu.defaulttable]
			menu.refresh = getElapsedTime() + 0.11
		end
	end
end

function menu.onSelectElement(uitable)
	if uitable == menu.defaulttable then
		menu.buttonGoTo()
	end
end

function menu.onCloseElement(dueToClose)
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.getNPCs(room, ships, issubtarget)
	local rawnpcs = GetPrioritizedPlatformNPCs(ConvertStringTo64Bit(tostring(room)))
	local npcs = {}
	
	if not issubtarget then
		if C.GetContextByClass(room, "ship", false) ~= 0 then
			npcs = GetNPCs(ConvertStringTo64Bit(tostring(room)))
		else
			npcs = rawnpcs
		end
	end
	if issubtarget then
		for _, ship in ipairs(ships) do
			local npcs2 = GetNPCs(ConvertStringTo64Bit(tostring(ship)))
			for _, npc in ipairs(npcs2) do
				table.insert(npcs, npc)
			end
		end
		for _, npc in ipairs(rawnpcs) do
			if C.GetContextByClass(ConvertIDTo64Bit(npc), "room", false) == room then
				table.insert(npcs, npc)
			end
		end
	end
	for i = #npcs, 1, -1 do
		-- filter out non-mission crowd actors
		if GetComponentData(npcs[i], "typestring") == "crowd" and GetComponentData(npcs[i], "ismissionactor") == false then
			table.remove(npcs, i)
		end
	end

	return npcs
end

function menu.checkPlayerProperty(transporter)
	if ffi.string(C.GetOwnerDetails(transporter.component).factionID) == "player" then
		return true
	end
	local room = C.GetRoomForTransporter(transporter)
	if room ~= 0 then
		local dockedships = {}
		if ffi.string(C.GetComponentClass(room)) == "dockingbay" then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, room, nil)
			for _, ship in ipairs(dockedships) do
				if ffi.string(C.GetOwnerDetails(ship).factionID) == "player" then
					return true
				end
			end
		end

		local npcs = menu.getNPCs(room, dockedships)
		for _, npc in ipairs(npcs) do
			if GetComponentData(npc, "isplayerowned") then
				return true
			end
		end
	end

	return false
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿
-- param == { 0, 0, mode, modeparam }
-- modes: - "hackpanel",			param: { panelcomponent, panelconnection, paneltype }
--		  - "abortupgrade",			param: { container, task, price }
--		  - "transporter",			param: { transportercomponent, transporterconnection }
--		  - "markashostile",		param: { component }
--		  - "discardstationeditor"
--		  - "removebuildstorage",	param: { buildstorage }
--		  - "custom",				param: { title, question, { leftoptionid, leftoptionname[, uicallbackparam, ...] }, { rightoptionid, rightoptionname[, uicallbackparam, ...] }[, uicallbackmode][, preselectoption ("left"|"right")] }
--			uicallbackmodes:		- "invertinput",				param: { rangeid, configname, value }
--									- "autoroll",					param: { value }
--									- "mouse_steering_adaptive",	param: { value }
--									- "stick_steering_adaptive",	param: { value }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t UniverseID;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	bool CancelConstruction(UniverseID containerid, BuildTaskID id);
	const char* GetControlPanelName(UIComponentSlot controlpanel);
	void ReloadSaveList(void);
	bool RemoveBuildStorage(UniverseID buildstorageid);
	void SetAutoRoll(bool value);
	void SetInversionSetting(uint32_t uirangeid, const char* parametername, bool value);
	void SetJoystickSteeringAdapative(bool value);
	void SetMouseSteeringAdapative(bool value);
	void SetMouseSteeringInvertedOption(const char* paramname, bool value);
	void SetUserData(const char* name, const char* value);
	void StartControlPanelHack(UIComponentSlot target, const char* paneltypeid);
	void TriggerAutosave(bool checkenabled);
	const char* UndockPlayerShip(bool checkonly);
]]

local menu = {
	name = "UserQuestionMenu",
	saveOption = false,
}

local config = {
	width = 400,
	layer = 2,
	saveOptionVersion = 1,
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	__CORE_DETAILMONITOR_USERQUESTION = __CORE_DETAILMONITOR_USERQUESTION or {
		version = config.saveOptionVersion,
	}
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	RegisterEvent("gameSaved", menu.onGameSaved)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

function menu.cleanup()
	menu.infoFrame = nil

	menu.mode = nil
	menu.modeparam = {}
	menu.hacktarget = nil
	menu.transportertarget = nil
	menu.upgradecontainer = nil
	menu.upgradetask = nil
	menu.upgradeprice = nil
	menu.buildstorage = nil
	menu.saveOption = false

	-- kuertee start:
	if menu.uix_callbacks ["cleanup_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup_end"]) do
			uix_callback ()
		end
	end
	-- kuertee end
end

-- Menu member functions

function menu.confirm()
	local allowclose = true
	if menu.mode == "hackpanel" then
		C.StartControlPanelHack(menu.hacktarget, menu.modeparam[3])
	elseif menu.mode == "abortupgrade" then
		if C.CancelConstruction(menu.upgradecontainer, menu.upgradetask) then
			if ffi.string(C.UndockPlayerShip(false)) ~= "granted" then
				DebugError("failed undocking.")
			end
		else
			menu.onCloseElement("back", true)
		end
	elseif menu.mode == "transporter" then
		C.TransportPlayerToTarget(menu.transportertarget)
	elseif menu.mode == "markashostile" then
		C.SetRelationBoostToFaction(menu.hostilecomponent, "player", "markedashostile", -1, 1, 600)
	elseif menu.mode == "discardstationeditor" then
		Helper.clearStationEditorState()
	elseif menu.mode == "starttutorial" then
		if menu.modeparam[2] == 1 then
			menu.saveTriggered = true
			if Helper.isOnlineGame() then
				SaveOnlineGame()
			else
				C.TriggerAutosave(false)
			end
			allowclose = false
		else
			C.SetUserData("tutorial_started_from", tostring(menu.modeparam[2]))
			NewGame(menu.modeparam[1])
		end
	elseif menu.mode == "removebuildstorage" then
		C.RemoveBuildStorage(menu.buildstorage)
	end
	if menu.saveOption then
		__CORE_DETAILMONITOR_USERQUESTION[menu.mode] = true
	end
	if allowclose then
		menu.onCloseElement("close")
	end
end

function menu.customOption(optionid, optionparameters)
	if menu.modeparam[5] then
		if menu.modeparam[5] == "invertinput" then
			if (optionparameters[3] ~= nil) and (optionparameters[4] ~= nil) and (optionparameters[5] ~= nil) then
				if optionparameters[3] == 0 then
					C.SetMouseSteeringInvertedOption(optionparameters[4], optionparameters[5])
				else
					C.SetInversionSetting(optionparameters[3], optionparameters[4], optionparameters[5])
				end
			end
		elseif menu.modeparam[5] == "autoroll" then
			if (optionparameters[3] ~= nil) then
				C.SetAutoRoll(optionparameters[3])
			end
		elseif menu.modeparam[5] == "mouse_steering_adaptive" then
			if (optionparameters[3] ~= nil) then
				C.SetMouseSteeringAdapative(optionparameters[3])
			end
		elseif menu.modeparam[5] == "stick_steering_adaptive" then
			if (optionparameters[3] ~= nil) then
				C.SetJoystickSteeringAdapative(optionparameters[3])
			end
		end
	end
	AddUITriggeredEvent(menu.name, "selected", optionid)
	menu.onCloseElement("close")
end

function menu.onShowMenu()
	menu.mode = menu.param[3]
	menu.modeparam = menu.param[4]
	if menu.mode == "hackpanel" then
		menu.hacktarget = ffi.new("UIComponentSlot")
		menu.hacktarget.component = ConvertIDTo64Bit(menu.modeparam[1])
		menu.hacktarget.connection = menu.modeparam[2]
	elseif menu.mode == "abortupgrade" then
		menu.upgradecontainer = ConvertIDTo64Bit(menu.modeparam[1])
		menu.upgradetask = ConvertIDTo64Bit(menu.modeparam[2])
		menu.upgradeprice = menu.modeparam[3]
	elseif menu.mode == "transporter" then
		menu.transportertarget = ffi.new("UIComponentSlot")
		menu.transportertarget.component = ConvertIDTo64Bit(menu.modeparam[1])
		menu.transportertarget.connection = menu.modeparam[2]
	elseif menu.mode == "markashostile" then
		menu.hostilecomponent = ConvertIDTo64Bit(menu.modeparam[1])
	elseif menu.mode == "discardstationeditor" then
		Helper.unregisterStationEditorChanges()
	elseif menu.mode == "removebuildstorage" then
		menu.buildstorage = ConvertIDTo64Bit(menu.modeparam[1])
	end

	if __CORE_DETAILMONITOR_USERQUESTION[menu.mode] then
		-- continue immediately
		menu.confirm()
	else
		-- display info
		menu.createInfoFrame()
	end
end

function menu.createInfoFrame()
	-- remove old data
	Helper.clearDataForRefresh(menu, config.infoLayer)

	-- kuertee start: callback
	local frameProperties, isUseFrameHeight
	if menu.uix_callbacks ["createInfoFrame_custom_frame_properties"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["createInfoFrame_custom_frame_properties"]) do
			frameProperties, isUseFrameHeight = uix_callback (config)
			if frameProperties then break end
		end
		-- Lib.Print_Table (frameProperties)
	end
	if not frameProperties then
	-- kuertee end: callback
		frameProperties = {
			standardButtons = {},
			width = Helper.scaleX(config.width) + 6 * Helper.borderSize,
			x = (Helper.viewWidth - Helper.scaleX(config.width)) / 2,
			y = Helper.viewHeight / 2,
			layer = config.layer,
			startAnimation = false,
			playerControls = menu.mode == "markashostile",
		}

	-- kuertee start: callback
	end
	-- kuertee end: callback

	menu.infoFrame = Helper.createFrameHandle(menu, frameProperties)
	menu.infoFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local tableProperties = {
		width = Helper.scaleX(config.width),
		x = 3 * Helper.borderSize,
		y = 3 * Helper.borderSize,
	}

	local ftable = menu.createTable(menu.infoFrame, tableProperties)

	-- kuertee start:
	if not isUseFrameHeight then
		menu.infoFrame.properties.height = ftable.properties.y + ftable:getVisibleHeight() + 3 * Helper.borderSize
	else
	-- kuertee end

		menu.infoFrame.properties.height = frameProperties.height

	-- kuertee start:
	end
	-- kuertee end

	menu.infoFrame.properties.y = (Helper.viewHeight - menu.infoFrame.properties.height) / 2

	menu.infoFrame:display()
end

function menu.createTable(frame, tableProperties)
	-- kuertee start: custom mode
	if string.find ("" .. tostring (menu.mode), "custom") then
		return menu.createTable_kuertee (frame, tableProperties)
	end
	-- kuertee end: custom mode

	local hasSaveOption = true
	if (menu.mode == "custom") or (menu.mode == "starttutorial") or (menu.mode == "removebuildstorage") then
		hasSaveOption = false
	end
	local numCols = 6
	if not hasSaveOption then
		numCols = 5
	end

	local ftable = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
	if menu.mode == "custom" then
		local leftwith = math.ceil(C.GetTextWidth(menu.modeparam[3][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		local rightwidth = math.ceil(C.GetTextWidth(menu.modeparam[4][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		local minbuttonwidth = 0.2 * tableProperties.width - Helper.borderSize
		local maxbuttonwidth = (tableProperties.width - 4 * Helper.borderSize - 3) / 2

		local buttonwidth = math.max(minbuttonwidth, math.min(maxbuttonwidth, math.max(leftwith, rightwidth) + 2 * Helper.standardTextOffsetx))
		ftable:setColWidth(2, buttonwidth, false)
		ftable:setColWidth(4, buttonwidth, false)
	elseif not hasSaveOption then
		ftable:setColWidth(2, 0.4 * tableProperties.width - Helper.borderSize, false)
		ftable:setColWidth(4, 0.4 * tableProperties.width - Helper.borderSize, false)
	else
		ftable:setColWidth(1, Helper.scaleY(Helper.standardButtonHeight), false)
		ftable:setColWidthPercent(5, 25, false)
		ftable:setColWidthPercent(6, 25, false)
	end

	if menu.mode == "hackpanel" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9701), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9702) .. ReadText(1001, 120))

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ffi.string(C.GetControlPanelName(menu.hacktarget)))
	elseif menu.mode == "abortupgrade" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9703), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9704), { wordwrap = true })
	elseif menu.mode == "transporter" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9707), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9708), { wordwrap = true })
	elseif menu.mode == "markashostile" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11114), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9710), { wordwrap = true })
	elseif menu.mode == "discardstationeditor" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9721), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9722), { wordwrap = true })
	elseif menu.mode == "starttutorial" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9728), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 9727), { wordwrap = true })
	elseif menu.mode == "removebuildstorage" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11667), Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(ReadText(1001, 11668), { wordwrap = true })
	elseif menu.mode == "custom" then
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(menu.modeparam[1] or "", Helper.headerRowCenteredProperties)

		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(numCols):createText(menu.modeparam[2] or "", { wordwrap = true })
	end

	local row = ftable:addRow(false, { fixed = true })
	row[1]:setColSpan(numCols):createText("")

	if menu.mode == "custom" then
		local row = ftable:addRow(true, { fixed = true })
		row[2]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[3][2] or "", { halign = "center" })
		row[2].handlers.onClick = function () return menu.customOption(menu.modeparam[3][1], menu.modeparam[3]) end
		row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[4][2] or "", { halign = "center" })
		row[4].handlers.onClick = function () return menu.customOption(menu.modeparam[4][1], menu.modeparam[4]) end

		if menu.modeparam[6] == "right" then
			ftable:setSelectedCol(4)
		elseif menu.modeparam[6] == "left" then
			ftable:setSelectedCol(2)
		end
	elseif menu.mode == "starttutorial" then
		local row = ftable:addRow(true, { fixed = true })
		row[2]:createButton({ active = function () return IsSavingPossible(false) end, helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 9724), { halign = "center" })
		row[2].handlers.onClick = menu.confirm
		row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[4].handlers.onClick = function () return menu.onCloseElement("back", true) end
	elseif not hasSaveOption then
		local row = ftable:addRow(true, { fixed = true })
		row[2]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[2].handlers.onClick = menu.confirm
		row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[4].handlers.onClick = function () return menu.onCloseElement("back", true) end
		ftable:setSelectedCol(4)
	else
		local row = ftable:addRow(true, { fixed = true })
		row[1]:createCheckBox(function () return menu.saveOption end, { height = Helper.standardButtonHeight })
		row[1].handlers.onClick = function () menu.saveOption = not menu.saveOption end
		row[2]:setColSpan(3):createButton({ bgColor = Color["button_background_hidden"] }):setText(ReadText(1001, 9709))
		row[2].handlers.onClick = function () menu.saveOption = not menu.saveOption end
		row[5]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 2821), { halign = "center" })
		row[5].handlers.onClick = menu.confirm
		row[6]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_cancel", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(ReadText(1001, 64), { halign = "center" })
		row[6].handlers.onClick = function () return menu.onCloseElement("back", true) end
		ftable:setSelectedCol(6)
	end

	return ftable
end

function menu.viewCreated(layer, ...)
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	-- kuertee start: refresh feature
	-- menu.infoFrame:update()
	local currentTime = getElapsedTime()
	if menu.isRefresh == true or menu.isRefresh == 1 or (menu.refresh and currentTime > menu.refresh) then
		menu.isRefresh = false
		menu.refresh = nil
		menu.createInfoFrame ()
	else
		menu.infoFrame:update()
	end
	-- kuertee end: refresh feature
end

function menu.onRowChanged(row, rowdata, uitable)
end

function menu.onSelectElement(uitable, modified, row)
end

function menu.onGameSaved(_, success)
	if menu.saveTriggered then
		menu.saveTriggered = nil
		if menu.mode == "starttutorial" then
			C.ReloadSaveList()
			C.SetUserData("tutorial_started_from", tostring(menu.modeparam[2]))
			if success then
				NewGame(menu.modeparam[1])
			end
			menu.onCloseElement("close")
		end
	end
end

function menu.onCloseElement(dueToClose, allowAutoMenu)
	if menu.mode == "discardstationeditor" then
		if dueToClose == "close" then
			Helper.clearStationEditorState()
		elseif dueToClose == "back" then
			-- restore state
			Helper.registerStationEditorChanges()
		end
	end
	Helper.closeMenu(menu, dueToClose, allowAutoMenu or (menu.mode ~= "abortupgrade"))
	menu.cleanup()
end

-- menu helpers

-- kuertee start:
function menu.createTable_kuertee(frame, tableProperties)
	-- DebugError ("kuertee_menu_userquestion createTable menu.mode " .. tostring (menu.mode))
	-- DebugError ("kuertee_menu_userquestion createTable #callbacks ['createTable_new_custom_table'] " .. tostring (#callbacks ["createTable_new_custom_table"]))
	local ftable
	if menu.mode == "custom" then
		-- kuertee start: re-written custom user question
		local numCols = (menu.mode == "custom") and 5 or 6
		ftable = frame:addTable(numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
		local leftwidth = 0
		if menu.modeparam[3] ~= nil then
			leftwidth = math.ceil(C.GetTextWidth(menu.modeparam[3][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		end
		local rightwidth = 0
		if menu.modeparam[4] ~= nil  then
			rightwidth = math.ceil(C.GetTextWidth(menu.modeparam[4][2] or "", Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize)))
		end
		local minbuttonwidth = 0.2 * tableProperties.width - Helper.borderSize
		local maxbuttonwidth = (tableProperties.width - 4 * Helper.borderSize - 3) / 2
		local buttonwidth = math.max(minbuttonwidth, math.min(maxbuttonwidth, math.max(leftwidth, rightwidth) + 2 * Helper.standardTextOffsetx))
		ftable:setColWidth(2, buttonwidth, false)
		ftable:setColWidth(4, buttonwidth, false)
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[1] or "", Helper.headerRowCenteredProperties)
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText(menu.modeparam[2] or "", { wordwrap = true })
		local row = ftable:addRow(false, { fixed = true, bgColor = Helper.color.transparent })
		row[1]:setColSpan(numCols):createText("")
		local row = ftable:addRow(true, { fixed = true, bgColor = Helper.color.transparent })
		if menu.modeparam[3] then
			row[2]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[3][2] or "", { halign = "center" })
			row[2].handlers.onClick = function () return menu.customOption(menu.modeparam[3][1], menu.modeparam[3]) end
		end
		if menu.modeparam[4] then
			row[4]:createButton({ helpOverlayID = "custom_" .. menu.mode .. "_confirm", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.modeparam[4][2] or "", { halign = "center" })
			row[4].handlers.onClick = function () return menu.customOption(menu.modeparam[4][1], menu.modeparam[4]) end
		end
		if menu.modeparam[4] and menu.modeparam[6] == "right" then
			ftable:setSelectedCol(4)
		elseif menu.modeparam[3] and menu.modeparam[6] == "left" then
			ftable:setSelectedCol(2)
		elseif menu.modeparam [3] then
			ftable:setSelectedCol(2)
		end
		-- kuertee end: re-written custom user question
	elseif string.find ("" .. tostring (menu.mode), "custom_") then
		-- <open_menu menu="UserQuestionMenu" param="[0, 0, 'custom', [$title, $text, null, ['kATD_on_death_notice_read', {111204, 903}], null, 'right']]" />
		-- local ftable = frame:addTable (numCols, { tabOrder = 1, borderEnabled = true, width = tableProperties.width, x = tableProperties.x, y = tableProperties.y, defaultInteractiveObject = true })
		if menu.uix_callbacks ["createTable_new_custom_table"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["createTable_new_custom_table"]) do
				ftable = uix_callback (frame, tableProperties, config)
				if ftable then break end
			end
		end
	end
	return ftable
end

menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- Custom gamestart editor
-- param == { 0, 0, gamestartid, ismultiplayer, iscreative, ispaused }

-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef struct {
		const char* id;
		uint32_t textid;
		uint32_t descriptionid;
		uint32_t value;
		uint32_t relevance;
		const char* ware;
	} SkillInfo;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;

	typedef struct {
		const char* ware;
	} CustomGameStartBlueprint;
	typedef struct {
		const char* state;
		uint32_t numvalues;
		uint32_t numdefaultvalues;
	} CustomGameStartBlueprintPropertyState;
	typedef struct {
		const char* state;
		bool defaultvalue;
	} CustomGameStartBoolPropertyState;
	typedef struct {
		const char* id;
		int64_t value;
	} CustomGameStartBudgetDetail;
	typedef struct {
		const char* id;
		int64_t value;
		int64_t limit;
		uint32_t numdetails;
	} CustomGameStartBudgetInfo;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		bool isresearch;
	} CustomGameStartBudgetGroupInfo;
	typedef struct {
		uint32_t nummacros;
		uint32_t numblueprints;
		uint32_t numconstructionplans;
		bool hasincompatibleloadout;
	} CustomGameStartContentCounts;
	typedef struct {
		UIMacroCount* macros;
		uint32_t nummacros;
		const char** blueprints;
		uint32_t numblueprints;
		const char** constructionplanids;
		uint32_t numconstructionplans;
	} CustomGameStartContentData2;
	typedef struct {
		const char* library;
		const char* item;
	} CustomGameStartEncyclopediaEntry;
	typedef struct {
		const char* state;
	} CustomGameStartEncyclopediaPropertyState;
	typedef struct {
		const char* id;
		const char* name;
		const char* filename;
	} CustomGameStartInfo;
	typedef struct {
		const char* ware;
		int32_t amount;
	} CustomGameStartInventory;
	typedef struct {
		const char* state;
		uint32_t numvalues;
		uint32_t numdefaultvalues;
	} CustomGameStartInventoryPropertyState;
	typedef struct {
		const char* type;
		const char* item;
		const char* classid;
		int64_t budgetvalue;
		bool unlocked;
		bool hidden;
	} CustomGameStartKnownEntry2;
	typedef struct {
		const char* state;
		uint32_t numvalues;
		uint32_t numdefaultvalues;
	} CustomGameStartKnownPropertyState;
	typedef struct {
		const char* state;
		int64_t defaultvalue;
		int64_t minvalue;
		int64_t maxvalue;
	} CustomGameStartMoneyPropertyState;
	typedef struct {
		const char* race;
		const char* tags;
		uint32_t numskills;
		SkillInfo* skills;
	} CustomGameStartPersonEntry;
	typedef struct {
		uint32_t numcargo;
	} CustomGameStartPlayerPropertyCounts;
	typedef struct {
		const char* state;
		uint32_t numvalues;
	} CustomGameStartPlayerPropertyPropertyState;
	typedef struct {
		const char* state;
		UIPosRot defaultvalue;
	} CustomGameStartPosRotPropertyState;
	typedef struct {
		const char* factionid;
		const char* otherfactionid;
		int32_t relation;
	} CustomGameStartRelationInfo;
	typedef struct {
		const char* state;
	} CustomGameStartRelationsPropertyState;
	typedef struct {
		const char* state;
	} CustomGameStartResearchPropertyState;
	typedef struct {
		const char* id;
		const char* name;
		const char* description;
		const char* groupid;
		const char* wareid;
		int32_t index;
		int64_t budgetvalue;
		uint32_t numdependencylists;
	} CustomGameStartStoryInfo;
	typedef struct {
		const char* state;
		uint32_t numvalues;
		uint32_t numdefaultvalues;
	} CustomGameStartStoryState;
	typedef struct {
		const char* state;
		const char* defaultvalue;
		const char* options;
	} CustomGameStartStringPropertyState;
	typedef struct {
		const char* id;
		const char* name;
		int32_t state;
		const char* requiredversion;
		const char* installedversion;
	} InvalidPatchInfo;
	typedef struct {
		const char* id;
		const char* name;
	} ProductionMethodInfo;
	typedef struct {
		const char* macro;
		const char* ware;
		const char* productionmethodid;
	} UIBlueprint;
	typedef struct {
		const char* name;
		const char* id;
		const char* source;
		bool deleteable;
	} UIConstructionPlan;
	typedef struct {
		const char* macro;
		uint32_t amount;
	} UIMacroCount;
	typedef struct {
		const char* ID;
		const char* Name;
		const char* RawName;
		const char* Icon;
	} UIPaintTheme;
	typedef struct {
		const char* ware;
		const char* macro;
		int amount;
	} UIWareInfo;
	
	typedef struct {
		const char* type;
		const char* id;
		const char* sector;
		UIPosRot offset;
		const char* dockedatid;
		const char* commanderid;
		const char* macroname;
		const char* name;
		const char* constructionplanid;
		const char* paintmod;
		const char* peopledefid;
		float peoplefillpercentage;
		uint32_t numcargo;
		UIWareInfo* cargo;
		uint32_t count;
	} CustomGameStartPlayerProperty3;
	typedef struct {
		size_t idx;
		const char* macroid;
		UniverseID componentid;
		UIPosRot offset;
		const char* connectionid;
		size_t predecessoridx;
		const char* predecessorconnectionid;
		bool isfixed;
	} UIConstructionPlanEntry;
	bool AreConstructionPlanLoadoutsCompatible(const char* constructionplanid);
	bool CanPlayerUseRace(const char* raceid, const char* postid);
	void ExportCustomGameStart(const char* filename, const char* id, const char* name);
	const char* GenerateFactionRelationTextFromRelation(int32_t uirelation);
	uint32_t GetAllFactions(const char** result, uint32_t resultlen, bool includehidden);
	uint32_t GetAllRaces(RaceInfo* result, uint32_t resultlen);
	uint32_t GetAvailableCustomGameStarts(CustomGameStartInfo* result, uint32_t resultlen, const char* id);
	size_t GetConstructionPlanInfo(UIConstructionPlanEntry* result, size_t resultlen, const char* constructionplanid);
	uint32_t GetConstructionPlanInvalidPatches(InvalidPatchInfo* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetConstructionPlans(UIConstructionPlan* result, uint32_t resultlen);
	uint32_t GetCustomGameStartBlueprintDefaultProperty(CustomGameStartBlueprint* result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartBlueprintProperty(CustomGameStartBlueprint* result, uint32_t resultlen, const char* id, const char* propertyid);
	CustomGameStartBlueprintPropertyState GetCustomGameStartBlueprintPropertyState(const char* id, const char* propertyid);
	bool GetCustomGameStartBoolProperty(const char* id, const char* propertyid, CustomGameStartBoolPropertyState* state);
	CustomGameStartBudgetInfo GetCustomGameStartBudget(const char* id, const char* budgetid);
	uint32_t GetCustomGameStartBudgetDetails(CustomGameStartBudgetDetail* result, uint32_t resultlen, const char* id, const char* budgetid);
	CustomGameStartBudgetGroupInfo GetCustomGameStartBudgetGroupInfo(const char* id, const char* budgetgroupid);
	uint32_t GetCustomGameStartBudgetGroups(const char** result, uint32_t resultlen, const char* id);
	uint32_t GetCustomGameStartEncyclopediaProperty(CustomGameStartEncyclopediaEntry* result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartEncyclopediaPropertyCounts(const char* id, const char* propertyid);
	CustomGameStartEncyclopediaPropertyState GetCustomGameStartEncyclopediaPropertyState(const char* id, const char* propertyid);
	uint32_t GetCustomGameStartInventoryDefaultProperty(CustomGameStartInventory* result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartInventoryProperty(CustomGameStartInventory* result, uint32_t resultlen, const char* id, const char* propertyid);
	CustomGameStartInventoryPropertyState GetCustomGameStartInventoryPropertyState(const char* id, const char* propertyid);
	uint32_t GetCustomGameStartKnownDefaultProperty2(CustomGameStartKnownEntry2* result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartKnownProperty2(CustomGameStartKnownEntry2* result, uint32_t resultlen, const char* id, const char* propertyid);
	bool GetCustomGameStartKnownPropertyBudgetValue2(const char* id, const char* propertyid, CustomGameStartKnownEntry2* uivalue);
	uint32_t GetCustomGameStartKnownPropertyNumStateDependencies(uint32_t* result, uint32_t resultlen, const char* id, const char* propertyid, CustomGameStartKnownEntry2 uivalue);
	uint32_t GetCustomGameStartKnownPropertyNumStateDependencyLists(const char* id, const char* propertyid, CustomGameStartKnownEntry2 uivalue);
	CustomGameStartKnownPropertyState GetCustomGameStartKnownPropertyState(const char* id, const char* propertyid);
	uint32_t GetCustomGameStartKnownPropertyStateDependencies(const char** result, uint32_t resultlen, const char* id, const char* propertyid, CustomGameStartKnownEntry2 uivalue);
	CustomGameStartContentCounts GetCustomGameStartContentCounts2(const char* id, const char* filename, const char* gamestartid);
	void GetCustomGameStartContent2(CustomGameStartContentData2* result, const char* id, const char* filename, const char* gamestartid);
	int64_t GetCustomGameStartMoneyProperty(const char* id, const char* propertyid, CustomGameStartMoneyPropertyState* state);
	uint32_t GetCustomGameStartPaintThemes(UIPaintTheme* result, uint32_t resultlen, const char* id);
	uint32_t GetCustomGameStartPlayerPropertyCounts(CustomGameStartPlayerPropertyCounts* result, uint32_t resultlen, const char* id, const char* propertyid);
	int64_t GetCustomGameStartPlayerPropertyPeopleValue(const char* id, const char* propertyid, const char* entryid);
	bool GetCustomGameStartPlayerPropertyPerson(CustomGameStartPersonEntry* result, const char* id, const char* propertyid, const char* entryid);
	uint32_t GetCustomGameStartPlayerPropertyProperty3(CustomGameStartPlayerProperty3* result, uint32_t resultlen, const char* id, const char* propertyid);
	CustomGameStartPlayerPropertyPropertyState GetCustomGameStartPlayerPropertyPropertyState(const char* id, const char* propertyid);
	const char* GetCustomGameStartPlayerPropertySector(const char* id, const char* propertyid, const char* entryid);
	int64_t GetCustomGameStartPlayerPropertyValue(const char* id, const char* propertyid, const char* entryid);
	UIPosRot GetCustomGameStartPosRotProperty(const char* id, const char* propertyid, CustomGameStartPosRotPropertyState* state);
	uint32_t GetCustomGameStartRelationsProperty(CustomGameStartRelationInfo* result, uint32_t resultlen, const char* id, const char* propertyid);
	int64_t GetCustomGameStartRelationsPropertyBudgetValue(const char* id, const char* propertyid, CustomGameStartRelationInfo uivalue);
	uint32_t GetCustomGameStartRelationsPropertyCounts(const char* id, const char* propertyid);
	CustomGameStartRelationsPropertyState GetCustomGameStartRelationsPropertyState(const char* id, const char* propertyid);
	uint32_t GetCustomGameStartResearchProperty(const char** result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartResearchPropertyCounts(const char* id, const char* propertyid);
	CustomGameStartResearchPropertyState GetCustomGameStartResearchPropertyState(const char* id, const char* propertyid);
	int64_t GetCustomGameStartShipPersonValue(const char* id, CustomGameStartPersonEntry uivalue);
	uint32_t GetCustomGameStartStoryBudgets(CustomGameStartStoryInfo* result, uint32_t resultlen, const char* id);
	uint32_t GetNumCustomGameStartStoryBudgetDependencyLists(uint32_t* result, uint32_t resultlen, const char* id, const char* storyid);
	uint32_t GetCustomGameStartStoryBudgetDependencies(const char** result, uint32_t resultlen, const char* id, const char* storyid);
	uint32_t GetCustomGameStartStoryDefaultProperty(const char** result, uint32_t resultlen, const char* id, const char* propertyid);
	uint32_t GetCustomGameStartStoryProperty(const char** result, uint32_t resultlen, const char* id, const char* propertyid);
	CustomGameStartStoryState GetCustomGameStartStoryPropertyState(const char* id, const char* propertyid);
	const char* GetCustomGameStartStringProperty(const char* id, const char* propertyid, CustomGameStartStringPropertyState* state);
	const char* GetMacroMapPositionOnEcliptic(UniverseID holomapid, UIPosRot* position);
	uint32_t GetNumAllFactions(bool includehidden);
	uint32_t GetNumAllRaces(void);
	uint32_t GetNumAvailableCustomGameStarts(const char* id);
	size_t GetNumConstructionPlanInfo(const char* constructionplanid);
	uint32_t GetNumConstructionPlans(void);
	uint32_t GetNumCustomGameStartBudgetGroups(const char* id);
	uint32_t GetNumCustomGameStartPaintThemes(const char* id);
	uint32_t GetNumCustomGameStartStoryBudgets(const char* id);
	uint32_t GetNumPlannedLimitedModules(const char* constructionplanid);
	uint32_t GetNumPlayerBuildMethods(void);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	uint32_t GetPlannedLimitedModules(UIMacroCount* result, uint32_t resultlen, const char* constructionplanid);
	uint32_t GetPlayerBuildMethods(ProductionMethodInfo* result, uint32_t resultlen);
	int64_t GetStationValue(const char* macroname, const char* constructionplanid);
	int32_t GetUIDefaultBaseRelation(const char* fromfactionid, const char* tofactionid);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	bool HasCustomGameStartBudget(const char* id, const char* budgetid);
	void ImportCustomGameStart(const char* id, const char* filename, const char* gamestartid);
	bool IsConstructionPlanAvailableInCustomGameStart(const char* constructionplanid);
	bool IsConstructionPlanValid(const char* constructionplanid, uint32_t* numinvalidpatches);
	bool IsCustomGameStartPropertyChanged(const char* id, const char* propertyid);
	bool IsGameStartModified(const char* id);
	void NewMultiplayerGame(const char* modulename, const char* difficulty);
	void RemoveCustomGameStartPlayerProperty(const char* id, const char* propertyid, const char* entryid);
	void RemoveHoloMap(void);
	void ResetCustomGameStart(const char* id);
	void ResetCustomGameStartProperty(const char* id, const char* propertyid);
	void SetCustomGameStartBlueprintProperty(const char* id, const char* propertyid, CustomGameStartBlueprint* uivalue, uint32_t uivaluecount);
	void SetCustomGameStartBoolProperty(const char* id, const char* propertyid, bool uivalue);
	void SetCustomGameStartEncyclopediaProperty(const char* id, const char* propertyid, CustomGameStartEncyclopediaEntry* uivalue, uint32_t uivaluecount);
	void SetCustomGameStartInventoryProperty(const char* id, const char* propertyid, CustomGameStartInventory* uivalue, uint32_t uivaluecount);
	void SetCustomGameStartKnownProperty2(const char* id, const char* propertyid, CustomGameStartKnownEntry2* uivalue, uint32_t uivaluecount);
	void SetCustomGameStartMoneyProperty(const char* id, const char* propertyid, int64_t uivalue);
	void SetCustomGameStartPlayerPropertyCount(const char* id, const char* propertyid, const char* entryid, uint32_t count);
	const char* SetCustomGameStartPlayerPropertyObjectMacro(const char* id, const char* propertyid, const char* entryid, const char* macroname);
	const char* SetCustomGameStartPlayerPropertyMacroAndConstructionPlan2(const char* id, const char* propertyid, const char* entryid, const char* macroname, const char* constructionplanid);
	void SetCustomGameStartPlayerPropertyName(const char* id, const char* propertyid, const char* entryid, const char* name);
	void SetCustomGameStartPlayerPropertyPeople(const char* id, const char* propertyid, const char* entryid, const char* peopledefid);
	void SetCustomGameStartPlayerPropertyPeopleFillPercentage2(const char* id, const char* propertyid, const char* entryid, float fillpercentage);
	void SetCustomGameStartPlayerPropertyPerson(const char* id, const char* propertyid, const char* entryid, CustomGameStartPersonEntry uivalue);
	void SetCustomGameStartPlayerPropertySectorAndOffset(const char* id, const char* propertyid, const char* entryid, const char* sectormacroname, UIPosRot uivalue);
	void SetCustomGameStartPosRotProperty(const char* id, const char* propertyid, UIPosRot uivalue);
	void SetCustomGameStartRelationsProperty(const char* id, const char* propertyid, CustomGameStartRelationInfo* uivalue, uint32_t uivaluecount);
	void SetCustomGameStartResearchProperty(const char* id, const char* propertyid, const char** uivalue, uint32_t uivaluecount);
	void SetCustomGameStartShipAndEmptyLoadout(const char* id, const char* shippropertyid, const char* loadoutpropertyid, const char* macroname);
	void SetCustomGameStartStringProperty(const char* id, const char* propertyid, const char* uivalue);
	void SetCustomGameStartStory(const char* id, const char* propertyid, const char** uivalue, uint32_t uivaluecount);
	void SetMacroMapLocalLinearHighways(UniverseID holomapid, bool value);
	void SetMacroMapLocalRingHighways(UniverseID holomapid, bool value);
	void SetMacroMapSelection(UniverseID holomapid, bool selectplayer, const char* propertyentryid);
	void SetMapRelativeMousePosition(UniverseID holomapid, bool valid, float x, float y);
	void ShowInfoLine(const char* text, uint32_t timeout);
	void ShowUniverseMacroMap2(UniverseID holomapid, const char* macroname, const char* startsectormacroname, UIPosRot sectoroffset, bool setoffset, bool showzone, const char* gamestartid);
	void StartPanMap(UniverseID holomapid);
	bool StopPanMap(UniverseID holomapid);
	void ZoomMap(UniverseID holomapid, float zoomstep);
]]

local utf8 = require("utf8")

local menu = {
	name = "CustomGameMenu",
	category = {},
	curDropDownOption = {},
	techtree = {},
	researchstoriesbyid = {},
	factions = {},
	encyclopedia = {},
	knowndata = {},
	excludedvalues = {},
	expandedProperty = {},
	hidestoryspoilers = true,
	stories = {},
	storiesbyid = {},
	researchstories = {},
	satellites = {},
	playerMacros = {},
	storygroups = {},
	cpwarescache = {},
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	-- register callbacks
	local contract = getElement("Scene.UIContract")
	registerForEvent("cutsceneReady", contract, menu.onCutsceneReady)
	registerForEvent("cutsceneStopped", contract, menu.onCutsceneStopped)

	-- init variables
	menu.isStartmenu = C.IsStartmenu()

	-- register menu
	Menus = Menus or {}
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
end
-- kuertee end

local config = {
	mainFrameLayer = 4,
	expandedMenuFrameLayer = 2,
	contextFrameLayer = 2,

	backarrow = "table_arrow_inv_left",
	backarrowOffsetX = 3,

	font = "Zekton outlined",
	fontBold = "Zekton bold outlined",

	headerFontSize = 13,
	infoFontSize = 9,
	standardFontSize = 10,

	headerTextHeight = 34,
	subHeaderTextHeight = 22,
	standardTextHeight = 19,
	infoTextHeight = 16,

	headerTextOffsetX = 5,
	standardTextOffsetX = 5,
	infoTextOffsetX = 5,

	standardTextOffsetY = 2,

	nodeoffsetx = 30,
	nodewidth = 270,

	budgetwidth = 130,
	budgetheight = 270,

	mapContextWidth = 260,

	satellites = {
		macro = "eq_arg_satellite_02_macro",
		coverageradius = 300 * 1000, -- 300km
	},

	table = {
		y = 45,
		x = 45,
		arrowColumnWidth = 20,
	},

	stateKeys = {
		{ "shownPropertyHint" },
		{ "addingFleet", "bool" },
		{ "usespacesuit", "bool" },
	},

	excludedmodules = {
		"landmarks_player_hq_01_research_macro"
	},

	blueprintcategories = {
		{ name = ReadText(1001, 2421),	classes = { ["production"] = true } },
		{ name = ReadText(1001, 2439),	classes = { ["buildmodule"] = true } },
		{ name = ReadText(1001, 2422),	classes = { ["storage"] = true } },
		{ name = ReadText(1001, 2451),	classes = { ["habitation"] = true } },
		{ name = ReadText(1001, 9620),	classes = { ["welfaremodule"] = true } },
		{ name = ReadText(1001, 2424),	classes = { ["defencemodule"] = true } },
		{ name = ReadText(1001, 2452),	classes = { ["pier"] = true, ["dockarea"] = true } },
		{ name = ReadText(1001, 9621),	classes = { ["processingmodule"] = true } },
		{ name = ReadText(1001, 2453),	classes = { ["connectionmodule"] = true, ["radar"] = true } },

		{ name = ReadText(1001, 11003),	classes = { ["ship_xl"] = true } },
		{ name = ReadText(1001, 11002),	classes = { ["ship_l"] = true } },
		{ name = ReadText(1001, 11001),	classes = { ["ship_m"] = true } },
		{ name = ReadText(1001, 11000),	classes = { ["ship_s"] = true } },

		{ name = ReadText(1001, 1301),	classes = { ["weapon"] = true, ["missilelauncher"] = true } },
		{ name = ReadText(1001, 1319),	classes = { ["turret"] = true, ["missileturret"] = true } },
		{ name = ReadText(1001, 1317),	classes = { ["shieldgenerator"] = true } },
		{ name = ReadText(1001, 1103),	classes = { ["engine"] = true } },
		{ name = ReadText(1001, 8001),	classes = { ["thruster"] = true } },
		{ name = ReadText(1001, 1304),	classes = { ["missile"] = true } },
		{ name = ReadText(1001, 8),		classes = { ["drone"] = true } },
		{ name = ReadText(1001, 8003),	classes = { ["lasertower"] = true, ["satellite"] = true, ["mine"] = true, ["navbeacon"] = true, ["resourceprobe"] = true } },
		{ name = ReadText(1001, 8063),	classes = { ["countermeasure"] = true } },
	},

	maxBudgetDetails = 9,

	fallbackShipMacro = "ship_arg_s_heavyfighter_02_a_macro",

	factionrelationsallowedbystory = {
		["buccaneers"] = { ["story_paranid_esc_1"] = true, ["story_paranid_esc_2"] = true, ["story_paranid_esc_3"] = true },
	},
}

config.headerTextProperties = {
	font = config.fontBold,
	fontsize = config.headerFontSize,
	x = config.headerTextOffsetX,
	y = 6,
	minRowHeight = config.headerTextHeight,
	titleColor = Color["row_title"],
}

config.subHeaderTextProperties = {
	font = config.font,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = 2,
	minRowHeight = config.subHeaderTextHeight,
	halign = "center",
	titleColor = Color["row_title"],
}

config.standardTextProperties = {
	font = config.font,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = config.standardTextOffsetY,
}

config.categories = {
	{ id = "player",	name = ReadText(1021, 10002),	type = "list",	rendertarget = true,	budget = "money",	displayOnRenderTarget = { "npc", "player" },	properties = {
		[1] = {
			id = "playername",
			name = ReadText(1021, 11003),
			type = "editbox",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = C.SetCustomGameStartStringProperty,
		},
		[2] = {
			id = "player",
			name = ReadText(1021, 11007),
			type = "dropdown",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = function (customgamestart, propertyid, option) return menu.setPlayerMacro(customgamestart, propertyid, option) end,
			formatValue = function (value, customoptions) return menu.playerMacro(value, customoptions) end,
		},
		[3] = {
			id = "playermoney",
			budget = "money",
			name = ReadText(1021, 11002),
			mouseOverText = ReadText(1026, 9908),
			type = "number",
			propertyType = "Money",
			get = C.GetCustomGameStartMoneyProperty,
			set = C.SetCustomGameStartMoneyProperty,
			formatValue = function (value) return menu.playerMoney(value) end,
		},
		[4] = {
			id = "playerinventory",
			budget = "money",
			name = ReadText(1021, 11009),
			type = "multiselectslider",
			propertyType = "Inventory",
			getState = C.GetCustomGameStartInventoryPropertyState,
			get = C.GetCustomGameStartInventoryProperty,
			getDefault = C.GetCustomGameStartInventoryDefaultProperty,
			set = C.SetCustomGameStartInventoryProperty,
			formatValue = function (numValues) return (numValues == 0) and ReadText(1001, 9915) or ReadText(1001, 8378) end,
			selectionText = ReadText(1001, 8376),
		},
		[5] = {
			id = "playerblueprints",
			budget = "money",
			name = ReadText(1021, 11010),
			mouseOverText = ReadText(1026, 9909),
			type = "multiselect",
			propertyType = "Blueprint",
			getState = C.GetCustomGameStartBlueprintPropertyState,
			get = C.GetCustomGameStartBlueprintProperty,
			getDefault = C.GetCustomGameStartBlueprintDefaultProperty,
			set = C.SetCustomGameStartBlueprintProperty,
			formatValue = function (numValues) return (numValues == 0) and ReadText(1001, 9916) or ReadText(1001, 9914) end,
			selectionText = ReadText(1001, 9913),
			excludetags = { "paintmod" },
		},
		[6] = {
			id = "playerbuildmethod",
			name = ReadText(1001, 11298),
			mouseOverText = ReadText(1026, 9910),
			type = "dropdown",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = C.SetCustomGameStartStringProperty,
			formatValue = function (value, customoptions) return menu.playerBuildMethod(value, customoptions) end,
			replaceempty = "auto",
		},
		[7] = {
			id = "playerpainttheme",
			name = ReadText(1001, 9104),
			mouseOverText = ReadText(1026, 9911),
			type = "dropdown",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = function (customgamestart, propertyid, option) return menu.setPlayerPaintTheme(customgamestart, propertyid, option) end,
			formatValue = function (value, customoptions) return menu.playerPaintThemes(value, customoptions) end,
			displayOnRenderTarget = "painttheme",
		},
	}},
	{ id = "ship",	name = ReadText(1021, 10003),	type = "list",	rendertarget = true,	budget = { "money", "people" },		displayOnRenderTarget = { "macro", "ship" },	properties = {
		[1] = {
			id = "shipname",
			name = ReadText(1021, 11003),
			type = "editbox",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = C.SetCustomGameStartStringProperty,
			active = function () return menu.usespacesuit ~= true end,
		},
		[2] = {
			id = "ship",
			budget = { "money", "people" },
			modifyingids = { "shiploadout" },
			name = ReadText(1021, 11008),
			type = "button",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = function () return menu.openShipConfig() end,
			formatValue = function (value) return menu.shipValue(value) end,
			active = function () return menu.usespacesuit ~= true end,
		},
		[3] = {
			id = "spacesuit",
			name = ReadText(1021, 11014),
			mouseOverText = ReadText(1026, 9912),
			type = "bool",
			propertyType = "Internal",
			get = function () return menu.usespacesuit end,
			set = function (_, _, checked) menu.usespacesuit = checked; menu.refreshMenu() end,
		},
	}},
	{ id = "playerproperty",	name = ReadText(1021, 5),		type = "property",	rendertarget = true,	budget = { "money", "people" } },
	{ id = "universe",			name = ReadText(1021, 10001),	type = "list",		rendertarget = true,	budget = { "money", "known" },	displayOnRenderTarget = { "map", "sector" },	properties = {
		[1] = {
			id = "seed",
			name = ReadText(1021, 11006),
			mouseOverText = ReadText(1026, 9901),
			type = "editbox",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = C.SetCustomGameStartStringProperty,
		},
		[2] = {
			id = "sector",
			modifyingids = { "offset" },
			name = ReadText(1021, 11001),
			mouseOverText = ReadText(1026, 9913),
			type = "dropdown",
			propertyType = "String",
			get = C.GetCustomGameStartStringProperty,
			set = function (...) return menu.setPlayerSector(...) end,
			formatValue = function (value) return menu.universeSector(value) end,
		},
		[3] = {
			id = "offset",
			propertyType = "PosRot",
			get = C.GetCustomGameStartPosRotProperty,
			set = C.SetCustomGameStartPosRotProperty,
		},
		[4] = {
			id = "universeringhighways",
			name = ReadText(1021, 11004),
			type = "bool",
			propertyType = "Bool",
			get = C.GetCustomGameStartBoolProperty,
			set = C.SetCustomGameStartBoolProperty,
		},
		[5] = {
			id = "universelinearhighways",
			name = ReadText(1021, 11005),
			type = "bool",
			propertyType = "Bool",
			get = C.GetCustomGameStartBoolProperty,
			set = C.SetCustomGameStartBoolProperty,
		},
		[6] = {
			id = "playerknownspace",
			budget = { "known", "money" },
			name = ReadText(1021, 11012),
			mouseOverText = ReadText(1026, 9914),
			type = "multiselect",
			propertyType = "KnownEntry2",
			getState = C.GetCustomGameStartKnownPropertyState,
			get = C.GetCustomGameStartKnownProperty2,
			getDefault = C.GetCustomGameStartKnownDefaultProperty2,
			set = C.SetCustomGameStartKnownProperty2,
			formatValue = function (numValues) return (numValues == 0) and ReadText(1001, 9926) or ReadText(1001, 9925) end,
			selectionText = ReadText(1001, 9927),
		},
	}},
	{ id = "universefactionrelations",	name = ReadText(1021, 10005),	type = "flowchart",	budget = { "relations", "known" } },
	{ id = "universestorystates",		name = ReadText(1021, 10006),	type = "story", budget = "story" },
	{ id = "playerresearch",			name = ReadText(1021, 10004),	type = "flowchart", budget = "research", active = function () return menu.playerresearchActive() end, mouseovertext = function () return menu.playerresearchMouseOver() end },
	{ id = "playerknownfactions",		name = ReadText(1021, 11011),	type = "dummy" },
	{ id = "playerknownobjects",		name = ReadText(1021, 11013),	type = "dummy" },
}

menu.budgets = {
	{ id = "money",		name = ReadText(1001, 9923),	desc = ReadText(1026, 9917),	icon = "gamestart_custom_credits",		color = Color["customgamestart_budget_money"],		suffix = " " .. ReadText(1001, 101),	details = {} },
	{ id = "people",	name = ReadText(1001, 9929),	desc = ReadText(1026, 9918),	icon = "gamestart_custom_people",		color = Color["customgamestart_budget_people"],		suffix = "",							details = {} },
	{ id = "known",		name = ReadText(1001, 9924),	desc = ReadText(1026, 9919),	icon = "gamestart_custom_knowledge",	color = Color["customgamestart_budget_known"],		suffix = "",							details = {} },
	{ id = "relations",	name = ReadText(1001, 9928),	desc = ReadText(1026, 9920),	icon = "gamestart_custom_relations",	color = Color["customgamestart_budget_relations"],	suffix = "",							details = {} },
	{ id = "story",		name = ReadText(1021, 10006),	desc = ReadText(1026, 9921),	icon = "gamestart_custom_story",		color = Color["customgamestart_budget_story"],		suffix = "",							details = {},	type = "story",		property = "universestorystates" },
	{ id = "research",	name = ReadText(1021, 10004),	desc = ReadText(1026, 9922),	icon = "gamestart_custom_research",		color = Color["customgamestart_budget_research"],	suffix = "",							details = {},	type = "research",	property = "universestorystates" },
}
menu.propertybudgets = {}

function menu.onCutsceneReady(_, cutsceneid)
	if menu.cutsceneid and (menu.cutsceneid == cutsceneid) then
		SetRenderTargetNoise(menu.rendertarget.id, false)
	end
end

function menu.onCutsceneStopped(_, cutsceneid)
	if menu.cutsceneid and (menu.cutsceneid == cutsceneid) then
		if menu.cutscenedesc then
			ReleaseCutsceneDescriptor(menu.cutscenedesc)
		end
		menu.cutscenedesc = nil
		menu.cutsceneid = nil
		DestroyPresentationCluster(menu.precluster)
	end
end

function menu.setCategory(category)
	menu.closeContextMenu(true)
	if menu.cutsceneid then
		StopCutscene(menu.cutsceneid)
		menu.cutsceneid = nil
		DestroyPresentationCluster(menu.precluster)
		menu.rendertargetLock = getElapsedTime() + 0.1
	end
	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end
	if menu.flowchart then
		menu.flowchart:collapseAllNodes()
		menu.flowchart = nil
	end
	menu.category = category or {}
end

function menu.cleanup()
	if not menu.isStartmenu then
		if menu.paused then
			Unpause()
			menu.paused = nil
		end
	end

	menu.customgamestart = nil
	menu.multiplayer = nil
	menu.creative = nil
	menu.category = {}
	if menu.cutsceneid then
		StopCutscene(menu.cutsceneid)
		menu.cutsceneid = nil
		DestroyPresentationCluster(menu.precluster)
	end
	if menu.holomap ~= 0 then
		C.RemoveHoloMap()
		menu.holomap = 0
	end

	menu.techtree = {}
	menu.researchstoriesbyid = {}
	menu.factions = {}
	menu.encyclopedia = {}
	menu.knowndata = {}
	menu.hidestoryspoilers = true
	menu.stories = {}
	menu.storiesbyid = {}
	menu.researchstories = {}
	menu.propertybudgets = {}
	menu.satellites = {}
	menu.playerMacros = {}
	menu.storygroups = {}
	menu.cpwarescache = {}

	menu.flowchartRows = nil
	menu.flowchartCols = nil
	menu.expandedNode = nil
	menu.expandedMenuFrame = nil
	menu.expandedMenuTable = nil
	menu.restoreNode = nil
	menu.restoreNodeTech = nil
	menu.restoreNodeFaction = nil

	menu.width = nil
	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.curDropDownOption = {}
	menu.shownPropertyHint = nil
	menu.addingFleet = nil
	menu.usespacesuit = nil
	menu.rendertargetLock = nil
	menu.rightdown = nil

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback(menu.customgamestart)
		end
	end
	-- kuertee end: callback
end

function menu.buttonNewGame()
	menu.closeContextMenu()
	local customgamestart = menu.customgamestart
	if menu.multiplayer then
		Helper.addDelayedOneTimeCallbackOnUpdate(function () C.NewMultiplayerGame(customgamestart) end, true, getElapsedTime() + 0.1)
	else

		-- kuertee start: callback
		-- Helper.addDelayedOneTimeCallbackOnUpdate(function () NewGame(customgamestart) end, true, getElapsedTime() + 0.1)
		Helper.addDelayedOneTimeCallbackOnUpdate(
			function ()
				-- kuertee start: callback
				if menu.uix_callbacks ["buttonNewGame_preNewGame"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonNewGame_preNewGame"]) do
						uix_callback(menu.customgamestart)
					end
				end
				-- kuertee end: callback

				NewGame(customgamestart)
			end,
		true, getElapsedTime() + 0.1)
		-- kuertee end: callback

	end
	menu.displayInit()
end

function menu.buttonReset()
	menu.closeContextMenu()
	C.ResetCustomGameStart(menu.customgamestart)
	menu.satellites = {}
	menu.usespacesuit = nil
	if next(menu.category) then
		if menu.category.id == "universe" then
			if menu.holomap ~= 0 then
				C.RemoveHoloMap()
				menu.holomap = 0
			end
		elseif menu.category.id == "ship" then
			if menu.cutsceneid then
				StopCutscene(menu.cutsceneid)
				menu.cutsceneid = nil
				DestroyPresentationCluster(menu.precluster)
			end
		elseif (menu.category.id == "playerresearch") or (menu.category.id == "universefactionrelations") then
			if menu.flowchart then
				menu.flowchart:collapseAllNodes()
				menu.flowchart = nil
			end
		end
	end

	menu.initEncyclopediaValue()
	menu.initKnownValue()
	menu.initStoryValue()
	menu.initSatellites()
	if menu.category.id == "playerresearch" then
		if not menu.playerresearchActive() then
			menu.setCategory(nil)
		end
	end
	menu.refresh = getElapsedTime()

	-- kuertee start: callback
	if menu.uix_callbacks ["buttonReset_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["buttonReset_on_end"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

function menu.buttonBoolProperty(property)
	property.value = not property.value
	if property.id == "universeringhighways" then
		C.SetMacroMapLocalRingHighways(menu.holomap, property.value)
	elseif property.id == "universelinearhighways" then
		C.SetMacroMapLocalLinearHighways(menu.holomap, property.value)
	elseif property.id == "spacesuit" then
		if property.value then
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			local playermacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "player", buf))
			local spacesuitmacro = GetMacroData(playermacro, "spacesuitmacro")
			C.SetCustomGameStartShipAndEmptyLoadout(menu.customgamestart, "ship", "shiploadout", spacesuitmacro)
			C.ResetCustomGameStartProperty(menu.customgamestart, "shipname")
		else
			C.ResetCustomGameStartProperty(menu.customgamestart, "ship")
			C.ResetCustomGameStartProperty(menu.customgamestart, "shiploadout")
		end
		if menu.cutsceneid then
			StopCutscene(menu.cutsceneid)
			menu.cutsceneid = nil
			DestroyPresentationCluster(menu.precluster)
			menu.rendertargetLock = getElapsedTime() + 0.1
		end
	end
	property.set(menu.customgamestart, property.id, property.value)
end

function menu.buttonMultiSelectConfirm(property)
	for i = #property.value, 1, -1 do
		if not menu.contextMenuData.selectedOptions[property.value[i].id] then
			if property.id == "playerknownspace" then
				menu.setKnownValue("playerknownobjects", property.value[i].id, false)
				menu.saveKnownValue("playerknownobjects")

				if menu.satellites[property.value[i].id] then
					for _, id in ipairs(menu.satellites[property.value[i].id]) do
						C.RemoveCustomGameStartPlayerProperty(menu.customgamestart, "playerproperty", id)
					end
					menu.satellites[property.value[i].id] = nil
				end
				menu.setKnownValue(property.id, property.value[i].id, false)
			end
			table.remove(property.value, i)
		else
			menu.contextMenuData.selectedOptions[property.value[i].id] = nil
		end
	end
	for id in pairs(menu.contextMenuData.selectedOptions) do
		if property.propertyType == "Inventory" then
			table.insert(property.value, { id = id, name = GetWareData(id, "name"), amount = 1, defaultamount = 0 })
		elseif property.propertyType == "Blueprint" then
			table.insert(property.value, { id = id, name = GetWareData(id, "name"), default = false })
		elseif property.propertyType == "KnownEntry2" then
			table.insert(property.value, { id = id, name = GetMacroData(id, "name"), default = false })
			menu.setKnownValue(property.id, id, true)
		end
	end

	menu.saveMultiSelect(property)

	menu.closeContextMenu()
	menu.refresh = getElapsedTime()
end

function menu.buttonSelectResearch(techdata, mainIdx, col)
	techdata.completed = not techdata.completed
	menu.category.value[techdata.tech] = techdata.completed or nil
	if menu.researchstoriesbyid[techdata.tech] then
		menu.researchstories[menu.researchstoriesbyid[techdata.tech].id] = techdata.completed or nil
	end
	if techdata.completed then
		if col > 1 then
			for prevCol = col - 1, 1, -1 do
				for _, techentry in ipairs(menu.techtree[mainIdx][prevCol]) do
					techentry.completed = true
					menu.category.value[techentry.tech] = true
					if menu.researchstoriesbyid[techentry.tech] then
						menu.researchstories[menu.researchstoriesbyid[techentry.tech].id] = true
					end
				end
			end
		end
	else
		if col < #menu.techtree[mainIdx] then
			for nextCol = col + 1, #menu.techtree[mainIdx] do
				for _, techentry in ipairs(menu.techtree[mainIdx][nextCol]) do
					techentry.completed = false
					menu.category.value[techentry.tech] = nil
					if menu.researchstoriesbyid[techentry.tech] then
						menu.researchstories[menu.researchstoriesbyid[techentry.tech].id] = nil
					end
				end
			end
		end
	end

	local numresearchwares = 0
	for _ in pairs(menu.category.value) do
		numresearchwares = numresearchwares + 1
	end
	local researchwares = ffi.new("const char*[?]", numresearchwares)
	local idx = 0
	for ware in pairs(menu.category.value) do
		researchwares[idx] = Helper.ffiNewString(ware)
		idx = idx + 1
	end

	C.SetCustomGameStartResearchProperty(menu.customgamestart, menu.category.id, researchwares, numresearchwares)
	menu.saveStoryValue("universestorystates")

	Helper.ffiClearNewHelper()

	menu.restoreNodeTech = techdata.tech
	menu.refresh = getElapsedTime()
end

function menu.buttonExpandProperty(id)
	RemoveHighlightOverlay("property_expand")
	if menu.expandedProperty[id] then
		menu.expandedProperty[id] = nil
	else
		menu.expandedProperty[id] = true
	end
	menu.refresh = getElapsedTime()
end

function menu.buttonRemovePlayerProperty(id)
	C.RemoveCustomGameStartPlayerProperty(menu.customgamestart, menu.category.id, id)
	menu.refresh = getElapsedTime()
end

function menu.buttonMapContextSelectSector(macro, remove)
	local knownspaceproperty = menu.findProperty("playerknownspace")
	if knownspaceproperty then
		menu.initPropertyValue(knownspaceproperty)

		local found
		for j, entry in ipairs(knownspaceproperty.value) do
			if entry.id == macro then
				found = j
				break
			end
		end
		if found and remove then
			table.remove(knownspaceproperty.value, found)
		end
		if (not found) and (not remove) then
			table.insert(knownspaceproperty.value, { id = macro, name = GetMacroData(macro, "name"), default = false })
		end
		menu.saveMultiSelect(knownspaceproperty)
	end

	menu.closeContextMenu()
end

function menu.buttonMapContextKnownStations(macro, checked)
	menu.checkboxKnownStations(macro, checked)
	menu.closeContextMenu()
end

function menu.buttonMapContextSatelliteCoverage(macro, checked)
	menu.checkboxSatelliteCoverage(macro, checked)
	menu.closeContextMenu()
end

function menu.buttonExport(checked)
	if not checked then
		menu.displayExportContext()
	else
		local filename = utf8.gsub(menu.gamestartName, "[^%w_%-%() ]", "_")
		C.ExportCustomGameStart(filename, menu.customgamestart, menu.gamestartName or "")
		menu.closeContextMenu()
		menu.refreshMenu()
	end
end

function menu.buttonConstructionCommunity()
	if C.CanOpenWebBrowser() then
		C.OpenWebBrowser(ReadText(1001, 7976))
	end
end

function menu.buttonResetBudget(budgetid)
	if budgetid == "story" then
		C.ResetCustomGameStartProperty(menu.customgamestart, "universestorystates")
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerresearch")
		menu.initStoryValue()
		menu.removeHQ()
		if menu.category.id == "playerresearch" then
			if not menu.playerresearchActive() then
				menu.setCategory(nil)
			end
		end
	elseif budgetid == "research" then
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerresearch")
		menu.initResearch()
		if menu.category.id == "playerresearch" then
			if not menu.playerresearchActive() then
				menu.setCategory(nil)
			end
		end
	elseif budgetid == "known" then
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerknownfactions")
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerknownobjects")
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerknownspace")
		menu.initKnownValue()

		-- restore sectors that are locked for player property
		local lockedsectors = {}
		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local playersectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
		table.insert(lockedsectors, playersectormacro)
		local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
		if state.numvalues > 0 then
			local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
			local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
			if n > 0 then
				local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
				for i = 0, n - 1 do
					buf[i].numcargo = counts[i].numcargo
					buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
				end
				n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
				for i = 0, n - 1 do
					local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, "playerproperty", ffi.string(buf[i].id)))
					if sector ~= "" then
						table.insert(lockedsectors, sector)
					end
				end
			end
		end
		for _, sector in ipairs(lockedsectors) do
			menu.setKnownValue("playerknownspace", sector, true)
		end
		menu.saveKnownValue("playerknownspace")
	elseif budgetid == "people" then
		C.ResetCustomGameStartProperty(menu.customgamestart, "shippeople")
		C.ResetCustomGameStartProperty(menu.customgamestart, "shippeoplefillpercent")

		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
		if state.numvalues > 0 then
			local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
			local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
			if n > 0 then
				local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
				for i = 0, n - 1 do
					buf[i].numcargo = counts[i].numcargo
					buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
				end
				n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
				for i = 0, n - 1 do
					local entryid = ffi.string(buf[i].id)
					C.SetCustomGameStartPlayerPropertyPeople(menu.customgamestart, "playerproperty", entryid, "")
					C.SetCustomGameStartPlayerPropertyPeopleFillPercentage2(menu.customgamestart, "playerproperty", entryid, 0)
					menu.initManagerSkills("playerproperty", entryid)
				end
			end
		end
	else
		for i, budget in ipairs(menu.budgets) do
			if (not budget.inactive) and (budget.id == budgetid) then
				for j, detail in ipairs(budget.details) do
					C.ResetCustomGameStartProperty(menu.customgamestart, detail.property)
					if detail.property == "ship" then
						C.ResetCustomGameStartProperty(menu.customgamestart, "shiploadout")
						menu.usespacesuit = nil
						if menu.category.id == "ship" then
							if menu.cutsceneid then
								StopCutscene(menu.cutsceneid)
								menu.cutsceneid = nil
								DestroyPresentationCluster(menu.precluster)
							end
						end
					elseif detail.property == "playerproperty" then
						menu.satellites = {}
						menu.initSatellites()
					end
				end
			end
		end
	end
	menu.refreshMenu()
end

function menu.checkboxMultiSelect(option, checked)
	menu.contextMenuData.selectedOptions[option] = checked or nil
end

function menu.checkboxToggleMultiSelect(checked)
	for _, data in ipairs(menu.contextMenuData.options) do
		for _, entry in ipairs(data.wares) do
			if not menu.contextMenuData.propertyLockedWares[entry.id] then
				menu.contextMenuData.selectedOptions[entry.id] = checked or nil
			end
		end
	end
end

function menu.checkboxKnownFaction(faction, checked)
	menu.setKnownValue("playerknownfactions", faction, checked)
	menu.saveKnownValue("playerknownfactions")
end

function menu.checkboxKnownStations(sector, checked)
	menu.setKnownValue("playerknownobjects", sector, checked)
	menu.saveKnownValue("playerknownobjects")
	menu.refreshMenu()
end

function menu.addSatellite(sector, id, x, z)
	local entryid = ffi.string(C.SetCustomGameStartPlayerPropertyObjectMacro(menu.customgamestart, "playerproperty", id, config.satellites.macro))
	if entryid ~= "" then
		local sectorpos = ffi.new("UIPosRot", {
			x = x, 
			y = 0, 
			z = z, 
			yaw = 0, 
			pitch = 0, 
			roll = 0
		})
		C.SetCustomGameStartPlayerPropertySectorAndOffset(menu.customgamestart, "playerproperty", entryid, sector, sectorpos)

		menu.satellites[sector] = menu.satellites[sector] or { totalvalue = 0 }
		table.insert(menu.satellites[sector], entryid)
		menu.satellites[sector].totalvalue = menu.satellites[sector].totalvalue + tonumber(C.GetCustomGameStartPlayerPropertyValue(menu.customgamestart, "playerproperty", entryid))
	end
end

function menu.checkboxSatelliteCoverage(sector, checked)
	if checked then
		local radarrange = GetMacroData(config.satellites.macro, "maxradarrange")
		-- maximum distance between 2 circles to cover a plane completely! in circles
		local effectiverange = radarrange * math.cos(math.pi / 6)
		local y_offset = radarrange * (1 + math.sin(math.pi / 6))

		local x_num = math.ceil(config.satellites.coverageradius / effectiverange)
		local overcoverage = x_num * effectiverange - config.satellites.coverageradius

		for x_ind = 1, x_num do
			local x = -config.satellites.coverageradius + (2 * x_ind - 1) * effectiverange - overcoverage
			menu.addSatellite(sector, sector .. "_satellite_" .. x_ind .. "_0", x, 0)
		end
		for y_ind = 1, math.floor(x_num / 2) do
			local x_max = x_num - y_ind
			for x_ind = 1, x_max do
				local x = (2 * x_ind - x_max - 1) * effectiverange
				local y = y_ind * y_offset
				menu.addSatellite(sector, sector .. "_satellite_" .. x_ind .. "_" .. y_ind, x, y)
				menu.addSatellite(sector, sector .. "_satellite_" .. x_ind .. "_" .. -y_ind, x, -y)
			end
		end
	else
		local ids = menu.satellites[sector] or {}
		for _, id in ipairs(ids) do
			C.RemoveCustomGameStartPlayerProperty(menu.customgamestart, "playerproperty", id)
		end
		menu.satellites[sector] = nil
	end
	menu.refreshMenu()
end

function menu.dropdownCurrentFaction(_, option)
	if option ~= menu.currentfaction.id then
		for _, factiondata in ipairs(menu.factions) do
			if factiondata.id == option then
				menu.currentfaction = factiondata

				menu.restoreNodeFaction = "current"
				menu.refresh = getElapsedTime()
				break
			end
		end
	end
end

function menu.dropdownProperty(property, row, option)
	-- kuertee start: callback
	if menu.uix_callbacks ["dropdownProperty_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["dropdownProperty_on_start"]) do
			uix_callback (property, row, option)
		end
	end
	-- kuertee end: callback

	if option ~= menu.curDropDownOption[property.id] then
		menu.curDropDownOption[property.id] = option
		property.value = option
		if property.id == "sector" then
			local buf = ffi.new("CustomGameStartPosRotPropertyState[1]")
			local sectoroffset = C.GetCustomGameStartPosRotProperty(menu.customgamestart, "offset", buf)
			menu.setKnownValue("playerknownspace", option, true)
			menu.saveKnownValue("playerknownspace")
			menu.refresh = getElapsedTime()
		end
		if property.replaceempty and (property.replaceempty == option) then
			option = ""
		end
		property.set(menu.customgamestart, property.id, option)
	end
end

function menu.addHQ()
	local entrybaseid = "player_HQ"
	local cpid = "x4ep1_playerheadquarters_with_dock"

	local found = false
	local buf = ffi.new("CustomGameStartStringPropertyState[1]")
	local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
	if state.numvalues > 0 then
		local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
		local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
		if n > 0 then
			local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
			for i = 0, n - 1 do
				buf[i].numcargo = counts[i].numcargo
				buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
			end
			n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
			for i = 0, n - 1 do
				if string.find(ffi.string(buf[i].id), entrybaseid, 1, true) then
					found = true
					break
				end
			end
		end
	end

	if not found then
		local entryid = ffi.string(C.SetCustomGameStartPlayerPropertyMacroAndConstructionPlan2(menu.customgamestart, "playerproperty", entrybaseid, "station_pla_headquarters_base_01_macro", cpid))
		if entryid ~= "" then
			local blueprintproperty = menu.findProperty("playerblueprints")
			if blueprintproperty then
				menu.initPropertyValue(blueprintproperty)

				for ware in pairs(menu.getCPWares(cpid)) do
					local found = false
					for j, entry in ipairs(blueprintproperty.value) do
						if entry.id == ware then
							found = true
							break
						end
					end
					if not found then
						table.insert(blueprintproperty.value, { id = ware, name = GetWareData(ware, "name"), default = false })
					end
				end
				menu.saveMultiSelect(blueprintproperty)
			end

			local sector = "cluster_01_sector001_macro"
			local sectorpos = ffi.new("UIPosRot", {
				x = 128000, 
				y = 0, 
				z = 198000, 
				yaw = 0, 
				pitch = 0, 
				roll = 0
			})
			C.SetCustomGameStartPlayerPropertySectorAndOffset(menu.customgamestart, "playerproperty", entryid, sector, sectorpos)

			menu.initManagerSkills("playerproperty", entryid)

			menu.setKnownValue("playerknownspace", sector, true)
			menu.saveKnownValue("playerknownspace")
		end
	end
end

function menu.initManagerSkills(property, entryid)
	local numskills = C.GetNumSkills()
	local buf = ffi.new("CustomGameStartPersonEntry")
	buf.race = ""
	buf.tags = ""
	local skillbuf = ffi.new("SkillInfo[?]", numskills)
	numskills = C.GetSkills(skillbuf, numskills)
	buf.numskills = numskills
	buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
	for i = 0, numskills - 1 do
		buf.skills[i].id = skillbuf[i].id
		buf.skills[i].value = 0
	end
	C.SetCustomGameStartPlayerPropertyPerson(menu.customgamestart, property, entryid, buf)
end

function menu.removeHQ()
	local entrybaseid = "player_HQ"

	local buf = ffi.new("CustomGameStartStringPropertyState[1]")
	local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
	if state.numvalues > 0 then
		local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
		local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
		if n > 0 then
			local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
			for i = 0, n - 1 do
				buf[i].numcargo = counts[i].numcargo
				buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
			end
			n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
			for i = 0, n - 1 do
				local id = ffi.string(buf[i].id)
				if string.find(id, entrybaseid, 1, true) then
					C.RemoveCustomGameStartPlayerProperty(menu.customgamestart, "playerproperty", id)
					break
				end
			end
		end
	end
end

function menu.dropdownPlayerPropertyAddStation(entryid, cpid, isHQentry, isNewStation)
	local entryid = ffi.string(C.SetCustomGameStartPlayerPropertyMacroAndConstructionPlan2(menu.customgamestart, menu.category.id, entryid, isHQentry and "station_pla_headquarters_base_01_macro" or "station_gen_factory_base_01_macro", cpid))

	if entryid ~= "" then
		local blueprintproperty = menu.findProperty("playerblueprints")
		if blueprintproperty then
			menu.initPropertyValue(blueprintproperty)

			for ware in pairs(menu.getCPWares(cpid)) do
				local found = false
				for j, entry in ipairs(blueprintproperty.value) do
					if entry.id == ware then
						found = true
						break
					end
				end
				if not found then
					table.insert(blueprintproperty.value, { id = ware, name = GetWareData(ware, "name"), default = false })
				end
			end
			menu.saveMultiSelect(blueprintproperty)
		end

		if isNewStation then
			menu.initManagerSkills(menu.category.id, entryid)
		end

		local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, menu.category.id, entryid))
		if sector ~= "" then
			menu.setKnownValue("playerknownspace", sector, true)
		end
		menu.saveKnownValue("playerknownspace")
	end

	menu.selectedCols.propertyTable = 2
	menu.refresh = getElapsedTime()

	if (entryid ~= "") and (not menu.shownPropertyHint) then
		menu.shownPropertyHint = getElapsedTime()
		menu.displayHint(ReadText(1001, 9935))
		menu.showHighlightOverlay = "property_expand"
	end
end

function menu.dropdownImport(filename)
	menu.closeContextMenu()
	C.ResetCustomGameStart(menu.customgamestart)
	menu.satellites = {}
	menu.usespacesuit = nil
	if next(menu.category) then
		if menu.category.id == "universe" then
			if menu.holomap ~= 0 then
				C.RemoveHoloMap()
				menu.holomap = 0
			end
		elseif menu.category.id == "ship" then
			if menu.cutsceneid then
				StopCutscene(menu.cutsceneid)
				menu.cutsceneid = nil
				DestroyPresentationCluster(menu.precluster)
			end
		elseif (menu.category.id == "playerresearch") or (menu.category.id == "universefactionrelations") then
			if menu.flowchart then
				menu.flowchart:collapseAllNodes()
				menu.flowchart = nil
			end
		end
	end

	C.ImportCustomGameStart(menu.customgamestart, filename, menu.customgamestart)
	
	menu.initEncyclopediaValue()
	menu.initKnownValue()
	menu.initStoryValue()
	menu.initSatellites()

	if menu.category.id == "playerresearch" then
		if not menu.playerresearchActive() then
			menu.setCategory(nil)
		end
	end
	menu.refreshMenu()
end

function menu.editboxNameUpdateText(_, text)
	menu.gamestartName = text
end

function menu.getCPWares(cpid)
	if not menu.cpwarescache[cpid] then
		menu.cpwarescache[cpid] = {}
		local n = C.GetNumConstructionPlanInfo(cpid)
		local buf = ffi.new("UIConstructionPlanEntry[?]", n)
		n = tonumber(C.GetConstructionPlanInfo(buf, n, cpid))
		for i = 0, n - 1 do
			local macro = ffi.string(buf[i].macroid)
			local ware = GetMacroData(macro, "ware")
			if ware then
				local hasblueprint, isdeprecated, isplayerblueprintallowed, nocustomgamestart, blueprintsowners, ismissiononly = GetWareData(ware, "hasblueprint", "isdeprecated", "isplayerblueprintallowed", "nocustomgamestart", "blueprintsowners", "ismissiononly")
				if menu.creative then
					nocustomgamestart = false
				end
				local isventure = false
				for i, owner in ipairs(blueprintsowners) do
					if owner == "visitor" then
						isventure = true
						break
					end
				end
				if hasblueprint and (not isdeprecated) and isplayerblueprintallowed and (not nocustomgamestart) and (not isventure) and (not ismissiononly) then
					menu.cpwarescache[cpid][ware] = true
				end
			end
		end
	end
	return menu.cpwarescache[cpid]
end

function menu.initPropertyValue(property)
	local bufstate = property.getState(menu.customgamestart, property.id)
	property.state = ffi.string(bufstate.state)

	local defaultvalues = {}
	local n = bufstate.numdefaultvalues
	local buf = ffi.new("CustomGameStart" .. property.propertyType .. "[?]", n)
	n = property.getDefault(buf, n, menu.customgamestart, property.id)
	for i = 0, n - 1 do
		if property.propertyType == "Inventory" then
			defaultvalues[ffi.string(buf[i].ware)] = buf[i].amount
		elseif property.propertyType == "Blueprint" then
			defaultvalues[ffi.string(buf[i].ware)] = true
		elseif property.propertyType == "KnownEntry2" then
			defaultvalues[ffi.string(buf[i].item)] = true
		end
	end

	local excludedvalues = {}
	property.value = {}
	local n = bufstate.numvalues
	local buf = ffi.new("CustomGameStart" .. property.propertyType .. "[?]", n)
	n = property.get(buf, n, menu.customgamestart, property.id)
	for i = 0, n - 1 do
		local entry = {}
		if property.propertyType == "Inventory" then
			local ware = ffi.string(buf[i].ware)
			entry.id = ware
			entry.name = GetWareData(ware, "name")
			entry.amount = buf[i].amount
			entry.defaultamount = defaultvalues[ware] or 0
		elseif property.propertyType == "Blueprint" then
			local ware = ffi.string(buf[i].ware)
			entry.id = ware
			entry.name = GetWareData(ware, "name")
			entry.default = defaultvalues[ware] or false
		elseif property.propertyType == "KnownEntry2" then
			local item = ffi.string(buf[i].item)
			entry.id = item
			entry.name = GetMacroData(item, "name")
			entry.budgetvalue = tonumber(buf[i].budgetvalue)
			entry.default = defaultvalues[item] or false
		end
		local skip = false
		if property.excludetags then
			local tags = GetWareData(entry.id, "tags") or {}
			for _, excludedtag in ipairs(property.excludetags) do
				if tags[excludedtag] then
					skip = true
					break
				end
			end
		end
		if not skip then
			table.insert(property.value, entry)
		else
			table.insert(excludedvalues, entry)
		end
	end
	if not menu.excludedvalues[property.id] then
		menu.excludedvalues[property.id] = {}
		for _, entry in ipairs(excludedvalues) do
			table.insert(menu.excludedvalues[property.id], entry.id)
		end
	end
	table.sort(property.value, Helper.sortName)
end

function menu.dropdownPlayerPropertySetSector(entryid, sector, offset)
	C.SetCustomGameStartPlayerPropertySectorAndOffset(menu.customgamestart, menu.category.id, entryid, sector, offset)
	menu.setKnownValue("playerknownspace", sector, true)
	menu.saveKnownValue("playerknownspace")
	menu.refresh = getElapsedTime()
end

function menu.cleanupFactionRelationsAllowedByStory(oldstoryid, newstoryid)
	for faction, stories in pairs(config.factionrelationsallowedbystory) do
		if stories[oldstoryid] and (not stories[newstoryid]) then
			menu.removeFactionRelationHelper(faction)
		end
	end
end

function menu.cleanupKnownSectorsAllowedByStory(oldstoryid, newstoryid)
	local knownspaceproperty = menu.findProperty("playerknownspace")
	if knownspaceproperty then
		menu.initPropertyValue(knownspaceproperty)

		for i = #knownspaceproperty.value, 1, -1 do
			local entry = knownspaceproperty.value[i]
			local knownitem = ffi.new("CustomGameStartKnownEntry2")
			knownitem.type = Helper.ffiNewString("sector")
			knownitem.item = Helper.ffiNewString(entry.id)
			local sectordependencies = menu.getStoryDependencies("playerknownspace", knownitem)
			local needstoberemoved = false
			for _, dependencylist in ipairs(sectordependencies) do
				local hasold, hasnew
				for _, dependency in ipairs(dependencylist) do
					if dependency == oldstoryid then
						hasold = true
					elseif dependency == newstoryid then
						hasnew = true
					end
				end
				if hasold and (not hasnew) then
					needstoberemoved = true
					break
				end
			end

			if needstoberemoved then
				menu.setKnownValue("playerknownspace", knownspaceproperty.value[i].id, false)
				table.remove(knownspaceproperty.value, i)
			end
		end
		menu.saveMultiSelect(knownspaceproperty)
	end
end

function menu.toggleStoryHQ(storyid)
	if storyid == "default" then
		C.ResetCustomGameStartProperty(menu.customgamestart, "playerresearch")
		menu.initResearch()
		menu.removeHQ()
	else
		menu.addHQ()
	end
end

function menu.dropdownStoryState(groupid, storyid)
	local id = (storyid == "default") and "" or storyid
	local oldid = (menu.stories[groupid].currentstory == "") and "default" or menu.stories[groupid].currentstory
	menu.stories[groupid].currentstory = id

	-- cleanup faction relations
	menu.cleanupFactionRelationsAllowedByStory(oldid, storyid)

	-- cleanup HQ
	if groupid == "hq_and_staff" then
		menu.toggleStoryHQ(storyid)
	end

	-- cleanup dependencies
	for groupid2, storyentry in pairs(menu.stories) do
		local story = menu.storiesbyid[storyentry.currentstory]
		if story and next(story.dependencies) then
			for _, dependencylist in ipairs(story.dependencies) do
				local found = false
				for _, dependency in ipairs(dependencylist) do
					for _, entry in pairs(menu.stories) do
						if entry.currentstory == dependency then
							found = true
							break
						end
					end
				end
				if not found then
					local olddependentid = storyentry.currentstory
					menu.stories[groupid2].currentstory = ""

					menu.cleanupKnownSectorsAllowedByStory(olddependentid, "")
					menu.cleanupFactionRelationsAllowedByStory(olddependentid, "default")

					if groupid2 == "hq_and_staff" then
						menu.toggleStoryHQ(storyid)
					end
				end
			end
		end
	end

	-- cleanup sectors with story dependencies
	menu.cleanupKnownSectorsAllowedByStory(oldid, id)

	menu.saveStoryValue(menu.category.id)
	menu.refreshMenu()
end

function menu.dropdownPlayerPropertySetCount(entryid, count, macro, oldcount)
	C.SetCustomGameStartPlayerPropertyCount(menu.customgamestart, menu.category.id, entryid, count)
	if menu.usedlimitedships[macro] then
		menu.usedlimitedships[macro] = menu.usedlimitedships[macro] - oldcount + count
	end
	menu.refresh = getElapsedTime()
end

function menu.editboxProperty(property, text)
	property.value = text
	property.set(menu.customgamestart, property.id, text)

	-- kuertee start: callback
	if menu.uix_callbacks ["editboxProperty_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["editboxProperty_on_end"]) do
			uix_callback (property, text)
		end
	end
	-- kuertee end: callback
end

function menu.editboxPlayerPropertyName(id, text)
	C.SetCustomGameStartPlayerPropertyName(menu.customgamestart, menu.category.id, id, text)
end

function menu.slidercellFaction(faction, value)
	if faction.relation == value then
		menu.removeFactionRelation(menu.category.value, menu.currentfaction.id, faction.id)
	else
		menu.setFactionRelation(menu.category.value, menu.currentfaction.id, faction.id, value)
	end

	local relationinfo = {}
	local relationpairs = {}
	for relationfaction, entry in pairs(menu.category.value) do
		for otherfaction, relation in pairs(entry) do
			if not relationpairs[relationfaction .. "+" .. otherfaction] then
				relationpairs[relationfaction .. "+" .. otherfaction] = true
				relationpairs[otherfaction .. "+" .. relationfaction] = true
				table.insert(relationinfo, { faction = relationfaction, otherfaction = otherfaction, relation = relation })
			end
		end
	end

	local relations = ffi.new("CustomGameStartRelationInfo[?]", #relationinfo)
	for i, entry in ipairs(relationinfo) do
		relations[i - 1].factionid = Helper.ffiNewString(entry.faction)
		relations[i - 1].otherfactionid = Helper.ffiNewString(entry.otherfaction)
		relations[i - 1].relation = entry.relation
	end

	C.SetCustomGameStartRelationsProperty(menu.customgamestart, menu.category.id, relations, #relationinfo)
	Helper.ffiClearNewHelper()

	-- kuertee start: callback
	if menu.uix_callbacks ["slidercellFaction_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["slidercellFaction_on_end"]) do
			uix_callback (faction, value)
		end
	end
	-- kuertee end: callback
end

function menu.removeFactionRelationHelper(faction)
	for _, entry in ipairs(menu.factions) do
		menu.removeFactionRelation(entry.relations, entry.id, faction)
	end

	local factionrelations = {}
	local n = C.GetCustomGameStartRelationsPropertyCounts(menu.customgamestart, menu.category.id)
	local buf = ffi.new("CustomGameStartRelationInfo[?]", n)
	n = C.GetCustomGameStartRelationsProperty(buf, n, menu.customgamestart, menu.category.id)
	for i = 0, n - 1 do
		menu.setFactionRelation(factionrelations, ffi.string(buf[i].factionid), ffi.string(buf[i].otherfactionid), buf[i].relation)
	end

	local relationinfo = {}
	local relationpairs = {}
	for relationfaction, entry in pairs(factionrelations) do
		for otherfaction, relation in pairs(entry) do
			if not relationpairs[relationfaction .. "+" .. otherfaction] then
				print(relationfaction .. ", " .. otherfaction)
				relationpairs[relationfaction .. "+" .. otherfaction] = true
				relationpairs[otherfaction .. "+" .. relationfaction] = true
				table.insert(relationinfo, { faction = relationfaction, otherfaction = otherfaction, relation = relation })
			end
		end
	end

	local relations = ffi.new("CustomGameStartRelationInfo[?]", #relationinfo)
	for i, entry in ipairs(relationinfo) do
		relations[i - 1].factionid = Helper.ffiNewString(entry.faction)
		relations[i - 1].otherfactionid = Helper.ffiNewString(entry.otherfaction)
		relations[i - 1].relation = entry.relation
	end

	C.SetCustomGameStartRelationsProperty(menu.customgamestart, "universefactionrelations", relations, #relationinfo)
	Helper.ffiClearNewHelper()

	-- kuertee start: callback
	if menu.uix_callbacks ["removeFactionRelationHelper_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["removeFactionRelationHelper_on_end"]) do
			uix_callback (faction)
		end
	end
	-- kuertee end: callback
end

function menu.saveMultiSelect(property)
	local numdata = #property.value + #menu.excludedvalues[property.id]
	local data = ffi.new("CustomGameStart" .. property.propertyType .. "[?]", numdata)
	local i = 0
	if property.propertyType == "Inventory" then
		for _, entry in ipairs(property.value) do
			data[i].ware = Helper.ffiNewString(entry.id)
			data[i].amount = entry.amount
			i = i + 1
		end
		for _, id in ipairs(menu.excludedvalues[property.id]) do
			local found = false
			for _, entry in ipairs(property.value) do
				if entry.id == id then
					found = true
					break
				end
			end
			if not found then
				data[i].ware = Helper.ffiNewString(entry.id)
				data[i].amount = entry.amount
				i = i + 1
			end
		end
	elseif property.propertyType == "Blueprint" then
		for _, entry in ipairs(property.value) do
			data[i].ware = Helper.ffiNewString(entry.id)
			i = i + 1
		end
		for _, id in ipairs(menu.excludedvalues[property.id]) do
			local found = false
			for _, entry in ipairs(property.value) do
				if entry.id == id then
					found = true
					break
				end
			end
			if not found then
				data[i].ware = Helper.ffiNewString(id)
				i = i + 1
			end
		end
	elseif property.propertyType == "KnownEntry2" then
		for _, entry in ipairs(property.value) do
				data[i].type = "sector"
				data[i].item = Helper.ffiNewString(entry.id)
				i = i + 1
		end
		for _, id in ipairs(menu.excludedvalues[property.id]) do
			local found = false
			for _, entry in ipairs(property.value) do
				if entry.id == id then
					found = true
					break
				end
			end
			if not found then
				data[i].type = "sector"
				data[i].item = Helper.ffiNewString(entry.id)
				i = i + 1
			end
		end
	end
	property.set(menu.customgamestart, property.id, data, i)
	Helper.ffiClearNewHelper()
end

function menu.slidercellMultiSelect(property, entryid, row, value)
	if property.propertyType == "Inventory" then
		for i, entry in ipairs(property.value) do
			if entry.id == entryid then
				entry.amount = value
				break
			end
		end
	end
	menu.saveMultiSelect(property)
end

function menu.slidercellNumberProperty(property, row, value)
	property.value = value
	property.set(menu.customgamestart, property.id, value)
end

function menu.playerMoney(start)
	local scale = {
		min            = 0,
		max            = 10000000,
		start          = start,
		step           = 1000,
		suffix         = ReadText(1001, 101),
		exceedMaxValue = true,
		hideMaxValue   = true,
	}

	return scale
end

function menu.playerMacro(current, customoptions)
	local options = {}
	local currentOption = current

	local macros = {}
	menu.playerMacros = {}
	for macro in string.gmatch(customoptions, "[%w_]+") do
		local race, racename, female, basemacro = GetMacroData(macro, "entityrace", "entityracename", "entityfemale", "basemacro")
		table.insert(macros, { macro = macro, basemacro = basemacro, race = race, racename = racename, gender = female and "female" or "male" })
		menu.playerMacros[basemacro] = macro
	end
	table.sort(macros, Helper.sortPlayerMacro)

	local lastrace, lastgender
	local doublingcount = 0
	for _, entry in ipairs(macros) do
		local name = entry.racename or ""
		if (entry.race ~= "teladi") and (entry.race ~= "paranid") then
			if entry.gender == "female" then
				name = name .. " " .. ReadText(1001, 9906)
			elseif entry.gender == "male" then
				name = name .. " " .. ReadText(1001, 9907)
			end
		end
		if (lastrace == entry.race) and (lastgender == entry.gender) then
			if doublingcount == 0 then
				options[#options].text = options[#options].text .. " " .. ReadText(20402, 1)
				doublingcount = 2
			else
				doublingcount = doublingcount + 1
			end
			name = name .. " " .. ReadText(20402, doublingcount)
		else
			lastrace = entry.race
			lastgender = entry.gender
			doublingcount = 0
		end

		table.insert(options, { id = entry.basemacro, text = name, icon = "", displayremoveoption = false })
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["playerMacro_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["playerMacro_on_end"]) do
			uix_callback (current, customoptions, options, currentOption)
		end
	end
	-- kuertee end: callback

	return options, currentOption
end

function menu.playerBuildMethod(current, customoptions)
	local options = {
		{ id = "auto", text = ReadText(1001, 9917), icon = "", displayremoveoption = false }
	}
	local currentOption = (current ~= "") and current or "auto"

	local n = C.GetNumPlayerBuildMethods()
	if n > 0 then
		local buf = ffi.new("ProductionMethodInfo[?]", n)
		n = C.GetPlayerBuildMethods(buf, n)
		for i = 0, n - 1 do
			table.insert(options, { id = ffi.string(buf[i].id), text = ffi.string(buf[i].name), icon = "", displayremoveoption = false })
		end
	end

	return options, currentOption
end

function menu.playerPaintThemes(current, customoptions)
	local options = {}
	local currentOption = current

	local n = C.GetNumCustomGameStartPaintThemes(menu.customgamestart)
	if n > 0 then
		local buf = ffi.new("UIPaintTheme[?]", n)
		n = C.GetCustomGameStartPaintThemes(buf, n, menu.customgamestart)
		for i = 0, n - 1 do
			table.insert(options, { id = ffi.string(buf[i].ID), text = ffi.string(buf[i].Name), icon = "", displayremoveoption = false })
		end
	end
	table.sort(options, function (a, b) return a.text < b.text end)

	return options, currentOption
end

function menu.playerresearchActive()
	for _, entry in pairs(menu.stories) do
		if (entry.currentstory == "story_hq_boso") or (entry.currentstory == "story_hq_dal") then
			return true
		end
	end
	return false
end

function menu.playerresearchMouseOver()
	local found = false
	local missingdependencies = ""
	for _, entry in pairs(menu.stories) do
		if (entry.currentstory == "story_hq_boso") or (entry.currentstory == "story_hq_dal") then
			return ""
		end
	end
	missingdependencies = "\n- " .. (menu.storiesbyid["story_hq_boso"] and menu.storiesbyid["story_hq_boso"].name or "story_hq_boso") .. "\n- " .. (menu.storiesbyid["story_hq_dal"] and menu.storiesbyid["story_hq_dal"].name or "story_hq_dal")
	return ReadText(1001, 9938) .. ReadText(1001, 120) .. ColorText["text_error"] .. missingdependencies .. "\27X"
end

function menu.universeSector(current)
	local options = {}
	local currentOption = current

	local buf = ffi.new("CustomGameStartStringPropertyState[1]")
	local galaxymacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "galaxy", buf))
	local sectormacros = GetMacroData(galaxymacro, "sectors") or {}
	table.sort(sectormacros, Helper.sortMacroName)
	for _, sector in ipairs(sectormacros) do
		local unlocked = true
		local hidden = false
		local knownitem = ffi.new("CustomGameStartKnownEntry2")
		knownitem.type = Helper.ffiNewString("sector")
		knownitem.item = Helper.ffiNewString(sector)
		if C.GetCustomGameStartKnownPropertyBudgetValue2(menu.customgamestart, "playerknownspace", knownitem) then
			unlocked = knownitem.unlocked
			hidden = knownitem.hidden
		end
		if not hidden then
			local mouseovertext = ""
			local active = true
			
			if not unlocked then
				active = false
				mouseovertext = ReadText(1026, 9928)
			else
				local dependencies = menu.getStoryDependencies("playerknownspace", knownitem)
				for _, dependencylist in ipairs(dependencies) do
					local found = false
					local missingdependencies = ""
					for _, dependency in ipairs(dependencylist) do
						for _, entry in pairs(menu.stories) do
							if entry.currentstory == dependency then
								found = true
								break
							end
						end
						missingdependencies = missingdependencies .. "\n- " .. (menu.storiesbyid[dependency] and menu.storiesbyid[dependency].name or dependency)
					end
					if not found then
						mouseovertext = ((mouseovertext ~= "") and (mouseovertext .. "\n\n") or "") .. ReadText(1001, 9951) .. ReadText(1001, 120) .. ColorText["text_error"] .. missingdependencies .. "\27X"
						active = false
					end
				end
			end

			table.insert(options, { id = sector, text = GetMacroData(sector, "name"), icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["universeSector_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["universeSector_on_end"]) do
			uix_callback (current, options, currentOption)
		end
	end
	-- kuertee end: callback

	return options, currentOption
end

function menu.getStoryDependencies(property, knownitem)
	local dependencies = {}
	local numdependencylists = C.GetCustomGameStartKnownPropertyNumStateDependencyLists(menu.customgamestart, property, knownitem)
	local dependencylist_lenghts = {}
	local numdependencies = 0
	local dependencylists_buf = ffi.new("uint32_t[?]", numdependencylists)
	numdependencylists = C.GetCustomGameStartKnownPropertyNumStateDependencies(dependencylists_buf, numdependencylists, menu.customgamestart, property, knownitem);
	for j = 0, numdependencylists - 1 do
		local count = dependencylists_buf[j]
		numdependencies = numdependencies + count
		table.insert(dependencylist_lenghts, count)
	end
	local dependencies_buf = ffi.new("const char*[?]", numdependencies)
	numdependencies = C.GetCustomGameStartKnownPropertyStateDependencies(dependencies_buf, numdependencies, menu.customgamestart, property, knownitem)
	local idx = 1
	for j = 0, numdependencies - 1 do
		while dependencylist_lenghts[1] and (dependencylist_lenghts[1] <= 0) do
			idx = idx + 1
			table.remove(dependencylist_lenghts, 1)
		end
		if #dependencylist_lenghts == 0 then
			DebugError("Dependency list counts and number of dependencies do not match - aborting.")
			break
		end

		if dependencies[idx] then
			table.insert(dependencies[idx], ffi.string(dependencies_buf[j]))
		else
			dependencies[idx] = { ffi.string(dependencies_buf[j]) }
		end
		dependencylist_lenghts[1] = dependencylist_lenghts[1] - 1
	end

	return dependencies
end

function menu.shipValue(current)
	menu.updateBudgets()

	local budget1 = ""
	if menu.propertybudgets["money" .. "ship"] then
		budget1 = " (" .. ConvertIntegerString(menu.propertybudgets["money" .. "ship"], true, 3, true) .. menu.getBudgetSuffix("money") .. ")"
	end

	local budget2 = ""
	if menu.propertybudgets["people" .. "ship"] then
		budget2 = " (" .. ConvertIntegerString(menu.propertybudgets["people" .. "ship"], true, 3, true) .. menu.getBudgetSuffix("people") .. ")"
	end

	if IsMacroClass(current, "spacesuit") then
		menu.usespacesuit = true
	end
	return GetMacroData(current, "name") .. budget1 .. budget2
end

function menu.openShipConfig()
	-- kuertee start: callback
	if menu.uix_callbacks ["openShipConfig_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["openShipConfig_on_start"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback

	menu.usespacesuit = nil
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "customgamestart", { menu.customgamestart, menu.creative, "ship", "shiploadout", "shippeople", "shippeoplefillpercent", nil, "playerpainttheme", nil, nil, nil, nil, nil, nil, menu.paused ~= nil } })
	menu.cleanup()

	-- kuertee start: callback
	if menu.uix_callbacks ["openShipConfig_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["openShipConfig_on_end"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback
end

function menu.openPlayerPropertyShipConfig(row, entryid, macro, commanderid, peopledef, peoplefillpercentage, count)
	menu.addingFleet = true
	menu.selectedRows.propertyTable = row
	menu.selectedCols.propertyTable = 2
	Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "customgamestart", { menu.customgamestart, menu.creative, "playerproperty", nil, nil, nil, nil, "playerpainttheme", entryid, macro, commanderid, peopledef, peoplefillpercentage, count, menu.paused ~= nil } })
	menu.cleanup()

	-- kuertee start: callback
	if menu.uix_callbacks ["openPlayerPropertyShipConfig_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["openPlayerPropertyShipConfig_on_end"]) do
			uix_callback (row, entryid, macro, commanderid, peopledef, peoplefillpercentage, count)
		end
	end
	-- kuertee end: callback
end

function menu.setPlayerMacro(customgamestart, propertyid, option)
	C.SetCustomGameStartStringProperty(customgamestart, propertyid, option)
	local isfemale = GetMacroData(option, "entityfemale")
	C.SetCustomGameStartBoolProperty(customgamestart, "playerfemale", isfemale)
	if menu.usespacesuit then
		local spacesuitmacro = GetMacroData(option, "spacesuitmacro")
		C.SetCustomGameStartShipAndEmptyLoadout(menu.customgamestart, "ship", "shiploadout", spacesuitmacro)
	end
	if menu.cutsceneid then
		StopCutscene(menu.cutsceneid)
		menu.cutsceneid = nil
		DestroyPresentationCluster(menu.precluster)
		SetRenderTargetNoise(menu.rendertarget.id, true)
		menu.rendertargetLock = getElapsedTime() + 0.1
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["setPlayerMacro_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["setPlayerMacro_on_end"]) do
			uix_callback (customgamestart, propertyid, option)
		end
	end
	-- kuertee end: callback
end

function menu.setPlayerPaintTheme(customgamestart, propertyid, option)
	C.SetCustomGameStartStringProperty(customgamestart, propertyid, option)
	if menu.preobject then
		local paintmod = ffi.new("UIPaintMod")
		if C.GetPaintThemeMod(option, "player", paintmod) then
			C.InstallPaintMod(ConvertIDTo64Bit(menu.preobject), ffi.string(paintmod.Ware), false)
		end
	end
end

function menu.setPlayerSector(gamestartid, propertyid, sector, noreset)
	if (not noreset) and (menu.holomap ~= 0) then
		C.RemoveHoloMap()
		menu.holomap = 0
	end
	C.SetCustomGameStartStringProperty(gamestartid, propertyid, sector)

	-- kuertee start: callback
	if menu.uix_callbacks ["setPlayerSector_on_end"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["setPlayerSector_on_end"]) do
			uix_callback (gamestartid, propertyid, sector, noreset)
		end
	end
	-- kuertee end: callback
end

function menu.displayMultiSelection(property)
	menu.contextMenu = "multiselect"
	menu.contextMenuData = { options = {}, selectedOptions = {}, origSelectedOptions = {}, propertyLockedWares = {} }

	if property.propertyType == "Inventory" then
		local craftingwares, upgradewares, tradeonlywares, paintmodwares, usefulwares = {}, {}, {}, {}, {}

		local tags = "inventory"
		local excludetags = "paintmod clothingmod missiononly braneitem deprecated seminar equipmentmodpart nocustomgamestart"
		local n = C.GetNumWares(tags, false, "", excludetags)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, tags, false, "", excludetags)
		menu.contextMenuData.optionCount = n
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			local name, iscraftingresource, ismodpart, isprimarymodpart, ispersonalupgrade, tradeonly, ispaintmod = GetWareData(ware, "name", "iscraftingresource", "ismodpart", "isprimarymodpart", "ispersonalupgrade", "tradeonly", "ispaintmod")
			if iscraftingresource or ismodpart or isprimarymodpart then
				table.insert(craftingwares, { id = ware, name = name })
			elseif ispersonalupgrade then
				table.insert(upgradewares, { id = ware, name = name })
			elseif tradeonly then
				table.insert(tradeonlywares, { id = ware, name = name })
			elseif ispaintmod then
				table.insert(paintmodwares, { id = ware, name = name })
			else
				table.insert(usefulwares, { id = ware, name = name })
			end

			for _, entry in ipairs(property.value) do
				if entry.id == ware then
					menu.contextMenuData.selectedOptions[ware] = true
					menu.contextMenuData.origSelectedOptions[ware] = true
					break
				end
			end
		end

		if #craftingwares > 0 then
			table.insert(menu.contextMenuData.options, { name = ReadText(1001, 2827), wares = craftingwares })	-- Crafting Wares
		end
		if #upgradewares > 0 then
			table.insert(menu.contextMenuData.options, { name = ReadText(1001, 7716), wares = upgradewares })	-- Spacesuit Upgrades
		end
		if #paintmodwares > 0 then
			table.insert(menu.contextMenuData.options, { name = ReadText(1001, 8510), wares = paintmodwares})	-- Trade Wares
		end
		if #usefulwares > 0 then
			table.insert(menu.contextMenuData.options, { name = ReadText(1001, 2828), wares = usefulwares })	-- General Wares
		end
		if #tradeonlywares > 0 then
			table.insert(menu.contextMenuData.options, { name = ReadText(1001, 2829), wares = tradeonlywares})	-- Trade Wares
		end
	elseif property.propertyType == "Blueprint" then
		local waresbyclass = {}

		local tags = "module ship weapon turret shield engine thruster missile drone consumables countermeasure lasertower satellite mine navbeacon resourceprobe"
		local excludetags = "noplayerblueprint noblueprint noplayerbuild deprecated missiononly"
		if not menu.creative then
			excludetags = excludetags .. " nocustomgamestart"
		end
		local n = C.GetNumWares(tags, false, "", excludetags)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetWares(buf, n, tags, false, "", excludetags)
		menu.contextMenuData.optionCount = 0
		for i = 0, n - 1 do
			local ware = ffi.string(buf[i])
			local name, macro, blueprintsowners = GetWareData(ware, "name", "component", "blueprintsowners")
			local isventure = false
			for i, owner in ipairs(blueprintsowners) do
				if owner == "visitor" then
					isventure = true
					break
				end
			end
			if not isventure then
				local isunit, isvirtual, islasertower, hasinfoalias = GetMacroData(macro, "isunit", "isvirtual", "islasertower", "hasinfoalias")
				if not hasinfoalias then
					local class = isunit and "drone" or ffi.string(C.GetMacroClass(macro))
					if (class == "engine") and isvirtual then
						class = "thruster"
					elseif islasertower then
						class = "lasertower"
					end

					if waresbyclass[class] then
						table.insert(waresbyclass[class], { id = ware, name = name })
					else
						waresbyclass[class] = { { id = ware, name = name } }
					end

					for _, entry in ipairs(property.value) do
						if entry.id == ware then
							menu.contextMenuData.selectedOptions[ware] = true
							menu.contextMenuData.origSelectedOptions[ware] = true
							break
						end
					end
				end
			end
		end

		local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
		if state.numvalues > 0 then
			local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
			local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
			if n > 0 then
				local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
				for i = 0, n - 1 do
					buf[i].numcargo = counts[i].numcargo
					buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
				end
				n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
				for i = 0, n - 1 do
					for ware in pairs(menu.getCPWares(ffi.string(buf[i].constructionplanid))) do
						menu.contextMenuData.propertyLockedWares[ware] = true
					end
				end
			end
		end

		for _, entry in ipairs(config.blueprintcategories) do
			local data = {}
			for class in pairs(entry.classes) do
				if waresbyclass[class] then
					if #data == 0 then
						data = waresbyclass[class]
						menu.contextMenuData.optionCount = menu.contextMenuData.optionCount + #waresbyclass[class]
					else
						for _, wareentry in ipairs(waresbyclass[class]) do
							table.insert(data, wareentry)
							menu.contextMenuData.optionCount = menu.contextMenuData.optionCount + 1
						end
					end
				end
			end
			if #data > 0 then
				table.insert(menu.contextMenuData.options, { name = entry.name, wares = data})
			end
		end
	elseif property.propertyType == "KnownEntry2" then
		local sectors = {}
		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local galaxymacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "galaxy", buf))
		local sectormacros = GetMacroData(galaxymacro, "sectors") or {}
		menu.contextMenuData.optionCount = #sectormacros
		for _, sector in ipairs(sectormacros) do
			table.insert(sectors, { id = sector, name = GetMacroData(sector, "name") })

			for _, entry in ipairs(property.value) do
				if entry.id == sector then
					menu.contextMenuData.selectedOptions[sector] = true
					menu.contextMenuData.origSelectedOptions[sector] = true
					break
				end
			end
		end

		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local playersectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
		menu.contextMenuData.propertyLockedWares[playersectormacro] = true
		local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
		if state.numvalues > 0 then
			local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
			local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
			if n > 0 then
				local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
				for i = 0, n - 1 do
					buf[i].numcargo = counts[i].numcargo
					buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
				end
				n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
				for i = 0, n - 1 do
					local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, "playerproperty", ffi.string(buf[i].id)))
					if sector ~= "" then
						menu.contextMenuData.propertyLockedWares[sector] = true
					end
				end
			end
		end

		table.insert(menu.contextMenuData.options, { name = "", wares = sectors})
	end
	for _, data in ipairs(menu.contextMenuData.options) do
		table.sort(data.wares, Helper.sortName)
	end

	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)
	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.propertyTable.properties.x + menu.propertyTable.properties.width + 2 * Helper.borderSize,
		y = menu.propertyTable.properties.y,
		width = menu.width / 4,
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
	})

	menu.contextTable = menu.contextFrame:addTable(3, { tabOrder = 3 })
	menu.contextTable:setColWidth(1, config.standardTextHeight)
	menu.contextTable:setColWidthPercent(3, 33)

	local row = menu.contextTable:addRow(true, { fixed = true })
	row[1]:createCheckBox(function () local count = 0; for _ in pairs(menu.contextMenuData.selectedOptions) do count = count + 1 end; return menu.contextMenuData.optionCount == count end, { height = Helper.standardTextHeight })
	row[1].handlers.onClick = function (_, checked) return menu.checkboxToggleMultiSelect(checked) end
	row[2]:setColSpan(2):createText(property.selectionText, Helper.headerRowCenteredProperties)

	for i, data in ipairs(menu.contextMenuData.options) do
		if i ~= 1 then
			menu.contextTable:addEmptyRow(config.standardTextHeight / 2)
		end
		if data.name ~= "" then
			local row = menu.contextTable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(data.name, { titleColor = Color["row_title"] })
		end
		for _, entry in ipairs(data.wares) do
			local unlocked = true
			local hidden = false
			local budgetvalue = 0
			local knownitem = ffi.new("CustomGameStartKnownEntry2")
			if property.propertyType == "KnownEntry2" then
				if property.id == "playerknownspace" then
					knownitem.type = Helper.ffiNewString("sector")
					knownitem.item = Helper.ffiNewString(entry.id)
				end
				if C.GetCustomGameStartKnownPropertyBudgetValue2(menu.customgamestart, property.id, knownitem) then
					budgetvalue = tonumber(knownitem.budgetvalue)
					unlocked = knownitem.unlocked
					hidden = knownitem.hidden
					if hidden then
						menu.contextMenuData.propertyLockedWares[entry.id] = true
						menu.contextMenuData.optionCount = menu.contextMenuData.optionCount - 1
					end
				end
			end

			if not hidden then
				local row = menu.contextTable:addRow(entry.id, {  })
				local active = true
				local mouseovertext = ""
				if not unlocked then
					active = false
					mouseovertext = ReadText(1026, 9928)
				elseif property.propertyType == "KnownEntry2" then
					local dependencies = menu.getStoryDependencies("playerknownspace", knownitem)
					for _, dependencylist in ipairs(dependencies) do
						local found = false
						local missingdependencies = ""
						for _, dependency in ipairs(dependencylist) do
							for _, entry in pairs(menu.stories) do
								if entry.currentstory == dependency then
									found = true
									break
								end
							end
							missingdependencies = missingdependencies .. "\n- " .. (menu.storiesbyid[dependency] and menu.storiesbyid[dependency].name or dependency)
						end
						if not found then
							mouseovertext = ((mouseovertext ~= "") and (mouseovertext .. "\n\n") or "") .. ReadText(1001, 9951) .. ReadText(1001, 120) .. ColorText["text_error"] .. missingdependencies .. "\27X"
							active = false
							menu.contextMenuData.propertyLockedWares[entry.id] = true
							menu.contextMenuData.optionCount = menu.contextMenuData.optionCount - 1
						end
					end
				end
				
				if active then
					if menu.contextMenuData.propertyLockedWares[entry.id] then
						active = false
						if property.propertyType == "Blueprint" then
							mouseovertext = ReadText(1026, 9906)
						elseif property.propertyType == "KnownEntry2" then
							if property.id == "playerknownspace" then
								mouseovertext = ReadText(1026, 9915)
							end
						end
					end
				end
				row[1]:createCheckBox(function () return menu.contextMenuData.selectedOptions[entry.id] or false end, { height = Helper.standardTextHeight, active = active, mouseOverText = mouseovertext })
				row[1].handlers.onClick = function (_, checked) return menu.checkboxMultiSelect(entry.id, checked) end
				row[2]:createText(entry.name)
				if not menu.creative then
					if (property.propertyType == "Inventory") or (property.propertyType == "Blueprint") then
						row[3]:createText(ConvertIntegerString(GetWareData(entry.id, "avgprice"), true, 0, true) .. " " .. ReadText(1001, 101), { halign = "right" })
					elseif property.propertyType == "KnownEntry2" then
						local budgetsuffix = menu.getBudgetSuffix("known")
						row[3]:createText(ConvertIntegerString(budgetvalue, true, 3, true) .. budgetsuffix, { halign = "right" })
					end
				end
			end
		end
	end

	menu.contextTable2 = menu.contextFrame:addTable(2, { tabOrder = 4, y = Helper.borderSize })
	local row = menu.contextTable2:addRow(true, { fixed = true })
	row[1]:createButton({ active = menu.isOptionSelectionChanged }):setText(ReadText(1001, 14), { halign = "center" })
	row[1].handlers.onClick = function () return menu.buttonMultiSelectConfirm(property) end
	row[2]:createButton({  }):setText(ReadText(1001, 64), { halign = "center" })
	row[2].handlers.onClick = function () return menu.onCloseElement("back", config.contextFrameLayer) end

	local maxVisibleHeight = menu.propertyTable.properties.maxVisibleHeight - menu.contextTable2:getFullHeight() - Helper.frameBorder
	menu.contextTable2.properties.y = menu.contextTable2.properties.y + math.min(maxVisibleHeight, menu.contextTable:getFullHeight())
	menu.contextTable.properties.maxVisibleHeight = menu.contextTable2.properties.y - menu.contextTable.properties.y

	menu.contextTable.properties.nextTable = menu.contextTable2.index
	menu.contextTable2.properties.prevTable = menu.contextTable.index

	menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight())
	menu.contextFrame:display()
	menu.refresh = getElapsedTime()
end

function menu.displayMapContext(offset, sectormacro, sectorpos)
	menu.contextMenu = "mapcontext"

	local offsetx = offset[1] + Helper.viewWidth / 2
	local offsety = Helper.viewHeight / 2 - offset[2]

	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)
	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = offsetx,
		y = offsety,
		width = Helper.scaleX(config.mapContextWidth),
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
	})

	menu.contextTable = menu.contextFrame:addTable(1, { tabOrder = 3, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"] })

	local row = menu.contextTable:addRow(nil, { fixed = true })
	row[1]:createText(GetMacroData(sectormacro, "name"), Helper.headerRowCenteredProperties)

	if menu.category.id == "universe" then
		local knownspaceproperty = menu.findProperty("playerknownspace")
		if knownspaceproperty then
			menu.initPropertyValue(knownspaceproperty)

			local found
			for j, entry in ipairs(knownspaceproperty.value) do
				if entry.id == sectormacro then
					found = j
					break
				end
			end

			-- known sector
			local locked = false
			local buf = ffi.new("CustomGameStartStringPropertyState[1]")
			local playersectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
			if playersectormacro == sectormacro then
				locked = true
			end
			if not locked then
				local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
				if state.numvalues > 0 then
					local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
					local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
					if n > 0 then
						local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
						for i = 0, n - 1 do
							buf[i].numcargo = counts[i].numcargo
							buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
						end
						n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
						for i = 0, n - 1 do
							local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, "playerproperty", ffi.string(buf[i].id)))
							if sector == sectormacro then
								locked = true
								break
							end
						end
					end
				end
			end

			local row = menu.contextTable:addRow({  })
			row[1]:createButton({ height = Helper.standardTextHeight, active = not locked, mouseOverText = locked and ReadText(1026, 9915) or "" }):setText(found and ReadText(1001, 9940) or ReadText(1001, 9939))
			row[1].handlers.onClick = function () return menu.buttonMapContextSelectSector(sectormacro, found) end

			if found then
				-- known stations
				local checked = menu.getKnownValue("playerknownobjects", sectormacro)
				local row = menu.contextTable:addRow({  })
				row[1]:createButton({ height = Helper.standardTextHeight }):setText(checked and ReadText(1001, 9941) or ReadText(1001, 9944))
				row[1].handlers.onClick = function () return menu.buttonMapContextKnownStations(sectormacro, not checked) end

				-- satelitte coverage
				local row = menu.contextTable:addRow({  })
				row[1]:createButton({ height = Helper.standardTextHeight }):setText(menu.satellites[sectormacro] and ReadText(1001, 9943) or ReadText(1001, 9942))
				row[1].handlers.onClick = function () return menu.buttonMapContextSatelliteCoverage(sectormacro, not menu.satellites[sectormacro]) end
			end
		end
	end

	menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight())
	menu.contextFrame:display()
end

function menu.displayExportContext()
	menu.contextMenu = "export"
	local width = menu.categoryTable.properties.width * 3 / 2

	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)
	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = menu.exportButtonPos.x,
		y = menu.exportButtonPos.y,
		width = width + 2 * Helper.borderSize,
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
	})
	menu.contextFrame:setBackground("solid", { color = Color["frame_background_black"] })

	menu.contextTable = menu.contextFrame:addTable(3, { tabOrder = 6, reserveScrollBar = false, x = Helper.borderSize, y = Helper.borderSize, width = width })
	menu.contextTable:setDefaultCellProperties("button", { height = Helper.standardTextHeight })
	menu.contextTable:setDefaultComplexCellProperties("button", "text", { fontsize = Helper.standardFontSize, halign = "center" })

	local row = menu.contextTable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 9946), Helper.headerRowCenteredProperties)

	local row = menu.contextTable:addRow(true, { fixed = true })
	row[1]:setColSpan(3):createEditBox({ height = Helper.headerRow1Height, defaultText = ReadText(1001, 9947) }):setText(menu.gamestartName or "", { fontsize = Helper.headerRow1FontSize, x = Helper.standardTextOffsetx })
	row[1].handlers.onTextChanged = menu.editboxNameUpdateText

	local row = menu.contextTable:addRow(nil, { fixed = true })
	row[1]:setColSpan(3):createText(ReadText(1001, 9948), { wordwrap = true })

	--[[
	local row = menu.contextTable:addRow(true, { fixed = true })
	row[1]:setColSpan(3):createButton({ active = C.CanOpenWebBrowser(), mouseOverText = ReadText(1026, 7918) }):setText(ReadText(1001, 7974)):setText2("\27[mm_externallink]", { halign = "right" })
	row[1].handlers.onClick = menu.buttonConstructionCommunity--]]

	local row = menu.contextTable:addRow(true, { fixed = true })
	row[1]:createButton({ active = function () return menu.checkExportActive(true) end }):setText(ReadText(1001, 9949), {  })
	row[1].handlers.onClick = function () return menu.buttonExport(true) end
	row[2]:createButton({ active = function () return menu.checkExportActive(false) end }):setText(ReadText(1001, 7909), {  })
	row[2].handlers.onClick = function () return menu.buttonExport(true) end
	row[3]:createButton({  }):setText(ReadText(1001, 64))
	row[3].handlers.onClick = menu.closeContextMenu

	menu.contextFrame.properties.height = math.min(Helper.viewHeight - menu.contextFrame.properties.y, menu.contextFrame:getUsedHeight() + Helper.borderSize)
	menu.contextFrame:display()
end

function menu.checkExportActive(overwrite)
	if menu.gamestartName and (menu.gamestartName ~= "") then
		for _, entry in ipairs(menu.availablecustomgamestarts) do
			if entry.text == menu.gamestartName then
				return overwrite
			end
		end
		return not overwrite
	end
	return false
end

function menu.displayHint(text)
	menu.contextMenu = "propertyadded"

	local width = Helper.scaleX(230)
	local textheight = math.ceil(C.GetTextHeight(text, config.font, Helper.scaleFont(config.font, config.standardFontSize), width - 2 * Helper.scaleX(config.standardTextOffsetX)))
	local height = textheight + Helper.standardButtons_Size
	local borderwidth = 2

	Helper.removeAllWidgetScripts(menu, config.contextFrameLayer)
	menu.contextFrame = Helper.createFrameHandle(menu, {
		x = (Helper.viewWidth - width - 2 * borderwidth) / 2,
		y = (Helper.viewHeight - height - 2 * borderwidth) / 2,
		width = width + 2 * borderwidth,
		height = height + 2 * borderwidth,
		layer = config.contextFrameLayer,
		standardButtons = { close = true },
	})
	menu.contextFrame:setBackground("tut_gradient_hint_01", {
		color = Color["hint_background_orange"],
		rotationRate = 360,
		rotationStart = 135,
		rotationDuration = 1,
		rotationInterval = 10,
		initialScaleFactor = 3,
		scaleDuration = 0.5,
	})
	menu.contextFrame:setBackground2("solid", {
		color = Color["hint_background2_black"],
		width = width,
		height = height,
		initialScaleFactor = 3,
		scaleDuration = 0.5,
	})

	menu.contextTable = menu.contextFrame:addTable(1, { tabOrder = 3, x = borderwidth, y = borderwidth, width = width, reserveScrollBar = false })
	local row = menu.contextTable:addRow(nil, { fixed = true })
	row[1]:createText(text, { scaling = false, fontsize = Helper.scaleFont(config.font, config.standardFontSize), x = Helper.scaleX(config.standardTextOffsetX), y = Helper.standardButtons_Size, wordwrap = true })

	menu.contextFrame:display()
end

function menu.isOptionSelectionChanged()
	for ware in pairs(menu.contextMenuData.selectedOptions) do
		if not menu.contextMenuData.origSelectedOptions[ware] then
			return true
		end
	end
	for ware in pairs(menu.contextMenuData.origSelectedOptions) do
		if not menu.contextMenuData.selectedOptions[ware] then
			return true
		end
	end
	return false
end

function menu.onShowMenu(state)
	if not menu.isStartmenu then
		if menu.param[6] ~= 0 then
			menu.paused = true
			Pause()
		end
	end

	menu.customgamestart = menu.param[3]
	menu.multiplayer = menu.param[4] ~= 0
	menu.creative = menu.param[5] ~= 0

	menu.width = Helper.viewWidth - 2 * config.table.x
	menu.topRows = {}
	menu.firstCols = {}
	menu.selectedRows = {}
	menu.selectedCols = {}

	if state then
		menu.onRestoreState(state)

		if menu.addingFleet then
			if not menu.shownPropertyHint then
				local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
				if state.numvalues > 0 then
					menu.shownPropertyHint = getElapsedTime()
					menu.displayHint(ReadText(1001, 9935))
					menu.showHighlightOverlay = "property_expand"
				end
			end
			menu.addingFleet = nil
		end
	else
		-- reset if the editor is opened
		C.ResetCustomGameStart(menu.customgamestart)
	end

	menu.initEncyclopediaValue()
	menu.initKnownValue()
	menu.initStoryValue()
	menu.initSatellites()
	menu.initFactions()

	menu.usedlimitedships = {}
	local buf = ffi.new("CustomGameStartStringPropertyState[1]")
	local playershipmacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "ship", buf))
	local ware = GetMacroData(playershipmacro, "ware")
	local islimited = GetWareData(ware, "islimited")
	if islimited then
		menu.usedlimitedships[playershipmacro] = (menu.usedlimitedships[playershipmacro] or 0) + 1
	end

	local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
	if state.numvalues > 0 then
		local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
		local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
		if n > 0 then
			local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
			for i = 0, n - 1 do
				buf[i].numcargo = counts[i].numcargo
				buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
			end
			n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
			for i = 0, n - 1 do
				local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, "playerproperty", ffi.string(buf[i].id)))
				if sector ~= "" then
					menu.setKnownValue("playerknownspace", sector, true)
				end
				local type = ffi.string(buf[i].type)
				if type == "ship" then
					local macro = ffi.string(buf[i].macroname)
					local ware = GetMacroData(macro, "ware")
					local islimited = GetWareData(ware, "islimited")
					if islimited then
						menu.usedlimitedships[macro] = (menu.usedlimitedships[macro] or 0) + buf[i].count
					end
				end
			end
		end
	end
	menu.saveKnownValue("playerknownspace")

	menu.display()
end


function menu.onSaveState()
	local state = {}

	state.topRows = {}
	state.selectedRows = {}
	state.selectedCols = {}
	state.topRows.categoryTable = GetTopRow(menu.categoryTable.id)
	state.selectedRows.categoryTable = Helper.currentTableRow[menu.categoryTable.id]
	if menu.propertyTable then
		state.topRows.propertyTable = GetTopRow(menu.propertyTable.id)
		state.selectedRows.propertyTable = menu.selectedRows.propertyTable or Helper.currentTableRow[menu.propertyTable.id]
		state.selectedCols.propertyTable = menu.selectedCols.propertyTable
	end

	state.category = menu.category.id

	for _, key in ipairs(config.stateKeys) do
		state[key[1]] = menu[key[1]]
	end
	return state
end

function menu.onRestoreState(state)
	menu.topRows.categoryTable = state.topRows.categoryTable
	menu.selectedRows.categoryTable = state.selectedRows.categoryTable
	menu.topRows.propertyTable = state.topRows.propertyTable
	menu.selectedRows.propertyTable = state.selectedRows.propertyTable
	menu.selectedCols.propertyTable = state.selectedCols.propertyTable

	for _, category in ipairs(config.categories) do
		if category.id == state.category then
			menu.setCategory(category)
		end
	end

	for _, key in ipairs(config.stateKeys) do
		if key[2] == "bool" then
			if type(state[key[1]]) == "number" then
				menu[key[1]] = state[key[1]] ~= 0
			else
				menu[key[1]] = state[key[1]]
			end
		else
			menu[key[1]] = state[key[1]]
		end
	end
end

function menu.display()
	-- kuertee start: callback
	if menu.uix_callbacks ["display_on_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_start"]) do
			uix_callback (config)
		end
	end
	-- kuertee end: callback

	-- remove old data
	Helper.clearDataForRefresh(menu, config.mainFrameLayer)

	menu.mainFrame = Helper.createFrameHandle(menu, {
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		standardButtons = {},
		layer = config.mainFrameLayer,
	})
	menu.mainFrame:setBackground("solid", { color = Color["frame_background_semitransparent"] })

	local width = math.min(0.25 * Helper.viewWidth, Helper.scaleX(800))

	menu.categoryTable = menu.mainFrame:addTable(4, { tabOrder = 2, x = Helper.scaleX(config.table.x), y = Helper.scaleY(config.table.y), width = width, reserveScrollBar = false })
	menu.categoryTable:setColWidth(1, Helper.scaleY(config.table.arrowColumnWidth), false)
	menu.categoryTable:setColWidth(3, (menu.categoryTable.properties.width - Helper.scaleY(config.table.arrowColumnWidth)) / 2 - Helper.scaleX(4 *config.standardTextHeight) - Helper.borderSize, false)
	menu.categoryTable:setColWidth(4, 4 * config.standardTextHeight)
	menu.categoryTable:setDefaultCellProperties("button", { height = config.standardTextHeight })
	menu.categoryTable:setDefaultComplexCellProperties("button", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
	menu.categoryTable:setDefaultCellProperties("dropdown", { height = config.standardTextHeight })
	menu.categoryTable:setDefaultComplexCellProperties("dropdown", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
	menu.categoryTable:setDefaultCellProperties("slidercell", { height = config.standardTextHeight })
	menu.categoryTable:setDefaultComplexCellProperties("slidercell", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })

	local row = menu.categoryTable:addRow({}, { fixed = true })
	row[1]:createButton({ height = config.headerTextHeight }):setIcon(config.backarrow, { x = config.backarrowOffsetX })
	row[1].handlers.onClick = function () return menu.closeMenu("back") end
	row[2]:setColSpan(3):createText(ReadText(1001, 9901), config.headerTextProperties)

	for _, category in ipairs(config.categories) do
		local shown = false
		if category.type == "list" then
			shown = true
		elseif category.type == "flowchart" then
			if category.id == "playerresearch" then
				local state = C.GetCustomGameStartResearchPropertyState(menu.customgamestart, category.id)
				category.state = ffi.string(state.state)
			elseif category.id == "universefactionrelations" then
				-- faction relations
				local state = C.GetCustomGameStartRelationsPropertyState(menu.customgamestart, category.id)
				category.state = ffi.string(state.state)
			end
			if category.state ~= "" then
				shown = true
			end
		elseif category.type == "property" then
			if category.id == "playerproperty" then
				local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, category.id)
				category.state = {
					state = ffi.string(state.state),
					numvalues = state.numvalues,
				}
			end
			if category.state.state ~= "" then
				shown = true
			end
		elseif category.type == "story" then
			if category.id == "universestorystates" then
				local state = C.GetCustomGameStartStoryPropertyState(menu.customgamestart, category.id)
				category.state = {
					state = ffi.string(state.state),
					numvalues = state.numvalues,
					numdefaultvalues = state.numdefaultvalues,
				}
			end
			if category.state.state ~= "" then
				shown = true
			end
		end
		if shown then
			local row = menu.categoryTable:addRow(category, {  })
			row[2]:setColSpan(category.budget and 2 or 3):createText(category.name, config.standardTextProperties)
			row[2].properties.color = function () return menu.getCategoryColor(category) end
			if category.mouseovertext then
				row[2].properties.mouseOverText = category.mouseovertext
			end
			if category.budget then
				local text, mouseovertext = "", ""
				for _, budget in ipairs(menu.budgets) do
					if type(category.budget) == "table" then
						for _, categorybudget in ipairs(category.budget) do
							if budget.id == categorybudget then
								if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, categorybudget) then
									text = text .. Helper.convertColorToText(budget.color) .. "\27[" .. budget.icon .. "]"
									if mouseovertext ~= "" then
										mouseovertext = mouseovertext .. "\n"
									end
									mouseovertext = mouseovertext .. budget.name
								end
							end
						end
					else
						if budget.id == category.budget then
							if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, category.budget) then
								row[4]:createText("\27[" .. budget.icon .. "]", { halign = "right", color = budget.color, mouseOverText = budget.name })
							end
							break
						end
					end
				end
				if text ~= "" then
					row[4]:createText(text, { halign = "right", mouseOverText = mouseovertext })
				end
			end
		end
	end

	local row = menu.categoryTable:addRow(nil, {  })
	row[2]:setColSpan(2):createText("")

	menu.availablecustomgamestarts = {}
	local n = C.GetNumAvailableCustomGameStarts(menu.customgamestart)
	local buf = ffi.new("CustomGameStartInfo[?]", n)
	n = C.GetAvailableCustomGameStarts(buf, n, menu.customgamestart)
	for i = 0, n - 1 do
		if ffi.string(buf[i].id) == menu.customgamestart then
			local filename = ffi.string(buf[i].filename)
			local name = ffi.string(buf[i].name)
			local active = true
			local mouseovertext = ""

			local content = C.GetCustomGameStartContentCounts2(menu.customgamestart, filename, menu.customgamestart)
			if not content.hasincompatibleloadout then
				local buf_content = ffi.new("CustomGameStartContentData2")
				buf_content.nummacros = content.nummacros
				buf_content.macros = Helper.ffiNewHelper("UIMacroCount[?]", content.nummacros)
				buf_content.numblueprints = content.numblueprints
				buf_content.blueprints = Helper.ffiNewHelper("const char*[?]", content.numblueprints)
				buf_content.numconstructionplans = content.numconstructionplans
				buf_content.constructionplanids = Helper.ffiNewHelper("const char*[?]", content.numconstructionplans)
				C.GetCustomGameStartContent2(buf_content, menu.customgamestart, filename, menu.customgamestart)
				-- need to cache the constructionplanids due to menu.checkConstructionPlan() in the constructionplan loop calling other ffi functions, causing the last entry in the array to break for an unknown (FFI library internal) reason
				local constructionplanids = {}
				for j = 0, buf_content.numconstructionplans - 1 do
					constructionplanids[j] = ffi.string(buf_content.constructionplanids[j])
				end
				-- macros
				local usedlimitedwares = {}
				for j = 0, buf_content.nummacros - 1 do
					local ware = GetMacroData(ffi.string(buf_content.macros[j].macro), "ware")
					if ware then
						local hasblueprint, isdeprecated, isplayerblueprintallowed, nocustomgamestart, islimited = GetWareData(ware, "hasblueprint", "isdeprecated", "isplayerblueprintallowed", "nocustomgamestart", "islimited")
						if menu.creative then
							nocustomgamestart = false
							islimited = false
						end
						if (not hasblueprint) or isdeprecated or (not isplayerblueprintallowed) or nocustomgamestart then
							active = false
							mouseovertext = ReadText(1026, 9925)
							break
						end
						if islimited then
							usedlimitedwares[ware] = (usedlimitedwares[ware] or 0) + buf_content.macros[j].amount
						end
					end
				end
				if active then
					for ware, amount in pairs(usedlimitedwares) do
						local limitamount = Helper.getLimitedWareAmount(ware)
						if amount > limitamount then
							active = false
							mouseovertext = ReadText(1026, 9930)
							break
						end
					end
				end
				-- blueprints
				if active then
					for j = 0, buf_content.numblueprints - 1 do
						local ware = ffi.string(buf_content.blueprints[j])
						local hasblueprint, isdeprecated, isplayerblueprintallowed, nocustomgamestart, blueprintsowners, ismissiononly = GetWareData(ware, "hasblueprint", "isdeprecated", "isplayerblueprintallowed", "nocustomgamestart", "blueprintsowners", "ismissiononly")
						if menu.creative then
							nocustomgamestart = false
						end
						local isventure = false
						for i, owner in ipairs(blueprintsowners or {}) do
							if owner == "visitor" then
								isventure = true
								break
							end
						end
						if (not hasblueprint) or isdeprecated or (not isplayerblueprintallowed) or nocustomgamestart or isventure or ismissiononly then
							active = false
							mouseovertext = ReadText(1026, 9926)
							break
						end
					end
				end
				-- cps
				if active then

					local onlineitems = OnlineGetUserItems()

					-- kuertee start:
					if not onlineitems then
						onlineitems = {}
					end
					-- kuertee end

					local limitedmodulesused = {}
					for j = 0, buf_content.numconstructionplans - 1 do
						local source, constructionplanid, isHQ = string.match(constructionplanids[j], "(.*):(.*):(%d)")
						if not menu.checkConstructionPlan(source, constructionplanid, limitedmodulesused, onlineitems, tonumber(isHQ) == 1) then
							active = false
							mouseovertext = ReadText(1026, 9927)
							break
						end
					end
				end
			else
				active = false
				mouseovertext = ReadText(1026, 9924)
			end

			table.insert(menu.availablecustomgamestarts, { id = filename, text = name, icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
		end
	end

	local row = menu.categoryTable:addRow(true, {  })
	row[2]:createDropDown(menu.availablecustomgamestarts, { textOverride = ReadText(1001, 9945), optionWidth = width - Helper.scaleY(config.table.arrowColumnWidth) - Helper.borderSize, scaling = false, height = Helper.scaleY(config.standardTextHeight), active = #menu.availablecustomgamestarts > 0 }):setTextProperties({ halign = "center", scaling = true })
	row[2].handlers.onDropDownConfirmed = function(_, id) return menu.dropdownImport(id) end
	row[3]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9946), { halign = "center" })
	row[3].handlers.onClick = function () return menu.buttonExport(false) end

	menu.exportButtonPos = { x = menu.categoryTable.properties.x + row[1]:getWidth() + row[2]:getWidth() + 2 * Helper.borderSize, y = menu.categoryTable.properties.y + menu.categoryTable:getFullHeight() }

	local row = menu.categoryTable:addRow(true, {  })
	row[2]:createButton({ active = function () return menu.creative or (not C.IsGameStartModified(menu.customgamestart)) end, mouseOverText = function () return C.IsGameStartModified(menu.customgamestart) and (menu.creative and ReadText(1026, 9904) or ReadText(1026, 9905)) or "" end }):setText(function () return (menu.creative and C.IsGameStartModified(menu.customgamestart)) and ReadText(1001, 9905) or ReadText(1001, 9902) end, { halign = "center", color = function () return C.IsGameStartModified(menu.customgamestart) and Color["text_warning"] or Color["text_normal"] end })
	row[2].handlers.onClick = menu.buttonNewGame
	row[3]:setColSpan(2):createButton({  }):setText(ReadText(1001, 9904), { halign = "center" })
	row[3].handlers.onClick = menu.buttonReset

	-- kuertee start: callback
	if menu.uix_callbacks ["display_on_after_main_options"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_main_options"]) do
			uix_callback ()
		end
	end
	-- kuertee end: callback

	menu.categoryTable:setTopRow(menu.topRows.categoryTable)
	menu.categoryTable:setSelectedRow(menu.selectedRows.categoryTable)
	menu.topRows.categoryTable = nil
	menu.selectedRows.categoryTable = nil

	local maxdetails, hasanybudget = menu.updateBudgets()
	maxdetails = math.min(config.maxBudgetDetails, maxdetails)

	local budgetTableHeight = Helper.scaleY(config.budgetheight)
	local budgetTableWidth = math.min(Helper.viewWidth, 2 * #menu.budgets * (Helper.scaleX(config.budgetwidth) + Helper.borderSize) - Helper.borderSize)
	local yoffset = Helper.viewHeight - Helper.frameBorder
	if hasanybudget then
		yoffset = yoffset - budgetTableHeight
	end
	menu.budgetTable = menu.mainFrame:addTable(2 * #menu.budgets, { tabOrder = 20, x = (Helper.viewWidth - budgetTableWidth) / 2, y = yoffset, width = budgetTableWidth })
	menu.budgetTable:setDefaultCellProperties("button", { height = config.standardTextHeight })
	menu.budgetTable:setDefaultComplexCellProperties("button", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })

	if hasanybudget then
		local row = menu.budgetTable:addRow(nil, { fixed = true })
		row[1]:setColSpan(2 * #menu.budgets):createText(ReadText(1001, 9922), config.headerTextProperties)
		row[1].properties.halign = "center"

		local rows = {}
		for i = 1, maxdetails + 2 do
			rows[i] = menu.budgetTable:addRow(true, { fixed = true })
		end
		for i, budget in ipairs(menu.budgets) do
			if not budget.inactive then
				if budget.type then
					rows[1][2 * i - 1]:setColSpan(2):createText(function () return menu.budgetHeaderName(budget.id) end, config.subHeaderTextProperties)
					rows[1][2 * i - 1].properties.halign = "left"
					rows[1][2 * i - 1].properties.mouseOverText = budget.desc
				else
					rows[1][2 * i - 1]:setBackgroundColSpan(2):createText(function () return menu.budgetHeaderName(budget.id) end, config.subHeaderTextProperties)
					rows[1][2 * i - 1].properties.halign = "left"
					rows[1][2 * i - 1].properties.mouseOverText = budget.desc
					rows[1][2 * i]:createText(function () return menu.budgetHeaderText(budget.id) end, config.subHeaderTextProperties)
					rows[1][2 * i].properties.halign = "right"
					rows[1][2 * i].properties.mouseOverText = budget.desc
				end

				for j, detail in ipairs(budget.details) do
					if (j <= maxdetails - 1) or (j == #budget.details) then
						if budget.type then
							rows[j + 1][2 * i - 1]:setColSpan(2):createText(menu.storiesbyid[detail.property] and menu.storiesbyid[detail.property].name or detail.property)
						else
							rows[j + 1][2 * i - 1]:createText(menu.findPropertyName(detail.property))
							rows[j + 1][2 * i]:createText(function () menu.updateBudgets(); return ConvertIntegerString(menu.propertybudgets[budget.id .. detail.property], true, 3, true) .. budget.suffix end, { halign = "right" })
						end
					else
						rows[j + 1][2 * i - 1]:setColSpan(2):createText("[...]")
						break
					end
				end

				rows[#rows][2 * i]:createButton({  }):setText(ReadText(1001, 9950), { halign = "center" })
				rows[#rows][2 * i].handlers.onClick = function () return menu.buttonResetBudget(budget.id) end
			end
		end
	end

	local offsetx = menu.categoryTable.properties.x + menu.categoryTable.properties.width + 2 * Helper.borderSize
	local width = menu.width / 2 - 4 * Helper.borderSize
	if menu.category.type == "flowchart" then
		width = width + menu.width / 4
	end
	width = math.min(width, Helper.scaleX(1600))
	if hasanybudget then
		local budgetTableRightBorder = menu.budgetTable.properties.x + menu.budgetTable.properties.width
		if budgetTableRightBorder < 0.75 * Helper.viewWidth then
			width = budgetTableRightBorder - offsetx
		end
	end

	menu.propertyTable = {}
	if next(menu.category) then
		local offsety = Helper.scaleY(config.table.y)
		local numCols = ((menu.category.type == "property") or (menu.category.type == "story")) and 4 or 5
		menu.propertyTable = menu.mainFrame:addTable(numCols, { tabOrder = 1, x = offsetx, y = offsety, width = width, maxVisibleHeight = menu.budgetTable.properties.y - Helper.borderSize - offsety, defaultInteractiveObject = true, highlightMode = "column" })
		if menu.category.type == "property" then
			menu.propertyTable:setColWidth(1, config.standardTextHeight)
			menu.propertyTable:setColWidthPercent(2, 45)
			menu.propertyTable:setColWidth(4, config.standardTextHeight)
		elseif menu.category.type == "story" then
			menu.propertyTable:setColWidth(1, config.standardTextHeight)
			menu.propertyTable:setColWidthPercent(2, 35)
			menu.propertyTable:setColWidth(4, config.standardTextHeight)
		else
			menu.propertyTable:setColWidthPercent(1, 30)
			menu.propertyTable:setColWidth(2, 4 * config.standardTextHeight)
			menu.propertyTable:setColWidth(3, config.standardTextHeight)
			menu.propertyTable:setColWidth(5, config.standardTextHeight)

			menu.propertyTable:setDefaultColSpan(3, 3)
		end
		menu.propertyTable:setDefaultCellProperties("text", { minRowHeight = config.standardTextHeight, fontsize = config.standardFontSize })
		menu.propertyTable:setDefaultCellProperties("button", { height = config.standardTextHeight })
		menu.propertyTable:setDefaultComplexCellProperties("button", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
		menu.propertyTable:setDefaultComplexCellProperties("button", "text2", { x = config.standardTextOffsetX, fontsize = config.standardFontSize, halign = "right" })
		menu.propertyTable:setDefaultCellProperties("dropdown", { height = config.standardTextHeight })
		menu.propertyTable:setDefaultComplexCellProperties("dropdown", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
		menu.propertyTable:setDefaultComplexCellProperties("dropdown", "text2", { x = config.standardTextOffsetX, fontsize = config.standardFontSize, halign = "right" })
		menu.propertyTable:setDefaultCellProperties("slidercell", { height = config.standardTextHeight })
		menu.propertyTable:setDefaultComplexCellProperties("slidercell", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })

		local row = menu.propertyTable:addRow(nil, { fixed = true })
		row[1]:setColSpan(numCols):createText(menu.category.name, config.headerTextProperties)

		-- kuertee start: callback
		if menu.uix_callbacks ["display_on_after_category_name"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_category_name"]) do
				uix_callback (numCols)
			end
		end
		-- kuertee end: callback

		if menu.category.type == "list" then
			for _, property in ipairs(menu.category.properties) do
				local minvalue, maxvalue, options
				if property.getState then
					menu.initPropertyValue(property)
				elseif property.propertyType == "Internal" then
					property.value = property.get()
				elseif property.get then
					local buf = ffi.new("CustomGameStart" .. property.propertyType .. "PropertyState[1]")
					property.value = property.get(menu.customgamestart, property.id, buf)
					property.state = ffi.string(buf[0].state)
					property.defaultvalue = buf[0].defaultvalue
					if property.propertyType == "String" then
						property.value = ffi.string(property.value)
						property.defaultvalue = ffi.string(property.defaultvalue)
						options = ffi.string(buf[0].options)
					elseif property.propertyType == "Money" then
						property.value = tonumber(property.value)
						property.defaultvalue = tonumber(property.defaultvalue)
						minvalue = buf[0].minvalue
						maxvalue = buf[0].maxvalue
					end
				end

				if property.name and (property.state ~= "") then
					local row = menu.propertyTable:addRow(property, {  })
					local propertyname = property.name .. (((not menu.creative) and (property.state == "modified")) and (" [" .. ReadText(1001, 9903) .. "]") or "")
					row[1]:setColSpan(property.budget and 1 or 2):createText(propertyname .. ReadText(1001, 120), config.standardTextProperties)
					row[1].properties.mouseOverText = property.mouseOverText
					row[1].properties.color = function () return menu.propertyColor(property) end

					-- kuertee start: callback
					if menu.uix_callbacks ["display_on_after_property_name"] then
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_property_name"]) do
							uix_callback (numCols, property)
						end
					end
					-- kuertee end: callback

					if property.budget then
						local text, mouseovertext = "", ""
						for _, budget in ipairs(menu.budgets) do
							if type(property.budget) == "table" then
								for _, propertybudget in ipairs(property.budget) do
									if budget.id == propertybudget then
										if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, propertybudget) then
											text = text .. Helper.convertColorToText(budget.color) .. "\27[" .. budget.icon .. "]"
											if mouseovertext ~= "" then
												mouseovertext = mouseovertext .. "\n"
											end
											mouseovertext = mouseovertext .. budget.name
										end
									end
								end
							else
								if budget.id == property.budget then
									if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, property.budget) then
										row[2]:createText("\27[" .. budget.icon .. "]", { halign = "right", color = budget.color, mouseOverText = budget.name })
									end
									break
								end
							end
						end
						if text ~= "" then
							row[2]:createText(text, { halign = "right", mouseOverText = mouseovertext })
						end
					end
					if property.type == "number" then
						local scale = property.formatValue(property.value, minvalue, maxvalue)
						row[3]:createSliderCell({ min = scale.min, minSelect = scale.minSelect, max = scale.max, maxSelect = scale.maxSelect, start = scale.start, step = scale.step, suffix = scale.suffix, exceedMaxValue = scale.exceedMaxValue, hideMaxValue = scale.hideMaxValue, readOnly = scale.readOnly, accuracyOverride = 0 })
						row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellNumberProperty(property, row.index, value) end
					elseif property.type == "dropdown" then
						local options, currentOption = property.formatValue(property.value, options)
						menu.curDropDownOption[property.id] = tostring(currentOption)
						row[3]:createDropDown(options, { startOption = currentOption })
						row[3].handlers.onDropDownConfirmed = function(_, id) return menu.dropdownProperty(property, row.index, id) end
						row[3].handlers.onDropDownActivated = function(_, id) return menu.onPropertyDropDownActivated(property, row.index, id) end
					elseif property.type == "editbox" then
						row[3]:createEditBox({ description = propertyname, active = property.active }):setText(property.value, { fontsize = config.standardFontSize })
						row[3].handlers.onTextChanged = function(_, text) return menu.editboxProperty(property, text) end
					elseif property.type == "bool" then
						row[3]:createButton({ active = property.active }):setText(function () return property.value and ReadText(1001, 2617) or ReadText(1001, 2618) end)
						row[3].handlers.onClick = function() return menu.buttonBoolProperty(property) end
					elseif property.type == "button" then
						local text = property.formatValue(property.value)
						row[3]:createButton({ active = property.active }):setText(text, { halign = "center" })
						row[3].handlers.onClick = property.set
					elseif property.type == "multiselectslider" then
						for i, entry in ipairs(property.value) do
							if i ~= 1 then
								row = menu.propertyTable:addRow(property, {  })
							end
							local name = entry.name

							local budgetsuffix = menu.getBudgetSuffix(property.budget)
							if property.propertyType == "Inventory" then
								name = name .. (budgetsuffix and (" (" .. ConvertIntegerString(GetWareData(entry.id, "avgprice"), true, 3, true) .. budgetsuffix .. ")") or "")
							end

							row[3]:createSliderCell({ min = 0, max = 10000, start = entry.amount, step = 1, hideMaxValue = true }):setText(name, { color = (entry.amount ~= entry.defaultamount) and Color["customgamestart_property_changed"] or Color["text_normal"] })
							row[3].handlers.onSliderCellChanged = function (_, value) return menu.slidercellMultiSelect(property, entry.id, row.index, value) end
							row[3].handlers.onSliderCellConfirm = function () menu.refresh = getElapsedTime() end
						end
						if #property.value > 0 then
							row = menu.propertyTable:addRow(property, {  })
						end
						local text = property.formatValue(#property.value)
						row[3]:createButton({  }):setText(text, { halign = "center" })
						row[3].handlers.onClick = function () return menu.displayMultiSelection(property) end
					elseif property.type == "multiselect" then
						for i, entry in ipairs(property.value) do
							if i ~= 1 then
								row = menu.propertyTable:addRow(property, {  })
							end
							
							if property.id == "playerknownspace" then
								row[3]:setColSpan(1):createButton({ helpOverlayID = "knownsector_expand", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.expandedProperty["knownsector_" .. entry.id] and "-" or "+", { halign = "center", x = 0 })
								row[3].handlers.onClick = function () return menu.buttonExpandProperty("knownsector_" .. entry.id) end
								row[4]:setColSpan(2):createText(function () return menu.getMultiSelectEntryName(property, entry) end, { color = (not entry.default) and Color["customgamestart_property_changed"] or Color["text_normal"] })
								if menu.expandedProperty["knownsector_" .. entry.id] then
									local budgetsuffix = menu.getBudgetSuffix("known")
									local checked, budgetvalue = menu.getKnownValue("playerknownobjects", entry.id)
									local row = menu.propertyTable:addRow(property, {  })
									row[3]:setColSpan(1)
									row[4]:setColSpan(1):createText(ReadText(1001, 9937) .. (budgetsuffix and (" (" .. ConvertIntegerString(checked and budgetvalue or 0, true, 3, true) .. budgetsuffix .. ")") or "") .. ReadText(1001, 120), { x = config.standardTextHeight })
									row[5]:createCheckBox(checked, { mouseOverText = ReadText(1026, 9903) })
									row[5].handlers.onClick = function (_, checked) return menu.checkboxKnownStations(entry.id, checked) end

									local budgetsuffix = menu.getBudgetSuffix("money")
									local row = menu.propertyTable:addRow(property, {  })
									row[3]:setColSpan(1)
									row[4]:setColSpan(1):createText(ReadText(1001, 9936) .. (budgetsuffix and (" (" .. ConvertIntegerString(menu.satellites[entry.id] and menu.satellites[entry.id].totalvalue or 0, true, 3, true) .. budgetsuffix .. ")") or "") .. ReadText(1001, 120), { x = config.standardTextHeight })
									row[5]:createCheckBox(menu.satellites[entry.id] ~= nil)
									row[5].handlers.onClick = function (_, checked) return menu.checkboxSatelliteCoverage(entry.id, checked) end
								end
							else
								row[3]:createText(function () return menu.getMultiSelectEntryName(property, entry) end, { color = (not entry.default) and Color["customgamestart_property_changed"] or Color["text_normal"] })
							end
						end
						if #property.value > 0 then
							row = menu.propertyTable:addRow(property, {  })
						end
						local text = property.formatValue(#property.value)
						row[3]:createButton({  }):setText(text, { halign = "center" })
						row[3].handlers.onClick = function () return menu.displayMultiSelection(property) end
					end
				end
			end

			menu.propertyTable:setTopRow(menu.topRows.propertyTable)
			menu.propertyTable:setSelectedRow(menu.selectedRows.propertyTable)
		elseif menu.category.type == "flowchart" then
			if menu.category.id == "playerresearch" then
				menu.category.value = {}
				local n = C.GetCustomGameStartResearchPropertyCounts(menu.customgamestart, menu.category.id)
				local buf = ffi.new("const char*[?]", n)
				n = C.GetCustomGameStartResearchProperty(buf, n, menu.customgamestart, menu.category.id)
				for i = 0, n - 1 do
					menu.category.value[ffi.string(buf[i])] = true
				end
			elseif menu.category.id == "universefactionrelations" then
				menu.category.value = {}
				local n = C.GetCustomGameStartRelationsPropertyCounts(menu.customgamestart, menu.category.id)
				local buf = ffi.new("CustomGameStartRelationInfo[?]", n)
				n = C.GetCustomGameStartRelationsProperty(buf, n, menu.customgamestart, menu.category.id)
				for i = 0, n - 1 do
					menu.setFactionRelation(menu.category.value, ffi.string(buf[i].factionid), ffi.string(buf[i].otherfactionid), buf[i].relation)
				end
			end

			Helper.clearDataForRefresh(menu, config.expandedMenuFrameLayer)

			menu.flowchartRows = 0
			menu.flowchartCols = 0
			if menu.category.id == "playerresearch" then
				local lastsortorder = 0
				for i, mainentry in ipairs(menu.techtree) do
					if (menu.flowchartRows ~= 0) and (math.floor(mainentry[1][1].sortorder / 100) ~= math.floor(lastsortorder / 100)) then
						menu.flowchartRows = menu.flowchartRows + 1
					end
					lastsortorder = mainentry[1][1].sortorder

					menu.flowchartCols = math.max(menu.flowchartCols, #mainentry)
					local maxRows = 0
					for col, columnentry in ipairs(mainentry) do
						maxRows = math.max(maxRows, #columnentry)
						table.sort(columnentry, menu.sortTechName)
					end

					menu.flowchartRows = menu.flowchartRows + maxRows
				end
			elseif menu.category.id == "universefactionrelations" then
				local count = 0
				for _, entry in ipairs(menu.factions) do
					local allowedbystory = false
					if config.factionrelationsallowedbystory[entry.id] then
						for groupid, storyentry in pairs(menu.stories) do
							if config.factionrelationsallowedbystory[entry.id][storyentry.currentstory] then
								allowedbystory = true
								break
							end
						end
					end

					if menu.creative or ((not entry.isrelationlocked) or allowedbystory) then
						count = count + 1
					end
				end

				menu.flowchartRows = math.max(1, count - 1)
				menu.flowchartCols = 3
			end

			local xoffset = menu.categoryTable.properties.x + menu.categoryTable.properties.width + 2 * Helper.borderSize
			local yoffset = menu.propertyTable.properties.y + menu.propertyTable:getFullHeight() + 2 * Helper.borderSize
			local width = 3 * menu.width / 4 - 4 * Helper.borderSize
			local height = menu.budgetTable.properties.y - Helper.borderSize - yoffset
			menu.flowchart = menu.mainFrame:addFlowchart(menu.flowchartRows, menu.flowchartCols, { minRowHeight = 45, minColWidth = config.nodewidth, x = xoffset, y = yoffset, width = width, maxVisibleHeight = height })
			menu.flowchart:setDefaultNodeProperties({
				expandedFrameLayer = config.expandedMenuFrameLayer,
				expandedTableNumColumns = 2,
				x = config.nodeoffsetx,
				width = config.nodewidth,
			})
			if menu.category.id == "playerresearch" then
				for col = 2, menu.flowchartCols, 2 do
					menu.flowchart:setColBackgroundColor(col, Color["row_title"])
				end
			end

			if menu.category.id == "playerresearch" then
				local rowCounter = 1
				local lastsortorder = 0
				for i, mainentry in ipairs(menu.techtree) do
					if (rowCounter ~= 1) and (math.floor(mainentry[1][1].sortorder / 100) ~= math.floor(lastsortorder / 100)) then
						rowCounter = rowCounter + 1
					end
					lastsortorder = mainentry[1][1].sortorder

					local maxRows = 0
					for col, columnentry in ipairs(mainentry) do
						maxRows = math.max(maxRows, #columnentry)
						for j, techentry in ipairs(columnentry) do
							local value, max = 0, 100
							if techentry.completed then
								value = 100
							end
							local color
							if not techentry.completed then
								color = Color["lso_node_inactive"]
							end
							techentry.node = menu.flowchart:addNode(rowCounter + j - 1, col, { data = { mainIdx = i, col = col, techdata = techentry }, expandHandler = menu.expandNodeResearch }, { shape = "stadium", value = value, max = max }):setText(GetWareData(techentry.tech, "name"))
							techentry.node.properties.outlineColor = color
							techentry.node.properties.text.color = (techentry.completed == techentry.origCompleted) and color or Color["customgamestart_property_changed"]

							techentry.node.handlers.onExpanded = menu.onFlowchartNodeExpanded
							techentry.node.handlers.onCollapsed = menu.onFlowchartNodeCollapsed

							if menu.restoreNodeTech and menu.restoreNodeTech == techentry.tech then
								menu.restoreNode = techentry.node
								menu.restoreNodeTech = nil
							end

							if col > 1 then
								for k, previousentry in ipairs(mainentry[col - 1]) do
									-- print("adding edge from node " .. previousentry.tech .. " to " .. techentry.tech)
									local edge = previousentry.node:addEdgeTo(techentry.node)
									if not previousentry.completed then
										edge.properties.sourceSlotColor = Color["lso_node_inactive"]
										edge.properties.color = Color["lso_node_inactive"]
									end
									edge.properties.destSlotColor = color
								end
							end
						end
					end

					local skiprow = false
					if math.floor(mainentry[1][1].sortorder / 100) ~= math.floor(lastsortorder / 100) then
						lastsortorder = mainentry[1][1].sortorder
						skiprow = true
					end

					rowCounter = rowCounter + maxRows
				end
			elseif menu.category.id == "universefactionrelations" then
				local name = menu.currentfaction.name
				if menu.currentfaction.id == "player" then
					local buf = ffi.new("CustomGameStartStringPropertyState[1]")
					name = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playername", buf))
				end
				-- Disabled npc / npc relation changes for now
				local factionnode = menu.flowchart:addNode(1, 1, { data = {}, --[[expandHandler = menu.expandNodeCurrentFaction]] }, { shape = "stadium", value = 1, max = 1, expandedFrameLayer = 0 }):setText(name)
				factionnode.properties.text.color = (menu.currentfaction.id == "player") and Color["text_player"] or nil

				-- factionnode.handlers.onExpanded = menu.onFlowchartNodeExpanded
				-- factionnode.handlers.onCollapsed = menu.onFlowchartNodeCollapsed

				if menu.restoreNodeFaction and menu.restoreNodeFaction == "current" then
					menu.restoreNode = factionnode
					menu.restoreNodeFaction = nil
				end

				local row = 0
				for _, entry in ipairs(menu.currentfaction.relations) do
					local allowedbystory = false
					if config.factionrelationsallowedbystory[entry.id] then
						for groupid, storyentry in pairs(menu.stories) do
							if config.factionrelationsallowedbystory[entry.id][storyentry.currentstory] then
								allowedbystory = true
								break
							end
						end
					end

					if (entry.id ~= menu.currentfaction.id) and (menu.creative or ((not entry.isrelationlocked) or allowedbystory)) then
						row = row + 1

						local name = entry.name
						if entry.id == "player" then
							local buf = ffi.new("CustomGameStartStringPropertyState[1]")
							name = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playername", buf))
						end
						local relation = menu.category.value[menu.currentfaction.id] and menu.category.value[menu.currentfaction.id][entry.id] or entry.relation
						local relationFunction = function () return (menu.category.value and menu.category.value[menu.currentfaction.id]) and menu.category.value[menu.currentfaction.id][entry.id] or entry.relation end

						local node = menu.flowchart:addNode(row, 3, { data = { faction = entry, relation = relation, relationFunction = relationFunction, origRelation = entry.origRelation }, expandHandler = menu.expandNodeFaction }, { shape = "stadium", value = function () return relationFunction() + 30 end, max = 60 }):setText(name):setStatusText(relationFunction)
						node.properties.valueColor = (relation <= -10) and Color["text_enemy"] or nil
						node.properties.outlineColor = (relation <= -10) and Color["text_enemy"] or nil
						node.properties.text.color = (entry.id == "player") and Color["text_player"] or nil
						node.properties.statustext.color = (relation ~= entry.origRelation) and Color["customgamestart_property_changed"] or nil

						node.handlers.onExpanded = menu.onFlowchartNodeExpanded
						node.handlers.onCollapsed = menu.onFlowchartNodeCollapsed

						if menu.restoreNodeFaction and menu.restoreNodeFaction == entry.id then
							menu.restoreNode = node
							menu.restoreNodeFaction = nil
						end

						local edge = factionnode:addEdgeTo(node)
						if relation <= -10 then
							edge.properties.destSlotColor = Color["text_enemy"]
							edge.properties.color = Color["text_enemy"]
						end
					end
				end
			end

			menu.restoreFlowchartState("flowchart", menu.flowchart)
		elseif menu.category.type == "property" then
			if menu.category.id == "playerproperty" then
				local limitedmodulesused = {}

				local stationdata = {}
				local fleetdata = {}
				menu.subordinates = {}
				if menu.category.state.numvalues > 0 then
					local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", menu.category.state.numvalues)
					local n = C.GetCustomGameStartPlayerPropertyCounts(counts, menu.category.state.numvalues, menu.customgamestart, menu.category.id)
					if n > 0 then
						local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
						for i = 0, n - 1 do
							buf[i].numcargo = counts[i].numcargo
							buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
						end
						n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, menu.category.id)
						for i = 0, n - 1 do
							local id = ffi.string(buf[i].id)
							local entry = {
								type = ffi.string(buf[i].type),
								id = id,
								macro = ffi.string(buf[i].macroname),
								name = ffi.string(buf[i].name),
								commanderid = ffi.string(buf[i].commanderid),
								constructionplanid = ffi.string(buf[i].constructionplanid),
								peopledef = ffi.string(buf[i].peopledefid),
								peoplefillpercentage = buf[i].peoplefillpercentage,
								sector = ffi.string(buf[i].sector),
								offset = { x = buf[i].offset.x, y = buf[i].offset.y, z = buf[i].offset.z, yaw = buf[i].offset.yaw, pitch = buf[i].offset.pitch, roll = buf[i].offset.roll },
								count = buf[i].count,
								budgetvalue = {
									money = tonumber(C.GetCustomGameStartPlayerPropertyValue(menu.customgamestart, "playerproperty", id)),
									people = tonumber(C.GetCustomGameStartPlayerPropertyPeopleValue(menu.customgamestart, "playerproperty", id)),
								},
							}

							if entry.commanderid ~= "" then
								if menu.subordinates[entry.commanderid] then
									table.insert(menu.subordinates[entry.commanderid], entry)
								else
									menu.subordinates[entry.commanderid] = { entry }
								end
							else
								if entry.type == "station" then
									local num_modules = C.GetNumPlannedLimitedModules(entry.constructionplanid)
									local buf_modules = ffi.new("UIMacroCount[?]", num_modules)
									num_modules = C.GetPlannedLimitedModules(buf_modules, num_modules, entry.constructionplanid)
									for j = 0, num_modules - 1 do
										local macro = ffi.string(buf_modules[j].macro)
										limitedmodulesused[macro] = (limitedmodulesused[macro] or 0) + buf_modules[j].amount
									end

									table.insert(stationdata, entry)
								elseif entry.type == "ship" then
									table.insert(fleetdata, entry)
								end
							end
						end
					end
				end

				local onlineitems = OnlineGetUserItems()

				-- kuertee start:
				if not onlineitems then
					onlineitems = {}
				end
				-- kuertee end

				-- stations
				menu.constructionplans = {}
				menu.hqconstructionplans = {}
				local n = C.GetNumConstructionPlans()
				local buf = ffi.new("UIConstructionPlan[?]", n)
				n = C.GetConstructionPlans(buf, n)
				local ischeatversion = IsCheatVersion()
				for i = 0, n - 1 do
					local id = ffi.string(buf[i].id)
					local source = ffi.string(buf[i].source)
					if (source == "local") or C.IsConstructionPlanAvailableInCustomGameStart(id) or ischeatversion then
						local isvalid, exceedslimitedmodules, hasexcludedmacros = true, false, false
						local mouseovertext
						local numinvalidpatches = ffi.new("uint32_t[?]", 1)
						if not C.IsConstructionPlanValid(id, numinvalidpatches) then
							isvalid = false
							local numpatches = numinvalidpatches[0]
							local patchbuf = ffi.new("InvalidPatchInfo[?]", numpatches)
							numpatches = C.GetConstructionPlanInvalidPatches(patchbuf, numpatches, id)
							mouseovertext = ReadText(1001, 2685) .. ReadText(1001, 120)			-- Missing, old or disabled extensions:
							for j = 0, numpatches - 1 do
								if j > 3 then
									mouseovertext = mouseovertext .. "\n- ..."
									break
								end
								mouseovertext = mouseovertext .. "\n- " .. ffi.string(patchbuf[j].name) .. " (" .. ffi.string(patchbuf[j].id) .. " - " .. ffi.string(patchbuf[j].requiredversion) .. ")"
								if patchbuf[j].state == 2 then
									mouseovertext = mouseovertext .. " " .. ReadText(1001, 2686)
								elseif patchbuf[j].state == 3 then
									mouseovertext = mouseovertext .. " " .. ReadText(1001, 2687)
								elseif patchbuf[j].state == 4 then
									mouseovertext = mouseovertext .. " " .. string.format(ReadText(1001, 2688), ffi.string(patchbuf[j].installedversion))
								end
							end
						elseif not C.AreConstructionPlanLoadoutsCompatible(id) then
							isvalid = false
							mouseovertext = ReadText(1026, 7929)
						end

						local limitedmodulestext = ""
						local limitedventuremodulestext = ""
						local num_modules = C.GetNumPlannedLimitedModules(id)
						local buf_modules = ffi.new("UIMacroCount[?]", num_modules)
						num_modules = C.GetPlannedLimitedModules(buf_modules, num_modules, id)
						for j = 0, num_modules - 1 do
							local macro = ffi.string(buf_modules[j].macro)
							local ware = GetMacroData(macro, "ware")
							local islimited = GetWareData(ware, "islimited")
							if islimited then
								if (limitedmodulesused[macro] or 0) + buf_modules[j].amount > Helper.getLimitedWareAmount(ware) then
									exceedslimitedmodules = true
									limitedmodulestext = limitedmodulestext .. "\n- " .. GetMacroData(macro, "name")
								end
							else
								if (limitedmodulesused[macro] or 0) + buf_modules[j].amount > (onlineitems[ware] and onlineitems[ware].amount or 0) then
									exceedslimitedmodules = true
									limitedventuremodulestext = limitedventuremodulestext .. "\n- " .. GetMacroData(macro, "name")
								end
							end
						end
						if limitedmodulestext ~= "" then
							if mouseovertext then
								mouseovertext = mouseovertext .. "\n"
							else
								mouseovertext = ""
							end
							mouseovertext = mouseovertext .. ReadText(1026, 7934) .. limitedmodulestext
						end
						if limitedventuremodulestext ~= "" then
							if mouseovertext then
								mouseovertext = mouseovertext .. "\n"
							else
								mouseovertext = ""
							end
							mouseovertext = mouseovertext .. ReadText(1026, 7915) .. limitedventuremodulestext
						end

						local excludedmacrosmouseovertext = ""
						local foundmacros = {}
						for _, macro in ipairs(config.excludedmodules) do
							local hasmacro = Helper.textArrayHelper({ macro }, function (numtexts, texts) return C.CheckConstructionPlanForMacros(id, texts, numtexts) end)
							if hasmacro then
								table.insert(foundmacros, macro)
							end
						end
						if #foundmacros > 0 then
							hasexcludedmacros = true
							if mouseovertext then
								excludedmacrosmouseovertext = "\n"
							end
							excludedmacrosmouseovertext = excludedmacrosmouseovertext .. ReadText(1026, 9902) .. ReadText(1001, 120)
							for j, macro in ipairs(foundmacros) do
								if j > 3 then
									excludedmacrosmouseovertext = excludedmacrosmouseovertext .. "\n- ..."
									break
								end
								excludedmacrosmouseovertext = excludedmacrosmouseovertext .. "\n- " .. GetMacroData(macro, "name")
							end
						end

						local blueprintcost = 0
						local blueprintproperty = menu.findProperty("playerblueprints")
						if blueprintproperty then
							menu.initPropertyValue(blueprintproperty)
							for ware in pairs(menu.getCPWares(id)) do
								local found = false
								for j, entry in ipairs(blueprintproperty.value) do
									if entry.id == ware then
										found = true
										break
									end
								end
								if not found then
									blueprintcost = blueprintcost + GetWareData(ware, "avgprice")
								end
							end
						end

						table.insert(menu.constructionplans, { id = id, text = ffi.string(buf[i].name), text2 = ConvertMoneyString(tonumber(C.GetStationValue("station_gen_factory_base_01_macro", id)) + blueprintcost, false, true, 0, true, false) .. " " .. ReadText(1001, 101), icon = "", displayremoveoption = false, active = isvalid and (not exceedslimitedmodules) and (not hasexcludedmacros), mouseovertext = (mouseovertext or "") .. excludedmacrosmouseovertext })
						if hasexcludedmacros then
							table.insert(menu.hqconstructionplans, { id = id, text = ffi.string(buf[i].name), text2 = ConvertMoneyString(tonumber(C.GetStationValue("station_pla_headquarters_base_01_macro", id)) + blueprintcost, false, true, 0, true, false) .. " " .. ReadText(1001, 101), icon = "", displayremoveoption = false, active = isvalid and (not exceedslimitedmodules), mouseovertext = mouseovertext })
						end
					end
				end
				table.sort(menu.constructionplans, function (a, b) return a.text < b.text end)
				table.sort(menu.hqconstructionplans, function (a, b) return a.text < b.text end)

				local row = menu.propertyTable:addRow(nil, {  })
				row[1]:setColSpan(4):createText(ReadText(1001, 4), config.subHeaderTextProperties)

				for _, entry in ipairs(stationdata) do
					menu.displayPlayerPropertyEntry(menu.propertyTable, entry, 0)
				end

				local row = menu.propertyTable:addRow(true, {  })
				row[1]:setColSpan(4):createDropDown(menu.constructionplans, { textOverride = ReadText(1001, 9921), text2Override = " " })
				row[1].handlers.onDropDownConfirmed = function(_, id) return menu.dropdownPlayerPropertyAddStation("station" .. #stationdata, id, nil, true) end
				if row.index == menu.selectedRows.propertyTable then
					menu.selectedCols.propertyTable = nil
				end

				menu.propertyTable:addEmptyRow(config.standardTextHeight / 2)

				local row = menu.propertyTable:addRow(nil, { bgColor = Color["row_background_unselectable"] })
				row[1]:setColSpan(4):createText("", { fontsize = 1, minRowHeight = 3 })

				menu.propertyTable:addEmptyRow(config.standardTextHeight / 2)

				--fleets
				local row = menu.propertyTable:addRow(nil, {  })
				row[1]:setColSpan(4):createText(ReadText(1001, 8326), config.subHeaderTextProperties)

				for _, entry in ipairs(fleetdata) do
					menu.displayPlayerPropertyEntry(menu.propertyTable, entry, 0)
				end

				local row = menu.propertyTable:addRow(true, {  })
				row[1]:setColSpan(4):createButton({  }):setText(ReadText(1001, 9918))
				row[1].handlers.onClick = function () return menu.openPlayerPropertyShipConfig(row.index, "fleet" .. #fleetdata) end
				if row.index == menu.selectedRows.propertyTable then
					menu.selectedCols.propertyTable = nil
				end

				menu.propertyTable:setTopRow(menu.topRows.propertyTable)
				menu.propertyTable:setSelectedRow(menu.selectedRows.propertyTable)
				if menu.selectedCols.propertyTable then
					menu.propertyTable:setSelectedCol(menu.selectedCols.propertyTable)
				end
			end
		elseif menu.category.type == "story" then
			if menu.category.id == "universestorystates" then
				local currentstories = {}
				local buf = ffi.new("const char*[?]", menu.category.state.numvalues)
				local n = C.GetCustomGameStartStoryProperty(buf, menu.category.state.numvalues, menu.customgamestart, menu.category.id)
				for i = 0, n - 1 do
					local storyid = ffi.string(buf[i])
					currentstories[storyid] = true
				end

				local defaultstories = {}
				local buf = ffi.new("const char*[?]", menu.category.state.numdefaultvalues)
				local n = C.GetCustomGameStartStoryDefaultProperty(buf, menu.category.state.numdefaultvalues, menu.customgamestart, menu.category.id)
				for i = 0, n - 1 do
					local storyid = ffi.string(buf[i])
					defaultstories[storyid] = true
				end

				for groupid, storyentry in pairs(menu.stories) do
					if groupid ~= "research" then
						for _, story in ipairs(storyentry.entries) do
							if currentstories[story.id] then
								menu.stories[groupid].currentstory = story.id
							end
							if defaultstories[story.id] then
								menu.stories[groupid].defaultstory = story.id
							end
						end
					end
				end

				local lockedStories = menu.getLockedStories()

				local row = menu.propertyTable:addRow(true, {  })
				row[1]:createCheckBox(menu.hidestoryspoilers)
				row[1].handlers.onClick = function (_, checked) menu.hidestoryspoilers = checked; menu.refreshMenu() end
				row[2]:setColSpan(3):createText(ReadText(1001, 9933), config.standardTextProperties)

				menu.propertyTable:addEmptyRow(config.standardTextHeight / 2)

				for _, groupid in ipairs(menu.storygroups) do
					local groupinfo = C.GetCustomGameStartBudgetGroupInfo(menu.customgamestart, groupid)
					if (not groupinfo.isresearch) and menu.stories[groupid] then
						local entry = menu.stories[groupid]
						local row = menu.propertyTable:addRow(true, {  })
						row[1]:setColSpan(2):createText(ffi.string(groupinfo.name), config.standardTextProperties)
						row[1].properties.mouseOverText = ffi.string(groupinfo.description)
						row[1].properties.color = (entry.currentstory ~= entry.defaultstory) and Color["customgamestart_property_changed"] or nil

						local startoption = entry.currentstory

						local islocked = false
						if lockedStories[startoption] then
							-- The current option is locked. Flag this dropdown to be locked and make all options inactive which are not locked
							islocked = true
						end

						local storyoptions = {}
						table.sort(entry.entries, function (a, b) return a.index < b.index end)
						for _, story in ipairs(entry.entries) do
							local ismodifying = (story.budgetvalue == 0) or menu.creative
							local hidden = (story.budgetvalue == 0) and menu.hidestoryspoilers
							local active = true
							local mouseovertext = story.description
							if not hidden then
								if next(story.dependencies) then
									for _, dependencylist in ipairs(story.dependencies) do
										local found = false
										local missingdependencies = ""
										for _, dependency in ipairs(dependencylist) do
											for _, entry in pairs(menu.stories) do
												if entry.currentstory == dependency then
													found = true
													break
												end
											end
											missingdependencies = missingdependencies .. "\n- " .. (menu.storiesbyid[dependency] and menu.storiesbyid[dependency].name or dependency)
										end
										if not found then
											mouseovertext = mouseovertext .. "\n\n" .. ReadText(1001, 9932) .. ReadText(1001, 120) .. ColorText["text_error"] .. missingdependencies .. "\27X"
											active = false
										end
									end
								end

								if active then
									-- Lock all options which are not required by the current sector selection
									if islocked and (not lockedStories[story.id]) then
										active = false
										mouseovertext = ReadText(1026, 9929)
									end
								end
							else
								active = false
								mouseovertext = ReadText(1026, 9907)
							end
							table.insert(storyoptions, { id = story.id, text = hidden and ReadText(1001, 3210) or story.name, text2 = ismodifying and ("[" .. ReadText(1001, 9903) .. "]") or "", icon = "", displayremoveoption = false, active = active, mouseovertext = mouseovertext })
						end
						table.insert(storyoptions, 1, { id = "default", text = ReadText(1001, 3231), icon = "", displayremoveoption = false, active = not islocked, mouseovertext = islocked and  ReadText(1026, 9929) or "" })

						row[3]:setColSpan(2):createDropDown(storyoptions, { startOption = (startoption and (startoption ~= "")) and startoption or "default", height = config.standardTextHeight })
						row[3].handlers.onDropDownConfirmed = function (_, storyid) return menu.dropdownStoryState(groupid, storyid) end
					end
				end

				menu.propertyTable:setTopRow(menu.topRows.propertyTable)
				menu.propertyTable:setSelectedRow(menu.selectedRows.propertyTable)
			end
		end

		-- kuertee start: callback
		if menu.uix_callbacks ["display_on_after_category_options"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["display_on_after_category_options"]) do
				uix_callback (numCols)
			end
		end
		-- kuertee end: callback

		if menu.category.rendertarget and (menu.contextMenu ~= "multiselect") then
			local offsetx = menu.propertyTable.properties.x + menu.propertyTable.properties.width + 2 * Helper.borderSize
			local offsety = Helper.scaleY(config.table.y)
			menu.renderTargetWidth = Helper.viewWidth - offsetx - Helper.frameBorder
			menu.renderTargetHeight = math.min(Helper.viewHeight - offsety - Helper.frameBorder, menu.width / 4)
			if hasanybudget then
				local budgetTableRightBorder = menu.budgetTable.properties.x + menu.budgetTable.properties.width
				if (offsetx < budgetTableRightBorder) and (offsety + menu.renderTargetHeight + Helper.borderSize > menu.budgetTable.properties.y) then
					menu.renderTargetHeight = Helper.viewHeight - menu.budgetTable.properties.y
				end
			end

			menu.rendertarget = menu.mainFrame:addRenderTarget({ width = menu.renderTargetWidth, height = menu.renderTargetHeight, x = offsetx, y = offsety, alpha = 100, clear = (menu.category.id ~= "universe") and (menu.category.id ~= "playerproperty"), startnoise = (menu.category.id == "player") and (not menu.cutsceneid) })
			menu.rendertargetLock = getElapsedTime() + 0.1
		end
	end
	menu.topRows.propertyTable = nil
	menu.selectedRows.propertyTable = nil
	menu.selectedCols.propertyTable = nil

	menu.mainFrame:display()
end

function menu.getLockedStories()
	local lockedStories = {}

	local buf = ffi.new("CustomGameStartStringPropertyState[1]")
	local playersectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
	menu.setStoriesLocked(lockedStories, playersectormacro)
	local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
	if state.numvalues > 0 then
		local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
		local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
		if n > 0 then
			local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
			for i = 0, n - 1 do
				buf[i].numcargo = counts[i].numcargo
				buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
			end
			n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
			for i = 0, n - 1 do
				local sector = ffi.string(C.GetCustomGameStartPlayerPropertySector(menu.customgamestart, "playerproperty", ffi.string(buf[i].id)))
				if sector ~= "" then
					menu.setStoriesLocked(lockedStories, sector)
				end
			end
		end
	end

	return lockedStories
end

function menu.setStoriesLocked(lookuptable, sector)
	local knownitem = ffi.new("CustomGameStartKnownEntry2")
	knownitem.type = Helper.ffiNewString("sector")
	knownitem.item = Helper.ffiNewString(sector)
	local sectordependencies = menu.getStoryDependencies("playerknownspace", knownitem)
	for _, dependencylist in ipairs(sectordependencies) do
		for _, dependency in ipairs(dependencylist) do
			lookuptable[dependency] = true

			-- set story dependencies of the dependency also locked
			local story = menu.storiesbyid[dependency]
			if story and next(story.dependencies) then
				for _, storydependencylist in ipairs(story.dependencies) do
					for _, storydependency in ipairs(storydependencylist) do
						lookuptable[storydependency] = true
					end
				end
			end
		end
	end
end

function menu.getBudgetSuffix(budget)
	for _, budgetentry in ipairs(menu.budgets) do
		if budgetentry.id == budget then
			if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, budget) then
				return (budgetentry.suffix ~= "") and budgetentry.suffix or (" " .. Helper.convertColorToText(budgetentry.color) .. "\27[" .. budgetentry.icon .. "]\27X")
			end
		end
	end
end

function menu.getMultiSelectEntryName(property, entry)
	local name = entry.name

	local budget = property.budget
	if type(budget) == "table" then
		for _, budgetid in ipairs(property.budget) do
			if property.propertyType == "Blueprint" then
				if budgetid == "money" then
					budget = budgetid
				end
			elseif property.propertyType == "KnownEntry2" then
				if budgetid == "known" then
					budget = budgetid
				end
			end
		end
	end

	local budgetsuffix = menu.getBudgetSuffix(budget)
	if property.propertyType == "Blueprint" then
		name = name .. (budgetsuffix and (" (" .. ConvertIntegerString(GetWareData(entry.id, "avgprice"), true, 3, true) .. budgetsuffix .. ")") or "")
	elseif property.propertyType == "KnownEntry2" then
		name = name .. (budgetsuffix and (" (" .. ConvertIntegerString(entry.budgetvalue, true, 3, true) .. budgetsuffix .. ")") or "")
	end

	return name
end

function menu.findPropertyName(propertyid)
	local name = ""
	for _, category in ipairs(config.categories) do
		if category.id == propertyid then
			name = category.name
			break
		end
		if category.properties then
			for _, property in ipairs(category.properties) do
				if property.id == propertyid then
					name = property.name
					break
				end
			end
		end
	end
	return name
end

function menu.findProperty(propertyid)
	for _, category in ipairs(config.categories) do
		if category.properties then
			for _, property in ipairs(category.properties) do
				if property.id == propertyid then
					return property
				end
			end
		end
	end
end

function menu.updateBudgets()
	local curtime = getElapsedTime()
	if curtime ~= menu.lastBudgetUpdateTime then
		menu.lastBudgetUpdateTime = curtime

		menu.maxdetails = 0
		menu.hasanybudget = false
		for i, budget in ipairs(menu.budgets) do
			if C.HasCustomGameStartBudget(menu.customgamestart, budget.id) then
				menu.hasanybudget = not menu.creative
				budget.inactive = false
				if budget.type then
					budget.details = {}
					if budget.type == "story" then
						for _, groupid in ipairs(menu.storygroups) do
						local groupinfo = C.GetCustomGameStartBudgetGroupInfo(menu.customgamestart, groupid)
						if (not groupinfo.isresearch) and menu.stories[groupid] then
							local entry = menu.stories[groupid]
							if entry.currentstory ~= "" then
									table.insert(budget.details, { property = entry.currentstory })
									menu.propertybudgets[budget.id .. entry.currentstory] = true
								end
							end
						end
					elseif budget.type == "research" then
						local sortedstories = {}
						for story in pairs(menu.researchstories) do
							table.insert(sortedstories, { id = story, name = menu.storiesbyid[story] and menu.storiesbyid[story].name or story })
						end
						table.sort(sortedstories, Helper.sortName)
						for _, story in ipairs(sortedstories) do
							table.insert(budget.details, { property = story.id })
							menu.propertybudgets[budget.id .. story.id] = true
						end
					end
					menu.maxdetails = math.max(menu.maxdetails, #budget.details)
				else
					local info = C.GetCustomGameStartBudget(menu.customgamestart, budget.id)
					budget.value = tonumber(info.value)
					budget.limit = tonumber(info.limit)
					local buf = ffi.new("CustomGameStartBudgetDetail[?]", info.numdetails)
					local n = C.GetCustomGameStartBudgetDetails(buf, info.numdetails, menu.customgamestart, budget.id)
					menu.maxdetails = math.max(menu.maxdetails, n)
					budget.details = {}
					for j = 0, n - 1 do
						local property = ffi.string(buf[j].id)
						local value = tonumber(buf[j].value)
						table.insert(budget.details, { property = property, value = value })
						menu.propertybudgets[budget.id .. property] = value
					end
				end
			else
				budget.inactive = true
			end
		end
	end
	return menu.maxdetails, menu.hasanybudget
end

function menu.budgetHeaderName(budgetid)
	menu.updateBudgets()
	for i, budget in ipairs(menu.budgets) do
		if budget.id == budgetid then
			return Helper.convertColorToText(budget.color) .. "\27[" .. budget.icon .. "]\27X " .. (menu.isBudgetOverBudget(budget) and ColorText["text_warning"] or "") .. budget.name
		end
	end
	return ""
end

function menu.budgetHeaderText(budgetid)
	menu.updateBudgets()
	for i, budget in ipairs(menu.budgets) do
		if budget.id == budgetid then
			if not budget.type then
				return (menu.isBudgetOverBudget(budget) and ColorText["text_warning"] or "") .. ConvertIntegerString(budget.value, true, 3, true) .. "\27X / " .. ConvertIntegerString(budget.limit, true, 3, true) .. budget.suffix
			end
		end
	end
	return ""
end

function menu.isBudgetIDOverBudget(budgetid)
	menu.updateBudgets()
	for i, budget in ipairs(menu.budgets) do
		if budget.id == budgetid then
			return menu.isBudgetOverBudget(budget)
		end
	end
end

function menu.isBudgetOverBudget(budget)
	if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, budget.id) then
		if budget.type then
			if budget.type == "story" then
				for groupid, entry in pairs(menu.stories) do
					if entry.currentstory ~= "" then
						local groupinfo = C.GetCustomGameStartBudgetGroupInfo(menu.customgamestart, groupid)
						if groupinfo.isresearch == (budget.type == "research") then
							local storyentry = menu.storiesbyid[entry.currentstory]
							if (storyentry and (storyentry.budgetvalue == 0)) or menu.creative then
								return true
							end
						end
					end
				end
			elseif budget.type == "research" then
				for story in pairs(menu.researchstories) do
					local storyentry = menu.storiesbyid[story]
					if (storyentry and (storyentry.budgetvalue == 0)) or menu.creative then
						return true
					end
				end
			end
			return false
		else
			return budget.value > budget.limit
		end
	end
end

function menu.getCategoryColor(category)
	local color = Color["text_normal"]
	if category.budget then
		if type(category.budget) == "table" then
			for _, categorybudget in ipairs(category.budget) do
				if menu.isBudgetIDOverBudget(categorybudget) then
					color = Color["text_warning"]
					break
				end
			end
		else
			if menu.isBudgetIDOverBudget(category.budget) then
				color = Color["text_warning"]
			end
		end
	end
	return ((not category.active) or category.active()) and color or Color["text_inactive"]
end

function menu.setStationManager(property, entryid, manager)
	local skills = {}
	for skill, value in pairs(manager.skills or {}) do
		table.insert(skills, { id = skill, value = value })
	end
	local buf = ffi.new("CustomGameStartPersonEntry")
	buf.race = Helper.ffiNewString(manager.race or "")
	buf.tags = Helper.ffiNewString(manager.tags or "")
	buf.numskills = #skills
	buf.skills = Helper.ffiNewHelper("SkillInfo[?]", buf.numskills)
	for i, entry in ipairs(skills) do
		buf.skills[i - 1].id = Helper.ffiNewString(entry.id)
		buf.skills[i - 1].value = entry.value
	end
	C.SetCustomGameStartPlayerPropertyPerson(menu.customgamestart, property, entryid, buf)
end

function menu.displayPlayerPropertyEntry(ftable, entry, iteration)
	local row = ftable:addRow(entry.id, {  })
	row[1]:createButton({ helpOverlayID = "property_expand", helpOverlayText = " ", helpOverlayHighlightOnly = true }):setText(menu.expandedProperty[entry.id] and "-" or "+", { halign = "center", x = 0 })
	row[1].handlers.onClick = function () return menu.buttonExpandProperty(entry.id) end
	local isHQentry = string.find(entry.id, "player_HQ_%d+", 1)

	local count, moneybudget, peoplebudget = menu.countPlayerProperty(entry.id, 0, entry.budgetvalue["money"], entry.budgetvalue["people"])
	local showmoney = (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, "money")
	local showpeople = (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, "people")
	local text2 = ""
	if showmoney then
		text2 = text2 .. ConvertMoneyString(moneybudget, false, true, 0, true, false) .. " " .. ReadText(1001, 101)
	end
	if showpeople then
		text2 = text2 .. ((text2 ~= "") and " - " or "") .. ConvertIntegerString(peoplebudget, true, 0, true) .. menu.getBudgetSuffix("people")
	end
	local name, ware = GetMacroData(entry.macro, "name", "ware")
	if entry.type == "ship" then
		row[2]:setColSpan(2):createButton({ x = iteration * config.standardTextHeight }):setText(name):setText2(text2)
		row[2].handlers.onClick = function () return menu.openPlayerPropertyShipConfig(row.index, entry.id, entry.macro, nil, entry.peopledef, entry.peoplefillpercentage, entry.count) end
	elseif entry.type == "station" then
		row[2]:setColSpan(2):createDropDown(isHQentry and menu.hqconstructionplans or menu.constructionplans, { startOption = entry.constructionplanid, text2Override = text2 })
		row[2].handlers.onDropDownConfirmed = function(_, id) return menu.dropdownPlayerPropertyAddStation(entry.id, id, isHQentry) end
	end

	row[4]:createButton({ active = not isHQentry }):setText("X", { halign = "center", x = 0 })
	row[4].handlers.onClick = function () return menu.buttonRemovePlayerProperty(entry.id)  end
	if menu.expandedProperty[entry.id] then
		-- name
		local row = ftable:addRow(entry.id, {  })
		row[2]:createText(ReadText(1021, 11003) .. ReadText(1001, 120), config.standardTextProperties)
		row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
		row[3]:setColSpan(2):createEditBox({ description = ReadText(1021, 11003) }):setText(entry.name, { fontsize = config.standardFontSize })
		row[3].handlers.onTextChanged = function(_, text) return menu.editboxPlayerPropertyName(entry.id, text) end
		row[3].handlers.onEditBoxDeactivated = function () menu.refresh = getElapsedTime() end
		-- sector
		local row = ftable:addRow(entry.id, {  })
		row[2]:createText(ReadText(1001, 11284) .. ReadText(1001, 120), config.standardTextProperties)
		row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local playersectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
		local options, currentOption = menu.universeSector((entry.sector ~= "") and entry.sector or playersectormacro)
		row[3]:setColSpan(2):createDropDown(options, { startOption = currentOption })
		row[3].handlers.onDropDownConfirmed = function(_, id) return menu.dropdownPlayerPropertySetSector(entry.id, id, entry.offset) end
		-- count
		if entry.type == "ship" then
			local row = ftable:addRow(entry.id, {  })
			row[2]:createText(ReadText(1001, 1202) .. ReadText(1001, 120), config.standardTextProperties)
			row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
			local options = {}
			for i = 1, 20 do
				local active = true
				local mouseovertext = ""
				local icon = ""
				if not menu.creative then
					local islimited = GetWareData(ware, "islimited")
					if islimited then
						local limitamount = Helper.getLimitedWareAmount(ware)
						if menu.usedlimitedships[entry.macro] - entry.count + i > limitamount then
							active = false
							mouseovertext = ReadText(1026, 8028)
							icon = "menu_locked"
						end
					end
				end
				table.insert(options, { id = i, text = i, icon = icon, displayremoveoption = false, active = active, mouseovertext = mouseovertext, overridecolor = (not active) and Color["text_error"] or nil })
			end
			for i = 30, 100, 10 do
				local active = true
				local mouseovertext = ""
				local icon = ""
				if not menu.creative then
					local islimited = GetWareData(ware, "islimited")
					if islimited then
						local limitamount = Helper.getLimitedWareAmount(ware)
						if menu.usedlimitedships[entry.macro] - entry.count + i > limitamount then
							active = false
							mouseovertext = ReadText(1026, 8028)
							icon = "menu_locked"
						end
					end
				end
				table.insert(options, { id = i, text = i, icon = icon, displayremoveoption = false, active = active, mouseovertext = mouseovertext, overridecolor = (not active) and Color["text_error"] or nil })
			end
			local dropdownheight = Helper.scaleY(config.standardTextHeight)
			row[3]:setColSpan(2):createDropDown(options, { startOption = entry.count }):setIconProperties({
				width = dropdownheight,
				height = dropdownheight,
				x = row[3]:getColSpanWidth() - 1.5 * dropdownheight,
				y = 0,
				scaling = false,
			})
			row[3].handlers.onDropDownConfirmed = function (_, amountstring) return menu.dropdownPlayerPropertySetCount(entry.id, tonumber(amountstring), entry.macro, entry.count) end
		end
		-- price
		if showmoney then
			local row = ftable:addRow(entry.id, {  })
			row[2]:createText(ReadText(1001, 2808) .. ReadText(1001, 120), config.standardTextProperties)
			row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
			row[3]:setColSpan(2):createText(ConvertMoneyString(entry.budgetvalue["money"], false, true, 0, true, false) .. " " .. ReadText(1001, 101), config.standardTextProperties)
		end
		-- crew
		if (entry.type == "ship") and showpeople then
			local row = ftable:addRow(entry.id, {  })
			row[2]:createText(ReadText(1001, 80) .. ReadText(1001, 120), config.standardTextProperties)
			row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
			row[3]:setColSpan(2):createText(ConvertIntegerString(entry.budgetvalue["people"], true, 0, true) .. menu.getBudgetSuffix("people"), config.standardTextProperties)
		end
		-- manager
		if entry.type == "station" then
			local manager = {}
			local value = 0
			local buf = ffi.new("CustomGameStartPersonEntry[1]")
			buf[0].numskills = C.GetNumSkills()
			buf[0].skills = Helper.ffiNewHelper("SkillInfo[?]", buf[0].numskills)
			if C.GetCustomGameStartPlayerPropertyPerson(buf, menu.customgamestart, "playerproperty", entry.id) then
				manager.race = ffi.string(buf[0].race)
				manager.tags = ffi.string(buf[0].tags)
				manager.skills = {}
				for i = 0, buf[0].numskills - 1 do
					local skill = ffi.string(buf[0].skills[i].id)
					manager.skills[skill] = buf[0].skills[i].value
				end

				value = tonumber(C.GetCustomGameStartShipPersonValue(menu.customgamestart, buf[0]))
			end

			local budgetsuffix = menu.getBudgetSuffix("people")
			local row = ftable:addRow(nil, {  })
			row[2]:createText(ReadText(20208, 30301) .. ReadText(1001, 120), config.standardTextProperties)
			row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
			row[3]:setColSpan(2):createText(budgetsuffix and (ConvertIntegerString(value, true, 0, true)  .. budgetsuffix) or "", config.standardTextProperties)

			local raceoptions = {}
			local n = C.GetNumAllRaces()
			local buf = ffi.new("RaceInfo[?]", n)
			n = C.GetAllRaces(buf, n)
			for i = 0, n - 1 do
				local id = ffi.string(buf[i].id)
				local name = ffi.string(buf[i].name)
				if C.CanPlayerUseRace(id, "aipilot") then
					table.insert(raceoptions, { id = id, text = name, icon = "", displayremoveoption = false })
				end
			end
			table.sort(raceoptions, function (a, b) return a.text < b.text end)
			table.insert(raceoptions, 1, { id = "any", text = ReadText(1001, 9930), icon = "", displayremoveoption = false })

			local row = ftable:addRow(entry.id, {  })
			row[2]:createText(ReadText(1001, 2428) .. ReadText(1001, 120), config.standardTextProperties)
			row[2].properties.x = row[2].properties.x + (iteration + 2) * config.standardTextHeight
			row[3]:setColSpan(2):createDropDown(raceoptions, { startOption = (manager.race and (manager.race ~= "")) and manager.race or "any", height = config.standardTextHeight })
			row[3].handlers.onDropDownConfirmed = function(_, raceid) if raceid == "any" then manager.race = "" else manager.race = raceid end; menu.setStationManager("playerproperty", entry.id, manager); menu.refreshMenu() end

			local numskills = C.GetNumSkills()
			local buf = ffi.new("SkillInfo[?]", numskills)
			numskills = C.GetSkills(buf, numskills)
			for i = 0, numskills - 1 do
				local id = ffi.string(buf[i].id)

				local row = ftable:addRow(entry.id, {  })
				if i == 0 then
					row[2]:createText(ReadText(1001, 1918) .. ReadText(1001, 120), config.standardTextProperties)
					row[2].properties.x = row[2].properties.x + (iteration + 2) * config.standardTextHeight
				end
				row[3]:setColSpan(2):createSliderCell({ height = config.standardTextHeight, valueColor = Color["slider_value"], min = 0, max = 15, start = manager.skills and manager.skills[id] or 0, step = 1 }):setText(ReadText(1013, buf[i].textid))
				row[3].handlers.onSliderCellChanged = function(_, newamount) if manager.skills then manager.skills[id] = newamount else manager.skills = { [id] = newamount } end; menu.setStationManager("playerproperty", entry.id, manager) end
				row[3].handlers.onSliderCellConfirm = menu.refreshMenu
			end
		end
		-- subordinates
		local row = ftable:addRow(nil, {  })
		row[2]:createText(ReadText(1001, 1503) .. ReadText(1001, 120), config.standardTextProperties)
		row[2].properties.x = row[2].properties.x + (iteration + 1) * config.standardTextHeight
		row[3]:setColSpan(2):createText((count == 1) and ReadText(1001, 7897) or string.format(ReadText(1001, 7898), count), config.standardTextProperties)

		local subcount = 0
		if menu.subordinates[entry.id] then
			subcount = #menu.subordinates[entry.id]
			for _, subentry in ipairs(menu.subordinates[entry.id]) do
				menu.displayPlayerPropertyEntry(ftable, subentry, iteration + 2)
			end
		end

		local row = ftable:addRow(true, {  })
		row[2]:setColSpan(3):createButton({ x = (iteration + 1) * config.standardTextHeight }):setText(ReadText(1001, 9920))
		row[2].handlers.onClick = function () return menu.openPlayerPropertyShipConfig(row.index, string.match(entry.id, "(.*)_%d+") .. "_sub" .. subcount, nil, entry.id) end

		ftable:addEmptyRow(config.standardTextHeight / 2)
	end
end

function menu.countPlayerProperty(id, count, moneybudget, peoplebudget, totalcount)
	totalcount = totalcount or 1
	if menu.subordinates[id] then
		for _, subentry in ipairs(menu.subordinates[id]) do
			count = count + totalcount * subentry.count
			moneybudget = moneybudget + subentry.budgetvalue["money"]
			peoplebudget = peoplebudget + subentry.budgetvalue["people"]
			count, moneybudget, peoplebudget = menu.countPlayerProperty(subentry.id, count, moneybudget, peoplebudget, totalcount * subentry.count)
		end
	end
	return count, moneybudget, peoplebudget
end

function menu.propertyColor(property)
	local modified
	if property.modifyingids then
		for _, modproperty in ipairs(property.modifyingids) do
			if C.IsCustomGameStartPropertyChanged(menu.customgamestart, modproperty) then
				modified = true
				break
			end
		end
	end

	if not modified then
		if property.propertyType ~= "Internal" then
			modified = C.IsCustomGameStartPropertyChanged(menu.customgamestart, property.id)
		else
			if property.id == "spacesuit" then
				modified = menu.usespacesuit == true
			end
		end
	end
	return modified and Color["customgamestart_property_changed"] or (((property.active == nil) or property.active()) and Color["text_normal"] or Color["text_inactive"])
end

function menu.findTech(ftable, tech)
	for i, mainentry in ipairs(menu.techtree) do
		for col, columnentry in ipairs(mainentry) do
			for j, techentry in ipairs(columnentry) do
				if techentry.tech == tech then
					return i, col, j
				end
			end
		end
	end
end

function menu.precursorSorter(a, b)
	local aIdx = a.mainIdx or 0
	local bIdx = b.mainIdx or 0
	return aIdx > bIdx
end

function menu.isResearchAvailable(tech, mainIdx, col)
	if col > 1 then
		for _, techentry in ipairs(menu.techtree[mainIdx][col - 1]) do
			if not techentry.completed then
				return false
			end
		end
	end
	return true
end

function menu.sortTechName(a, b)
	local aname = GetWareData(a.tech, "name")
	local bname = GetWareData(b.tech, "name")

	return aname < bname
end

function menu.expandNodeResearch(_, ftable, _, data)
	local description, researchtime = GetWareData(data.techdata.tech, "description", "researchtime")
	-- description
	local row = ftable:addRow(nil, { fixed = true })
	row[1]:setColSpan(2):createText(description .. "\n ", { wordwrap = true })
	-- select button
	local row = ftable:addRow(true, { fixed = true })

	local storyentry = menu.researchstoriesbyid[data.techdata.tech]
	row[1]:setColSpan(2):createButton({ mouseOverText = mouseovertext }):setText(data.techdata.completed and ReadText(1001, 9909) or ReadText(1001, 9908)):setText2(((storyentry and (storyentry.budgetvalue == 0)) or menu.creative) and ("[" .. ReadText(1001, 9903) .. "]") or "", { halign = "right" })
	row[1].handlers.onClick = function () menu.saveFlowchartState("flowchart", menu.flowchart); return menu.buttonSelectResearch(data.techdata, data.mainIdx, data.col) end
end

function menu.expandNodeCurrentFaction(_, ftable, _, data)
	-- ui range
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 9911) .. ReadText(1001, 120))
	-- faction selection
	local row = ftable:addRow(true, { fixed = true })

	local options = {}
	local currentOption = menu.currentfaction.id

	for _, factiondata in ipairs(menu.factions) do
		local allowedbystory = false
		if config.factionrelationsallowedbystory[factiondata.id] then
			for groupid, storyentry in pairs(menu.stories) do
				if config.factionrelationsallowedbystory[factiondata.id][storyentry.currentstory] then
					allowedbystory = true
					break
				end
			end
		end

		if menu.creative or ((not factiondata.isrelationlocked) or allowedbystory) then
			local name = factiondata.name
			if factiondata.id == "player" then
				local buf = ffi.new("CustomGameStartStringPropertyState[1]")
				name = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playername", buf))
			end
			table.insert(options, { id = factiondata.id, text = name, icon = "", displayremoveoption = false })
		end
	end

	row[1]:setColSpan(2):createDropDown(options, { startOption = currentOption, height = config.standardTextHeight })
	row[1].handlers.onDropDownConfirmed = menu.dropdownCurrentFaction
end

function menu.expandNodeFaction(_, ftable, _, data)
	ftable:setColWidth(1, config.standardTextHeight)

	-- ui range
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createText(ReadText(1001, 9910) .. ReadText(1001, 120))
	-- slider
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createSliderCell({ min = -30, max = 30, start = data.relation, step = 1, suffix = "", hideMaxValue = true, height = config.standardTextHeight })
	row[1].handlers.onSliderCellChanged = function (_, value) return menu.slidercellFaction(data.faction, value) end
	row[1].handlers.onSliderCellConfirm = function () menu.saveFlowchartState("flowchart", menu.flowchart); menu.restoreNodeFaction = data.faction.id; menu.refresh = getElapsedTime() end
	-- relation description
	local row = ftable:addRow(true, { fixed = true })
	row[1]:setColSpan(2):createText(function () return menu.relationText(data.relationFunction(), ftable.properties.width) end, { wordwrap = true })
	-- budget
	local budgetsuffix = menu.getBudgetSuffix("relations")
	if budgetsuffix then
		local relation = ffi.new("CustomGameStartRelationInfo")
		relation.factionid = Helper.ffiNewString(menu.currentfaction.id)
		relation.otherfactionid = Helper.ffiNewString(data.faction.id)
		relation.relation = data.relation

		local row = ftable:addRow(nil, { fixed = true })
		row[1]:setColSpan(2):createText(((data.relation ~= data.origRelation) and ConvertIntegerString(tonumber(C.GetCustomGameStartRelationsPropertyBudgetValue(menu.customgamestart, menu.category.id, relation)), true, 3, true) or 0) .. budgetsuffix)
	end
	-- known faction
	local knownentry
	for _, entry in ipairs(menu.knowndata) do
		if entry.id == "playerknownfactions" then
			knownentry = entry
		end
	end
	if (menu.currentfaction.id == "player") and knownentry and (knownentry.state ~= "") then
		local row = ftable:addRow(true, { fixed = true })
		local checked = menu.getKnownValue("playerknownfactions", data.faction.id)
		row[1]:createCheckBox(checked)
		row[1].handlers.onClick = function (_, checked) return menu.checkboxKnownFaction(data.faction.id, checked) end

		local budgetinfo = ""
		for _, budget in ipairs(menu.budgets) do
			if budget.id == "known" then
				if (not menu.creative) and C.HasCustomGameStartBudget(menu.customgamestart, "known") then
					budgetinfo = " " .. Helper.convertColorToText(budget.color) .. "\27[" .. budget.icon .. "]"
				end
				break
			end
		end

		row[2]:createText(ReadText(1001, 9912) .. budgetinfo, { color = function () return menu.isKnownValueItemChanged("playerknownfactions", data.faction.id) and Color["customgamestart_property_changed"] or Color["text_normal"] end })
	end
end

function menu.setFactionRelation(relations, faction, otherfaction, relation)
	if relations[faction] then
		relations[faction][otherfaction] = relation
	else
		relations[faction] = { [otherfaction] = relation }
	end
	if relations[otherfaction] then
		relations[otherfaction][faction] = relation
	else
		relations[otherfaction] = { [faction] = relation }
	end
end

function menu.removeFactionRelation(relations, faction, otherfaction)
	if relations[faction] then
		relations[faction][otherfaction] = nil
		relations[otherfaction][faction] = nil
	end
end

function menu.relationText(relation, width)
	local text = ffi.string(C.GenerateFactionRelationTextFromRelation(relation))
	local lines = GetTextLines(text, Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), width)
	local maxlines = GetTextLines(ReadText(20218, 705) .. "\n" .. ReadText(20218, 805) .. "\n" .. ReadText(20218, 1005), Helper.standardFont, Helper.scaleFont(Helper.standardFont, Helper.standardFontSize), width)
	for i = 1, #maxlines - #lines do
		if i == 1 then
			-- we need to add one extra line break, iff we need to add line breaks at all
			text = text .. "\n"
		end
		text = text .. "\n"
	end
	return text
end

function menu.initEncyclopediaValue()
	menu.encyclopedia = { id = "playerencyclopedia", entries = {} }
	local state = C.GetCustomGameStartEncyclopediaPropertyState(menu.customgamestart, menu.encyclopedia.id)
	menu.encyclopedia.state = ffi.string(state.state)

	local n = C.GetCustomGameStartEncyclopediaPropertyCounts(menu.customgamestart, menu.encyclopedia.id)
	local buf = ffi.new("CustomGameStartEncyclopediaEntry[?]", n)
	n = C.GetCustomGameStartEncyclopediaProperty(buf, n, menu.customgamestart, menu.encyclopedia.id)
	for i = 0, n - 1 do
		local library = ffi.string(buf[i].library)
		local item = ffi.string(buf[i].item)
		if menu.encyclopedia.entries[library] then
			menu.encyclopedia.entries[library][item] = { value = true, origValue = true }
		else
			menu.encyclopedia.entries[library] = { [item] = { value = true, origValue = true } }
		end
	end
end

function menu.getEncyclopediaValue(library, item)
	if menu.encyclopedia.entries[library] then
		if menu.encyclopedia.entries[library][item] then
			return menu.encyclopedia.entries[library][item].value
		end
	end
	return false
end

function menu.setEncyclopediaValue(library, item, value)
	if menu.encyclopedia.entries[library] then
		if menu.encyclopedia.entries[library][item] then
			menu.encyclopedia.entries[library][item].value = value
		else
			menu.encyclopedia.entries[library][item] = { value = value, origValue = false }
		end
	else
		menu.encyclopedia.entries[library] = { [item] = { value = value, origValue = false } }
	end
end

function menu.isEncyclopediaValueItemChanged(checklibrary, checkitem)
	for library, data in pairs(menu.encyclopedia.entries) do
		if library == checklibrary then
			for item, entry in pairs(data) do
				if item == checkitem then
					if entry.value ~= entry.origValue then
						return true
					end
				end
			end
		end
	end
	return false
end

function menu.saveEncyclopediaValue()
	local encyclopedialist = {}
	for library, data in pairs(menu.encyclopedia.entries) do
		for item, entry in pairs(data) do
			if entry.value then
				table.insert(encyclopedialist, { library = library, item = item })
			end
		end
	end

	local encyclopedia = ffi.new("CustomGameStartEncyclopediaEntry[?]", #encyclopedialist)
	for i, entry in ipairs(encyclopedialist) do
		encyclopedia[i - 1].library = Helper.ffiNewString(entry.library)
		encyclopedia[i - 1].item = Helper.ffiNewString(entry.item)
	end

	C.SetCustomGameStartEncyclopediaProperty(menu.customgamestart, menu.encyclopedia.id, encyclopedia, #encyclopedialist)
	Helper.ffiClearNewHelper()
end

function menu.initKnownValue()
	menu.knowndata = {
		[1] = { id = "playerknownfactions", entries = {} },
		[2] = { id = "playerknownobjects", entries = {} },
		[3] = { id = "playerknownspace", entries = {} },
	}
	for _, entry in ipairs(menu.knowndata) do
		local state = C.GetCustomGameStartKnownPropertyState(menu.customgamestart, entry.id)
		entry.state = ffi.string(state.state)

		local n = state.numvalues
		local buf = ffi.new("CustomGameStartKnownEntry2[?]", n)
		n = C.GetCustomGameStartKnownProperty2(buf, n, menu.customgamestart, entry.id)
		for i = 0, n - 1 do
			local item = ffi.string(buf[i].item)
			entry.entries[item] = { value = true, origValue = true, budgetvalue = tonumber(buf[i].budgetvalue) }
		end
	end
end

function menu.getKnownValue(property, item)
	local found = false
	for _, entry in ipairs(menu.knowndata) do
		if entry.id == property then
			found = true
			if entry.entries[item] then
				return entry.entries[item].value, entry.entries[item].budgetvalue
			end
		end
	end
	if not found then
		DebugError("menu.getKnownValue(): Trying to access unknown known property '" .. property .. "'.")
	end
	return false, 0
end

function menu.setKnownValue(property, item, value)
	local found = false
	for _, entry in ipairs(menu.knowndata) do
		if entry.id == property then
			found = true
			if entry.entries[item] then
				entry.entries[item].value = value
			else
				local knownitem = ffi.new("CustomGameStartKnownEntry2")
				if entry.id == "playerknownfactions" then
					knownitem.type = Helper.ffiNewString("faction")
					knownitem.item = Helper.ffiNewString(item)
				elseif entry.id == "playerknownobjects" then
					knownitem.type = Helper.ffiNewString("sector")
					knownitem.item = Helper.ffiNewString(item)
					knownitem.classid = "station"
				elseif entry.id == "playerknownspace" then
					knownitem.type = Helper.ffiNewString("sector")
					knownitem.item = Helper.ffiNewString(item)
				end
				local valid = C.GetCustomGameStartKnownPropertyBudgetValue2(menu.customgamestart, entry.id, knownitem)
				entry.entries[item] = { value = value, origValue = false, budgetvalue = valid and tonumber(knownitem.budgetvalue) or 0 }
			end
		end
	end
	if not found then
		DebugError("menu.setKnownValue(): Trying to access unknown known property '" .. property .. "'.")
	end
end

function menu.isKnownValueItemChanged(property, checkitem)
	local found = false
	for _, knownentry in ipairs(menu.knowndata) do
		if knownentry.id == property then
			found = true
			for item, entry in pairs(knownentry.entries) do
				if item == checkitem then
					if entry.value ~= entry.origValue then
						return true
					end
				end
			end
		end
	end
	if not found then
		DebugError("menu.isKnownValueItemChanged(): Trying to access unknown known property '" .. property .. "'.")
	end
	return false
end

function menu.saveKnownValue(property)
	local found = false
	local knownlist = {}
	for _, knownentry in ipairs(menu.knowndata) do
		if knownentry.id == property then
			found = true
			for item, entry in pairs(knownentry.entries) do
				if entry.value then
					table.insert(knownlist, { item = item })
				end
			end
		end
	end
	if not found then
		DebugError("menu.saveKnownValue(): Trying to access unknown known property '" .. property .. "'.")
		return
	end

	local knownitems = ffi.new("CustomGameStartKnownEntry2[?]", #knownlist)
	for i, entry in ipairs(knownlist) do
		if property == "playerknownfactions" then
			knownitems[i - 1].type = Helper.ffiNewString("faction")
			knownitems[i - 1].item = Helper.ffiNewString(entry.item)
		elseif property == "playerknownobjects" then
			knownitems[i - 1].type = Helper.ffiNewString("sector")
			knownitems[i - 1].item = Helper.ffiNewString(entry.item)
			knownitems[i - 1].classid = "station"
		elseif property == "playerknownspace" then
			knownitems[i - 1].type = Helper.ffiNewString("sector")
			knownitems[i - 1].item = Helper.ffiNewString(entry.item)
		end
	end

	C.SetCustomGameStartKnownProperty2(menu.customgamestart, property, knownitems, #knownlist)
	Helper.ffiClearNewHelper()
end

function menu.initStoryValue()
	menu.storiesbyid = {}
	menu.stories = {}
	local n = C.GetNumCustomGameStartStoryBudgets(menu.customgamestart)
	local buf = ffi.new("CustomGameStartStoryInfo[?]", n)
	n = C.GetCustomGameStartStoryBudgets(buf, n, menu.customgamestart)
	for i = 0, n - 1 do
		local groupid = ffi.string(buf[i].groupid)
		local storyid = ffi.string(buf[i].id)

		local dependencies = {}
		local dependencylist_lenghts = {}
		local numdependencies = 0
		local dependencylists_buf = ffi.new("uint32_t[?]", buf[i].numdependencylists)
		local numdependencylists = C.GetNumCustomGameStartStoryBudgetDependencyLists(dependencylists_buf, buf[i].numdependencylists, menu.customgamestart, storyid);
		for j = 0, numdependencylists - 1 do
			local count = dependencylists_buf[j]
			numdependencies = numdependencies + count
			table.insert(dependencylist_lenghts, count)
		end
		local dependencies_buf = ffi.new("const char*[?]", numdependencies)
		numdependencies = C.GetCustomGameStartStoryBudgetDependencies(dependencies_buf, numdependencies, menu.customgamestart, storyid)
		local idx = 1
		for j = 0, numdependencies - 1 do
			while dependencylist_lenghts[1] and (dependencylist_lenghts[1] <= 0) do
				idx = idx + 1
				table.remove(dependencylist_lenghts, 1)
			end
			if #dependencylist_lenghts == 0 then
				DebugError("Dependency list counts and number of dependencies do not match - aborting.")
				break
			end

			if dependencies[idx] then
				table.insert(dependencies[idx], ffi.string(dependencies_buf[j]))
			else
				dependencies[idx] = { ffi.string(dependencies_buf[j]) }
			end
			dependencylist_lenghts[1] = dependencylist_lenghts[1] - 1
		end

		local entry = {
			id = storyid,
			name = ffi.string(buf[i].name),
			description = ffi.string(buf[i].description),
			index = buf[i].index,
			budgetvalue = buf[i].budgetvalue,
			dependencies = dependencies,
		}
		menu.storiesbyid[storyid] = entry

		local groupinfo = C.GetCustomGameStartBudgetGroupInfo(menu.customgamestart, groupid)
		if groupinfo.isresearch then
			local wareid = ffi.string(buf[i].wareid)
			menu.researchstoriesbyid[wareid] = entry
		end

		if menu.stories[groupid] then
			table.insert(menu.stories[groupid].entries, entry)
		else
			menu.stories[groupid] = {
				currentstory = "",
				defaultstory = "",
				entries = { entry },
			}
		end
	end

	menu.storygroups = {}
	local n = C.GetNumCustomGameStartBudgetGroups(menu.customgamestart)
	local buf = ffi.new("const char*[?]", n)
	n = C.GetCustomGameStartBudgetGroups(buf, n, menu.customgamestart)
	for i = 0, n - 1 do
		local groupid = ffi.string(buf[i])
		table.insert(menu.storygroups, groupid)
	end

	local storyproperties = { "universestorystates" }
	for _, id in ipairs(storyproperties) do
		local state = C.GetCustomGameStartStoryPropertyState(menu.customgamestart, id)
		local currentstories = {}
		local buf = ffi.new("const char*[?]", state.numvalues)
		local n = C.GetCustomGameStartStoryProperty(buf, state.numvalues, menu.customgamestart, id)
		for i = 0, n - 1 do
			local storyid = ffi.string(buf[i])
			currentstories[storyid] = true
		end

		local defaultstories = {}
		local buf = ffi.new("const char*[?]", state.numdefaultvalues)
		local n = C.GetCustomGameStartStoryDefaultProperty(buf, state.numdefaultvalues, menu.customgamestart, id)
		for i = 0, n - 1 do
			local storyid = ffi.string(buf[i])
			defaultstories[storyid] = true
		end

		for groupid, storyentry in pairs(menu.stories) do
			if groupid ~= "research" then
				for _, story in ipairs(storyentry.entries) do
					if currentstories[story.id] then
						menu.stories[groupid].currentstory = story.id
					end
					if defaultstories[story.id] then
						menu.stories[groupid].defaultstory = story.id
					end
				end
			end
		end
	end

	menu.initResearch()
end

function menu.initResearch()
	local research = {}
	local n = C.GetCustomGameStartResearchPropertyCounts(menu.customgamestart, "playerresearch")
	local buf = ffi.new("const char*[?]", n)
	n = C.GetCustomGameStartResearchProperty(buf, n, menu.customgamestart, "playerresearch")
	for i = 0, n - 1 do
		research[ffi.string(buf[i])] = true
	end

	menu.techtree = {}
	-- Get all research wares from the WareDB.
	local numtechs = C.GetNumWares("", true, "", "hidden nocustomgamestart")
	local rawtechlist = ffi.new("const char*[?]", numtechs)
	local temptechlist = {}
	numtechs = C.GetWares(rawtechlist, numtechs, "", true, "", "hidden nocustomgamestart")
	for i = 0, numtechs - 1 do
		table.insert(temptechlist, ffi.string(rawtechlist[i]))
	end
	-- NB: don't really need to sort at this point, but will help the entries in the menu stay consistent.
	table.sort(temptechlist, Helper.sortWareSortOrder)

	--print("searching for wares without precursor")
	for i = #temptechlist, 1, -1 do
		local techprecursors, sortorder = GetWareData(temptechlist[i], "researchprecursors", "sortorder")
		if #techprecursors == 0 then
			if not GetWareData(temptechlist[i], "ismissiononly") then
				--print("found " .. temptechlist[i])
				local completed = research[temptechlist[i]] or false
				table.insert(menu.techtree, { [1] = { [1] = { tech = temptechlist[i], sortorder = sortorder, completed = completed, origCompleted = completed } } })
			end
			table.remove(temptechlist, i)
		else
			local hasonlymissionprecursors = true
			for i, precursor in ipairs(techprecursors) do
				if not GetWareData(precursor, "ismissiononly") then
					hasonlymissionprecursors = false
					break
				end
			end
			if hasonlymissionprecursors then
				-- print("found with only mission precursors" .. temptechlist[i])
				local completed = research[temptechlist[i]] or false
				table.insert(menu.techtree, { [1] = { [1] = { tech = temptechlist[i], sortorder = sortorder, completed = completed, origCompleted = completed } } })
				table.remove(temptechlist, i)
			end
		end
	end

	--print("\ngoing through remaining wares")
	local loopcounter = 0
	local idx = 1
	while #temptechlist > 0 do
		--print("looking at: " .. temptechlist[idx])
		local techprecursors, sortorder = GetWareData(temptechlist[idx], "researchprecursors", "sortorder")
		--print("    #precusors: " .. #techprecursors)
		local precursordata = {}
		local smallestMainIdx, foundPrecusorCol
		-- try to find all precusors in existing data
		for i, precursor in ipairs(techprecursors) do
			local mainIdx, precursorCol = menu.findTech(menu.techtree, precursor)
			--print("    precusor " .. precursor .. ": " .. tostring(mainIdx) .. ", " .. tostring(precursorCol))
			if mainIdx and ((not smallestMainIdx) or (smallestMainIdx > mainIdx)) then
				smallestMainIdx = mainIdx
				foundPrecusorCol = precursorCol
			end
			precursordata[i] = { mainIdx = mainIdx, precursorCol = precursorCol }
		end
		-- sort so that highest index comes first - important for deletion order and keeping smallestMainIdx valid
		table.sort(precursordata, menu.precursorSorter)

		if smallestMainIdx then
			--print("    smallestMainIdx: " .. smallestMainIdx .. ", foundPrecusorCol: " .. foundPrecusorCol)
			-- fix wares without precursors that there wrongly placed in different main entries
			for i, entry in ipairs(precursordata) do
				if entry.mainIdx and (entry.mainIdx ~= smallestMainIdx) then
					--print("    precusor " .. techprecursors[i] .. " @ " .. entry.mainIdx .. " ... merging")
					for col, columndata in ipairs(menu.techtree[entry.mainIdx]) do
						for techidx, techentry in ipairs(columndata) do
							--print("    adding menu.techtree[" .. entry.mainIdx .. "][" .. col .. "][" .. techidx .. "] to menu.techtree[" .. smallestMainIdx .. "][" .. col .. "]")
							table.insert(menu.techtree[smallestMainIdx][col], techentry)
						end
					end
					--print("    removing mainIdx " .. entry.mainIdx)
					table.remove(menu.techtree, entry.mainIdx)
				end
			end

			-- add this tech to the tree and remove it from the list
			local completed = research[temptechlist[idx]] or false
			if menu.techtree[smallestMainIdx][foundPrecusorCol + 1] then
				--print("    adding")
				table.insert(menu.techtree[smallestMainIdx][foundPrecusorCol + 1], { tech = temptechlist[idx], sortorder = sortorder, completed = completed, origCompleted = completed })
			else
				--print("    new entry")
				menu.techtree[smallestMainIdx][foundPrecusorCol + 1] = { [1] = { tech = temptechlist[idx], sortorder = sortorder, completed = completed, origCompleted = completed } }
			end
			--print("    removed")
			table.remove(temptechlist, idx)
		end

		if idx >= #temptechlist then
			loopcounter = loopcounter + 1
			idx = 1
		else
			idx = idx + 1
		end
		if loopcounter > 100 then
			DebugError("Infinite loop detected - aborting.")
			break
		end
	end

	menu.researchstories = {}
	for i, mainentry in ipairs(menu.techtree) do
		for col, columnentry in ipairs(mainentry) do
			for j, techentry in ipairs(columnentry) do
				techentry.completed = techentry.origCompleted
				if menu.researchstoriesbyid[techentry.tech] then
					menu.researchstories[menu.researchstoriesbyid[techentry.tech].id] = techentry.completed or nil
				end
			end
		end
	end
end

function menu.saveStoryValue(property)
	local storylist = {}
	for _, data in pairs(menu.stories) do
		if data.currentstory ~= "" then
			table.insert(storylist, data.currentstory)
		end
	end
	for story in pairs(menu.researchstories) do
		table.insert(storylist, story)
	end

	local stories = ffi.new("const char*[?]", #storylist)
	for i, story in ipairs(storylist) do
		stories[i - 1] = Helper.ffiNewString(story)
	end

	C.SetCustomGameStartStory(menu.customgamestart, property, stories, #storylist)
	Helper.ffiClearNewHelper()
end

function menu.initSatellites()
	local state = C.GetCustomGameStartPlayerPropertyPropertyState(menu.customgamestart, "playerproperty")
	if state.numvalues > 0 then
		local counts = ffi.new("CustomGameStartPlayerPropertyCounts[?]", state.numvalues)
		local n = C.GetCustomGameStartPlayerPropertyCounts(counts, state.numvalues, menu.customgamestart, "playerproperty")
		if n > 0 then
			local buf = ffi.new("CustomGameStartPlayerProperty3[?]", n)
			for i = 0, n - 1 do
				buf[i].numcargo = counts[i].numcargo
				buf[i].cargo = Helper.ffiNewHelper("UIWareInfo[?]", counts[i].numcargo)
			end
			n = C.GetCustomGameStartPlayerPropertyProperty3(buf, n, menu.customgamestart, "playerproperty")
			for i = 0, n - 1 do
				if (ffi.string(buf[i].type) == "object") and (ffi.string(buf[i].macroname) == config.satellites.macro) then
					local id = ffi.string(buf[i].id)
					local sector = ffi.string(buf[i].sector)

					menu.satellites[sector] = menu.satellites[sector] or { totalvalue = 0 }
					table.insert(menu.satellites[sector], id)
					menu.satellites[sector].totalvalue = menu.satellites[sector].totalvalue + tonumber(C.GetCustomGameStartPlayerPropertyValue(menu.customgamestart, "playerproperty", id))
				end
			end
		end
	end
end

function menu.initFactions()
	if #menu.factions == 0 then
		local value = {}
		local n = C.GetCustomGameStartRelationsPropertyCounts(menu.customgamestart, "universefactionrelations")
		local buf = ffi.new("CustomGameStartRelationInfo[?]", n)
		n = C.GetCustomGameStartRelationsProperty(buf, n, menu.customgamestart, "universefactionrelations")
		for i = 0, n - 1 do
			menu.setFactionRelation(value, ffi.string(buf[i].factionid), ffi.string(buf[i].otherfactionid), buf[i].relation)
		end

		-- all factions
		local tempfactionlist = {}
		local n = C.GetNumAllFactions(false)
		local buf = ffi.new("const char*[?]", n)
		n = C.GetAllFactions(buf, n, false)
		for i = 0, n - 1 do
			local id = ffi.string(buf[i])
			local isrelationlocked = GetFactionData(id, "isrelationlocked")
			if (id ~= "player") and (menu.creative or ((not isrelationlocked) or config.factionrelationsallowedbystory[id])) then
				table.insert(tempfactionlist, { id = id, name = GetFactionData(id, "name"), isrelationlocked = isrelationlocked })
			end
		end
		table.sort(tempfactionlist, Helper.sortName)
		-- player faction in front
		local buf = ffi.new("CustomGameStartStringPropertyState[1]")
		local name = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playername", buf))
		table.insert(tempfactionlist, 1, { id = "player", name = name })
		-- create relation structure
		for _, entry in ipairs(tempfactionlist) do
			local relations = {}
			for _, entry2 in ipairs(tempfactionlist) do
				local relation = C.GetUIDefaultBaseRelation(entry.id, entry2.id)
				local origRelation = relation
				if value[entry.id] and value[entry.id][entry2.id] then
					origRelation = value[entry.id][entry2.id]
				end
				table.insert(relations, { id = entry2.id, name = entry2.name, isrelationlocked = entry2.isrelationlocked, relation = relation, origRelation = origRelation })
			end
			table.insert(menu.factions, { id = entry.id, name = entry.name, isrelationlocked = entry.isrelationlocked, relations = relations })
			if #menu.factions == 1 then
				menu.currentfaction = menu.factions[1]
			end
		end
	end
end

function menu.displayInit()
	if menu.flowchart then
		menu.flowchart:collapseAllNodes()
		menu.flowchart = nil
	end
	-- remove old data
	Helper.clearDataForRefresh(menu)
	menu.selectedOption = nil

	menu.mainFrame = Helper.createFrameHandle(menu, {
		x = 0,
		y = 0,
		width = Helper.viewWidth,
		height = Helper.viewHeight,
		standardButtons = {},
		playerControls = false,
		layer = config.mainFrameLayer,
	})

	local ftable = menu.mainFrame:addTable(1, { tabOrder = 0, width = math.floor(Helper.viewWidth / 2), x = math.floor(Helper.viewWidth / 4), y = math.floor(Helper.viewHeight / 2) })

	local row = ftable:addRow(false, { fixed = true })
	row[1]:createText(" ", { halign = "center", font = config.fontBold, fontsize = config.headerFontSize, x = 0, y = 0 })

	ftable.properties.y = math.floor((Helper.viewHeight - ftable:getVisibleHeight()) / 2)

	menu.mainFrame:display()

	menu.cleanup()

	C.ShowInfoLine(ReadText(1001, 7230), 10)
end

function menu.refreshMenu()
	menu.topRows.categoryTable = GetTopRow(menu.categoryTable.id)
	menu.selectedRows.categoryTable = Helper.currentTableRow[menu.categoryTable.id]
	if menu.propertyTable then
		menu.topRows.propertyTable = GetTopRow(menu.propertyTable.id)
		menu.selectedRows.propertyTable = Helper.currentTableRow[menu.propertyTable.id]
	end
	menu.display()
end

function menu.onRowChanged(row, rowdata, uitable, modified, input, source)
	row = row or Helper.currentTableRow[uitable]
	if uitable == menu.categoryTable.id then
		if input == "mouse" then
			local category = menu.rowDataMap[uitable][row]
			if category ~= menu.category then
				if (not category.active) or category.active() then
					menu.setCategory(category)
					menu.refresh = getElapsedTime()
				end
			end
		end
	elseif uitable == menu.propertyTable.id then
		if menu.category.type == "property" then
			if type(rowdata) == "string" then
				menu.category.selectedEntry = rowdata
				if menu.holomap ~= 0 then
					C.SetMacroMapSelection(menu.holomap, false, menu.category.selectedEntry)
				end
			else
				menu.category.selectedEntry = nil
				if menu.holomap ~= 0 then
					C.SetMacroMapSelection(menu.holomap, false, "")
				end
			end
		elseif menu.category.type == "list" then
			local newproperty = menu.rowDataMap[uitable][row]
			if newproperty.displayOnRenderTarget or (menu.category.selectedProperty and menu.category.selectedProperty.displayOnRenderTarget) then
				if menu.cutsceneid then
					StopCutscene(menu.cutsceneid)
					menu.cutsceneid = nil
					DestroyPresentationCluster(menu.precluster)
				end
				if menu.holomap ~= 0 then
					C.RemoveHoloMap()
					menu.holomap = 0
				end
				menu.rendertargetLock = getElapsedTime() + 0.1
			end
			menu.category.selectedProperty = newproperty
		end
	end
end

function menu.onSelectElement(uitable, modified, row)
	row = row or Helper.currentTableRow[uitable]
	if uitable == menu.categoryTable.id then
		local category = menu.rowDataMap[uitable][row]
		if category ~= menu.category then
			if (not category.active) or category.active() then
				menu.setCategory(category)
				menu.refresh = getElapsedTime()
			end
		end
	end
end

menu.updateInterval = 0.01
function menu.onUpdate()
	local curtime = getElapsedTime()
	if menu.refresh and (menu.refresh < curtime) then
		menu.refreshMenu()
		menu.refresh = nil
		return
	end

	if menu.shownPropertyHint and (menu.shownPropertyHint > 0) and (menu.shownPropertyHint + 10 < curtime) then
		menu.shownPropertyHint = -1
		menu.closeContextMenu()
	end

	if menu.showHighlightOverlay then
		ShowHighlightOverlay(menu.showHighlightOverlay)
		menu.showHighlightOverlay = nil
	end

	if menu.rendertarget and menu.holomap ~= 0 then
		local x, y = GetRenderTargetMousePosition(menu.rendertarget.id)
		C.SetMapRelativeMousePosition(menu.holomap, (x and y) ~= nil, x or 0, y or 0)
	end

	if menu.category.rendertarget then
		if menu.rendertarget then
			local rendertargetTexture = GetRenderTargetTexture(menu.rendertarget.id)
			if rendertargetTexture then
				if (not menu.cutsceneid) and (menu.holomap == 0) and ((not menu.rendertargetLock) or (menu.rendertargetLock < getElapsedTime())) then
					menu.rendertargetLock = nil
					if menu.category.type == "property" then
						if menu.holomap == 0 then
							local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainFrameLayer, menu.rendertarget.id)
							local buf = ffi.new("CustomGameStartStringPropertyState[1]")
							local galaxymacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "galaxy", buf))
							local sectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
							local buf2 = ffi.new("CustomGameStartPosRotPropertyState[1]")
							local sectoroffset = C.GetCustomGameStartPosRotProperty(menu.customgamestart, "offset", buf2)
							-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
							menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.renderTargetWidth / menu.renderTargetHeight, 1)

							C.ShowUniverseMacroMap2(menu.holomap, galaxymacro, sectormacro, sectoroffset, true, false, menu.customgamestart)
							C.SetMacroMapSelection(menu.holomap, false, menu.category.selectedEntry or "")
						end
					else
						local currentproperty = menu.category.selectedProperty or {}
						local mode = menu.category.displayOnRenderTarget[1]
						local modeproperty
						for _, property in ipairs(menu.category.properties) do
							if property.displayOnRenderTarget and (property.id == currentproperty.id) then
								mode = property.displayOnRenderTarget
								modeproperty = property
								break
							elseif property.id == menu.category.displayOnRenderTarget[2] then
								modeproperty = property
							end
						end

						if mode == "macro" then
							if not menu.cutsceneid then
								local buf = ffi.new("CustomGameStart" .. modeproperty.propertyType .. "PropertyState[1]")
								local renderobject = ffi.string(modeproperty.get(menu.customgamestart, modeproperty.id, buf))
								if renderobject then
									menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
									if menu.preobject then
										if IsComponentClass(menu.preobject, "object") then
											local buf = ffi.new("CustomGameStartStringPropertyState[1]")
											local painttheme = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playerpainttheme", buf))
											local paintmod = ffi.new("UIPaintMod")
											if C.GetPaintThemeMod(painttheme, "player", paintmod) then
												C.InstallPaintMod(ConvertIDTo64Bit(menu.preobject), ffi.string(paintmod.Ware), false)
											end
										end

										menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", { targetobject = menu.preobject })
										menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)

										if not menu.cutsceneNotification then
											NotifyOnCutsceneReady(getElement("Scene.UIContract"))
											NotifyOnCutsceneStopped(getElement("Scene.UIContract"))
										end
									end
								end
							end
						elseif mode == "npc" then
							if not menu.cutsceneid then
								local buf = ffi.new("CustomGameStart" .. modeproperty.propertyType .. "PropertyState[1]")
								local playermacro = ffi.string(modeproperty.get(menu.customgamestart, modeproperty.id, buf))
								local renderobject = menu.playerMacros[playermacro]
								if renderobject and (renderobject ~= "") then
									menu.precluster, menu.prenpc = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
									if menu.prenpc then
										local cutscenekey = GetComponentData(menu.prenpc, "npcfacecutscenekey")
										if cutscenekey then
											menu.cutscenedesc = CreateCutsceneDescriptor(cutscenekey, { npcref = menu.prenpc })
											menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)
											
											if not menu.cutsceneNotification then
												NotifyOnCutsceneReady(getElement("Scene.UIContract"))
												NotifyOnCutsceneStopped(getElement("Scene.UIContract"))
											end
										end
									end
								end
							end
						elseif mode == "map" then
							if menu.holomap == 0 then
								local renderX0, renderX1, renderY0, renderY1 = Helper.getRelativeRenderTargetSize(menu, config.mainFrameLayer, menu.rendertarget.id)
								local buf = ffi.new("CustomGameStartStringPropertyState[1]")
								local galaxymacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "galaxy", buf))
								local sectormacro = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "sector", buf))
								local buf2 = ffi.new("CustomGameStartPosRotPropertyState[1]")
								local sectoroffset = C.GetCustomGameStartPosRotProperty(menu.customgamestart, "offset", buf2)
								-- pass relative screenspace of the holomap rendertarget to the holomap (value range = -1 .. 1)
								menu.holomap = C.AddHoloMap(rendertargetTexture, renderX0, renderX1, renderY0, renderY1, menu.renderTargetWidth / menu.renderTargetHeight, 1)
								C.ShowUniverseMacroMap2(menu.holomap, galaxymacro, sectormacro, sectoroffset, true, false, menu.customgamestart)
								C.SetMacroMapSelection(menu.holomap, true, "")
							end
						elseif mode == "painttheme" then
							local renderobject
							if not menu.usespacesuit then
								local buf = ffi.new("CustomGameStartStringPropertyState[1]")
								renderobject = ffi.string(modeproperty.get(menu.customgamestart, "ship", buf))
							else
								renderobject = config.fallbackShipMacro
							end

							if renderobject then
								menu.precluster, menu.preobject = CreateObjectInPresentationCluster(renderobject, "cluster_black_wlight_bg_macro")
								if menu.preobject then
									if IsComponentClass(menu.preobject, "object") then
										local buf = ffi.new("CustomGameStartStringPropertyState[1]")
										local painttheme = ffi.string(C.GetCustomGameStartStringProperty(menu.customgamestart, "playerpainttheme", buf))
										local paintmod = ffi.new("UIPaintMod")
										if C.GetPaintThemeMod(painttheme, "player", paintmod) then
											C.InstallPaintMod(ConvertIDTo64Bit(menu.preobject), ffi.string(paintmod.Ware), false)
										end
									end

									menu.cutscenedesc = CreateCutsceneDescriptor("OrbitIndefinitelySlow", { targetobject = menu.preobject })
									menu.cutsceneid = StartCutscene(menu.cutscenedesc, rendertargetTexture)

									if not menu.cutsceneNotification then
										NotifyOnCutsceneReady(getElement("Scene.UIContract"))
										NotifyOnCutsceneStopped(getElement("Scene.UIContract"))
									end
								end
							end
						end
					end
				end
			end
		end
	end

	if menu.rightdown then
		if not menu.rightdown.wasmoved then
			local offset = table.pack(GetLocalMousePosition())
			if Helper.comparePositions(menu.rightdown.position, offset, 5) then
				menu.rightdown.wasmoved = true
			end
		end
	end

	if menu.restoreNode and menu.restoreNode.id then
		menu.restoreNode:expand()
		menu.restoreNode = nil
	end

	menu.mainFrame:update()
	if menu.expandedMenuFrame then
		menu.expandedMenuFrame:update()
	end
	if menu.contextFrame then
		menu.contextFrame:update()
	end
end

function menu.onRenderTargetSelect(modified)
	menu.closeContextMenu()

	local offset = table.pack(GetLocalMousePosition())
	-- Check if the mouse button was down less than 0.5 seconds and the mouse was moved more than a distance of 5px
	if (not menu.leftdown) or ((menu.leftdown.time + 0.5 > getElapsedTime()) and not Helper.comparePositions(menu.leftdown.position, offset, 5)) then
		if menu.holomap ~= 0 then
			local sectorpos = ffi.new("UIPosRot")
			local sectormacro = ffi.string(C.GetMacroMapPositionOnEcliptic(menu.holomap, sectorpos))
			if sectormacro ~= "" then
				if menu.category.id == "universe" then
					for _, property in ipairs(menu.category.properties) do
						if property.id == "sector" then
							property.value = sectormacro
							property.set(menu.customgamestart, property.id, property.value, true)
							menu.setKnownValue("playerknownspace", sectormacro, true)
							menu.saveKnownValue("playerknownspace")
						elseif property.id == "offset" then
							property.value = sectorpos
							property.set(menu.customgamestart, property.id, property.value)
						end
					end
				elseif menu.category.id == "playerproperty" then
					if menu.category.selectedEntry then
						C.SetCustomGameStartPlayerPropertySectorAndOffset(menu.customgamestart, menu.category.id, menu.category.selectedEntry, sectormacro, sectorpos)
						menu.setKnownValue("playerknownspace", sectormacro, true)
						menu.saveKnownValue("playerknownspace")
					end
				end
				menu.refreshMenu()
			end
		end
	end
	menu.leftdown = nil
end

-- rendertarget mouse input helper
function menu.onRenderTargetMouseDown(modified)
	menu.leftdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }
	
	if menu.holomap ~= 0 then
		C.StartPanMap(menu.holomap)
		menu.panningmap = { isclick = true }
	end
end

function menu.onRenderTargetMouseUp(modified)
	if menu.panningmap then
		if menu.holomap ~= 0 then
			C.StopPanMap(menu.holomap)
		end
		menu.panningmap = nil
	end
end

function menu.onRenderTargetCombinedScrollDown(step)
	if menu.holomap ~= 0 then
		C.ZoomMap(menu.holomap, step)
	end
end

function menu.onRenderTargetCombinedScrollUp(step)
	if menu.holomap ~= 0 then
		C.ZoomMap(menu.holomap, -step)
	end
end

function menu.onRenderTargetRightMouseDown()
	menu.closeContextMenu()
	menu.rightdown = { time = getElapsedTime(), position = table.pack(GetLocalMousePosition()), dynpos = table.pack(GetLocalMousePosition()) }
end

function menu.onRenderTargetRightMouseUp(modified)
	local offset = table.pack(GetLocalMousePosition())

	-- Check if the mouse was moved more than a distance of 5px
	if menu.rightdown and (not Helper.comparePositions(menu.rightdown.position, offset, 5)) and (not menu.rightdown.wasmoved) then
		if menu.holomap ~= 0 then
			local sectorpos = ffi.new("UIPosRot")
			local sectormacro = ffi.string(C.GetMacroMapPositionOnEcliptic(menu.holomap, sectorpos))
		
			if menu.category.id == "universe" then
				menu.displayMapContext(offset, sectormacro, sectorpos)
			end
		end
	end
	menu.rightdown = nil
end

function menu.onFlowchartNodeExpanded(node, frame, ftable, ftable2)
	node.flowchart:collapseAllNodes()
	local data = node.customdata
	local expandHandler = data.expandHandler
	if expandHandler then
		expandHandler(frame, ftable, ftable2, data.data)
		menu.expandedNode = node
		menu.expandedMenuFrame = frame
		menu.expandedMenuTable = ftable
	end
end

function menu.onFlowchartNodeCollapsed(node, frame)
	if menu.expandedNode == node and menu.expandedMenuFrame == frame then
		local data = node.customdata
		local collapseHandler = data.collapseHandler
		if collapseHandler then
			collapseHandler(data)
		end
		Helper.clearFrame(menu, config.expandedMenuFrameLayer)
		menu.expandedMenuTable = nil
		menu.expandedMenuFrame = nil
		menu.expandedNode = nil
	end
end

function menu.onPropertyDropDownActivated(property, row, dropdown)
	SelectRow(menu.propertyTable.id, row)
end

function menu.closeContextMenu(skiprefresh)
	if menu.contextMenu then
		menu.contextTable = nil
		menu.contextFrame = nil
		Helper.clearFrame(menu, config.contextFrameLayer)
		menu.contextMenuData = {}
		menu.contextMenu = nil
		if (not skiprefresh) and menu.category.rendertarget then
			menu.refreshMenu()
		end
	end
end

function menu.closeMenu(dueToClose)
	menu.closeContextMenu()
	Helper.closeMenu(menu, dueToClose)
	menu.cleanup()
end

function menu.onCloseElement(dueToClose, layer)
	if menu.contextMenu then
		menu.closeContextMenu()
		return
	end
	if layer == config.expandedMenuFrameLayer then
		menu.expandedNode:collapse()
		return
	end
	if dueToClose == "close" then
		__CORE_GAMEOPTIONS_RESTOREINFO.returnhistory = nil
		if menu.isStartmenu then
			menu.closeMenu("back")
		else
			menu.closeMenu("close")
		end
	else
		if next(menu.category) and (dueToClose == "back") then
			menu.setCategory(nil)
			menu.refreshMenu()
			return
		end
		if (not menu.isStartmenu) and (dueToClose == "back") and (not menu.paused) then
			menu.param2[2] = "toplevel"
		end
		menu.closeMenu(dueToClose)
	end
end

function menu.saveFlowchartState(name, flowchart)
	menu.topRows[name], menu.firstCols[name] = GetFlowchartFirstVisibleCell(flowchart.id)
	menu.selectedRows[name], menu.selectedCols[name] = GetFlowchartSelectedCell(flowchart.id)
end

function menu.restoreFlowchartState(name, flowchart)
	flowchart.properties.firstVisibleRow = menu.topRows[name] or 1
	flowchart.properties.firstVisibleCol = menu.firstCols[name] or 1
	menu.topRows[name] = nil
	menu.firstCols[name] = nil
	flowchart.properties.selectedRow = menu.selectedRows[name] or 1
	flowchart.properties.selectedCol = menu.selectedCols[name] or 1
	menu.selectedRows[name] = nil
	menu.selectedCols[name] = nil
end

function menu.checkConstructionPlan(source, id, limitedmodulesused, onlineitems, isHQ)
	if (source == "local") or C.IsConstructionPlanAvailableInCustomGameStart(id) or IsCheatVersion() then
		local numinvalidpatches = ffi.new("uint32_t[?]", 1)
		if not C.IsConstructionPlanValid(id, numinvalidpatches) then
			return false
		end

		local limitedmodulesexceeded = false
		local num_modules = C.GetNumPlannedLimitedModules(id)
		local buf_modules = ffi.new("UIMacroCount[?]", num_modules)
		num_modules = C.GetPlannedLimitedModules(buf_modules, num_modules, id)
		for j = 0, num_modules - 1 do
			local macro = ffi.string(buf_modules[j].macro)
			local ware = GetMacroData(macro, "ware")
			local usedamount = limitedmodulesused[macro] or 0
			local islimited = GetWareData(ware, "islimited")
			if islimited then
				if usedamount + buf_modules[j].amount > Helper.getLimitedWareAmount(ware) then
					limitedmodulesexceeded = true
				end
			else
				if usedamount + buf_modules[j].amount > (onlineitems[ware] and onlineitems[ware].amount or 0) then
					limitedmodulesexceeded = true
				end
			end
			limitedmodulesused[macro] = usedamount + buf_modules[j].amount
		end
		if limitedmodulesexceeded then
			return false
		end

		if not isHQ then
			local foundmacros = {}
			for _, macro in ipairs(config.excludedmodules) do
				local hasmacro = Helper.textArrayHelper({ macro }, function (numtexts, texts) return C.CheckConstructionPlanForMacros(id, texts, numtexts) end)
				if hasmacro then
					table.insert(foundmacros, macro)
				end
			end
			if #foundmacros > 0 then
				return false
			end
		end
		return true
	end
	return false
end

-- kuertee start:
menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
    if not menu.uix_callbacks_toDeregister[callbackName] then
        menu.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
    else
        if menu.uix_callbacks[callbackName] then
            for id, func in pairs(menu.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not menu.uix_isDeregisterQueued then
        menu.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.deregisterCallbacksNow()
    menu.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
        if menu.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if menu.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix registerCallback (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                    menu.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix registerCallback (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
    if not menu.uix_callbacks_toUpdate[callbackName] then
        menu.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not menu.uix_isUpdateQueued then
        menu.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function menu.updateCallbacksNow()
    menu.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
        if menu.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if menu.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                    menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end
-- kuertee end

init()
﻿-- ffi setup
local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[
	typedef uint64_t BuildTaskID;
	typedef uint64_t FleetUnitID;
	typedef uint64_t UniverseID;
	typedef struct {
		const char* wareid;
		uint32_t amount;
	} UIWareAmount;

	typedef struct {
		const char* macro;
		const char* ware;
		uint32_t amount;
		uint32_t capacity;
	} AmmoData;
	typedef struct {
		UniverseID controllableid;
		FleetUnitID fleetunitid;
		int32_t groupindex;
	} CommanderInfo;
	typedef struct {
		int x;
		int y;
	} Coord2D;
	typedef struct {
		float x;
		float y;
		float z;
	} Coord3D;
	typedef struct {
		float dps;
		uint32_t quadranttextid;
	} DPSData;
	typedef struct {
		FleetUnitID fleetunitid;
		const char* name;
		const char* idcode;
		const char* macro;
		BuildTaskID buildtaskid;
		UniverseID replacementid;
	} FleetUnitInfo;
	typedef struct {
		UniverseID attacker;
		double time;
		const char* method;
	} LastAttackerInfo;
	typedef struct {
		UniverseID target;
		UIWareAmount* wares;
		uint32_t numwares;
	} MissionWareDeliveryInfo;
	// @since X4 4.10 - added
	typedef struct {
		UniverseID target;
		uint32_t numwares;
		MissionID missionid;
	} MissionWareDeliveryCounts;
	typedef struct {
		float x;
		float y;
		float width;
		float height;
	} MonitorExtents;
	typedef struct {
		size_t queueidx;
		const char* state;
		const char* statename;
		const char* orderdef;
		size_t actualparams;
		bool enabled;
		bool isinfinite;
		bool issyncpointreached;
		bool istemporder;
	} Order;
	typedef struct {
		const char* id;
		const char* name;
		const char* icon;
		const char* description;
		const char* category;
		const char* categoryname;
		bool infinite;
		uint32_t requiredSkill;
	} OrderDefinition;
	typedef struct {
		const char* id;
		const char* name;
		const char* desc;
		uint32_t amount;
		uint32_t numtiers;
		bool canhire;
	} PeopleInfo;
	typedef struct {
		float x;
		float y;
	} Position2D;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} PosRot;
	typedef struct {
		uint32_t id;
		const char* text;
		const char* type;
		bool ispossible;
		bool istobedisplayed;
	} UIAction;
	typedef struct {
		UniverseID component;
		const char* connection;
	} UIComponentSlot;
	typedef struct {
		const char* shape;
		const char* name;
		uint32_t requiredSkill;
		float radius;
		bool rollMembers;
		bool rollFormation;
		size_t maxShipsPerLine;
	} UIFormationInfo;
	typedef struct {
		float x;
		float y;
		float z;
		float yaw;
		float pitch;
		float roll;
	} UIPosRot;
	typedef struct {
		UniverseID contextid;
		const char* path;
		const char* group;
	} UpgradeGroup2;
	typedef struct {
		const char* wareid;
		int32_t amount;
	} YieldInfo;
	void ActivateObject(UniverseID objectid, bool active);
	void AddFleetUnitSubordinate(FleetUnitID fleetunitid, UniverseID subordinateid, FleetUnitID subordinatefleetunitid, int32_t subordinategroupid);
	bool AdjustOrder(UniverseID controllableid, size_t idx, size_t newidx, bool enabled, bool forcestates, bool checkonly);
	bool CanAcceptSubordinate(UniverseID commanderid, UniverseID potentialsubordinateid);
	bool CanBeDismantled(UniverseID componentid);
	bool CanBeTowed(UniverseID componentid);
	bool CancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanCancelConstruction(UniverseID containerid, BuildTaskID id);
	bool CanClaimOwnership(UniverseID destructibleid);
	bool CanContainerBuildShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerEquipShip(UniverseID containerid, UniverseID shipid);
	bool CanContainerSupplyShip(UniverseID containerid, UniverseID shipid);
	bool CanDockAtDockingBay(UniverseID shipid, UniverseID dockingbayid);
	bool CanPutShipIntoStorage(UniverseID containerid, UniverseID shipid);
	bool CanSetPlayerCameraCinematicView(void);
	bool CanStartTravelMode(UniverseID objectid);
	const char* CanTeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool force);
	bool ClaimShip(UniverseID shipid, UniverseID shiptobeclaimedid);
	uint32_t CreateDeployToStationOrder(UniverseID controllableid);
	uint32_t CreateOrder(UniverseID controllableid, const char* orderid, bool defaultorder);
	uint32_t CreateOrder3(UniverseID controllableid, const char* orderid, bool defaultorder, bool isoverride, bool istemp);
	void DeactivateMouseEmulation(void);
	bool DoesConstructionSequenceRequireBuilder(UniverseID containerid);
	uint32_t GetAllFleetUnitSubordinates(UniverseID* result, uint32_t resultlen, FleetUnitID fleetunitid);
	uint32_t GetAllLaserTowers(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllMines(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllNavBeacons(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllResourceProbes(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetAllSatellites(AmmoData* result, uint32_t resultlen, UniverseID defensibleid);
	CommanderInfo GetCommander(UniverseID controllableid, FleetUnitID fleetunitid);
	uint32_t GetCompSlotPlayerActions(UIAction* result, uint32_t resultlen, UIComponentSlot compslot);
	Coord2D GetCompSlotScreenPos(UIComponentSlot compslot);
	UniverseID GetContextByClass(UniverseID componentid, const char* classname, bool includeself);
	uint32_t GetControllableSubordinateFleetUnits(FleetUnitID* result, uint32_t resultlen, UniverseID controllableid, int subordinategroupid);
	uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
	float GetDistanceBetween(UniverseID component1id, UniverseID component2id);
	uint32_t GetDockedShips(UniverseID* result, uint32_t resultlen, UniverseID dockingbayorcontainerid, const char* factionid);
	UniverseID GetFleetLead(UniverseID controllableid, FleetUnitID fleetunitid);
	FleetUnitInfo GetFleetUnitInfo(FleetUnitID fleetunitid);
	uint32_t GetFleetUnitSubordinateFleetUnits(FleetUnitID* result, uint32_t resultlen, FleetUnitID fleetunitid, int subordinategroupid);
	int32_t GetFleetUnitSubordinateGroup(FleetUnitID fleetunitid);
	const char* GetFleetUnitSubordinateGroupAssignment(FleetUnitID fleetunitid, int32_t group);
	uint32_t GetFleetUnitSubordinates(UniverseID* result, uint32_t resultlen, FleetUnitID fleetunitid, int32_t subordinategroupid);
	uint32_t GetFormationShapes(UIFormationInfo* result, uint32_t resultlen);
	uint32_t GetHQs(UniverseID* result, uint32_t resultlen, const char* factionid);
	LastAttackerInfo GetLastAttackInfo(UniverseID destructibleid);
	uint32_t GetMineablesAtSectorPos(YieldInfo* result, uint32_t resultlen, UniverseID sectorid, Coord3D position);
	void GetMissionDeliveryWares(MissionWareDeliveryInfo* result, MissionID missionid);
	uint32_t GetMissionThreadSubMissions(MissionID* result, uint32_t resultlen, MissionID missionid);
	MonitorExtents GetMonitorExtents(const char* monitorid);
	uint32_t GetNumAllFleetUnitSubordinates(FleetUnitID fleetunitid);
	uint32_t GetNumAllLaserTowers(UniverseID defensibleid);
	uint32_t GetNumAllMines(UniverseID defensibleid);
	uint32_t GetNumAllRoles(void);
	uint32_t GetNumAllNavBeacons(UniverseID defensibleid);
	uint32_t GetNumAllResourceProbes(UniverseID defensibleid);
	uint32_t GetNumAllSatellites(UniverseID defensibleid);
	uint32_t GetNumCompSlotPlayerActions(UIComponentSlot compslot);
	uint32_t GetNumControllableSubordinateFleetUnits(UniverseID controllableid, int subordinategroupid);
	uint32_t GetNumDockedShips(UniverseID dockingbayorcontainerid, const char* factionid);
	uint32_t GetNumFleetUnitSubordinateFleetUnits(FleetUnitID fleetunitid, int subordinategroupid);
	uint32_t GetNumFleetUnitSubordinates(FleetUnitID fleetunitid, int32_t subordinategroupid);
	uint32_t GetNumFormationShapes(void);
	uint32_t GetNumHQs(const char* factionid);
	uint32_t GetNumMineablesAtSectorPos(UniverseID sectorid, Coord3D position);
	uint32_t GetNumMissionThreadSubMissions(MissionID missionid);
	uint32_t GetNumObjectsWithSyncPoint(uint32_t syncid, bool onlyreached);
	uint32_t GetNumObjectsWithSyncPointFromOrder(UniverseID controllableid, size_t idx, bool onlyreached);
	uint32_t GetNumOrderDefinitions(void);
	uint32_t GetNumRequestedMissionNPCs(UniverseID containerid);
	uint32_t GetNumRequestedMissionWares(UniverseID containerid);
	uint32_t GetNumStoredUnits(UniverseID defensibleid, const char* cat, bool virtualammo);
	uint32_t GetNumSubordinatesOfGroup(UniverseID commanderid, int group);
	uint32_t GetNumUpgradeGroups(UniverseID destructibleid, const char* macroname);
	size_t GetNumUpgradeSlots(UniverseID destructibleid, const char* macroname, const char* upgradetypename);
	uint32_t GetNumVenturePlatformDocks(UniverseID ventureplatformid);
	uint32_t GetNumVenturePlatforms(UniverseID defensibleid);
	uint32_t GetNumWares(const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	UIPosRot GetObjectPositionInSector(UniverseID objectid);
	uint32_t GetOrderDefinitions(OrderDefinition* result, uint32_t resultlen);
	UniverseID GetPlayerContainerID(void);
	UniverseID GetPlayerID(void);
	UniverseID GetPlayerOccupiedShipID(void);
	uint32_t GetRequestedMissionWares(MissionWareDeliveryCounts* result, uint32_t resultlen, UniverseID containerid);
	const char* GetSubordinateGroupAssignment(UniverseID controllableid, int group);
	uint32_t GetSubordinatesOfGroup(UniverseID* result, uint32_t resultlen, UniverseID commanderid, int group);
	bool GetSyncPointAutoRelease(uint32_t syncid, bool checkall);
	bool GetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool checkall);
	Position2D GetUIAnchorScreenPosition(const char* presentationid, uint32_t index, PosRot additionaloffset);
	uint32_t GetUpgradeGroups2(UpgradeGroup2* result, uint32_t resultlen, UniverseID destructibleid, const char* macroname);
	UniverseID GetUpgradeSlotCurrentComponent(UniverseID destructibleid, const char* upgradetypename, size_t slot);
	UpgradeGroup GetUpgradeSlotGroup(UniverseID destructibleid, const char* macroname, const char* upgradetypename, size_t slot);
	float GetTextWidth(const char*const text, const char*const fontname, const float fontsize);
	UniverseID GetTopLevelContainer(UniverseID componentid);
	UniverseID GetTowedObject(UniverseID shipid);
	uint32_t GetVenturePlatformDocks(UniverseID* result, uint32_t resultlen, UniverseID ventureplatformid);
	uint32_t GetVenturePlatforms(UniverseID* result, uint32_t resultlen, UniverseID defensibleid);
	uint32_t GetWares(const char** result, uint32_t resultlen, const char* tags, bool research, const char* licenceownerid, const char* exclusiontags);
	bool HasContainerFreeInternalShipStorage(UniverseID containerid, UniverseID shipid);
	bool HasContainerProcessingModule(UniverseID containerid);
	bool HasFactionShipyard(const char* factionid);
	bool HasFactionWharf(const char* factionid);
	bool HasSubordinateAssignment(UniverseID controllableid, const char* assignment);
	bool HasVenturerDock(UniverseID containerid, UniverseID shipid, UniverseID ventureplatformid);
	bool IsBuilderBusy(UniverseID shipid);
	bool IsComponentWrecked(const UniverseID componentid);
	bool IsDefensibleBeingBoardedBy(UniverseID defensibleid, const char* factionid);
	bool IsExternalViewDisabled();
	bool IsFleetManagerPlayerEnabled(void);
	bool IsMissionLimitReached(bool includeupkeep, bool includeguidance, bool includeplot);
	bool IsMouseEmulationActive(void);
	bool IsObjectKnown(const UniverseID componentid);
	bool IsOrderLoopable(const char* orderdefid);
	bool IsPlayerCameraTargetViewPossible(UniverseID targetid, bool force);
	bool IsShipAtExternalDock(UniverseID shipid);
	bool IsSurfaceElement(const UniverseID componentid);
	bool IsUnit(UniverseID controllableid);
	void LaunchLaserTower(UniverseID defensibleid, const char* lasertowermacroname);
	void LaunchMine(UniverseID defensibleid, const char* minemacroname);
	void LaunchNavBeacon(UniverseID defensibleid, const char* navbeaconmacroname);
	void LaunchResourceProbe(UniverseID defensibleid, const char* resourceprobemacroname);
	void LaunchSatellite(UniverseID defensibleid, const char* satellitemacroname);
	void MakePlayerOwnerOf(UniverseID objectid);
	void MovePlayerToSectorPos(UniverseID sectorid, UIPosRot position);
	void NotifyInteractMenuHidden(const uint32_t id, const bool allclosed);
	void NotifyInteractMenuShown(const uint32_t id);
	bool PerformCompSlotPlayerAction(UIComponentSlot compslot, uint32_t actionid);
	void PutShipIntoStorage(UniverseID containerid, UniverseID shipid);
	void ReassignControllableToFleetUnit(UniverseID controllableid, FleetUnitID commanderfleetunitid, int32_t subordinategroupid);
	void ReleaseOrderSyncPoint(uint32_t syncid);
	void ReleaseOrderSyncPointFromOrder(UniverseID controllableid, size_t idx);
	bool RemoveCommander2(UniverseID controllableid);
	void RemoveFleetUnit(FleetUnitID fleetunitid);
	bool RemoveOrder(UniverseID controllableid, size_t idx, bool playercancelled, bool checkonly);
	bool RequestDockAt(UniverseID containerid, bool checkonly);
	const char* RequestDockAtReason(UniverseID containerid, bool checkonly);
	bool RequestShipFromInternalStorage2(UniverseID shipid, bool highpriority, UniverseID refcomponentid);
	void ResetOrderLoop(UniverseID controllableid);
	void SelfDestructComponent(UniverseID componentid);
	void SetAllDronesArmed(UniverseID defensibleid, bool arm);
	void SetDockingBayReservation(UniverseID dockingbayid, double duration);
	void SetFleetManagement(UniverseID controllableid, bool enable);
	void SetFleetUnitCommander(FleetUnitID fleetunitid, UniverseID commanderid, FleetUnitID commanderfleetunitid, int32_t subordinategroupid);
	void SetFleetUnitSubordinateGroupAssignment(FleetUnitID fleetunitid, int group, const char* assignment);
	UIFormationInfo SetFormationShape(UniverseID objectid, const char* formationshape);
	void SetGroupAndAssignment(UniverseID controllableid, int group, const char* assignment);
	void SetGuidance(UniverseID componentid, UIPosRot offset);
	void SetMouseCursorPosition(const int32_t posx, const int32_t posy);
	void SetPlayerCameraCinematicView(UniverseID componentid);
	void SetRelationBoostToFaction(UniverseID componentid, const char* factionid, const char* reasonid, float boostvalue, float decayrate, double decaydelay);
	bool SetSofttarget(UniverseID componentid, const char*const connectionname);
	void SetSubordinateGroupAssignment(UniverseID controllableid, int group, const char* assignment);
	void SetSubordinateGroupAttackOnSight(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupProtectedLocation(UniverseID controllableid, int group, UniverseID sectorid, UIPosRot offset);
	void SetSubordinateGroupReinforceFleet(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupRespondToDistressCalls(UniverseID controllableid, int group, bool value);
	void SetSubordinateGroupResupplyAtFleet(UniverseID controllableid, int group, bool value);
	void SetSyncPointAutoRelease(uint32_t syncid, bool all, bool any);
	void SetSyncPointAutoReleaseFromOrder(UniverseID controllableid, size_t orderidx, bool all, bool any);
	void SetTrackedMenuFullscreen(const char* menu, bool fullscreen);
	bool ShouldSubordinateGroupAttackOnSight(UniverseID controllableid, int group);
	bool ShouldSubordinateGroupReinforceFleet(UniverseID controllableid, int group);
	bool ShouldSubordinateGroupRespondToDistressCalls(UniverseID controllableid, int group);
	bool ShouldSubordinateGroupResupplyAtFleet(UniverseID controllableid, int group);
	void SpawnObjectAtPos(const char* macroname, UniverseID sectorid, UIPosRot offset);
	void StartPlayerActivity(const char* activityid);
	void StopPlayerActivity(const char* activityid);
	bool TakeShipFromInternalStorage(UniverseID shipid, bool highpriority, bool checkonly);
	bool TeleportPlayerTo(UniverseID controllableid, bool allowcontrolling, bool instant, bool force);
]]

local utf8 = require("utf8")

local menu = {
	name = "InteractMenu",
	selectedRows = {},
	topRows = {},
	selectedplayerships = {},
}

local config = {
	layer = 2,
	width = 260,
	rowHeight = 16,
	entryFontSize = Helper.standardFontSize,
	entryX = 3,
	mouseOutRange = 100,
	border = Helper.frameBorder,
	subsectionDelay = 0.5,

	sections = {
		{ id = "behaviourinspection",	text = "",						skippable = false },
		{ id = "main",					text = "",						isorder = false },
		{ id = "interaction",			text = ReadText(1001, 7865),	isorder = false },
		{ id = "hiringbuilderoption",	text = "",						isorder = false,	subsections = {
			{ id = "hiringbuilder",		text = ReadText(1001, 7873) },
			{ id = "assigningbuilder",	text = ReadText(1001, 11141) },
		}},
		{ id = "trade",					text = ReadText(1001, 7104),	isorder = false },

		-- mycu start: add custom actions group
		{ id = "custom_actions",	text = ReadText(101475, 100),		isorder = false,	subsections = {}},
		-- mycu end: add custom actions group

		{ id = "playersquad_orders",	text = ReadText(1001, 1002),	isorder = false },	-- Broadcast
		{ id = "overrideorderoption",	text = ReadText(1001, 11118),	isorder = false,	subsections = {
			{ id = "overrideorder",		text = ReadText(1001, 11248) },
		}},
		{ id = "main_orders",			text = ReadText(1001, 7802),	isorder = false },
		{ id = "formationshapeoption",	text = "",						isorder = false,	subsections = {
			{ id = "formationshape",	text = ReadText(1001, 7862) },
		}},
		{ id = "main_assignments",		text = ReadText(1001, 7803),	isorder = false },
		{ id = "main_assignments_subsections",	text = ReadText(1001, 7805),	isorder = false,	subsections = {
			{ id = "main_assignments_defence",				text = ReadText(20208, 40304),	helpOverlayID = "interactmenu_change_assign_defence",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_positiondefence",		text = ReadText(20208, 41504),	helpOverlayID = "interactmenu_change_assign_positiondefence",		helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_attack",				text = ReadText(20208, 40904),	helpOverlayID = "interactmenu_change_assign_attack",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_interception",			text = ReadText(20208, 41004),	helpOverlayID = "interactmenu_change_assign_interception",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_bombardment",			text = ReadText(20208, 41604),	helpOverlayID = "interactmenu_change_assign_bombardment",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_follow",				text = ReadText(20208, 41304),	helpOverlayID = "interactmenu_change_assign_follow",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_supplyfleet",			text = ReadText(20208, 40704),	helpOverlayID = "interactmenu_change_assign_supplyfleet",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_mining",				text = ReadText(20208, 40204),	helpOverlayID = "interactmenu_change_assign_mining",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_trade",				text = ReadText(20208, 40104),	helpOverlayID = "interactmenu_change_assign_trade",					helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804),	helpOverlayID = "interactmenu_change_assign_tradeforbuildstorage",	helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_assist",				text = ReadText(20208, 41204),	helpOverlayID = "interactmenu_change_assign_assist",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "main_assignments_salvage",				text = ReadText(20208, 41404),	helpOverlayID = "interactmenu_change_assign_salvage",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
		}},
		{ id = "order",					text = "",						isorder = nil },
		{ id = "syncpoint",				text = "",						isorder = nil },
		{ id = "intersectordefencegroup",	text = "",					isorder = nil },
		{ id = "guidance",				text = "",						isorder = nil,		isplayerinteraction = true },
		{ id = "player_interaction",	text = ReadText(1001, 7843),	isorder = false,	isplayerinteraction = true },
		{ id = "consumables",			text = ReadText(1001, 7846),	isorder = false,	subsections = {
			{ id = "consumables_civilian",	text = ReadText(1001, 7847) },
			{ id = "consumables_military",	text = ReadText(1001, 7848) },
		}},
		{ id = "venturereport",			text = ReadText(1001, 12110),	isorder = false },
		{ id = "cheats",				text = "Cheats",				isorder = false }, -- (cheat only)
		{ id = "selected_orders_all",	text = ReadText(1001, 7804),	isorder = true,		showloop = true,		allowmultiloop = true },
		{ id = "selected_orders",		text = ReadText(1001, 7804),	isorder = true,		showloop = true },
		{ id = "mining_orders",			text = "",						isorder = true,		showloop = true,		subsections = {
			{ id = "mining",			text = "\27[order_miningplayer] " .. ReadText(1041, 351), helpOverlayID = "interactmenu_mining", helpOverlayText = " ", helpOverlayHighlightOnly = true },
		}},
		{ id = "venturedockoption",		text = "",						isorder = true,		showloop = true,		subsections = {
			{ id = "venturedock",	text = "\27[order_dockandwait] " .. ReadText(1001, 7844) },
		}},
		{ id = "selected_disable",	text = "",	isorder = true,		subsections = {
			{ id = "selected_disable_attack",		text = ReadText(1001, 11128),	orderid = "Attack" },
		}},
		{ id = "trade_orders",			text = ReadText(1001, 7861),	isorder = true,		showloop = true },

		-- mycu start: add custom orders group
		{ id = "custom_orders",	text = ReadText(101475, 101),		isorder = true,	showloop = true, subsections = {}},
		-- mycu end: add custom orders group

		{ id = "selected_assignments_all", text = ReadText(1001, 7886),	isorder = true },
		{ id = "selected_change_assignments",	text = ReadText(1001, 11119),	isorder = true,		subsections = {
			{ id = "selected_change_assignments_defence",				text = ReadText(20208, 40304),	helpOverlayID = "interactmenu_change_assign_defence",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_positiondefence",		text = ReadText(20208, 41504),	helpOverlayID = "interactmenu_change_assign_positiondefence",		helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_attack",				text = ReadText(20208, 40904),	helpOverlayID = "interactmenu_change_assign_attack",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_interception",			text = ReadText(20208, 41004),	helpOverlayID = "interactmenu_change_assign_interception",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_bombardment",			text = ReadText(20208, 41604),	helpOverlayID = "interactmenu_change_assign_bombardment",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_follow",				text = ReadText(20208, 41304),	helpOverlayID = "interactmenu_change_assign_follow",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_supplyfleet",			text = ReadText(20208, 40704),	helpOverlayID = "interactmenu_change_assign_supplyfleet",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_mining",				text = ReadText(20208, 40204),	helpOverlayID = "interactmenu_change_assign_mining",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_trade",					text = ReadText(20208, 40104),	helpOverlayID = "interactmenu_change_assign_trade",					helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804),	helpOverlayID = "interactmenu_change_assign_tradeforbuildstorage",	helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_assist",				text = ReadText(20208, 41204),	helpOverlayID = "interactmenu_change_assign_assist",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_change_assignments_salvage",				text = ReadText(20208, 41404),	helpOverlayID = "interactmenu_change_assign_salvage",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
		}},
		{ id = "selected_assignments",	text = ReadText(1001, 7805),	isorder = true,		subsections = {
			{ id = "selected_assignments_defence",				text = ReadText(20208, 40304),	helpOverlayID = "interactmenu_assign_defence",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_positiondefence",		text = ReadText(20208, 41504),	helpOverlayID = "interactmenu_assign_positiondefence",		helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_attack",				text = ReadText(20208, 40904),	helpOverlayID = "interactmenu_assign_attack",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_interception",			text = ReadText(20208, 41004),	helpOverlayID = "interactmenu_assign_interception",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_bombardment",			text = ReadText(20208, 41604),	helpOverlayID = "interactmenu_assign_bombardment",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_follow",				text = ReadText(20208, 41304),	helpOverlayID = "interactmenu_assign_follow",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_supplyfleet",			text = ReadText(20208, 40704),	helpOverlayID = "interactmenu_assign_supplyfleet",			helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_mining",				text = ReadText(20208, 40204),	helpOverlayID = "interactmenu_assign_mining",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_trade",				text = ReadText(20208, 40104),	helpOverlayID = "interactmenu_assign_trade",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_tradeforbuildstorage",	text = ReadText(20208, 40804),	helpOverlayID = "interactmenu_assign_tradeforbuildstorage",	helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_assist",				text = ReadText(20208, 41204),	helpOverlayID = "interactmenu_assign_assist",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
			{ id = "selected_assignments_salvage",				text = ReadText(20208, 41404),	helpOverlayID = "interactmenu_assign_salvage",				helpOverlayText = " ",	helpOverlayHighlightOnly = true },
		}},
		{ id = "selected_consumables",	text = ReadText(1001, 7849),	isorder = true,		subsections = {
			{ id = "selected_consumables_civilian",	text = "\27[order_deployobjectatposition] " .. ReadText(1001, 7847) },
			{ id = "selected_consumables_military",	text = "\27[order_deployobjectatposition] " .. ReadText(1001, 7848) },
		}},
		{ id = "shipconsole",			text = "",						isorder = false },
	},

	assignments = {
		["defence"]					= { name = ReadText(20208, 40304) },
		["positiondefence"]			= { name = ReadText(20208, 41504) },
		["attack"]					= { name = ReadText(20208, 40904) },
		["interception"]			= { name = ReadText(20208, 41004) },
		["bombardment"]				= { name = ReadText(20208, 41604) },
		["follow"]					= { name = ReadText(20208, 41304) },
		["supplyfleet"]				= { name = ReadText(20208, 40704) },
		["mining"]					= { name = ReadText(20208, 40204) },
		["trade"]					= { name = ReadText(20208, 40104) },
		["tradeforbuildstorage"]	= { name = ReadText(20208, 40804) },
		["assist"]					= { name = ReadText(20208, 41204) },
		["salvage"]					= { name = ReadText(20208, 41401) },
	},

	buildStationModeAllowedActions = {
		["configurestation"] = true,
		["removebuildstorage"] = true,
	}
}

-- kuertee start:
menu.uix_callbacks = {}
-- kuertee end

local function init()
	Menus = Menus or { }
	table.insert(Menus, menu)
	if Helper then
		Helper.registerMenu(menu)
	end

	RegisterEvent("hideInteractMenu", function () menu.onCloseElement("auto") end)

	-- kuertee start:
	menu.init_kuertee()
	-- kuertee end
end

-- kuertee start:
function menu.init_kuertee ()
	RegisterEvent ("Interact_Menu_API.Add_Custom_Actions_Group_Id", menu.Add_Custom_Actions_Group_Id)
	RegisterEvent ("Interact_Menu_API.Add_Custom_Actions_Group_Text", menu.Add_Custom_Actions_Group_Text)
	RegisterEvent ("Interact_Menu_API.Existence_Query", menu.Existence_Query)
end
-- kuertee end

function menu.cleanup()
	menu.mode = nil
	menu.interactMenuID = nil
	menu.componentSlot = nil
	menu.connection = nil
	menu.componentOrder = nil
	menu.syncpoint = nil
	menu.syncpointorder = nil
	menu.intersectordefencegroup = nil
	menu.mission = nil
	menu.componentMissions = nil
	menu.missionoffer = nil
	menu.construction = nil
	menu.fleetunit = nil
	menu.replacingcontrollable = nil
	menu.selectedfleetunit = nil
	menu.selectedreplacingcontrollable = nil
	menu.subordinategroup = nil
	menu.selectedplayerships = {}
	menu.selectedotherobjects = {}
	menu.selectedplayerdeployables = {}
	menu.playerSquad = {}
	menu.removedOccupiedPlayerShip = nil
	menu.showPlayerInteractions = nil
	menu.offsetcomponent = nil
	menu.offset = nil
	menu.mouseX = nil
	menu.mouseY = nil
	menu.dockingbayReserveTime = nil
	menu.isdockedship = nil
	menu.shipswithcurrentcommander = {}
	menu.groupShips = {}

	menu.subsection = nil
	menu.pendingSubSection = nil
	menu.possibleorders = {}
	menu.numdockingpossible = nil
	menu.numremovableorders = nil
	menu.numwaitingforsignal = nil
	menu.numdockingatplayerpossible = nil
	menu.numshipswithcommander = nil
	menu.actions = {}
	menu.holomapcolor = {}
	menu.texts = {}
	menu.colors = {}

	menu.contentTable = nil
	menu.currentOverTable = nil
	menu.selectedRows = {}
	menu.topRows = {}
	menu.mouseOutBox = {}
	menu.wasMonitorAdjusted = {}
	menu.forceSubSectionToLeft = nil

	Helper.ffiClearNewHelper()

	-- kurtee start: multi-rename
	menu.uix_multiRename_removedActionTarget = nil
	-- kurtee end: multi-rename
end

-- perform helpers

function menu.orderAssignCommander(component, commander, assignment, group, informfleetmanager)
	if (not C.IsOrderSelectableFor("AssignCommander", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	local orderindex = C.CreateOrder(component, "AssignCommander", false)
	if orderindex > 0 then
		-- commander
		SetOrderParam(component, orderindex, 1, nil, ConvertStringToLuaID(tostring(commander)))
		-- assignment
		SetOrderParam(component, orderindex, 2, nil, assignment)
		-- subordinategroup
		SetOrderParam(component, orderindex, 3, nil, group)
		-- setgroupassignment
		SetOrderParam(component, orderindex, 4, nil, true)
		-- cancelorders
		SetOrderParam(component, orderindex, 5, nil, true)
		-- response
		SetOrderParam(component, orderindex, 6, nil, true)
		-- informfleetmanager
		if informfleetmanager == nil then
			informfleetmanager = true
		end
		SetOrderParam(component, orderindex, 8, nil, informfleetmanager)

		C.EnableOrder(component, orderindex)
		if orderindex ~= 1 then
			C.AdjustOrder(component, orderindex, 1, true, false, false)
		end
	end
end

function menu.orderAttack(component, target, clear, immediate)
	if (not C.IsOrderSelectableFor("Attack", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder3(component, "Attack", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderAttackInRange(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("AttackInRange", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "AttackInRange", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderAttackSurfaceElements(component, target, targetclasses, clear)
	if (not C.IsOrderSelectableFor("Attack", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	local orderidx = C.CreateOrder(component, "Attack", false)
	if orderidx > 0 then
		-- primarytarget
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		-- disable
		SetOrderParam(component, orderidx, 8, nil, true)
		-- disablehullpercentagethreshold
		SetOrderParam(component, orderidx, 9, nil, 100)
		-- behaviortargetclasses
		SetOrderParam(component, orderidx, 16, nil, targetclasses)
		-- debugchance
		--SetOrderParam(component, orderidx, 25, nil, 100)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderCollect(component, drop, sector, offset, clear)
	if (not C.IsOrderSelectableFor("Collect", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Collect", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, 0, ConvertStringToLuaID(tostring(drop)) )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectDeployable(component, deployable, sector, offset, clear)
	if (not C.IsOrderSelectableFor("CollectDeployables", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDeployables", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(deployable)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectLockbox(component, lockbox, clear)
	if (not C.IsOrderSelectableFor("CollectLockbox", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectLockbox", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, 0, ConvertStringToLuaID(tostring(lockbox)) )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderCollectRadius(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("CollectDropsInRadius", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "CollectDropsInRadius", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDeployAtPosition(component, sector, offset, macro, amount, clear)
	if (not C.IsOrderSelectableFor("DeployObjectAtPosition", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DeployObjectAtPosition", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		SetOrderParam(component, orderidx, 2, 0, macro )
		SetOrderParam(component, orderidx, 3, 0, amount )

		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDeployToStation(component, station, clear)
	if (not C.IsOrderSelectableFor("DeployToStation", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateDeployToStationOrder(component)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(station)))
		C.EnableOrder(component, orderidx)
	end
end

function menu.orderDepositInventoryAtHQ(component, clear)
	if (not C.IsOrderSelectableFor("DepositInventory", component)) or (not GetComponentData(ConvertStringTo64Bit(tostring(component)), "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DepositInventory", false)
	if orderidx > 0 then
		-- we can optionally set a destination here, but we only support transferring inventory items to/from the player HQ at the moment using this method. order defaults to deposit at the player HQ, if it exists.
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderDock(component, target, clear, ventureplatform)
	if (not C.IsOrderSelectableFor("DockAndWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "DockAndWait", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		if ventureplatform then
			SetOrderParam(component, orderidx, 5, nil, ConvertStringToLuaID(tostring(ventureplatform)))
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderExplore(component, sectororgate, sector, offset, clear)
	if (not C.IsOrderSelectableFor("Explore", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Explore", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(sectororgate)) )
		if C.IsComponentClass(sectororgate, "sector") or (C.IsComponentClass(sectororgate, "gate") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			SetOrderParam(component, orderidx, 2, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderExploreUpdate(component, sectororgate, sector, offset, clear)
	if (not C.IsOrderSelectableFor("ExploreUpdate", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "ExploreUpdate", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(sectororgate)) )
		if C.IsComponentClass(sectororgate, "sector") or (C.IsComponentClass(sectororgate, "gate") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			SetOrderParam(component, orderidx, 2, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		end
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderFollow(component, targetobject, clear)
	if (not C.IsOrderSelectableFor("Follow", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Follow", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(targetobject)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderGetSupplies(component, clear)
	if (not C.IsOrderSelectableFor("GetSupplies", component)) or (not GetComponentData(ConvertStringTo64Bit(tostring(component)), "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "GetSupplies", false)
	if orderidx > 0 then
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderMining(component, ware, sector, offset, clear)
	if (not C.IsOrderSelectableFor("MiningPlayer", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx
	if GetWareCapacity(component, ware, true) > 0 then
		orderidx = C.CreateOrder(component, "MiningPlayer", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
			SetOrderParam(component, orderidx, 3, nil, ware)
			C.EnableOrder(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderMoveWait(component, sector, offset, targetobject, playerprecise, clear)
	if (not C.IsOrderSelectableFor("MoveWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx
	if not C.IsComponentClass(targetobject, "sector") then
		orderidx = C.CreateOrder(component, "MoveToObject", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(targetobject)))
		end
	else
		orderidx = C.CreateOrder(component, "MoveWait", false)
		if orderidx > 0 then
			SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y,offset.z} })
			if playerprecise then
				SetOrderParam(component, orderidx, 5, nil, true)
			end
		end
	end
	if orderidx > 0 then
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderPlayerDockToTrade(component, target, clear)
	if (not C.IsOrderSelectableFor("Player_DockToTrade", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "Player_DockToTrade", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderProtect(component, target, clear)
	if (not C.IsOrderSelectableFor("ProtectStation", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "ProtectStation", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderRemove(ship, removedefaultorder, removeassignment, removedockorder)
	local numorders = C.GetNumOrders(ship)
	local currentorders = ffi.new("Order[?]", numorders)
	numorders = C.GetOrders(currentorders, numorders, ship)
	local assigncommanderfound = false
	for i = numorders, 1, -1 do
		local isdocked, isdocking = GetComponentData(ConvertStringTo64Bit(tostring(ship)), "isdocked", "isdocking")
		local orderdef = ffi.string(currentorders[i - 1].orderdef)
		if (i == 1) and ((orderdef == "DockAndWait") and (isdocked or isdocking)) and (not removedockorder) then
			-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
		elseif (not removeassignment) and (not assigncommanderfound) and (orderdef == "AssignCommander") then
			-- keep the last assign commander order unless we are removing assignments
			assigncommanderfound = true
		else
			C.RemoveOrder(ship, i, false, false)
		end
	end
	if removedefaultorder then
		C.ResetOrderLoop(ship)
		local currentdefaultorder = ffi.new("Order")
		if C.GetDefaultOrder(currentdefaultorder, ship) then
			if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
				C.CreateOrder(ship, "Wait", true)
				C.EnablePlannedDefaultOrder(ship, false)
			end
		end
	end
	if removeassignment then
		C.RemoveCommander2(ship)
		C.CreateOrder(ship, "Wait", true)
		C.EnablePlannedDefaultOrder(ship, false)
	end
end

function menu.orderRescueInRange(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("RescueInRange", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "RescueInRange", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderRescueShip(component, targetobject, clear)
	if (not C.IsOrderSelectableFor("RescueShip", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "RescueShip", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(targetobject)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageCollect(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageCollect", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageCollect", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageCrush(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageCrush", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageCrush", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageDeliver(component, target, tradeoffer, amount, clear)
	if (not C.IsOrderSelectableFor("SalvageDeliver", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	AddTradeToShipQueue(tradeoffer, ConvertStringTo64Bit(tostring(component)), amount, false, true)
end

function menu.orderSalvageDeliver_NoTrade(component, target, clear)
	if (not C.IsOrderSelectableFor("SalvageDeliver_NoTrade", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageDeliver_NoTrade", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderSalvageInRadius(component, sector, offset, clear)
	if (not C.IsOrderSelectableFor("SalvageInRadius", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder(component, "SalvageInRadius", false)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sector)), {offset.x, offset.y, offset.z} } )
		C.EnableOrder(component, orderidx)
	end

	return orderidx
end

function menu.orderStopAndHoldFire(component, clear, immediate)
	if (not C.IsOrderSelectableFor("Wait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	-- ship will stop and hold fire.
	-- params: 1: timeout, 2: allowdocked, 3: holdfire, 4: debugchance
	local orderidx = C.CreateOrder3(component, "Wait", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, clear and 0 or 3600)
		SetOrderParam(component, orderidx, 3, nil, true)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderTacticalAttack(component, target, clear, immediate)
	if (not C.IsOrderSelectableFor("TacticalOrder", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end
	local orderidx = C.CreateOrder3(component, "TacticalOrder", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(component, orderidx, 1, nil, ConvertStringToLuaID(tostring(target)))
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderWithdrawAndHold(component, clear, immediate)
	if (not C.IsOrderSelectableFor("MoveWait", component)) or (not GetComponentData(component, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(component)
	end

	local pos = ffi.new("UIPosRot")
	pos = C.GetObjectPositionInSector(component)
	local sectorid = GetComponentData(component, "sectorid")
	if sectorid then
		sectorid = ConvertIDTo64Bit(sectorid)
	end

	-- ship will hold fire and withdraw from combat, then hold position.
	-- params: 1: destination, 2: timeout, 3: withdraw, 4: debugchance
	local orderidx = C.CreateOrder3(component, "MoveWait", false, immediate, immediate)
	if orderidx > 0 then
		-- HACK: MoveWait requires a destination but does not use it when $withdraw is true
		SetOrderParam(component, orderidx, 1, nil, { ConvertStringToLuaID(tostring(sectorid)), {pos.x, pos.y, pos.z} })
		SetOrderParam(component, orderidx, 2, nil, clear and 0 or 3600)
		SetOrderParam(component, orderidx, 3, nil, true)
		C.EnableOrder(component, orderidx)
		if immediate then
			menu.setOrderImmediate(component, orderidx)
		end
	end

	return orderidx
end

function menu.orderWithdrawFromCombat(component, clear, immediate, attacker)
	local convertedComponent = ConvertStringTo64Bit(tostring(component))
	if (not C.IsOrderSelectableFor("Flee", convertedComponent)) or (not GetComponentData(convertedComponent, "assignedpilot")) then
		return
	end

	if clear then
		C.RemoveAllOrders(convertedComponent)
	end

	-- ship will hold fire and withdraw from combat.
	-- params: 1: method ('boost','maneuver','highway','dock'), 2: return, 3: donotdrop, 4: deploydistraction, 5: holdfire, 6: attacker, 7: maxboostdistance, 8: maxboostduration, 9: log, 10: debugchance
	local orderidx = C.CreateOrder3(convertedComponent, "Flee", false, immediate, immediate)
	if orderidx > 0 then
		SetOrderParam(convertedComponent, orderidx, 1, nil, 'boost')
		SetOrderParam(convertedComponent, orderidx, 3, nil, true)
		SetOrderParam(convertedComponent, orderidx, 4, nil, true)
		if attacker then
			SetOrderParam(convertedComponent, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
		end
		C.EnableOrder(convertedComponent, orderidx)
		if immediate then
			menu.setOrderImmediate(convertedComponent, orderidx)
		end
	end

	return orderidx
end

-- other helpers

function menu.plotCourse(object, offset)
	local convertedObject = ConvertStringToLuaID(tostring(object))
	if (object == C.GetPlayerControlledShipID()) then
		return -- no plot course to playership or when menu.mode is set
	end

	if IsSameComponent(GetActiveGuidanceMissionComponent(), convertedObject) then
		C.EndGuidance()
	else
		if offset == nil then
			offset = ffi.new("UIPosRot", 0)
		elseif C.IsComponentClass(object, "sector") then
			object = C.GetZoneAt(object, offset)
		end
		C.SetGuidance(object, offset)
	end
end

function menu.canCollectCrates(haspilot)
	local iscapship = false
	local hascollector = false
	if haspilot then
		for _, ship in ipairs(menu.selectedplayerships) do
			iscapship = C.IsComponentClass(ship, "ship_l") or C.IsComponentClass(ship, "ship_xl")
			if iscapship then
				hascollector = (C.GetNumStoredUnits(ship, "transport", false) > 0)
			end

			if not iscapship or hascollector then
				break
			end
		end
	end

	local active = haspilot and (not iscapship or hascollector)
	local reason = ""
	if iscapship and not hascollector then
		reason = ReadText(1026, 20014)
	elseif not haspilot then
		reason = ReadText(1026, 7830)
	end
	--print("menu.canCollectCrates. active: " .. tostring(active) .. ", mouseovertext: " .. tostring(reason))
	return active, reason
end

function menu.canSalvage(haspilot)
	local istug = false
	local hasbuilder = false
	if haspilot then
		for _, ship in ipairs(menu.selectedplayerships) do
			istug = (GetComponentData(ship, "shiptype") == "tug")
			if not istug then
				hasbuilder = (C.GetNumStoredUnits(ship, "build", false) > 0)
			end

			if istug or hasbuilder then
				break
			end
		end
	end

	local active = haspilot and (istug or hasbuilder)
	local reason = ""
	if not istug and not hasbuilder then
		reason = ReadText(1026, 20029)
	elseif not haspilot then
		reason = ReadText(1026, 7830)
	end
	--print("menu.canSalvage. active: " .. tostring(active) .. ", mouseovertext: " .. tostring(reason))
	return active, reason
end

function menu.getCanCancelConstructionCount()
	local count = 0
	for _, id in ipairs(menu.construction.ids) do
		if C.CanCancelConstruction(menu.componentSlot.component, id) then
			count = count + 1
		end
	end
	return count
end

-- widget scripts

function menu.buttonActivateDeployables(isactive)
	for _, deployable in ipairs(menu.selectedplayerdeployables) do
		if GetComponentData(deployable, "isactive") == isactive then
			C.ActivateObject(deployable, not isactive)
		end
	end
	menu.onCloseElement("close")
end

function menu.buttonSelfDestructDeployables(selecteddeployable)
	if selecteddeployable then
		C.SelfDestructComponent(selecteddeployable)
	else
		for _, deployable in ipairs(menu.selectedplayerdeployables) do
			C.SelfDestructComponent(deployable)
		end
	end
	menu.onCloseElement("close")
end

function menu.buttonArmTurrets(armed)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")

	if isplayerownedtarget and C.IsComponentClass(menu.componentSlot.component, "ship") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isdeployable")) then
		C.SetAllTurretsArmed(menu.componentSlot.component, armed)
	end
	for _, ship in ipairs(menu.selectedplayerships) do
		C.SetAllTurretsArmed(ship, armed)
	end

	menu.onCloseElement("close")
end

function menu.buttonAssignCommander(assignment, group)
	if menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")

		local playeroccupiedship = C.GetPlayerOccupiedShipID()
		local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(playeroccupiedship, group))
		if assignment == "positiondefence" and oldassignment ~= "positiondefence" then
			Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(playeroccupiedship)), group)
		end

		C.ResetOrderLoop(menu.componentSlot.component)
		menu.orderAssignCommander(convertedComponent, playeroccupiedship, assignment, group)
	else
		if menu.fleetunit then
			C.SetFleetUnitSubordinateGroupAssignment(menu.fleetunit, group, assignment)

			local replacingcontrollable64
			if menu.replacingcontrollable then
				replacingcontrollable64 = ConvertStringTo64Bit(tostring(menu.replacingcontrollable))

				if assignment == "positiondefence" then
					Helper.setIntersectorDefence(replacingcontrollable64, group)
				end
			end

			for _, ship in ipairs(menu.selectedplayerships) do
				local skip = false
				if not GetComponentData(ship, "assignedpilot") then
					skip = true
				elseif GetComponentData(ship, "primarypurpose") == "mine" then
					if assignment == "tradeforbuildstorage" then
						skip = true
					end
				else
					if assignment == "mining" then
						skip = true
					end
				end
				if not skip then
					C.ResetOrderLoop(ship)
					C.AddFleetUnitSubordinate(menu.fleetunit, ship, 0, group)

					if menu.replacingcontrollable then
						if ship ~= replacingcontrollable64 then
							menu.orderAssignCommander(ship, replacingcontrollable64, assignment, group, false)
						end
					end
				end
			end
		elseif C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
			local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")

			local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, group))
			if assignment == "positiondefence" and oldassignment ~= "positiondefence" then
				Helper.setIntersectorDefence(convertedComponent, group)
			end

			for _, ship in ipairs(menu.selectedplayerships) do
				if (convertedComponent ~= ship) and isplayerownedtarget then
					local skip = false
					if not GetComponentData(ship, "assignedpilot") then
						skip = true
					elseif GetComponentData(ship, "primarypurpose") == "mine" then
						if assignment == "tradeforbuildstorage" then
							skip = true
						end
					else
						if assignment == "mining" then
							skip = true
						end
					end
					if not skip then
						C.ResetOrderLoop(ship)
						menu.orderAssignCommander(ship, menu.componentSlot.component, assignment, group)
					end
				end
			end
		end
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.clearExtraSubordinates(selectedfleetunit, selectedreplacingcomponent)
	-- find all subordinates of the re-assigned fleetunit
	local subordinates = {}
	local n = C.GetNumAllFleetUnitSubordinates(selectedfleetunit)
	if n > 0 then
		local buf = ffi.new("UniverseID[?]", n)
		n = C.GetAllFleetUnitSubordinates(buf, n, selectedfleetunit)
		for i = 0, n - 1 do
			subordinates[ConvertStringTo64Bit(tostring(buf[i]))] = true
		end
	end

	local newreplacementcomponent
	local oldcommander = GetCommander(selectedreplacingcomponent)
	local oldgroup = GetComponentData(selectedreplacingcomponent, "subordinategroup")
	local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(C.ConvertStringTo64Bit(tostring(oldcommander)), oldgroup))

	-- find all subordinates of selectedreplacingcontrollable that is not a subordinate of the fleet unit
	local commandersubordinates = GetSubordinates(selectedreplacingcomponent)
	for _, commandersubordinate in ipairs(commandersubordinates) do
		local commandersubordinate64 = ConvertStringTo64Bit(tostring(commandersubordinate))
		if not subordinates[commandersubordinate64] then
			if not newreplacementcomponent then
				-- promote the first such subordinate to be the new replacing subordinate
				menu.orderAssignCommander(commandersubordinate64, oldcommander, oldassignment, oldgroup, false)
				newreplacementcomponent = commandersubordinate
			else
				-- assign all other subordinates to the new replacing one
				local currentgroup = GetComponentData(commandersubordinate, "subordinategroup")
				local currentassignment = ffi.string(C.GetSubordinateGroupAssignment(selectedreplacingcomponent, currentgroup))
				menu.orderAssignCommander(commandersubordinate64, newreplacementcomponent, currentassignment, currentgroup)
			end
		end
	end
end

function menu.buttonAssignFleetUnitCommander(assignment, group)
	if menu.fleetunit then
		local unitinfo = C.GetFleetUnitInfo(menu.selectedfleetunit)
		local primarypurpose = GetMacroData(ffi.string(unitinfo.macro), "primarypurpose")

		local skip = false
		if primarypurpose == "mine" then
			if assignment == "tradeforbuildstorage" then
				skip = true
			end
		else
			if assignment == "mining" then
				skip = true
			end
		end
		if not skip then
			C.SetFleetUnitSubordinateGroupAssignment(menu.fleetunit, group, assignment)
			C.SetFleetUnitCommander(menu.selectedfleetunit, 0, menu.fleetunit, group)

			if menu.selectedreplacingcontrollable then
				local replacingComponent = ConvertStringTo64Bit(tostring(menu.selectedreplacingcontrollable))
				menu.clearExtraSubordinates(menu.selectedfleetunit, replacingComponent)

				-- re-assign the selectedreplacingcontrollable with the remaining subordinates to the replacingcomponent of the new commander fleet unit
				if menu.replacingcontrollable then
					local convertedComponent = ConvertStringTo64Bit(tostring(menu.replacingcontrollable))
					menu.orderAssignCommander(replacingComponent, convertedComponent, assignment, group, false)
				end
			end
		end
	else
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		local isplayerownedtarget = GetComponentData(convertedComponent, "isplayerowned")

		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local oldassignment = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, group))
			if assignment == "positiondefence" and oldassignment ~= "positiondefence" then
				Helper.setIntersectorDefence(convertedComponent, group)
			end

			local unitinfo = C.GetFleetUnitInfo(menu.selectedfleetunit)
			local primarypurpose = GetMacroData(ffi.string(unitinfo.macro), "primarypurpose")

			local skip = false
			if primarypurpose == "mine" then
				if assignment == "tradeforbuildstorage" then
					skip = true
				end
			else
				if assignment == "mining" then
					skip = true
				end
			end
			if not skip then
				C.SetSubordinateGroupAssignment(menu.componentSlot.component, group, assignment)
				C.SetFleetUnitCommander(menu.selectedfleetunit, menu.componentSlot.component, 0, group)

				if menu.selectedreplacingcontrollable then
					local replacingComponent = ConvertStringTo64Bit(tostring(menu.selectedreplacingcontrollable))
					menu.clearExtraSubordinates(menu.selectedfleetunit, replacingComponent)

					-- re-assign the selectedreplacingcontrollable with the remaining subordinates to the new commander of the selected fleetunit
					menu.orderAssignCommander(replacingComponent, convertedComponent, assignment, group, false)
				end
			end
		end
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonAttack(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttack(ship, menu.componentSlot.component, clear, false)
	end

	menu.onCloseElement("close")
end

function menu.buttonAttackInRange()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttackInRange(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonAttackMultiple(clear)
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "attackmultiple", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), clear })
		menu.cleanup()
	end
end

function menu.buttonAttackSurfaceElements(target, targetclass, clear)
	local targetclasses = {}
	if targetclass == "all" then
		if C.IsComponentClass(menu.componentSlot.component, "station") then
			targetclasses = {"turret", "shieldgenerator"}
		else
			targetclasses = {"engine", "turret", "shieldgenerator"}
		end
	else
		targetclasses = {targetclass}
	end

	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderAttackSurfaceElements(ship, target, targetclasses, clear)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonBehaviourInspection()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'behaviourinspection', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "behaviourinspection", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } )
		menu.cleanup()
	end
end

function menu.buttonBoard()
	local selectedplayerships = {table.unpack(menu.selectedplayerships)}
	if menu.removedOccupiedPlayerShip then
		table.insert(selectedplayerships, menu.removedOccupiedPlayerShip)
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "boardingcontext", {ConvertStringTo64Bit(tostring(menu.componentSlot.component)), selectedplayerships} }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.interactMenuCallbacks.returnToMenu("boardingcontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), selectedplayerships } )
		Helper.resetInteractMenuCallbacks()
		menu.cleanup()
	end
end

function menu.buttonCancelConstruction()
	C.CancelConstruction(menu.componentSlot.component, menu.construction.id)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonCancelAllConstruction()
	for _, id in ipairs(menu.construction.ids) do
		if C.CanCancelConstruction(menu.componentSlot.component, id) then
			C.CancelConstruction(menu.componentSlot.component, id)
		end
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonChangeAssignment(assignment, group)
	if menu.fleetunit then
		C.SetFleetUnitSubordinateGroupAssignment(menu.fleetunit, group, assignment)

		local replacingcontrollable64
		if menu.replacingcontrollable then
			replacingcontrollable64 = ConvertStringTo64Bit(tostring(menu.replacingcontrollable))

			if assignment == "positiondefence" then
				Helper.setIntersectorDefence(replacingcontrollable64, group)
			end
		end
		if menu.groupShips and #menu.groupShips > 0 then
			for _, shipentry in ipairs(menu.groupShips) do
				if shipentry.component then
					local shipentry64 = ConvertIDTo64Bit(shipentry.component)
					C.ReassignControllableToFleetUnit(shipentry64, menu.fleetunit, group)

					if menu.replacingcontrollable then
						if shipentry64 ~= replacingcontrollable64 then
							menu.orderAssignCommander(shipentry64, replacingcontrollable64, assignment, group)
						end
					end
				else
					C.SetFleetUnitCommander(shipentry.fleetunit, 0, menu.fleetunit, group)
				end
			end
		end
	else
		if menu.shipswithcurrentcommander and #menu.shipswithcurrentcommander > 0 then
			if assignment == "positiondefence" then
				Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), group)
			end

			for _, ship in ipairs(menu.shipswithcurrentcommander) do
				menu.orderAssignCommander(ship, menu.componentSlot.component, assignment, group)
			end
		elseif menu.groupShips and #menu.groupShips > 0 then
			if assignment == "positiondefence" then
				Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), group)
			end

			for _, shipentry in ipairs(menu.groupShips) do
				if shipentry.component then
					menu.orderAssignCommander(ConvertIDTo64Bit(shipentry.component), menu.componentSlot.component, assignment, group)
				else
					C.SetSubordinateGroupAssignment(menu.componentSlot.component, group, assignment)
					C.SetFleetUnitCommander(shipentry.fleetunit, menu.componentSlot.component, 0, group)
				end
			end
		else
			local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
			local commander = C.GetCommander(menu.componentSlot.component, 0)

			if commander.fleetunitid ~= 0 then
				C.SetFleetUnitSubordinateGroupAssignment(commander.fleetunitid, group, assignment)
				C.ReassignControllableToFleetUnit(menu.componentSlot.component, commander.fleetunitid, group)

				menu.orderAssignCommander(convertedComponent, GetCommander(convertedComponent), assignment, group)
			else
				menu.orderAssignCommander(convertedComponent, commander.controllableid, assignment, group)
			end
		end
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonChangeFleetUnitAssignment(assignment, group)
	local commander = C.GetCommander(0, menu.fleetunit)
	if commander.controllableid ~= 0 then
		C.SetSubordinateGroupAssignment(commander.controllableid, group, assignment)
	else
		C.SetFleetUnitSubordinateGroupAssignment(commander.fleetunitid, group, assignment)
	end
	C.SetFleetUnitCommander(menu.fleetunit, commander.controllableid, commander.fleetunitid, group)

	if menu.replacingcontrollable then
		-- check whether the fleet units commander is a component. If not the replacingcontrollable is filling in for another
		if commander.controllableid ~= 0 then
			local convertedComponent = ConvertStringTo64Bit(tostring(menu.replacingcontrollable))
			menu.orderAssignCommander(convertedComponent, GetCommander(convertedComponent), assignment, group)
		end
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonChangeLogo()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'changelogocontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "changelogocontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } )
		menu.cleanup()
	end
end

function menu.buttonChangeOverrideOrder(idstring, attacker)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))

	-- remove all override orders
	local numorders = C.GetNumOrders(menu.componentSlot.component)
	local currentorders = ffi.new("Order2[?]", numorders)
	numorders = C.GetOrders2(currentorders, numorders, menu.componentSlot.component)
	for i = numorders, 1, -1 do
		if currentorders[i - 1].isoverride then
			C.RemoveOrder(menu.componentSlot.component, i, false, false)
		end
	end

	local orderidx
	if idstring == "Flee" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Flee", false, true, true)
		if orderidx > 0 then
			SetOrderParam(convertedComponent, orderidx, 1, nil, 'boost')
			SetOrderParam(convertedComponent, orderidx, 3, nil, true)
			SetOrderParam(convertedComponent, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 6, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Attack" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Attack", false, true, true)
		if orderidx > 0 then
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 1, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	elseif idstring == "Wait" then
		orderidx = C.CreateOrder3(menu.componentSlot.component, "Wait", false, true, true)
		if orderidx > 0 then
			SetOrderParam(convertedComponent, orderidx, 4, nil, true)
			if attacker then
				SetOrderParam(convertedComponent, orderidx, 5, nil, ConvertStringToLuaID(tostring(attacker)))
			end
		end
	end

	if orderidx > 0 then
		C.EnableOrder(menu.componentSlot.component, orderidx)
		local newidx = 1
		if not C.AdjustOrder(menu.componentSlot.component, orderidx, newidx, true, false, true) then
			newidx = 2
		end
		C.AdjustOrder(menu.componentSlot.component, orderidx, newidx, true, false, false)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonClaim(selectedship)
	C.ClaimShip(selectedship, menu.componentSlot.component)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refreshcrew")
		menu.cleanup()
	end
end

function menu.buttonCollect()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollect(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectDeployable(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectDeployable(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectDeployables(clear)
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "collectdeployables", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), clear })
		menu.cleanup()
	end
end

function menu.buttonCollectLockbox()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectLockbox(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonCollectRadius()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderCollectRadius(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonComm()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		local entities = Helper.getSuitableControlEntities(convertedComponent, true)
		Helper.closeMenuForNewConversation(menu, "default", entities[1], convertedComponent, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "comm", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))
		menu.cleanup()
	end
end

function menu.buttonCrewTransfer(othership)
	local ship = ConvertStringTo64Bit(tostring(menu.componentSlot.component))

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "crewtransfercontext", { othership, ship } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "crewtransfercontext", { othership, ship } )
		menu.cleanup()
	end
end

function menu.buttonDeliverWares(missionid)
	SignalObject(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "ware_mission_delivery", ConvertStringToLuaID(tostring(missionid)))
	menu.onCloseElement("close")
end

function menu.buttonDeploy(type, macro, amount)
	if type == "mine" then
		for i = 1, amount do
			C.LaunchMine(menu.componentSlot.component, macro)
		end
	elseif type == "navbeacon" then
		for i = 1, amount do
			C.LaunchNavBeacon(menu.componentSlot.component, macro)
		end
	elseif type == "satellite" then
		for i = 1, amount do
			C.LaunchSatellite(menu.componentSlot.component, macro)
		end
	elseif type == "lasertower" then
		for i = 1, amount do
			C.LaunchLaserTower(menu.componentSlot.component, macro)
		end
	elseif type == "resourceprobe" then
		for i = 1, amount do
			C.LaunchResourceProbe(menu.componentSlot.component, macro)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonDeployAtPosition(type, macro, amount)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderDeployAtPosition(ship, menu.offsetcomponent, menu.offset, macro, amount)
	end

	menu.onCloseElement("close")
end

function menu.buttonDeployToStation(selectedbuilder, clear, target)
	if not C.IsBuilderBusy(selectedbuilder) then
		local convertedBuilder = ConvertStringTo64Bit(tostring(selectedbuilder))
		if not GetComponentData(convertedBuilder, "isplayerowned") then
			local playermoney = GetPlayerMoney()
			local fee = tonumber(C.GetBuilderHiringFee())
			if playermoney >= fee then
				TransferPlayerMoneyTo(fee, convertedBuilder)
			else
				return
			end
		end

		local station = target or menu.componentSlot.component
		if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
			station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
		end
		menu.orderDeployToStation(convertedBuilder, station, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonDepositInventoryAtHQ()
	local convertedComponent = ConvertStringToLuaID(tostring(menu.componentSlot.component))
	local isdeployable, pilot = GetComponentData(convertedComponent, "isdeployable", "pilot")
	if (not C.IsUnit(menu.componentSlot.component)) and (not isdeployable) then
		if pilot and (pilot ~= 0) then
			if next(GetInventory(pilot)) ~= nil then
				menu.orderDepositInventoryAtHQ(menu.componentSlot.component, clear)
			end
		end
	end

	for _, ship in ipairs(menu.selectedplayerships) do
		local isdeployable, pilot = GetComponentData(ship, "isdeployable", "pilot")
		if (not C.IsUnit(ship)) and (not isdeployable) then
			if pilot and (pilot ~= 0) then
				if next(GetInventory(pilot)) ~= nil then
					menu.orderDepositInventoryAtHQ(ship, clear)
				end
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonDock(clear, ventureplatform)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local convertedVenturePlatform = ventureplatform and ConvertStringTo64Bit(tostring(ventureplatform))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent, convertedVenturePlatform) then
			menu.orderDock(ship, menu.componentSlot.component, clear, ventureplatform)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonDockAtPlayer(clear)
	local playercontainer = C.GetPlayerContainerID()
	local convertedComponent = ConvertStringTo64Bit(tostring(playercontainer))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent) then
			if C.GetContextByClass(ship, "container", false) == playercontainer then
				if (not C.IsShipAtExternalDock(ship)) and (not C.IsShipBeingRetrieved(ship)) then
					C.RequestShipFromInternalStorage2(ship, false, C.GetPlayerID())
				end
			else
				menu.orderDock(ship, playercontainer, clear)
			end
		end
	end
	if C.GetContextByClass(menu.componentSlot.component, "container", false) == playercontainer then
		if (not C.IsShipAtExternalDock(menu.componentSlot.component)) and (not C.IsShipBeingRetrieved(menu.componentSlot.component)) then
			C.RequestShipFromInternalStorage2(menu.componentSlot.component, false, C.GetPlayerID())
		end
	else
		menu.orderDock(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), playercontainer, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonDockRequest()
	local dockcontainer = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "dockingbay") then
		dockcontainer = C.GetContextByClass(dockcontainer, "container", false)
	end

	C.RequestDockAt(dockcontainer, false)

	menu.onCloseElement("close")
end

function menu.buttonDropInventory(pilot)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "dropwarescontext", { "inventory", ConvertStringToLuaID(tostring(pilot)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "dropwarescontext", { "inventory", pilot } )
		menu.cleanup()
	end
end

function menu.buttonEndGuidance()
	C.EndGuidance()
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh" )
		menu.cleanup()
	end
end

function menu.buttonExplore(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderExplore(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonExploreUpdate(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderExploreUpdate(ship, menu.componentSlot.component, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonExternal()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
	local target = 0
	if C.IsComponentClass(menu.componentSlot.component, "highway") then
		local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
		if issuperhighway then
			target = ConvertIDTo64Bit(entrygate)
		else
			target = menu.componentSlot.component
		end
	else
		target = menu.componentSlot.component
	end
	local targetsector = C.GetContextByClass(target, "sector", false)
	if (target ~= C.GetPlayerControlledShipID()) and (playersector == targetsector) then
		local success = C.SetSofttarget(menu.componentSlot.component, "")
		if success then
			PlaySound("ui_target_set")
			C.SetPlayerCameraTargetView(target, true)
		else
			PlaySound("ui_target_set_fail")
		end
	else
		PlaySound("ui_target_set_fail")
	end

	menu.onCloseElement("close")
end

function menu.buttonFlee(attacker, clear)
	menu.orderWithdrawFromCombat(menu.componentSlot.component, clear, true, attacker)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderWithdrawFromCombat(ship, clear, true, attacker)
	end

	menu.onCloseElement("close")
end

function menu.buttonFleetManagement(controllable, enable)
	C.SetFleetManagement(controllable, enable)

	menu.onCloseElement("close")
end

function menu.buttonFollow(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderFollow(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonFormationShape(shape, subordinates)
	local info = C.SetFormationShape(menu.componentSlot.component, shape)
	shape = ffi.string(info.shape)

	if (shape ~= "") then
		for i = #subordinates, 1, -1 do
			local subordinate = ConvertIDTo64Bit(subordinates[i])

			local numorders = C.GetNumOrders(subordinate)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, subordinate)
			local paramoffset = 0
			for j = 1, numorders do
				if (ffi.string(currentorders[0].orderdef) == "Escort") then
					paramoffset = 0
				elseif (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
					paramoffset = 1
				end
				if (ffi.string(currentorders[0].orderdef) == "Escort") or (ffi.string(currentorders[0].orderdef) == "SupplyFleet") then
					SetOrderParam(subordinate, j, paramoffset + 2, nil, shape) -- shape
					SetOrderParam(subordinate, j, paramoffset + 3, nil, info.radius) -- radius
					SetOrderParam(subordinate, j, paramoffset + 4, nil, info.rollMembers) -- rollmembers
					SetOrderParam(subordinate, j, paramoffset + 5, nil, info.rollFormation) -- rollformation
					SetOrderParam(subordinate, j, paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
				end
			end

			local currentdefaultorder = ffi.new("Order")
			if C.GetDefaultOrder(currentdefaultorder, subordinate) then
				if (ffi.string(currentdefaultorder.orderdef) == "Escort") then
					paramoffset = 0
				elseif (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
					paramoffset = 1
				end
				if (ffi.string(currentdefaultorder.orderdef) == "Escort") or (ffi.string(currentdefaultorder.orderdef) == "SupplyFleet") then
					SetOrderParam(subordinate, "default", paramoffset + 2, nil, shape) -- shape
					SetOrderParam(subordinate, "default", paramoffset + 3, nil, info.radius) -- radius
					SetOrderParam(subordinate, "default", paramoffset + 4, nil, info.rollMembers) -- rollmembers
					SetOrderParam(subordinate, "default", paramoffset + 5, nil, info.rollFormation) -- rollformation
					SetOrderParam(subordinate, "default", paramoffset + 6, nil, tonumber(info.maxShipsPerLine)) -- maxshipsperline
				end
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonGetSupplies()
	menu.orderGetSupplies(menu.componentSlot.component, clear)

	menu.onCloseElement("close")
end

function menu.buttonGuidance(useoffset)
	if useoffset then
		menu.plotCourse(menu.offsetcomponent, menu.offset)
	else
		menu.plotCourse(menu.componentSlot.component, nil)
	end

	menu.onCloseElement("close")
end

function menu.buttonInfo()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "info", ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "info", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) })
		menu.cleanup()
	end
end

function menu.buttonLiveStream()
	C.SetPlayerCameraCinematicView(menu.componentSlot.component)
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "close")
		menu.cleanup()
	end
end

function menu.buttonSetInterSectorDefence(groups, reset)
	local sectorid = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "sectorid")
	local pos = C.GetObjectPositionInSector(menu.componentSlot.component)

	for i = 1, 10 do
		if reset or groups[i] then
			Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), i, reset, sectorid, pos)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonStopBehaviourInspection()
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "stopbehaviourinspection" )
		menu.cleanup()
	end
end

function menu.buttonSubordinateGroupInterSectorDefence(group, reset)
	Helper.setIntersectorDefence(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), group, reset)
	menu.onCloseElement("close")
end

function menu.buttonEncyclopedia()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local macro, ismodule = GetComponentData(convertedComponent, "macro", "ismodule")

	local mode, library, id, object
	if C.IsComponentClass(menu.componentSlot.component, "sector") then
		mode = "Galaxy"
		library = ""
		object = ConvertStringToLuaID(tostring(menu.componentSlot.component))
	else
		mode = ismodule and "Stations" or "Ships"
		library = GetMacroData(macro, "infolibrary")
		id = macro
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "EncyclopediaMenu", { 0, 0, mode, library, id, object }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "EncyclopediaMenu", { 0, 0, mode, library, id, object } })
		menu.cleanup()
	end
end

function menu.buttonMarkAsHostile()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "markashostile", { menu.componentSlot.component } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "markashostile", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) })
		menu.cleanup()
	end
end

function menu.buttonMining(ware, clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderMining(ship, ware, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonMissionSetInactive()
	C.SetActiveMission(0)

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionSetActive(missionid)
	C.SetActiveMission(missionid)
	PlaySound("ui_mission_set_active")

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionAbort(missionid)
	C.AbortMission(missionid)

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMissionShow(missionid)
	local missiondetails = C.GetMissionIDDetails(missionid)
	local entry = {
		["missionGroup"] = {},
		["maintype"] = ffi.string(missiondetails.mainType),
	}
	if missiondetails.threadMissionID ~= 0 then
		local missionGroup = C.GetMissionGroupDetails(missiondetails.threadMissionID)
		entry.missionGroup.id = ffi.string(missionGroup.id)
		entry.missionGroup.name = ffi.string(missionGroup.name)
	else
		local missionGroup = C.GetMissionGroupDetails(missionid)
		entry.missionGroup.id = ffi.string(missionGroup.id)
		entry.missionGroup.name = ffi.string(missionGroup.name)
	end

	local mode
	if entry.maintype == "upkeep" then
		mode = "upkeep"
	else
		if entry.maintype == "guidance" then
			DebugError("menu.buttonMissionShow(): Trying to show guidance mission. [Florian]")
		else
			mode = "plot"
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "mission", mode, ConvertStringTo64Bit(tostring(missionid)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "mission", { mode, ConvertStringTo64Bit(tostring(missionid)) })
		menu.cleanup()
	end
end

function menu.buttonShowUpkeepMissions()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "infomode", { "mission", "upkeep", tostring(menu.componentSlot.component), true } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "mission", { "upkeep", tostring(menu.componentSlot.component), true })
		menu.cleanup()
	end
end

function menu.buttonMissionBriefing(missionid, isoffer)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), isoffer }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "MissionBriefingMenu", { 0, 0, ConvertStringToLuaID(tostring(missionid)), isoffer } })
		menu.cleanup()
	end
end

function menu.buttonMissionAccept(offerid)
	local name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, rewardmoney, rewardtext, briefingobjectives, activebriefingstep, briefingmissions, oppfaction, licence, missiontime, duration, abortable, guidancedisabled, associatedcomponent, alertLevel, offeractor, offercomponent = GetMissionOfferDetails(ConvertStringToLuaID(menu.missionoffer))

	SignalObject(offeractor, "accept", ConvertStringToLuaID(tostring(offerid)))

	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "missionaccepted", { offerid })
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonMoveWait(clear)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local target = 0
	local playerprecise = (#menu.selectedplayerships == 1)
	if C.IsComponentClass(menu.componentSlot.component, "highway") then
		local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
		if issuperhighway then
			target = ConvertIDTo64Bit(entrygate)
		else
			target = menu.componentSlot.component
		end
	else
		target = menu.componentSlot.component
	end
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderMoveWait(ship, menu.offsetcomponent, menu.offset, target, playerprecise, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadAttackPlayerTarget(clear)
	local playertarget = ConvertIDTo64Bit(GetPlayerTarget())
	if (playertarget ~= 0) then
		for ship in pairs(menu.playerSquad) do
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(ship, hasloop)
			if not hasloop[0] then
				menu.orderAttack(ship, playertarget, clear, true)
				--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to attack " .. ffi.string(C.GetComponentName(playertarget)) .. " " .. tostring(playertarget))
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadStopAndHoldFire(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderStopAndHoldFire(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to halt and stop firing.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadWithdrawAndHold(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderWithdrawAndHold(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to withdraw from combat and hold position.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPlayerSquadWithdrawFromCombat(clear)
	for ship in pairs(menu.playerSquad) do
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(ship, hasloop)
		if not hasloop[0] then
			menu.orderWithdrawFromCombat(ship, clear, true)
			--print("ordering " .. ffi.string(C.GetComponentName(ship)) .. " " .. tostring(ship) .. " to withdraw from combat.")
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonPerformPlayerAction(id, type)
	C.PerformCompSlotPlayerAction(menu.componentSlot, id)
	AddUITriggeredEvent(menu.name, "perform", type)
	menu.onCloseElement("close", nil, false)
end

function menu.buttonPlayerDockToTrade(clear)
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	for _, ship in ipairs(menu.selectedplayerships) do
		if IsDockingPossible(ship, convertedComponent, nil, true) then
			menu.orderPlayerDockToTrade(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonProceedWithOrders()
	SignalObject(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "playerownedship_proceed")
	for _, ship in ipairs(menu.selectedplayerships) do
		SignalObject(ship, "playerownedship_proceed")
	end
	menu.onCloseElement("close")
end

function menu.buttonProtect(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderProtect(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonPutIntoStorage(container, ship)
	if C.IsShipAtExternalDock(ship) then
		C.PutShipIntoStorage(container, ship)
	else
		C.RequestShipFromInternalStorage2(ship, false, C.GetPlayerID())
	end

	menu.onCloseElement("close")
end

function menu.buttonRecallSubordinates(component, subordinates, level)
	if not level then
		level = 1
	end

	if not component then
		DebugError("menu.buttonRecallSubordinates(): " .. tostring(component) .. " is not a valid component.")
	elseif not subordinates or #subordinates < 1 then
		DebugError("menu.buttonRecallSubordinates(): tried to recall subordinates on " .. tostring(component) .. " that has no subordinates.")
	else
		C.SetAllDronesArmed(component, false)
		for i = #subordinates, 1, -1 do
			local subordinate = ConvertIDTo64Bit(subordinates[i])
			local numorders = C.GetNumOrders(subordinate)
			for j = numorders, 1, -1 do
				C.RemoveOrder(subordinate, j, false, false)
			end

			local subsubordinates = GetSubordinates(subordinates[i])
			if #subsubordinates > 0 then
				menu.buttonRecallSubordinates(subordinate, subsubordinates, level + 1)
			end
		end
	end

	if level == 1 then
		menu.onCloseElement("close")
	end
end

function menu.buttonRemoveAllOrders(removedefaultorder, removeassignment, removedockorder)
	menu.orderRemove(menu.componentSlot.component, removedefaultorder, removeassignment, removedockorder)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderRemove(ship, removedefaultorder, removeassignment, removedockorder)
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonRemoveAssignment(removeall)
	C.RemoveCommander2(menu.componentSlot.component)
	C.CreateOrder(menu.componentSlot.component, "Wait", true)
	C.EnablePlannedDefaultOrder(menu.componentSlot.component, false)
	if removeall then
		for _, ship in ipairs(menu.selectedplayerships) do
			C.RemoveCommander2(ship)
			C.CreateOrder(ship, "Wait", true)
			C.EnablePlannedDefaultOrder(ship, false)
		end
	end
	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonRemoveFleetUnit()
	C.RemoveFleetUnit(menu.fleetunit)
	menu.onCloseElement("close")
end

function menu.buttonRemoveOrder()
	if menu.componentOrder then
		C.RemoveOrder(menu.componentSlot.component, menu.componentOrder.queueidx, false, false)
	elseif menu.syncpointorder then
		C.RemoveOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, false, false)
	end
	menu.onCloseElement("close")
end

-- kuertee start: multi-rename
menu.uix_multiRename_removedActionTarget = nil
function menu.uix_multiRename_getObjects()
	-- Helper.debugText_forced("")
	-- Helper.debugText_forced("")
	-- Helper.debugText_forced("")
	-- Helper.debugText_forced(menu.name .. "uix_multiRename_getObjects")
	-- Helper.debugText_forced("menu.componentSlot.component", tostring(ConvertStringTo64Bit(tostring(menu.componentSlot.component))))
	local actionTarget = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	-- local name = GetComponentData(actionTarget, "name")
	-- local idcode = ""
	-- if C.IsComponentClass(actionTarget, "object") then
	-- 	idcode = ffi.string(C.GetObjectIDCode(actionTarget))
	-- end
	-- Helper.debugText_forced("actionTarget " .. tostring(actionTarget), name .. " " .. tostring(idcode))
	local isActionTargetInList
	uix_multiRename_objects = {}
	if menu.selectedplayerships and #menu.selectedplayerships > 0 then
		for _, object in ipairs(menu.selectedplayerships) do
			if IsValidComponent(object) then
				-- local name = GetComponentData(object, "name")
				-- local idcode = ""
				-- if C.IsComponentClass(object, "object") then
				-- 	idcode = ffi.string(C.GetObjectIDCode(object))
				-- end
				-- Helper.debugText_forced("selectedplayerships " .. tostring(object), name .. " " .. tostring(idcode))
				table.insert(uix_multiRename_objects, object)
				isActionTargetInList = isActionTargetInList or IsSameComponent(object, actionTarget)
			end
		end
	end
	if menu.selectedotherobjects and #menu.selectedotherobjects > 0 then
		for _, object in ipairs(menu.selectedotherobjects) do
			if IsValidComponent(object) then
				local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(object)), "isplayerowned")
				if isplayerowned then
					-- local name = GetComponentData(object, "name")
					-- local idcode = ""
					-- if C.IsComponentClass(object, "object") then
					-- 	idcode = ffi.string(C.GetObjectIDCode(object))
					-- end
					-- Helper.debugText_forced("selectedotherobjects " .. tostring(object), name .. " " .. tostring(idcode))
					-- Helper.debugText_forced("selectedotherobjects isplayerowned", isplayerowned)
					table.insert(uix_multiRename_objects, object)
					isActionTargetInList = isActionTargetInList or IsSameComponent(object, actionTarget)
				end
			end
		end
	end
	if menu.selectedplayerdeployables and #menu.selectedplayerdeployables > 0 then
		for _, object in ipairs(menu.selectedplayerdeployables) do
			if IsValidComponent(object) then
				-- local name = GetComponentData(object, "name")
				-- local idcode = ""
				-- if C.IsComponentClass(object, "object") then
				-- 	idcode = ffi.string(C.GetObjectIDCode(object))
				-- end
				-- Helper.debugText_forced("selectedplayerdeployables " .. tostring(object), name .. " " .. tostring(idcode))
				table.insert(uix_multiRename_objects, object)
				isActionTargetInList = isActionTargetInList or IsSameComponent(object, actionTarget)
			end
		end
	end
	if menu.removedOccupiedPlayerShip then
		-- local name = GetComponentData(menu.removedOccupiedPlayerShip, "name")
		-- local idcode = ""
		-- if C.IsComponentClass(menu.removedOccupiedPlayerShip, "object") then
		-- 	idcode = ffi.string(C.GetObjectIDCode(menu.removedOccupiedPlayerShip))
		-- end
		-- Helper.debugText_forced("menu.removedOccupiedPlayerShip " .. tostring(menu.removedOccupiedPlayerShip), name .. " " .. tostring(idcode))
		table.insert(uix_multiRename_objects, menu.removedOccupiedPlayerShip)
		isActionTargetInList = isActionTargetInList or IsSameComponent(menu.removedOccupiedPlayerShip, actionTarget)
	end
	if menu.uix_multiRename_removedActionTarget then
		-- local name = GetComponentData(menu.uix_multiRename_removedActionTarget, "name")
		-- local idcode = ""
		-- if C.IsComponentClass(menu.uix_multiRename_removedActionTarget, "object") then
		-- 	idcode = ffi.string(C.GetObjectIDCode(menu.uix_multiRename_removedActionTarget))
		-- end
		-- Helper.debugText_forced("menu.uix_multiRename_removedActionTarget " .. tostring(menu.uix_multiRename_removedActionTarget), name .. " " .. tostring(idcode))
		table.insert(uix_multiRename_objects, menu.uix_multiRename_removedActionTarget)
	end
	if menu.uix_multiRename_removedActionTarget or isActionTargetInList then
		-- if uix_multiRename_removedActionTarget, then right-click target was removed from one of the lists, and so multi-rename is valid.
		-- if isActionTargetinList, then right-click target was already in one of the lists, and so multi-rename is valid.
		-- i.e. right-clicking on a deployable will not remove it from one of the lists.
		-- for _, object in ipairs(uix_multiRename_objects) do
		-- 	local name = GetComponentData(object, "name")
		-- 	local idcode = ""
		-- 	if C.IsComponentClass(object, "object") then
		-- 		idcode = ffi.string(C.GetObjectIDCode(object))
		-- 	end
		-- 	Helper.debugText_forced(object, name .. " " .. tostring(idcode))
		-- end
		return uix_multiRename_objects
	else
		return {}
	end
end
-- kuertee end: multi-rename

function menu.buttonRemoveBuildStorage()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "removebuildstorage", { menu.componentSlot.component } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "removebuildstorage", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) })
		menu.cleanup()
	end
end

-- kuertee start: multi-rename
-- function menu.buttonRename(isfleet)
-- kuertee end: multi-rename
function menu.buttonRename(isfleet, isMultiRename)
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end

		-- kuertee start: multi-rename
		-- Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'renamecontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } }, true)
		if isMultiRename and uix_multiRename_objects and #uix_multiRename_objects > 0 then
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'renamecontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet, uix_multiRename_objects } }, true)
			uix_multiRename_objects = nil
		else
			Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'renamecontext', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } }, true)
		end
		-- kuertee end: multi-rename

		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)

		-- kuertee start: multi-rename
		-- Helper.returnFromInteractMenu(menu.currentOverTable, "renamecontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } )
		if isMultiRename and uix_multiRename_objects and #uix_multiRename_objects > 0 then
			Helper.returnFromInteractMenu(menu.currentOverTable, "renamecontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet, uix_multiRename_objects } )
			uix_multiRename_objects = nil
		else
			Helper.returnFromInteractMenu(menu.currentOverTable, "renamecontext", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), isfleet } )
		end
		-- kuertee end: multi-rename

		menu.cleanup()
	end
end

function menu.buttonRequestShip()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "PlatformUndockMenu", { 0, 0, C.GetContextByClass(menu.componentSlot.component, "container", false), "requestship", { menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component } }, true)
		menu.cleanup()
	end
end

function menu.buttonRescueInRange(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderRescueInRange(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonRescueShip(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderRescueShip(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageCollect(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		if GetComponentData(ship, "shiptype") == "tug" then
			menu.orderSalvageCollect(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageCrush(clear)
	for _, ship in ipairs(menu.selectedplayerships) do
		if GetComponentData(ship, "shiptype") == "compactor" then
			menu.orderSalvageCrush(ship, menu.componentSlot.component, clear)
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageDeliver(clear, ware, tradeoffer)
	for _, ship in ipairs(menu.selectedplayerships) do
		local towedobject = C.GetTowedObject(ship)
		if towedobject ~= 0 then
			local recyclingwares = GetComponentData(ConvertStringTo64Bit(tostring(towedobject)), "recyclingwares")
			if #recyclingwares > 0 then
				if ware == recyclingwares[1].ware then
					menu.orderSalvageDeliver(ship, menu.componentSlot.component, tradeoffer, recyclingwares[1].amount, clear)
				end
			end
		end
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageDeliver_NoTrade()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderSalvageDeliver_NoTrade(ship, menu.componentSlot.component, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonSalvageInRadius()
	for _, ship in ipairs(menu.selectedplayerships) do
		menu.orderSalvageInRadius(ship, menu.offsetcomponent, menu.offset, clear)
	end

	menu.onCloseElement("close")
end

function menu.buttonSyncPointAutoRelease()
	if menu.syncpointorder then
		C.SetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, not C.GetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true), false)
	elseif menu.syncpoint then
		C.SetSyncPointAutoRelease(menu.syncpoint, not C.GetSyncPointAutoRelease(menu.syncpoint, true), false)
	end
end

function menu.buttonTacticalAttack(ships, clear)
	for _, ship in ipairs(ships) do
		menu.orderTacticalAttack(ship, menu.componentSlot.component, clear, false)
	end

	menu.onCloseElement("close")
end

function menu.buttonTriggerSyncPoint()
	if menu.syncpointorder then
		C.ReleaseOrderSyncPointFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx)
	elseif menu.syncpoint then
		C.ReleaseOrderSyncPoint(menu.syncpoint)
	end
	menu.onCloseElement("close")
end

function menu.buttonUpgrade(clear)
	local shiptrader = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "shiptrader")
	if shiptrader then
		if menu.shown then
			if menu.interactMenuID then
				C.NotifyInteractMenuHidden(menu.interactMenuID, true)
			end
			Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, ConvertStringToLuaID(tostring(menu.componentSlot.component)), "upgrade", menu.selectedplayerships }, true)
			menu.cleanup()
		else
			Helper.resetUpdateHandler()
			Helper.clearFrame(menu, config.layer)
			Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, ConvertStringToLuaID(tostring(menu.componentSlot.component)), "upgrade", menu.selectedplayerships } })
			menu.cleanup()
		end
	else
		DebugError("menu.buttonUpgrade(): unable to retrieve ship trader of " .. ffi.string(C.GetComponentName(menu.componentSlot.component)) .. ".")
	end
end

function menu.buttonPaintMod()
	local found = false
	local ships = {}
	if menu.shown then
		table.insert(ships, menu.componentSlot.component)
	else
		for _, ship in ipairs(menu.selectedplayerships) do
			table.insert(ships, ship)
			if ship == menu.componentSlot.component then
				found = true
			end
		end
		if not found then
			table.insert(ships, menu.componentSlot.component)
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, nil, "modify", { true, ships } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, nil, "modify", { true, ships } } })
		menu.cleanup()
	end
end

function menu.buttonSelectSubordinateGroup()
	if not menu.shown then
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		if menu.componentSlot.component ~= 0 then
			Helper.returnFromInteractMenu(menu.currentOverTable, "selectsubordinates", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), menu.subordinategroup })
		else
			Helper.returnFromInteractMenu(menu.currentOverTable, "selectsubordinates", { 0, menu.subordinategroup, ConvertStringTo64Bit(tostring(menu.fleetunit)) })
		end
		menu.cleanup()
	else
		menu.onCloseElement("close")
	end
end

function menu.buttonSellShips()
	local isshipyard, iswharf = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isshipyard", "iswharf")
	local sellableships = {}
	for _, ship in ipairs(menu.selectedplayerships) do
		if C.CanContainerBuildShip(menu.componentSlot.component, ship) and GetComponentData(ship, "issellable") then
			table.insert(sellableships, ship)
		end
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, "sellships", { ConvertStringToLuaID(tostring(menu.componentSlot.component)), sellableships, menu.frameX, menu.frameY } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "sellships", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)), sellableships, menu.frameX, menu.frameY })
		menu.cleanup()
	end
end

function menu.buttonShipConfig(mode)
	local shiptrader = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "shiptrader")
	if shiptrader then
		if menu.shown then
			if menu.interactMenuID then
				C.NotifyInteractMenuHidden(menu.interactMenuID, true)
			end
			Helper.closeMenuAndOpenNewMenu(menu, "ShipConfigurationMenu", { 0, 0, menu.componentSlot.component, mode }, true)
			menu.cleanup()
		else
			Helper.resetUpdateHandler()
			Helper.clearFrame(menu, config.layer)
			Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "ShipConfigurationMenu", { 0, 0, menu.componentSlot.component, mode } })
			menu.cleanup()
		end
	else
		DebugError("menu.buttonShipConfig(): unable to retrieve ship trader of " .. ffi.string(C.GetComponentName(menu.componentSlot.component)) .. ".")
	end
end

function menu.buttonStationConfig()
	local station = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
		station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "StationConfigurationMenu", { 0, 0, station }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "StationConfigurationMenu", { 0, 0, station } })
		menu.cleanup()
	end
end

function menu.buttonStationOverview()
	local station = menu.componentSlot.component
	if C.IsComponentClass(menu.componentSlot.component, "buildstorage") then
		station = ConvertIDTo64Bit(GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "basestation")) or 0
	end

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "StationOverviewMenu", { 0, 0, station }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "newmenu", { "StationOverviewMenu", { 0, 0, station } })
		menu.cleanup()
	end
end

function menu.buttonTeleport()
	local isplayerownedtarget = GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isplayerowned")

	C.TeleportPlayerTo(menu.componentSlot.component, false, menu.mode == "shipconsole", (menu.mode == "shipconsole") and isplayerownedtarget)
	menu.onCloseElement("close")
end

function menu.buttonTrade(wareexchange, tradepartner, loop)
	tradepartner = tradepartner or ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	trader = (#menu.selectedplayerships == 1) and ConvertStringTo64Bit(tostring(menu.selectedplayerships[1])) or nil

	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'tradecontext', { tradepartner, nil, wareexchange, nil, loop, trader } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "tradecontext", { tradepartner, nil, wareexchange, loop, trader } )
		menu.cleanup()
	end
end

function menu.buttonTravelMode(activate)
	if activate then
		C.StartPlayerActivity("travel")
	else
		local currentactivity = GetPlayerActivity()
		C.StopPlayerActivity(currentactivity)
	end
	menu.onCloseElement("close")
end

function menu.buttonVenturePatron()
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturepatroninfo', { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } }, true)
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturepatroninfo", { ConvertStringTo64Bit(tostring(menu.componentSlot.component)) } )
		menu.cleanup()
	end
end

function menu.buttonVentureReportShip()
	local convertedcomponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local venturetransactionid = GetComponentData(convertedcomponent, "venturetransactionid")
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "ship", "Offensive ship name", nil, nil, venturetransactionid } }, true) -- hardcoded text only visible in venture server moderator interface
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturereport", { "ship", "Offensive ship name", nil, nil, venturetransactionid } )
		menu.cleanup()
	end
end

function menu.buttonVentureReportUser()
	local convertedcomponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local userid = GetComponentData(convertedcomponent, "ventureuserid")
	if menu.shown then
		if menu.interactMenuID then
			C.NotifyInteractMenuHidden(menu.interactMenuID, true)
		end
		Helper.closeMenuAndOpenNewMenu(menu, "MapMenu", { 0, 0, true, nil, nil, 'venturereport', { "user", "Offensive ship name", nil, nil, nil, userid } }, true) -- hardcoded text only visible in venture server moderator interface
		menu.cleanup()
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "venturereport", { "user", "Offensive ship name", nil, nil, nil, userid } )
		menu.cleanup()
	end
end

-- cheats

function menu.buttonOwnerCheat()
	C.MakePlayerOwnerOf(menu.componentSlot.component)
	if C.IsComponentClass(menu.componentSlot.component, "ship") and (not GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isdeployable")) then
		C.CreateOrder(menu.componentSlot.component, "Wait", true)
		C.EnablePlannedDefaultOrder(menu.componentSlot.component, false)
	end

	if menu.shown then
		menu.onCloseElement("close")
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		Helper.returnFromInteractMenu(menu.currentOverTable, "refresh")
		menu.cleanup()
	end
end

function menu.buttonSatelliteCheat()
	local macro = GetWareData("satellite_mk2", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonNavBeaconCheat()
	local macro = GetWareData("waypointmarker_01", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonResourceProbeCheat()
	local macro = GetWareData("resourceprobe_01", "component")
	C.SpawnObjectAtPos(macro, menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.buttonWarpCheat()
	C.MovePlayerToSectorPos(menu.offsetcomponent, menu.offset)
	menu.onCloseElement("close")
end

function menu.checkboxSubordinateGroupAttackOnSight(group, checked)
	C.SetSubordinateGroupAttackOnSight(menu.componentSlot.component, group, checked)
end

function menu.checkboxSubordinateGroupResupplyAtFleet(group, checked)
	C.SetSubordinateGroupResupplyAtFleet(menu.componentSlot.component, group, checked)
end

function menu.checkboxSubordinateGroupReinforceFleet(group, checked)
	C.SetSubordinateGroupReinforceFleet(menu.componentSlot.component, group, checked)
end

function menu.checkboxSubordinateGroupRespondToDistressCalls(group, checked)
	C.SetSubordinateGroupRespondToDistressCalls(menu.componentSlot.component, group, checked)
end

-- interact menu hooks

function menu.showInteractMenu(param)
	AddUITriggeredEvent(menu.name, "")
	menu.componentSlot = ffi.new("UIComponentSlot")
	menu.componentSlot.component = ConvertStringTo64Bit(tostring(param.component))
	AddUITriggeredEvent(menu.name, "id", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))
	local connection = "connectionui"
	menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
	menu.componentSlot.connection = menu.connection
	menu.componentOrder = param.order
	menu.syncpoint = param.syncpoint
	menu.syncpointorder = param.syncpointorder
	menu.intersectordefencegroup = param.intersectordefencegroup
	menu.fleetunit = param.fleetunit
	menu.replacingcontrollable = param.replacingcontrollable
	menu.selectedfleetunit = param.selectedfleetunit
	menu.selectedreplacingcontrollable = param.selectedreplacingcontrollable
	menu.mission = param.mission
	menu.componentMissions = param.componentmissions
	menu.missionoffer = param.missionoffer
	menu.construction = param.construction
	menu.subordinategroup = param.subordinategroup
	menu.selectedplayerships = param.playerships
	menu.selectedotherobjects = param.otherobjects
	menu.selectedplayerdeployables = param.playerdeployables
	menu.playerSquad = menu.getPlayerSquad()
	menu.behaviourInspectionComponent = param.behaviourInspectionComponent
	menu.buildStationMode = param.buildStationMode
	menu.offsetcomponent = param.offsetcomponent
	menu.offset = param.offset
	menu.mouseX = param.mouseX
	menu.mouseY = param.mouseY

	menu.processSelectedPlayerShips()
	if menu.fleetunit == menu.selectedfleetunit then
		menu.selectedfleetunit = nil
		menu.selectedreplacingcontrollable = nil
	end

	menu.display()
end

function menu.onShowMenu(_, _, serializedArg)
	C.SetTrackedMenuFullscreen(menu.name, false)
	if menu.param and (menu.param[3] == "shipconsole") then
		menu.mode = "shipconsole"
		menu.interactMenuID = nil
		menu.componentSlot = ffi.new("UIComponentSlot")
		menu.componentSlot.component = ConvertIDTo64Bit(menu.param[4])
		local connection = "connectionui"
		menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
		menu.componentSlot.connection = menu.connection
		menu.isdockedship = menu.param[5] == 1
	else
		menu.interactMenuID = tonumber(string.match(serializedArg, "%d+"))
		serializedArg = string.sub(serializedArg, string.find(serializedArg, ";") + 1)
		menu.componentSlot = ffi.new("UIComponentSlot")
		menu.componentSlot.component = ConvertStringTo64Bit(string.match(serializedArg, "%d+"))
		if C.IsSurfaceElement(menu.componentSlot.component) then
			menu.componentSlot.component = C.GetContextByClass(menu.componentSlot.component, "container", false)
		end
		local connection = string.sub(serializedArg, string.find(serializedArg, ";") + 1)
		menu.connection = Helper.ffiNewString(connection)	-- store string here to keep it alive during lifetime of menu.componentSlot
		menu.componentSlot.connection = menu.connection
		-- Handle mission offers
		local _, _, _, _, _, _, _, _, _, _, missionOfferID = GetMissionOfferAtConnection(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), connection)
		if missionOfferID ~= nil then
			menu.missionoffer = tostring(missionOfferID)
		end
	end
	AddUITriggeredEvent(menu.name, "id", ConvertStringTo64Bit(tostring(menu.componentSlot.component)))

	local occupiedPlayerShip = C.GetPlayerOccupiedShipID()
	local toplevelcontainer = C.GetTopLevelContainer(C.GetPlayerID())
	if occupiedPlayerShip ~= 0 then
		menu.selectedplayerships = { ConvertStringTo64Bit(tostring(occupiedPlayerShip)) }
	elseif (menu.mode ~= "shipconsole") and (toplevelcontainer ~= 0) and C.IsComponentClass(toplevelcontainer, "ship") and GetComponentData(ConvertStringTo64Bit(tostring(toplevelcontainer)), "isplayerowned") then
		menu.selectedplayerships = { ConvertStringTo64Bit(tostring(toplevelcontainer)) }
	else
		menu.selectedplayerships = {}
	end
	menu.selectedotherobjects = {}
	menu.selectedplayerdeployables = {}
	menu.processSelectedPlayerShips()
	menu.playerSquad = menu.getPlayerSquad()

	if menu.interactMenuID then
		C.NotifyInteractMenuShown(menu.interactMenuID)
	end

	menu.display()
end

function menu.onShowMenuSound()
	-- no sound
end

-- displaying the menu

function menu.display()
	menu.width = Helper.scaleX(config.width)

	local posX, posY = GetLocalMousePosition()
	if menu.mode == "shipconsole" then
		posX, posY = -menu.width / 2, 0
	end
	if posX == nil then
		-- gamepad case
		if menu.mouseX ~= nil then
			posX = menu.mouseX + Helper.viewWidth / 2
			posY = menu.mouseY + Helper.viewHeight / 2
		else
			local pos = C.GetCompSlotScreenPos(menu.componentSlot)
			posX = pos.x + Helper.viewWidth / 2
			posY = pos.y + Helper.viewHeight / 2
		end
	else
		posX = posX + Helper.viewWidth / 2
		posY = Helper.viewHeight / 2 - posY
	end
	menu.posX = posX
	menu.posY = posY

	menu.holomapcolor = Helper.getHoloMapColors()
	menu.prepareTexts()
	if not menu.prepareActions() then
		-- no actions found
		menu.onCloseElement("close")
		return
	end

	menu.draw()
end

function menu.draw()
	local width = menu.width
	if menu.subsection then
		width = 2 * width + Helper.borderSize
	end

	menu.frameX = menu.wasMonitorAdjusted and menu.wasMonitorAdjusted.x or math.max(0, menu.posX)
	menu.frameY = menu.wasMonitorAdjusted and menu.wasMonitorAdjusted.y or math.max(0, menu.posY)
	menu.frame = Helper.createFrameHandle(menu, {
		x = menu.frameX,
		y = 0,
		width = width + Helper.scrollbarWidth,
		layer = config.layer,
		standardButtons = { close = true },
		standardButtonX = Helper.scrollbarWidth,
		autoFrameHeight = true,
		closeOnUnhandledClick = true,
		playerControls = true,
		startAnimation = false,
	})
	local frame = menu.frame

	local content_position = "left"
	local subsection_position = "right"
	if menu.subsection then
		if menu.forceSubSectionToLeft then
			-- content table is at the right border of a monitor -> subsection table goes to the left
			menu.frameX = menu.frameX - menu.width - Helper.borderSize
			content_position = "right"
			subsection_position = "left"
		elseif frame.properties.x + menu.width > Helper.viewWidth then
			-- content table is at the right border -> subsection table goes to the left
			menu.frameX = Helper.viewWidth - width - config.border
			content_position = "right"
			subsection_position = "left"
		elseif frame.properties.x + width > Helper.viewWidth then
			-- not enough space for the subsection table -> subsection table goes to the left
			menu.frameX = frame.properties.x - menu.width - Helper.borderSize
			content_position = "right"
			subsection_position = "left"
		else
			frame.properties.standardButtonX = frame.properties.standardButtonX + menu.width + Helper.borderSize
		end
	else
		if frame.properties.x + menu.width > Helper.viewWidth then
			menu.frameX = Helper.viewWidth - menu.width - config.border
		end
	end
	frame.properties.x = menu.frameX

	Helper.removeAllWidgetScripts(menu, config.layer)
	local contentTable = menu.createContentTable(frame, content_position)
	local subsectionTable
	if menu.subsection then
		subsectionTable = menu.createSubSectionTable(frame, subsection_position)
	end

	local height = contentTable:getFullHeight()
	local subsectionHeight = 0
	if menu.frameY + height > Helper.viewHeight then
		menu.frameY = math.max(0, Helper.viewHeight - height - config.border)
	else
		if menu.mode == "shipconsole" then
			menu.frameY = Helper.viewHeight / 2 - height / 2
		end
	end
	frame.properties.y = menu.frameY
	if menu.subsection then
		subsectionHeight = subsectionTable:getFullHeight()
		subsectionTable.properties.y = menu.subsection.y - subsectionHeight + Helper.scaleY(config.rowHeight)
		if subsectionTable.properties.y < 0 then
			local diff = -subsectionTable.properties.y
			menu.frameY = frame.properties.y - diff
			frame.properties.y = menu.frameY
			frame.properties.standardButtonY = diff
			contentTable.properties.y = diff
			subsectionTable.properties.y = 0
		end
	end

	local frameheight = frame:getUsedHeight()

	local mouseOutBoxExtension = {
		left = 0,
		right = 0,
		top = 0,
		bottom = 0,
	}

	-- in HUD prevent overlap with monitors (but do not update if we are showing a subsection, we do not want the interact menu to jump around)
	if menu.shown and (not menu.subsection) then
		--[[ comment this line to enable debug visualisation
		local visframe = Helper.createFrameHandle(menu, {
			x = 0,
			y = 0,
			width = Helper.viewWidth,
			height = Helper.viewHeight,
			layer = config.layer + 1,
			standardButtons = {  },
			playerControls = true,
			startAnimation = false,
		})--]]

		local monitors = {
			{ offsetid = "targetmonitor",	uianchorindex = 0 },
			{ offsetid = "radar",			uianchorindex = 2,		noright = true },
			{ offsetid = "messageticker",	uianchorindex = 3,		noright = true },
		}

		-- keep original frame position for comparision with new position to judge convenience
		local origFrameX, origFrameY = menu.frameX, menu.frameY
		for _, monitor in ipairs(monitors) do
			-- get the monitor extents (in worldspace coordinates)
			local monitoroffset = C.GetMonitorExtents(monitor.offsetid)
			if (monitoroffset.width ~= 0) and (monitoroffset.height ~= 0) then
				-- get monitor extents in screen position coordinates
				local minX, maxX, minY, maxY = menu.getMonitorExtents(monitoroffset, monitor.uianchorindex, visframe)
				local monitorexclusionzone = {
					x = math.floor(minX),
					y = math.floor(minY),
					width = math.ceil(maxX - minX),
				}

				if visframe then
					-- debug visualization
					local vistable = visframe:addTable(1, { tabOrder = 100, x = monitorexclusionzone.x, y = monitorexclusionzone.y, width = math.min(monitorexclusionzone.width, Helper.viewWidth - monitorexclusionzone.x), backgroundID = "solid", backgroundColor = Color["text_error"], highlightMode = "off" })
					local visrow = vistable:addRow(false, {})
					visrow[1]:createText(" ", { minRowHeight = Helper.viewHeight - monitorexclusionzone.y, scaling = false, x = 0 })
				end

				-- move interact menu out of exclusion zone
				menu.excludeMonitorZone(frame, monitorexclusionzone, width, frameheight, origFrameX, origFrameY, mouseOutBoxExtension, monitor.noright)
			end
		end

		if visframe then
			visframe:display()
		end
	end

	local xleft = frame.properties.x - Helper.viewWidth / 2
	local ytop = -frame.properties.y + Helper.viewHeight / 2
	local xright = xleft + width
	local ybottom = ytop - frameheight

	menu.mouseOutBox = {
		x1 = xleft   - config.mouseOutRange - mouseOutBoxExtension.left,
		x2 = xright  + config.mouseOutRange + mouseOutBoxExtension.right,
		y1 = ytop    + config.mouseOutRange + mouseOutBoxExtension.top,
		y2 = ybottom - config.mouseOutRange - mouseOutBoxExtension.bottom,
	}

	if GetControllerInfo() == "gamepad" and menu.mode ~= "shipconsole" then
		-- Prepare emulated mouse cursor when using gamepad:
		-- Find a good default cursor position, even if emulated mouse cursor is currently not visible.
		-- The menu auto-closes when the cursor is too far away from the menu, so make sure that it will be located within the menu frame.
		local posx, posy = GetLocalMousePosition()
		if posx and posy then
			-- Cursor is already on screen: Keep unchanged if possible, but move it inside the frame if it is outside
			if posx < xleft then
				posx = xleft
			elseif posx > xright then
				posx = xright
			end
			if posy > ytop then
				posy = ytop
			elseif posy < ybottom then
				posy = ybottom
			end
		else
			-- No mouse position available: Place default cursor position at the top of the frame (horizontally centered) for when the cursor becomes visible
			C.DeactivateMouseEmulation()		-- just to be safe (mouse emulation is most likely already disabled anyway)
			posx = (xleft + xright) / 2
			posy = ytop - Helper.headerRow1Height
		end
		C.SetMouseCursorPosition(posx, -posy)
	end

	frame:display()
end

function menu.getMonitorExtents(monitoroffset, uianchorindex, visframe)
	local minX, maxX, minY, maxY
	for i = 1, 4 do
		local offset = ffi.new("PosRot")
		if i == 1 then
			-- upper left corner
			offset.x = monitoroffset.x - monitoroffset.width / 2
			offset.y = monitoroffset.y + monitoroffset.height / 2
		elseif i == 2 then
			-- upper right corner
			offset.x = monitoroffset.x + monitoroffset.width / 2
			offset.y = monitoroffset.y + monitoroffset.height / 2
		elseif i == 3 then
			-- lower right corner
			offset.x = monitoroffset.x + monitoroffset.width / 2
			offset.y = monitoroffset.y - monitoroffset.height / 2
		elseif i == 4 then
			-- lower left corner
			offset.x = monitoroffset.x - monitoroffset.width / 2
			offset.y = monitoroffset.y - monitoroffset.height / 2
		end
		local anchoroffset = C.GetUIAnchorScreenPosition("monitors", uianchorindex, offset)
		minX = minX and math.min(anchoroffset.x, minX) or anchoroffset.x
		maxX = maxX and math.max(anchoroffset.x, maxX) or anchoroffset.x
		minY = minY and math.min(anchoroffset.y, minY) or anchoroffset.y
		maxY = maxY and math.max(anchoroffset.y, maxY) or anchoroffset.y

		if visframe then
			-- debug visualization
			local vistable = visframe:addTable(1, { tabOrder = 100 + i, x = anchoroffset.x, y = math.min(anchoroffset.y, Helper.viewHeight - 5), width = 5, backgroundID = "solid", backgroundColor = Color["text_warning"], highlightMode = "off", reserveScrollBar = false })
			local visrow = vistable:addRow(false, {})
			visrow[1]:createText(" ", { fontsize = 1, minRowHeight = 5, scaling = false, x = 0 })
		end
	end
	return minX, maxX, minY, maxY
end

function menu.excludeMonitorZone(frame, monitorexclusionzone, framewidth, frameheight, origFrameX, origFrameY, mouseOutBoxExtension, noright)
	local needschange = true
	-- check y coord first
	if menu.frameY + frameheight > monitorexclusionzone.y then
		if needschange and (menu.frameX < monitorexclusionzone.x) then
			-- clicked left of the monitor, check if overlapping
			if menu.frameX + framewidth > monitorexclusionzone.x + monitorexclusionzone.width then
				-- interact menu extends beyond the monitor on both sides, move it up
				local newY = monitorexclusionzone.y - frameheight
				mouseOutBoxExtension.bottom = origFrameY - newY
				menu.frameY = math.max(0, newY)
				needschange = false
			elseif menu.frameX + framewidth > monitorexclusionzone.x then
				-- overlapping with the monitor, flip to left from cursor
				if not menu.forceSubSectionToLeft then
					local newX = menu.frameX - framewidth
					-- make sure we have enough space left for a subsection on the left
					if newX > menu.width + Helper.borderSize then
						menu.frameX = newX
						needschange = false
						menu.forceSubSectionToLeft = true
					end
				else
					-- we already flipped to the left (from a previous monitor), move up now
					local newY = monitorexclusionzone.y - frameheight
					mouseOutBoxExtension.bottom = origFrameY - newY
					menu.frameY = math.max(0, newY)
					needschange = false
				end
			elseif menu.frameX + 2 * menu.width + Helper.borderSize > monitorexclusionzone.x then
				-- ok, but no space for subsection -> force to left
				needschange = false
				menu.forceSubSectionToLeft = true
			else
				needschange = false
			end
		end
		if needschange and (menu.frameX < monitorexclusionzone.x + monitorexclusionzone.width) then
			-- clicked inside the monitor or left to the monitor but no space on the left
			-- check whether to move left, up or right
			local newX1 = monitorexclusionzone.x - framewidth
			if newX1 < menu.width + Helper.borderSize then
				-- doesn't fit a potential subsection, make impossible
				newX1 = -1000000000
			end
			local newX2 = monitorexclusionzone.x + monitorexclusionzone.width
			if noright or (newX2 + framewidth > Helper.viewWidth) then
				-- doesn't fit, make impossible
				newX2 = 1000000000
			end
			local newY = monitorexclusionzone.y - frameheight

			local diffX1 = origFrameX - newX1
			local diffX2 = newX2 - origFrameX
			local diffY = origFrameY - newY

			if (diffX1 < diffX2) and (diffX1 < diffY) then
				-- moving left
				mouseOutBoxExtension.right = diffX1
				menu.frameX = newX1
				needschange = false
				menu.forceSubSectionToLeft = true
			elseif (not diffX1) or (diffX2 < diffX1) and (diffX2 < diffY) then
				-- moving right
				mouseOutBoxExtension.left = diffX2
				needschange = false
				menu.frameX = newX2
			elseif (diffY < diffX1) and (diffY < diffX2) then
				-- moving up
				mouseOutBoxExtension.bottom = diffY
				menu.frameY = math.max(0, newY)
				needschange = false
			end
		end
	end

	if not needschange then
		menu.wasMonitorAdjusted = { x = menu.frameX, y = menu.frameY }
		frame.properties.x = menu.frameX
		frame.properties.y = menu.frameY
	end

end

function menu.addSectionTitle(ftable, section, first)
	if first and (#menu.selectedplayerships > 0) then
		return 0
	end

	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local commander
	if (convertedComponent ~= 0) and C.IsComponentClass(menu.componentSlot.component, "controllable") then
		commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
	end

	local height = 0
	if section.text ~= "" then
		local addspacing = not first
		if section.id == "main_assignments_subsections" then
			addspacing = false
			if menu.subordinategroup then
				addspacing = true
			elseif menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
				if (not commander) or (commander == 0) then
					addspacing = true
				end
			end
		end
		if addspacing then
			local row = ftable:addEmptyRow(config.rowHeight / 2)
			height = height + row:getHeight() + Helper.borderSize
		end
		local text = section.text
		if section.showloop and (menu.numorderloops > 0) then
			text = utf8.char(8734) .. " " .. text
		end

		local row = ftable:addRow(false, {  })
		if section.id == "main_assignments" then
			row[1]:createText(string.format(text, menu.texts.commanderShortName), { font = Helper.standardFontBold, mouseOverText = menu.texts.commanderName, titleColor = Color["row_title"] })
			row[4]:createText("[" .. GetComponentData(convertedComponent, "assignmentname") .. "]", { font = Helper.standardFontBold, halign = "right", height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		elseif section.id == "main_assignments_subsections" then
			if menu.subordinategroup then
				local selectiontext = menu.texts.selectedName
				local fullselectiontext = menu.texts.selectedFullNames
				if menu.groupShips and (#menu.groupShips > 0) then
					if menu.groupShips[1].component then
						selectiontext = GetComponentData(menu.groupShips[1].component, "name")
					else
						local unitinfo = C.GetFleetUnitInfo(menu.groupShips[1].fleetunit)
						selectiontext = ffi.string(unitinfo.name)
					end
					if #menu.groupShips > 1 then
						selectiontext = string.format(ReadText(1001, 7801), #menu.groupShips)
					end
					local color = menu.holomapcolor.playercolor
					local first = true
					fullselectiontext = ""
					for _, shipentry in ipairs(menu.groupShips) do
						fullselectiontext = fullselectiontext .. (first and "" or "\n") .. Helper.convertColorToText(color) .. shipentry.name .. " (" .. shipentry.objectid .. ")"
						first = false
					end
				end
				row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Color["row_title"] })
				row[4]:createText(selectiontext, { font = Helper.standardFontBold, halign = "right", color = menu.holomapcolor.playercolor, mouseOverText = fullselectiontext, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
			elseif menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown)) then
				if (not commander) or (commander == 0) then
					row[1]:setColSpan(5):createText(ReadText(1010, 1), { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Color["row_title"] })
				end
			end
		elseif section.id == "player_interaction" then
			if not first then
				row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = text .. " " .. menu.texts.targetName, titleColor = Color["row_title"] })
				row[4]:createText(menu.texts.targetBaseName or menu.texts.targetShortName, { font = Helper.standardFontBold, halign = "right", color = menu.colors.target, mouseOverText = text .. " " .. menu.texts.targetName, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
			end
		elseif (section.id == "selected_orders_all") or (section.id == "selected_assignments_all") then
			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNamesAll, titleColor = Color["row_title"] })
			row[4]:createText(menu.texts.selectedNameAll, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNamesAll, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		elseif (section.id == "selected_orders") or (section.id == "trade_orders") then
			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNames, titleColor = Color["row_title"] })
			row[4]:createText(menu.texts.selectedName, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNames, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		elseif (section.id == "selected_assignments") or (section.id == "selected_change_assignments") then
			local selectiontext = menu.texts.selectedName
			local fullselectiontext = menu.texts.selectedFullNames

			if section.id == "selected_change_assignments" then
				if menu.shipswithcurrentcommander and (#menu.shipswithcurrentcommander > 0) then
					selectiontext = GetComponentData(menu.shipswithcurrentcommander[1], "name")
					if #menu.shipswithcurrentcommander > 1 then
						selectiontext = string.format(ReadText(1001, 7801), #menu.shipswithcurrentcommander)
					end
					local color = menu.holomapcolor.playercolor
					local first = true
					fullselectiontext = ""
					for _, ship in ipairs(menu.shipswithcurrentcommander) do
						fullselectiontext = fullselectiontext .. (first and "" or "\n") .. Helper.convertColorToText(color) .. GetComponentData(ship, "name") .. " (" .. ffi.string(C.GetObjectIDCode(ship)) .. ")"
						first = false
					end
				end
			end

			row[1]:createText(text, { font = Helper.standardFontBold, mouseOverText = fullselectiontext, titleColor = Color["row_title"] })
			row[4]:createText(selectiontext, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = fullselectiontext, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		elseif section.id == "overrideorderoption" then
			row[1]:createText(ColorText["text_error"] .. text, { font = Helper.standardFontBold, mouseOverText = menu.texts.selectedFullNames, titleColor = Color["row_title"] })
			row[4]:createText(menu.texts.overrideordername, { font = Helper.standardFontBold, halign = "right", color = menu.colors.selected, mouseOverText = menu.texts.selectedFullNames, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		else
			row[1]:setColSpan(5):createText(text, { font = Helper.standardFontBold, height = Helper.subHeaderHeight, titleColor = Color["row_title"] })
		end
		height = height + row:getHeight() + Helper.borderSize
	elseif section.id == "shipconsole" then
		if not first then
			local row = ftable:addEmptyRow(config.rowHeight / 2)
			height = height + row:getHeight() + Helper.borderSize
			local row = ftable:addRow(false, {  })
			row[1]:setColSpan(5):createText(ffi.string(C.GetComponentName(menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component)), Helper.headerRowCenteredProperties)
			height = height + row:getHeight() + Helper.borderSize
		end
	end
	return height
end

function menu.createContentTable(frame, position)
	local x = 0
	if position == "right" then
		x = menu.width + Helper.borderSize
	end

	-- kuertee start: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
	-- local uix_forceShowSections = {"main", "interaction", "custom_actions"}
	-- local uix_forceShowSections = {"interaction", "custom_actions"}
	local uix_forceShowSections = {"custom_actions"}
	local uix_forceShowSections_isStationActions
	if #menu.selectedplayerships == 0 and #menu.selectedotherobjects > 0 then
		uix_forceShowSections_isStationActions = C.IsRealComponentClass(menu.selectedotherobjects[1], "station")
	end
	-- kuertee end: forceShowMenus: show main, interaction, custom_actions menu when no actions to show

	local ftable = frame:addTable(5, { tabOrder = menu.subsection and 2 or 1, x = x, width = menu.width, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"], highlightMode = "off" })
	ftable:setDefaultCellProperties("text",   { minRowHeight = config.rowHeight, fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultCellProperties("button", { height = config.rowHeight })
	ftable:setDefaultCellProperties("checkbox", { height = config.rowHeight, width = config.rowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = config.entryFontSize, x = config.entryX })

	local text = menu.texts.targetShortName
	local color = menu.colors.target
	if menu.construction then
		text = menu.texts.constructionName
	end

	local modetext = ReadText(1001, 7804)
	if (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) and (not menu.fleetunit) and (not menu.selectedfleetunit) then
		if (not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) then
			if #menu.actions["selected_orders_all"] > 0 then
				modetext = ReadText(1001, 7804)
				text = menu.texts.selectedNameAll
			elseif #menu.actions["selected_orders"] > 0 then
				modetext = ReadText(1001, 7804)
				text = menu.texts.selectedName
			elseif #menu.actions["trade_orders"] > 0 then
				modetext = ReadText(1001, 7861)
				text = menu.texts.selectedName
			elseif #menu.actions["selected_assignments_all"] > 0 then
				modetext = ReadText(1001, 7886)
				text = menu.texts.selectedNameAll
			else
				-- fallback if no section is used (aka no interaction possible)
				text = menu.texts.selectedName
			end
			if menu.numorderloops > 0 then
				modetext = utf8.char(8734) .. " " .. modetext
			end
			color = menu.colors.selected
		elseif (#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0) then
			modetext = ReadText(1001, 7804)

			-- kuertee start: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
			if not uix_forceShowSections_isStationActions then
				text = menu.texts.otherName
			else
				text = GetComponentData(menu.selectedotherobjects[1], "name")
			end
			-- kuertee end: forceShowMenus: show main, interaction, custom_actions menu when no actions to show

			color = menu.colors.selected
		elseif (#menu.ventureships > 0) and (#menu.selectedplayerships == 0) then
			text = menu.texts.ventureName
			color = menu.colors.venture
		end
	end
	if text == nil then
		DebugError("Interact title text is nil [Florian]" ..
			"\n   targetShortName: " ..tostring(menu.texts.targetShortName) ..
			"\n   construction: " .. tostring(menu.construction) ..
			"\n   constructionName: " .. tostring(menu.texts.constructionName) ..
			"\n   selectedNameAll: " .. tostring(menu.texts.selectedNameAll) ..
			"\n   selectedName: " .. tostring(menu.texts.selectedName) ..
			"\n   otherName: " .. tostring(menu.texts.otherName) ..
			"\n   ventureName: " .. tostring(menu.texts.ventureName) ..
			"\n   #menu.selectedplayerships: " .. tostring(#menu.selectedplayerships) ..
			"\n   #menu.selectedotherobjects: " .. tostring(#menu.selectedotherobjects) ..
			"\n   #menu.ventureships: " .. tostring(#menu.ventureships) ..
			"\n   showPlayerInteractions: " .. tostring(menu.showPlayerInteractions) ..
			"\n   syncpoint: " .. tostring(menu.syncpoint) ..
			"\n   syncpointorder: " .. tostring(menu.syncpointorder) ..
			"\n   intersectordefencegroup: " .. tostring(menu.intersectordefencegroup) ..
			"\n   mission: " .. tostring(menu.mission) ..
			"\n   missionoffer: " .. tostring(menu.missionoffer) ..
			"\n   fleetunit: " .. tostring(menu.fleetunit) ..
			"\n   #menu.actions['selected_orders_all']: " .. tostring(#menu.actions["selected_orders_all"]) ..
			"\n   #menu.actions['selected_orders']: " .. tostring(#menu.actions["selected_orders"]) ..
			"\n   #menu.actions['trade_orders']: " .. tostring(#menu.actions["trade_orders"]) ..
			"\n   #menu.actions['selected_assignments_all']: " .. tostring(#menu.actions["selected_assignments_all"])
		)
		text = ""
	end

	-- need a min width here, otherwise column 3 gets a negative width if the mode text would fit into column 2
	local modetextwidth = math.ceil(math.max(0.2 * menu.width + 2 * Helper.borderSize, C.GetTextWidth(" " .. modetext .. " ", Helper.standardFontBold, Helper.scaleFont(Helper.standardFont, Helper.headerRow1FontSize, true))))
	local bordericonsize = Helper.scaleX(Helper.headerRow1Height)
	local borderwidth = math.ceil(math.max(bordericonsize, (menu.width - modetextwidth - 2 * Helper.borderSize) / 2))
	borderwidth = math.max(borderwidth, Helper.scaleX(config.rowHeight) + Helper.borderSize + 1)

	ftable:setColWidth(1, config.rowHeight)
	ftable:setColWidth(2, borderwidth - Helper.scaleX(config.rowHeight) - Helper.borderSize, false)
	ftable:setColWidth(4, math.ceil(0.4 * menu.width - borderwidth - Helper.borderSize), false)
	ftable:setColWidth(5, borderwidth, false)
	ftable:setDefaultBackgroundColSpan(1, 4)
	ftable:setDefaultColSpan(1, 3)
	ftable:setDefaultColSpan(4, 2)

	local height = 0
	if (((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) or ((#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0))) and (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) and (not menu.fleetunit) and (not menu.selectedfleetunit) then
		-- modemarker
		local row = ftable:addRow(false, {  })
		row[1]:setBackgroundColSpan(5):setColSpan(2):createIcon("be_diagonal_01", { width = bordericonsize, height = bordericonsize, x = borderwidth - bordericonsize + Helper.borderSize, scaling = false, color = Color["row_background_blue_opaque"] })
		row[4]:setColSpan(1)
		row[3]:setColSpan(2)
		local width = row[3]:getColSpanWidth() + Helper.scrollbarWidth + Helper.borderSize
		row[3]:createIcon("solid", { height = bordericonsize, width = width, scaling = false, color = Color["row_background_blue_opaque"] }):setText(modetext, { font = Helper.headerRow1Font, fontsize = Helper.scaleFont(Helper.headerRow1Font, Helper.headerRow1FontSize, true), halign = "center", x = math.ceil((width - Helper.borderSize) / 2) })
		row[5]:setColSpan(1):createIcon("be_diagonal_02", { width = bordericonsize, height = bordericonsize, scaling = false, color = Color["row_background_blue_opaque"] })
		height = height + row:getHeight() + Helper.borderSize
	end
	-- title
	local row = ftable:addRow(false, {  })
	text = TruncateText(text, Helper.standardFontBold, Helper.scaleFont(Helper.standardFontBold, Helper.headerRow1FontSize), menu.width - Helper.scaleX(Helper.standardButtonWidth) - 2 * config.entryX)
	row[1]:setColSpan(5):createText(text, Helper.headerRowCenteredProperties)
	row[1].properties.color = color
	height = height + row:getHeight() + Helper.borderSize
	if (menu.subordinategroup or menu.intersectordefencegroup) and (#menu.selectedplayerships == 0) then
		row[1].properties.titleColor = nil
		local row = ftable:addRow(nil, {  })
		row[1]:setColSpan(5):createText(string.format(ReadText(1001, 8398), ReadText(20401, menu.subordinategroup or menu.intersectordefencegroup)), Helper.headerRowCenteredProperties)
		row[1].properties.color = color
	end

	-- kuertee start: distance tool
	if Helper.distanceTool_distance then
		local kuertee_dist = Helper.distanceTool_distance / 1000.0
		kuertee_dist = math.floor (kuertee_dist * 100 + 0.5) / 100
		row = ftable:addRow (false, {bgColor = Helper.color.transparent})
		local kuertee_text = ReadText (1001, 2957) .. ReadText (1001, 120) .. " " .. tostring (kuertee_dist) .. " " .. ReadText (1001, 108) -- Distance colon space X space km
		row [1]:setColSpan (5):createText (kuertee_text, {halign = "center"})
	end
	-- kuertee end

	-- kuertee start: multi-rename
	local hasPlayerOwnedSelectedOtherObjects
	if menu.selectedotherobjects and #menu.selectedotherobjects > 0 then
		for _, object in ipairs(menu.selectedotherobjects) do
			if IsValidComponent(object) then
				local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(object)), "isplayerowned")
				if isplayerowned then
					hasPlayerOwnedSelectedOtherObjects = true
					break
				end
			end
		end
	end
	if #menu.selectedplayerships > 0 or hasPlayerOwnedSelectedOtherObjects or #menu.selectedplayerdeployables > 0 then
		height = height + menu.uix_multiRename_addButton(ftable)
	end
	-- kuertee end: multi-rename

	-- entries
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isonlinetarget, isplayerownedtarget
	if convertedComponent ~= 0 then
		isonlinetarget, isplayerownedtarget = GetComponentData(convertedComponent, "isonlineobject", "isplayerowned")
	end

	local skipped = false
	local skiporders = false
	if (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.mission) and (not menu.missionoffer) and (not menu.fleetunit) and (not menu.selectedfleetunit) then
		if (#menu.selectedplayerships == 0) and (#menu.selectedotherobjects > 0) then
			-- show the player that they cannot do anything with their selection
			menu.noopreason = {}
			for _, selectedcomponent in ipairs(menu.selectedotherobjects) do
				if C.IsRealComponentClass(selectedcomponent, "ship") then
					local selected64 = ConvertStringTo64Bit(tostring(selectedcomponent))
					if GetComponentData(selected64, "isplayerowned") then
						if IsComponentConstruction(selected64) then
							-- player ship in construction
							menu.noopreason[1] = ReadText(1001, 11106)
						end
					else
						-- npc ship
						menu.noopreason[2] = ReadText(1001, 7852)
					end
				else
					-- station case
					menu.noopreason[3] = ReadText(1001, 11104)
				end
			end
			local reason = ""
			if menu.noopreason[1] then
				reason = menu.noopreason[1]
			end
			if menu.noopreason[2] then
				if reason ~= "" then
					reason = reason .. "\n"
				end
				reason = reason .. menu.noopreason[2]
			elseif menu.noopreason[3] then
				if reason ~= "" then
					reason = reason .. "\n"
				end
				reason = reason .. menu.noopreason[3]
			end

			local row = ftable:addRow(true, { bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(reason, { wordwrap = true, color = Color["text_inactive"] })
			skipped = true
		elseif isonlinetarget and isplayerownedtarget then
			local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7868), { wordwrap = true, color = Color["text_inactive"] })
			skipped = true
		elseif (#menu.ventureships > 0) and (#menu.selectedplayerships == 0) then
			local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 7868), { wordwrap = true, color = Color["text_inactive"] })
			skipped = true
		elseif (menu.numorderloops > 0) and (#menu.selectedplayerships ~= menu.numorderloops) then
			local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_unselectable"] })
			row[1]:setColSpan(5):createText(ReadText(1001, 11108), { wordwrap = true, color = Color["text_inactive"] })
			skipped = true
		elseif (menu.numorderloops > 1) then
			skiporders = ReadText(1001, 11109)
		end
	end

	-- kuertee start: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
	local uix_forceShowSections_skipped_orig = skipped
	skipped = false
	-- kuertee end: forceShowMenus: show main, interaction, custom_actions menu when no actions to show

	local first = not skipped
	for _, section in ipairs(config.sections) do
		if ((not skipped) or (section.skippable == false)) and ((not skiporders) or section.allowmultiloop) then
			-- kuertee start: callback
			local kUIX_isSectionValid = true
			if menu.uix_callbacks ["createContentTable_getIsSectionValid"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["createContentTable_getIsSectionValid"]) do
					kUIX_isSectionValid = uix_callback (section)
					if kUIX_isSectionValid ~= true then
						break
					end
				end
			end
			if kUIX_isSectionValid ~= true then
				goto createContentTable_skipSection
			end
			-- kuertee end: callback

			local pass = false
			if menu.showPlayerInteractions then
				if section.isplayerinteraction or (menu.shown and (not section.isorder)) then
					pass = true
				end
			elseif (section.isorder == nil) or (section.isorder == (#menu.selectedplayerships > 0)) then
				-- kuertee start: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
				if not uix_forceShowSections_skipped_orig then
					pass = true
				end
				-- kuertee end: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
			end

			-- kuertee start: forceShowMenus: show main, interaction, custom_actions menu when no actions to show
			if uix_forceShowSections_skipped_orig then
				if not pass then
					for _, uix_forceShowSection in ipairs(uix_forceShowSections) do
						if section.id == uix_forceShowSection then
							pass = true
							break
						end
					end
				end
			end
			-- kuertee end: forceShowMenus: show main, interaction, custom_actions menu when no actions to show

			-- kuertee start: don't show custom actions in position defense options
			if pass and section.id == "custom_actions" and menu.intersectordefencegroup then
				pass = false
			end
			-- kuertee end: don't show custom actions in position defense options

			if pass then
				if section.subsections then
					local hastitle = false
					for _, subsection in ipairs(section.subsections) do
						-- kuertee start: callback
						local kUIX_isSubsectionValid = true
						if menu.uix_callbacks ["createContentTable_getIsSubsectionValid"] then
							for uix_id, uix_callback in pairs (menu.uix_callbacks ["createContentTable_getIsSubsectionValid"]) do
								kUIX_isSubsectionValid = uix_callback (subsection)
								if kUIX_isSubsectionValid ~= true then
									break
								end
							end
						end
						if kUIX_isSubsectionValid ~= true then
							goto createContentTable_skipSubsection
						end
						-- kuertee end: callback

						if (#menu.actions[subsection.id] > 0) or menu.forceSubSection[subsection.id] then
							if not hastitle then
								height = height + menu.addSectionTitle(ftable, section, first)
								first = false
								hastitle = true
							end
							local data = { id = subsection.id, y = height }
							local row = ftable:addRow(data, {  })
							local iconHeight = Helper.scaleY(config.rowHeight)
							local button = row[1]:setColSpan(5):createButton({
								bgColor = #menu.actions[subsection.id] > 0 and Color["button_background_hidden"] or Color["button_background_inactive"],
								highlightColor = #menu.actions[subsection.id] > 0 and Color["button_highlight_default"] or Color["button_highlight_inactive"],
								mouseOverText = (#menu.actions[subsection.id] > 0) and "" or menu.forceSubSection[subsection.id],
								helpOverlayID = subsection.helpOverlayID,
								helpOverlayText = subsection.helpOverlayText,
								helpOverlayHighlightOnly = subsection.helpOverlayHighlightOnly,
							}):setText((subsection.orderid and menu.orderIconText(subsection.orderid) or "") .. subsection.text):setIcon("table_arrow_inv_right", { scaling = false, width = iconHeight, height = iconHeight, x = menu.width - iconHeight })

							-- kuertee start: callback
							-- row[1].handlers.onClick = function () return menu.handleSubSectionOption(data, true) end
							row[1].handlers.onClick = function()
								local uix_isOverrideClickEvent
								if menu.uix_callbacks ["interactMenu_clickSubsection"] then
									for uix_id, uix_callback in pairs (menu.uix_callbacks ["interactMenu_clickSubsection"]) do
										uix_isOverrideClickEvent = uix_callback (menu.actions[subsection.id])
										if uix_isOverrideClickEvent then
											break
										end
									end
								end
								if not uix_isOverrideClickEvent then
									return menu.handleSubSectionOption(data, true)
								end
							end
							-- kuertee end: callback

							height = height + row:getHeight() + Helper.borderSize
						end

						-- kuertee start: callback
						:: createContentTable_skipSubsection ::
						-- kuertee end: callback
					end
				elseif #menu.actions[section.id] > 0 then
					height = height + menu.addSectionTitle(ftable, section, first)
					first = false
					local availabletextwidth
					if (section.id == "main") or (section.id == "selected_orders") or (section.id == "trade_orders") or (section.id == "selected_assignments") or (section.id == "player_interaction") or (section.id == "trade") then
						local maxtextwidth = 0
						for _, entry in ipairs(menu.actions[section.id]) do
							if not entry.hidetarget then
								maxtextwidth = math.max(maxtextwidth, C.GetTextWidth(entry.text .. " ", Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.entryFontSize, true)))
							end
						end
						availabletextwidth = menu.width - maxtextwidth - 2 * Helper.scaleX(config.entryX) - Helper.borderSize
					end

					for _, entry in ipairs(menu.actions[section.id]) do

						-- kuertee start: callback
						local kUIX_isActionValid = true
						if menu.uix_callbacks ["createContentTable_getIsActionValid"] then
							for uix_id, uix_callback in pairs (menu.uix_callbacks ["createContentTable_getIsActionValid"]) do
								kUIX_isActionValid = uix_callback (entry)
								if kUIX_isActionValid ~= true then
									break
								end
							end
						end
						if kUIX_isActionValid ~= true then
							goto createContentTable_skipAction
						end
						-- kuertee end: callback

						if entry.active == nil then
							entry.active = true
						end
						local row = ftable:addRow(true, {  })
						if entry.checkbox ~= nil then
							row[1]:setColSpan(1):createCheckBox(entry.checkbox, { active = entry.active, mouseOverText = entry.mouseOverText })
							row[1].properties.uiTriggerID = entry.type
							row[2]:setColSpan(4):createText(entry.text, {
								color = entry.active and Color["text_normal"] or Color["text_inactive"],
								mouseOverText = entry.mouseOverText,
								helpOverlayID = entry.helpOverlayID,
								helpOverlayText = entry.helpOverlayText,
								helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
							})
						else
							local button = row[1]:setColSpan(5):createButton({
								bgColor = entry.active and Color["button_background_hidden"] or Color["button_background_inactive"],
								highlightColor = entry.active and Color["button_highlight_default"] or Color["button_highlight_inactive"],
								mouseOverText = entry.mouseOverText,
								helpOverlayID = entry.helpOverlayID,
								helpOverlayText = entry.helpOverlayText,
								helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
							}):setText(entry.text, { color = entry.active and Color["text_normal"] or Color["text_inactive"] })
							button.properties.uiTriggerID = entry.type
							if (section.id == "selected_orders") or (section.id == "trade_orders") or (section.id == "selected_assignments") or (section.id == "player_interaction") or (section.id == "trade") then
								if not entry.hidetarget then
									local text2 = ""
									if entry.text2 then
										text2 = entry.text2
									else
										if ((section.id == "trade_orders") or (section.id == "trade") or (section.id == "player_interaction")) and entry.buildstorage then
											text2 = menu.texts.buildstorageName
										else
											text2 = menu.texts.targetBaseName or menu.texts.targetShortName
										end
									end
									text2 = TruncateText(text2, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
									button:setText2(text2, { halign = "right", color = menu.colors.target })
									if (entry.mouseOverText == nil) or (entry.mouseOverText == "") then
										button.properties.mouseOverText = entry.text .. " " .. (entry.buildstorage and menu.texts.buildstorageFullName or menu.texts.targetName)
									end
								end
							elseif (section.id == "main") then
								if entry.text2 then
									local text2 = entry.text2
									text2 = TruncateText(text2, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
									button:setText2(text2, { halign = "right", color = menu.colors.target })
								end
							end
						end
						if entry.active then

							-- kuertee start: callback
							-- row[1].handlers.onClick = entry.script
							row[1].handlers.onClick = function()
								local uix_isOverrideClickEvent
								if menu.uix_callbacks ["interactMenu_clickAction"] then
									for uix_id, uix_callback in pairs (menu.uix_callbacks ["interactMenu_clickAction"]) do
										uix_isOverrideClickEvent = uix_callback (entry)
										if uix_isOverrideClickEvent then
											break
										end
									end
								end
								if not uix_isOverrideClickEvent then
									entry.script()
								end
							end
							-- kuertee end: callback

						end
						height = height + row:getHeight() + Helper.borderSize

						-- kuertee start: callback
						:: createContentTable_skipAction ::
						-- kuertee end: callback
					end
				end
			end


			-- kuertee start: callback
			:: createContentTable_skipSection ::
			-- kuertee end: callback
		end
	end
	if skiporders then
		local row = ftable:addEmptyRow(config.rowHeight / 2)

		local row = ftable:addRow(true, { fixed = true })
		row[1]:setColSpan(5):createText(utf8.char(8734) .. " " .. ReadText(1001, 16), { font = Helper.standardFontBold, titleColor = Color["row_title"] })

		local row = ftable:addRow(true, { fixed = true, bgColor = Color["row_background_unselectable"] })
		row[1]:setColSpan(5):createText(skiporders, { wordwrap = true, color = Color["text_inactive"] })
	elseif first then
		local row = ftable:addRow(true, {  })
		local button = row[1]:setColSpan(5):createButton({ active = false, bgColor = Color["button_background_inactive"] }):setText("---", { halign = "center", color = Color["text_error"] })
	end

	ftable:setSelectedRow(menu.selectedRows.contentTable)
	ftable:setTopRow(menu.topRows.contentTable)
	menu.selectedRows.contentTable = nil
	menu.topRows.contentTable = nil

	return ftable
end

-- kuertee start: multi-rename
local uix_multiRename_objects
function menu.uix_multiRename_addButton(ftable)
	uix_multiRename_objects = menu.uix_multiRename_getObjects()
	local height = 0
	if #uix_multiRename_objects > 1 then
		local row = ftable:addRow(true, {  })
		local button = row[1]:setColSpan(5):createButton({
			active = true,
			bgColor = Color["button_background_inactive"],
			highlightColor = Color["button_highlight_default"],
		}):setText((ReadText(1001, 1114)))
		local text2 = string.format(ReadText(1001, 11105), #uix_multiRename_objects)
		button:setText2(text2, { halign = "right", color = menu.colors.target })
		row[1].handlers.onClick = function () return menu.buttonRename(nil, true) end
		height = height + row:getHeight() + Helper.borderSize
	end
	return height
end
-- kuertee end: multi-rename

function menu.createSubSectionTable(frame, position)
	local x = 0
	if position == "right" then
		x = menu.width + Helper.borderSize
	end

	local ftable = frame:addTable(2, { tabOrder = 1, x = x, width = menu.width, backgroundID = "solid", backgroundColor = Color["frame_background_semitransparent"], highlightMode = "off" })
	ftable:setDefaultCellProperties("text",   { minRowHeight = config.rowHeight, fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultCellProperties("button", { height = config.rowHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setDefaultComplexCellProperties("button", "text2", { fontsize = config.entryFontSize, x = config.entryX })
	ftable:setColWidthPercent(2, 40)
	ftable:setDefaultBackgroundColSpan(1, 2)

	for _, entry in ipairs(menu.actions[menu.subsection.id]) do
		if entry.active == nil then
			entry.active = true
		end
		row = ftable:addRow(true, {  })
		local maxtextwidth = 0
		if entry.text2 then
			maxtextwidth = C.GetTextWidth(entry.text2 .. " ", entry.text2font or Helper.standardFont, Helper.scaleFont(Helper.standardFont, config.entryFontSize, true))
		end
		local availabletextwidth = menu.width - maxtextwidth - 2 * Helper.scaleX(config.entryX) - Helper.borderSize

		local button = row[1]:setColSpan(2):createButton({
			active = entry.active,
			bgColor = entry.active and Color["button_background_hidden"] or Color["button_background_inactive"],
			helpOverlayID = entry.helpOverlayID,
			helpOverlayText = entry.helpOverlayText,
			helpOverlayHighlightOnly = entry.helpOverlayHighlightOnly,
		})
		button.properties.uiTriggerID = entry.type
		local text = TruncateText(entry.text, button.properties.text.font, Helper.scaleFont(button.properties.text.font, button.properties.text.fontsize, button.properties.scaling), availabletextwidth)
		if entry.mouseOverText then
			button.properties.mouseOverText = entry.mouseOverText
		elseif text ~= entry.text then
			button.properties.mouseOverText = entry.text
		end
		button:setText(text, { color = entry.active and Color["text_normal"] or Color["text_inactive"] })

		-- kuertee start: callback
		-- row[1].handlers.onClick = entry.script
		row[1].handlers.onClick = function()
			local uix_isOverrideClickEvent
			if menu.uix_callbacks ["interactMenu_clickAction"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["interactMenu_clickAction"]) do
					uix_isOverrideClickEvent = uix_callback (entry)
					if uix_isOverrideClickEvent then
						break
					end
				end
			end
			if not uix_isOverrideClickEvent then
				entry.script()
			end
		end
		-- kuertee end: callback

		if entry.text2 then
			button:setText2(entry.text2, { halign = "right", color = entry.active and Color["text_normal"] or Color["text_inactive"], font = entry.text2font or Helper.standardFont })
		end
	end

	return ftable
end

-- helpers

function menu.getPlayerSquad()
	local playerSquad = {}

	local playerOccupiedShip = C.GetPlayerOccupiedShipID()
	if (playerOccupiedShip ~= 0) then
		local locplayersubordinates = GetSubordinates(ConvertStringTo64Bit(tostring(playerOccupiedShip)), nil, true)
		for _, subordinate in ipairs(locplayersubordinates) do
			playerSquad[ConvertIDTo64Bit(subordinate)] = true
			--print("inserting: " .. ConvertIDTo64Bit(subordinate))
		end
	end

	return playerSquad
end

function menu.getSubordinatesInGroups(commander, isstation, assignment, singlegroup)
	local groups = {}
	for group = 1, isstation and 5 or 10 do
		local locassignment = ffi.string(C.GetSubordinateGroupAssignment(commander, group))
		local process
		if assignment then
			process = assignment == locassignment
		else
			process = locassignment ~= ""
		end
		if process then
			local numsubordinates = C.GetNumSubordinatesOfGroup(commander, group)
			if numsubordinates > 0 then
				local subordinates = ffi.new("UniverseID[?]", numsubordinates)
				numsubordinates = C.GetSubordinatesOfGroup(subordinates, numsubordinates, commander, group)
				if numsubordinates > 0 then
					for i = 0, numsubordinates - 1 do
						local component = ConvertStringToLuaID(tostring(subordinates[i]))
						-- filter out subordinates that are actually subordinates of a fleetunit, we want to show the fleetunit instead
						local commander = C.GetCommander(subordinates[i], 0)
						if commander.controllableid ~= 0 then
							groups[group] = groups[group] or { assignment = locassignment, subordinates = {} }
							table.insert(groups[group].subordinates, { component = component, name = GetComponentData(component, "name"), objectid = ffi.string(C.GetObjectIDCode(subordinates[i])) })
						end
					end
				end
			end

			local n = C.GetNumControllableSubordinateFleetUnits(commander, group)
			if n > 0 then
				groups[group] = groups[group] or { assignment = locassignment, subordinates = {} }
				local buf = ffi.new("FleetUnitID[?]", n)
				n = C.GetControllableSubordinateFleetUnits(buf, n, commander, group)
				local fleetunits = {}
				for i = 0, n - 1 do
					table.insert(fleetunits, buf[i])
				end

				for _, fleetunit in ipairs(fleetunits) do
					local unitinfo = C.GetFleetUnitInfo(fleetunit)
					table.insert(groups[group].subordinates, { fleetunit = fleetunit, name = ffi.string(unitinfo.name), objectid = ffi.string(unitinfo.idcode) })
				end
			end

			if groups[group] then
				table.sort(groups[group].subordinates, Helper.sortNameAndObjectID)
				if singlegroup then
					break
				end
			end
		end
	end
	return groups
end

function menu.getSubordinatesInFleetUnitGroups(commanderfleetunit, assignment, singlegroup)
	local groups = {}
	for group = 1, 10 do
		local locassignment = ffi.string(C.GetFleetUnitSubordinateGroupAssignment(commanderfleetunit, group))
		local process
		if assignment then
			process = assignment == locassignment
		else
			process = locassignment ~= ""
		end
		if process then
			local numsubordinates = C.GetNumFleetUnitSubordinates(commanderfleetunit, group)
			if numsubordinates > 0 then
				local subordinates = ffi.new("UniverseID[?]", numsubordinates)
				numsubordinates = C.GetFleetUnitSubordinates(subordinates, numsubordinates, commanderfleetunit, group)
				if numsubordinates > 0 then
					groups[group] = { assignment = locassignment, subordinates = {} }
					for i = 0, numsubordinates - 1 do
						local component = ConvertStringToLuaID(tostring(subordinates[i]))
						table.insert(groups[group].subordinates, { component = component, name = GetComponentData(component, "name"), objectid = ffi.string(C.GetObjectIDCode(subordinates[i])) })
					end
					table.sort(groups[group].subordinates, Helper.sortNameAndObjectID)
					if singlegroup then
						break
					end
				end
			end

			local num_fleetunits = C.GetNumFleetUnitSubordinateFleetUnits(commanderfleetunit, group)
			if num_fleetunits > 0 then
				groups[group] = groups[group] or { assignment = locassignment, subordinates = {} }
				local buf_fleetunits = ffi.new("FleetUnitID[?]", num_fleetunits)
				num_fleetunits = C.GetFleetUnitSubordinateFleetUnits(buf_fleetunits, num_fleetunits, commanderfleetunit, group)
				local fleetunits = {}
				for i = 0, num_fleetunits - 1 do
					table.insert(fleetunits, buf_fleetunits[i])
				end

				for _, fleetunitsubordinate in ipairs(fleetunits) do
					local unitinfo = C.GetFleetUnitInfo(fleetunitsubordinate)
					table.insert(groups[group].subordinates, { fleetunit = fleetunitsubordinate, name = ffi.string(unitinfo.name), objectid = ffi.string(unitinfo.idcode) })
				end
			end

			if groups[group] then
				table.sort(groups[group].subordinates, Helper.sortNameAndObjectID)
				if singlegroup then
					break
				end
			end
		end
	end
	return groups
end

function menu.setOrderImmediate(component, orderidx)
	local newidx = 1
	if not C.AdjustOrder(component, orderidx, newidx, true, false, true) then
		newidx = 2
	end
	C.AdjustOrder(component, orderidx, newidx, true, false, false)
end

function menu.handleSubSectionOption(data, skipdelay)
	if type(data) == "table" then
		if ((not menu.pendingSubSection) and ((not menu.subsection) or (menu.subsection.id ~= data.id))) or (menu.pendingSubSection and ((type(menu.pendingSubSection) ~= "table") or (menu.pendingSubSection.id ~= data.id))) then
			if #menu.actions[data.id] > 0 then
				if skipdelay then
					menu.subsection = data
				else
					if (not menu.subsection) or (menu.subsection.id ~= data.id) then
						menu.pendingSubSection = data
					else
						menu.pendingSubSection = nil
					end
				end
			else
				if skipdelay then
					menu.subsection = nil
				else
					menu.pendingSubSection = -1
				end
			end
			if skipdelay then
				menu.pendingSubSection = nil
				menu.refresh = true
			else
				menu.lastSubSectionTime = getElapsedTime()
			end
		end
	else
		if type(menu.subsection) == "table" then
			if skipdelay then
				menu.subsection = nil
				menu.pendingSubSection = nil
				menu.refresh = true
			else
				menu.pendingSubSection = -1
				menu.lastSubSectionTime = getElapsedTime()
			end
		end
	end
end

function menu.processSelectedPlayerShips()
	local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	local isplayerownedtarget, istargetatdockrelation, istargetdockingenabled = false, false, false
	if convertedComponent ~= 0 then
		isplayerownedtarget, istargetatdockrelation, istargetdockingenabled = GetComponentData(convertedComponent, "isplayerowned", "isdock", "isdockingenabled")
		iscontrollable = C.IsComponentClass(menu.componentSlot.component, "controllable")
	end
	local playercontainer = C.GetPlayerContainerID()
	local convertedPlayerContainer
	if playercontainer ~= 0 then
		convertedPlayerContainer = ConvertStringTo64Bit(tostring(playercontainer))
	end
	local occupiedPlayerShip = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))

	menu.possibleorders = {
		["Attack"] = false,
		["AttackInRange"] = false,
		["Board"] = false,
		["Collect"] = false,
		["CollectDeployables"] = false,
		["CollectDropsInRadius"] = false,
		["CollectLockbox"] = false,
		["DeployObjectAtPosition"] = false,
		["DockAndWait"] = false,
		["Explore"] = false,
		["ExploreUpdate"] = false,
		["Flee"] = false,
		["Follow"] = false,
		["MiningPlayer"] = false,
		["MoveWait"] = false,
		["Player_DockToTrade"] = false,
		["ProtectStation"] = false,
		["Repair"] = false,
		["RescueInRange"] = false,
		["RescueShip"] = false,
		["SalvageCrush"] = false,
		["SalvageCollect"] = false,
		["SalvageDeliver"] = false,
		["SalvageDeliver_NoTrade"] = false,
		["SalvageInRadius"] = false,
		["TacticalOrder"] = false,
	}
	menu.orderdefs = {}
	menu.loopableorders = {}
	local n = C.GetNumOrderDefinitions()
	local buf = ffi.new("OrderDefinition[?]", n)
	n = C.GetOrderDefinitions(buf, n)
	for i = 0, n - 1 do
		local id = ffi.string(buf[i].id)
		menu.orderdefs[id] = { icon = ffi.string(buf[i].icon), description = ffi.string(buf[i].description) }
		menu.loopableorders[id] = C.IsOrderLoopable(id)
	end

	menu.numdockingpossible = 0
	menu.numassignableships = 0
	menu.numassignableminingships = 0
	menu.numassignableresupplyships = 0
	menu.numassignabletugs = 0
	menu.numremovableorders = 0
	menu.numremovabledefaultorders = 0
	menu.numwaitingforsignal = 0
	menu.numdockingatplayerpossible = 0
	menu.numshipswithcommander = 0
	menu.numhaveturret = 0
	menu.numshipsexcludingspacesuits = 0
	menu.ventureships = {}
	menu.numorderloops = 0
	menu.dockingerrors = {}
	menu.shipswithcurrentcommander = {}

	for i = #menu.selectedplayerships, 1, -1 do
		local ship = menu.selectedplayerships[i]

		local isdocked, isdocking, hasturret, isonlineobject = GetComponentData(ship, "isdocked", "isdocking", "hasturret", "isonlineobject")
		if (not C.IsUnit(ship)) and (not isonlineobject) then
			local commander = ConvertIDTo64Bit(GetCommander(ship))
			-- check commander
			if commander then
				menu.numshipswithcommander = menu.numshipswithcommander + 1
				if commander == convertedComponent then
					table.insert(menu.shipswithcurrentcommander, ship)
				end
			end
			-- check turrets
			if hasturret then
				menu.numhaveturret = menu.numhaveturret + 1
			end
			-- check order removal
			local numorders = C.GetNumOrders(ship)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, ship)
			for i = numorders, 1, -1 do
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
				else
					if C.RemoveOrder(ship, i, false, true) then
						menu.numremovableorders = menu.numremovableorders + 1
						break
					end
					local currentdefaultorder = ffi.new("Order")
					if C.GetDefaultOrder(currentdefaultorder, ship) then
						if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
							menu.numremovabledefaultorders = menu.numremovabledefaultorders + 1
							break
						end
					end
					if commander and (commander ~= 0) and (commander ~= occupiedPlayerShip) then
						menu.numremovabledefaultorders = menu.numremovabledefaultorders + 1
						break
					end
				end
			end
		end

		if ship == menu.componentSlot.component then
			table.remove(menu.selectedplayerships, i)

			-- kuertee start: multi-rename
			menu.uix_multiRename_removedActionTarget = ship
			-- kuertee end: multi-rename

		elseif C.IsUnit(ship) then
			table.remove(menu.selectedplayerships, i)
		elseif isonlineobject then
			table.insert(menu.ventureships, ship)
			table.remove(menu.selectedplayerships, i)
		else
			-- Check orders
			for orderid, value in pairs(menu.possibleorders) do
				if not value then
					if C.IsOrderSelectableFor(orderid, ship) then
						menu.possibleorders[orderid] = true
					end
				end
			end

			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(ship, hasloop)
			if hasloop[0] then
				menu.numorderloops = menu.numorderloops + 1
			end

			-- Check space suit
			local isspacesuit = C.IsComponentClass(ship, "spacesuit")
			if not isspacesuit then
				menu.numshipsexcludingspacesuits = menu.numshipsexcludingspacesuits + 1
			end

			-- Check assignments
			if (not isspacesuit) and GetComponentData(ship, "assignedpilot") then
				if menu.fleetunit or (isplayerownedtarget and iscontrollable and (commander ~= convertedComponent) and C.CanAcceptSubordinate(menu.componentSlot.component, ship)) then
					menu.numassignableships = menu.numassignableships + 1
					if GetComponentData(ship, "primarypurpose") == "mine" then
						menu.numassignableminingships = menu.numassignableminingships + 1
					elseif GetComponentData(ship, "shiptype") == "resupplier" then
						menu.numassignableresupplyships = menu.numassignableresupplyships + 1
					elseif GetComponentData(ship, "shiptype") == "tug" then
						menu.numassignabletugs = menu.numassignabletugs + 1
					end
				end
			end

			-- Check docking
			if (convertedComponent ~= 0) and C.IsComponentClass(menu.componentSlot.component, "container") then
				if IsDockingPossible(ship, convertedComponent) then
					menu.numdockingpossible = menu.numdockingpossible + 1
				elseif not istargetatdockrelation then
					menu.dockingerrors[1] = ReadText(1026, 7825)
				elseif not istargetdockingenabled then
					menu.dockingerrors[2] = ReadText(1026, 7843)
				else
					menu.dockingerrors[3] = ReadText(1026, 7824)
				end
			end
			if (playercontainer ~= 0) and IsDockingPossible(ship, convertedPlayerContainer) and (GetComponentData(ship, "assignedpilot") ~= nil) then
				menu.numdockingatplayerpossible = menu.numdockingatplayerpossible + 1
			end

			-- check for waiting for signal
			local numorders = C.GetNumOrders(ship)
			if numorders > 0 then
				local orderparams = GetOrderParams(ship, 1)
				local iswaitingforsignal = false
				for i, param in ipairs(orderparams) do
					if param.name == "releasesignal" and type(param.value) == "table" and param.value[1] == "playerownedship_proceed" then
						menu.numwaitingforsignal = menu.numwaitingforsignal + 1
						break
					end
				end
			end
		end
	end
	menu.hasPlayerShipPilot = false
	if (#menu.selectedplayerships == 1) and (menu.selectedplayerships[1] == occupiedPlayerShip) then
		menu.showPlayerInteractions = true
	else
		for i, ship in ipairs(menu.selectedplayerships) do
			if ship == occupiedPlayerShip then
				menu.removedOccupiedPlayerShip = occupiedPlayerShip
				table.remove(menu.selectedplayerships, i)
			end
			if GetComponentData(ship, "assignedpilot") then
				menu.hasPlayerShipPilot = true
			end
		end
	end

	if isplayerownedtarget and C.IsComponentClass(menu.componentSlot.component, "ship") then
		if (playercontainer ~= 0) and (convertedComponent ~= 0) and IsDockingPossible(convertedComponent, convertedPlayerContainer) and (GetComponentData(convertedComponent, "assignedpilot") ~= nil) then
			menu.numdockingatplayerpossible = menu.numdockingatplayerpossible + 1
		end
	end

	for i = #menu.selectedotherobjects, 1, -1 do
		local ship = menu.selectedotherobjects[i]
		if ship == menu.componentSlot.component then
			table.remove(menu.selectedotherobjects, i)

			-- kuertee start: multi-rename
			menu.uix_multiRename_removedActionTarget = ship
			-- kuertee end: multi-rename

			break
		end
	end
end

function menu.prepareSections()
	menu.actions = {}
	for _, section in ipairs(config.sections) do
		if section.subsections then

			-- kuertee start: add section initializer
			menu.actions[section.id] = {}
			-- kuertee end: add section initializer

			for _, subsection in ipairs(section.subsections) do
				menu.actions[subsection.id] = {}
			end
		else
			menu.actions[section.id] = {}
		end
	end
end

function menu.insertInteractionContent(section, entry)
	if menu.actions[section] then

		if entry.orderid then
			if menu.numorderloops > 0 then
				if not menu.loopableorders[entry.orderid] then
					entry.active = false
					entry.mouseOverText = ReadText(1026, 7851)
				end
			end
			if entry.active ~= false then
				if not menu.hasPlayerShipPilot then
					entry.active = false
					entry.mouseOverText = ReadText(1026, 7830)
				end
			end

			entry.mouseOverText = menu.orderdefs[entry.orderid].description .. (((entry.mouseOverText ~= nil) and (entry.mouseOverText ~= "")) and ("\n\n" .. entry.mouseOverText) or "")
		end

		table.insert(menu.actions[section], entry)
	else
		DebugError("The requested context section is not defined: '" .. section .. "' [Florian]")
	end
end

config.consumables = {
	{ id = "satellite",		type = "civilian",	getnum = C.GetNumAllSatellites,		getdata = C.GetAllSatellites },
	{ id = "navbeacon",		type = "civilian",	getnum = C.GetNumAllNavBeacons,		getdata = C.GetAllNavBeacons },
	{ id = "resourceprobe",	type = "civilian",	getnum = C.GetNumAllResourceProbes,	getdata = C.GetAllResourceProbes },
	{ id = "lasertower",	type = "military",	getnum = C.GetNumAllLaserTowers,	getdata = C.GetAllLaserTowers },
	{ id = "mine",			type = "military",	getnum = C.GetNumAllMines,			getdata = C.GetAllMines },
}

function menu.addConsumableEntry(basesection, consumabledata, object, callback)
	local numconsumable = consumabledata.getnum(object)
	if numconsumable > 0 then
		local consumables = ffi.new("AmmoData[?]", numconsumable)
		numconsumable = consumabledata.getdata(consumables, numconsumable, object)
		for j = 0, numconsumable - 1 do
			if consumables[j].amount > 0 then
				local macro = ffi.string(consumables[j].macro)
				menu.insertInteractionContent(basesection .. "_" .. consumabledata.type, { type = consumabledata.type, text = GetMacroData(macro, "name"), text2 = "(" .. consumables[j].amount .. ")", script = function () return callback(consumabledata.id, macro, 1) end })
			end
		end
	end
end

function menu.insertAssignSubActions(section, assignment, callback, groups, isstation, unique, currentgroup, mouseovertextadd)
	local groupexists = false
	if unique then
		for i = 1, isstation and 5 or 10 do
			if groups[i] and (groups[i].assignment == assignment) then
				-- found a matching group
				groupexists = true
				break
			end
		end
	end
	for i = 1, isstation and 5 or 10 do
		if groups[i] then
			local active = (groups[i].assignment == assignment) or ((i == menu.subordinategroup) and ((not unique) or (not groupexists)))
			local mouseovertext = ""
			if active then
				for i, subordinateentry in ipairs(groups[i].subordinates) do
					mouseovertext = mouseovertext .. ((i > 1) and "\n" or "") .. (subordinateentry.fleetunit and ColorText["text_player_lowlight"] or Helper.convertColorToText(menu.holomapcolor.playercolor)) .. subordinateentry.name .. " (" .. subordinateentry.objectid .. ")"
				end
				if mouseovertextadd and (mouseovertextadd ~= "") then
					mouseovertext = mouseovertextadd .. ((mouseovertext ~= "") and "\n\n" or "") .. mouseovertext
				end
			else
				mouseovertext = ReadText(1026, 7839) .. "\n" .. (config.assignments[groups[i].assignment] and config.assignments[groups[i].assignment].name or "")
			end

			local currenttext = ""
			if i == currentgroup then
				currenttext = " [" .. ReadText(1001, 7899) .. "]"
			end

			menu.insertInteractionContent(section, { type = "assign", text = ReadText(20401, i) .. currenttext, text2 = ((#groups[i].subordinates > 0) and Helper.convertColorToText(menu.holomapcolor.playercolor) or "") .. ((#groups[i].subordinates > 1) and string.format(ReadText(1001, 7898), #groups[i].subordinates) or (#groups[i].subordinates == 1) and ReadText(1001, 7897) or ReadText(1001, 7896)), script = function () callback(assignment, i) end, active = active, mouseOverText = mouseovertext })
		else
			local active = ((not unique) or (not groupexists)) and (assignment ~= "positiondefence")
			local mouseovertext = ""
			if not active then
				if assignment == "positiondefence" then
					mouseovertext = ReadText(1026, 7863)
				else
					mouseovertext = ReadText(1026, 7840)
				end
			end
			if active then
				if mouseovertextadd and (mouseovertextadd ~= "") then
					mouseovertext = mouseovertextadd .. ((mouseovertext ~= "") and "\n\n" or "") .. mouseovertext
				end
			end
			menu.insertInteractionContent(section, { type = "assign", text = ReadText(20401, i), text2 = ReadText(1001, 7896), script = function () callback(assignment, i) end, active = active, mouseOverText = mouseovertext })
		end
	end
end

function menu.insertLuaAction(actiontype, istobedisplayed)
	local convertedComponent = menu.data.convertedComponent
	local isplayerownedtarget = menu.data.isplayerownedtarget
	local istargetinplayersquad = menu.data.istargetinplayersquad
	local istargetplayeroccupiedship = menu.data.istargetplayeroccupiedship
	local hastargetpilot = menu.data.hastargetpilot

	if actiontype == "armturrets" then
		if istobedisplayed and (menu.numhaveturret > 0) then
			local allarmed = true
			local hasturret = GetComponentData(convertedComponent, "hasturret")
			if hasturret then
				allarmed = menu.areTurretsArmed(menu.componentSlot.component)
			end
			if allarmed then
				for _, ship in ipairs(menu.selectedplayerships) do
					local hasturret = GetComponentData(ship, "hasturret")
					if hasturret and (not menu.areTurretsArmed(ship)) then
						allarmed = false
						break
					end
				end
			end

			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "interaction", { type = actiontype, text = allarmed and ReadText(1001, 11102) or ReadText(1001, 11101), script = function () return menu.buttonArmTurrets(not allarmed) end })
		end
	elseif actiontype == "assign" then
		if (menu.showPlayerInteractions or ((#menu.selectedplayerships == 0) and (not menu.shown))) and C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local isplayerowned = GetComponentData(convertedComponent, "isplayerowned")
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if isplayerowned and (not commander) or (commander == 0) then
				local occupiedplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
				if occupiedplayership and (occupiedplayership ~= 0) and (occupiedplayership ~= menu.componentSlot.component) and C.CanAcceptSubordinate(occupiedplayership, menu.componentSlot.component) then
					local subordinates = GetSubordinates(occupiedplayership)
					local groups = menu.getSubordinatesInGroups(occupiedplayership, false)

					-- defence
					menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonAssignCommander, groups, false, false)
					-- position defence
					local commandershiptype = GetComponentData(occupiedplayership, "shiptype")
					local parentcommander = ConvertIDTo64Bit(GetCommander(occupiedplayership))
					local isfleetcommander = (not parentcommander) and (#subordinates > 0)
					if (commandershiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonAssignCommander, groups, false, false)
					end
					-- supplyfleet
					if GetComponentData(convertedComponent, "shiptype") == "resupplier" then
						menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonAssignCommander, groups, false, true)
					end
					menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonAssignCommander, groups, false)
					menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonAssignCommander, groups, false, true)
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, occupiedplayership) then
						menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonAssignCommander, groups, false, true)
					end
				end
			end
		elseif menu.numassignableships > 0 then
			local subordinates = GetSubordinates(convertedComponent)

			local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
			local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
			local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, isstation)
			if isstation and C.CanClaimOwnership(menu.componentSlot.component) then
				menu.insertAssignSubActions("selected_assignments_positiondefence", "positiondefence", menu.buttonAssignCommander, groups, isstation, isstation)
			end
			-- defence
			menu.insertAssignSubActions("selected_assignments_defence", "defence", menu.buttonAssignCommander, groups, isstation, isstation)
			-- supplyfleet
			if menu.numassignableresupplyships > 0 then
				menu.insertAssignSubActions("selected_assignments_supplyfleet", "supplyfleet", menu.buttonAssignCommander, groups, isstation, true)
			end
			if isstation then
				-- trading
				menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignCommander, groups, isstation, true, nil, (menu.numassignableminingships > 0) and (ColorText["text_warning"] .. ReadText(1026, 8609)) or "")
				-- mining
				if menu.numassignableminingships > 0 then
					menu.insertAssignSubActions("selected_assignments_mining", "mining", menu.buttonAssignCommander, groups, isstation, true)
				end
				-- trading for buildstorage
				local numnonminingships = menu.numassignableships - menu.numassignableminingships
				if numnonminingships > 0 then
					menu.insertAssignSubActions("selected_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonAssignCommander, groups, isstation, true)
				end
				if menu.numassignabletugs > 0 then
					menu.insertAssignSubActions("selected_assignments_salvage", "salvage", menu.buttonAssignCommander, groups, isstation, true)
				end
			elseif isship then
				-- position defence
				local shiptype = GetComponentData(convertedComponent, "shiptype")
				local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
				local isfleetcommander = (not commander) and (#subordinates > 0)
				if (shiptype == "carrier") and isfleetcommander then
					menu.insertAssignSubActions("selected_assignments_positiondefence", "positiondefence", menu.buttonAssignCommander, groups, isstation)
				end
				menu.insertAssignSubActions("selected_assignments_attack", "attack", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_interception", "interception", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_bombardment", "bombardment", menu.buttonAssignCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_follow", "follow", menu.buttonAssignCommander, groups, isstation, true)
				local buf = ffi.new("Order")
				if C.GetDefaultOrder(buf, menu.componentSlot.component) then
					menu.insertAssignSubActions("selected_assignments_assist", "assist", menu.buttonAssignCommander, groups, isstation, true)
				end

				-- start: aegs call-back
				if menu.uix_callbacks ["map_rightMenu_shipassignments_insert_01"] then
					local state,main_o,assignment_o
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_rightMenu_shipassignments_insert_01"]) do
						state,main_o,assignment_o = uix_callback (GetComponentData(convertedComponent, "macro"),menu.numassignableminingships,menu.numassignabletugs)
						if state then
							menu.insertAssignSubActions(main_o, assignment_o, menu.buttonAssignCommander, groups, isstation, true)
						end
					end
				end
				-- end: aegs call-back

				if shiptype == "resupplier" then
					menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignCommander, groups, isstation, true)
				end
			end
		end
	elseif actiontype == "attack" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Attack") .. ReadText(1001, 7815), helpOverlayID = "interactmenu_attack", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttack(false) end, orderid = "Attack" })
		end

		-- start: aegs call-back
		if menu.uix_callbacks ["map_rightMenu_shipOverview_insert"] then
			local category_o,text_o
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_rightMenu_shipOverview_insert"]) do
				category_o,text_o = uix_callback (GetComponentData(convertedComponent, "macro"))
				if category_o then
					menu.insertInteractionContent("main", { type = "logicalstationoverview", text = text_o, helpOverlayID = "interactmenu_logicalstationoverview", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStationOverview })
				end
			end
		end
		-- end: aegs call-back

	elseif actiontype == "attackinrange" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["AttackInRange"] then
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("AttackInRange") .. ReadText(1041, 631), helpOverlayID = "interactmenu_attackinrange", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttackInRange(false) end, hidetarget = true, orderid = "AttackInRange" } )
			end
		end
	elseif actiontype == "attackmultiple" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Attack") .. ReadText(1001, 7816), helpOverlayID = "interactmenu_attackmultiple", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonAttackMultiple(false) end, hidetarget = true, orderid = "Attack" })
		end
	elseif actiontype == "attackplayertarget" then
		if (istargetinplayersquad or istargetplayeroccupiedship) and GetPlayerTarget() then
			--print("player target: " .. tostring(GetPlayerTarget()))
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7869), helpOverlayID = "interactmenu_attackplayertarget", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerSquadAttackPlayerTarget(false) end, hidetarget = true })	-- Fleet: Attack my target
		end
	elseif actiontype == "behaviourinspection" then
		if (not menu.shown) and istobedisplayed and (menu.componentSlot.component ~= C.GetPlayerControlledShipID()) and C.IsComponentOperational(menu.componentSlot.component) then
			local active = true
			local mouseovertext = ""
			if menu.componentSlot.component == menu.behaviourInspectionComponent then
				active = false
				mouseovertext = ReadText(1026, 7870)
			end
			menu.insertInteractionContent("main", { type = actiontype, text = "\27[menu_behaviourinspection] " .. ReadText(1001, 11144), helpOverlayID = "interactmenu_behaviourinspection", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonBehaviourInspection, active = active, mouseOverText = mouseovertext })
			if menu.behaviourInspectionComponent and (not menu.shown) then
				menu.insertInteractionContent((#menu.selectedplayerships > 0) and "behaviourinspection" or "main", { type = "stopbehaviourinspection", text = ColorText["behaviour_inspection_text"] .. "\27[menu_behaviourinspection_exit]\27X " .. ReadText(1001, 11145), helpOverlayID = "interactmenu_stopbehaviourinspection", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStopBehaviourInspection })
			end
		end
	elseif actiontype == "disable" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Attack"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "defensible") and (C.IsComponentClass(menu.componentSlot.component, "ship_l") or C.IsComponentClass(menu.componentSlot.component, "ship_xl") or C.IsComponentClass(menu.componentSlot.component, "station")) then
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11129), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "all", false) end, active = true, orderid = "Attack" })
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11132), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "turret", false) end, active = true, orderid = "Attack" })
			menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11131), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "shieldgenerator", false) end, active = true, orderid = "Attack" })
			if C.IsComponentClass(menu.componentSlot.component, "ship") then
				menu.insertInteractionContent("selected_disable_attack", { type = "disable", text = ReadText(1001, 11130), script = function() menu.buttonAttackSurfaceElements(menu.componentSlot.component, "engine", false) end, active = true, orderid = "Attack" })
			end
		end
	elseif actiontype == "board" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Board"] and (not isplayerownedtarget) and (C.IsComponentClass(menu.componentSlot.component, "ship_l") or C.IsComponentClass(menu.componentSlot.component, "ship_xl")) and (GetComponentData(convertedComponent, "owner") ~= "ownerless") then
			menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "selected_orders", { type = actiontype, text = menu.orderIconText("Board") .. ReadText(1001, 7842), helpOverlayID = "interactmenu_board", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function() return menu.buttonBoard() end, orderid = (not menu.showPlayerInteractions) and "Board" or nil })
		end
	elseif actiontype == "build" then
		if (#menu.selectedplayerships == 1) and isplayerownedtarget and (GetComponentData(menu.selectedplayerships[1], "primarypurpose") == "build") and (menu.numorderloops == 0) then
			local buildstorage
			if C.IsRealComponentClass(menu.componentSlot.component, "station") then
				buildstorage = ConvertIDTo64Bit(GetComponentData(convertedComponent, "buildstorage")) or 0
			else
				buildstorage = convertedComponent
			end
			local constructionvessels = {}
			Helper.ffiVLA(constructionvessels, "UniverseID", C.GetNumAssignedConstructionVessels, C.GetAssignedConstructionVessels, buildstorage)
			local mouseovertext
			if #constructionvessels > 0 then
				mouseovertext = ReadText(1026, 7821)
			elseif C.IsBuilderBusy(menu.selectedplayerships[1]) then
				mouseovertext = ReadText(1026, 7820)
			elseif not menu.hasPlayerShipPilot then
				mouseovertext = ReadText(1026, 7830)
			end
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = ReadText(1001, 7833), helpOverlayID = "interactmenu_build", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeployToStation(menu.selectedplayerships[1], true) end, active = (#constructionvessels == 0) and (not C.IsBuilderBusy(menu.selectedplayerships[1])) and menu.hasPlayerShipPilot, mouseOverText = mouseovertext })
		end
	elseif actiontype == "buildships" then
		local canbuildships, shiptrader, isdock, owner = GetComponentData(convertedComponent, "canbuildships", "shiptrader", "isdock", "owner")
		local doessellshipstoplayer = GetFactionData(owner, "doessellshipstoplayer")
		if canbuildships then
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if shiptrader or isplayerownedtarget then
				local active = true
				local mouseovertext = ""
				if not doessellshipstoplayer then
					active = false
					mouseovertext = ReadText(1026, 7865)
				elseif not isdock then
					active = false
					mouseovertext = ReadText(1026, 8014)
				elseif shiptrader == nil then
					active = false
					mouseovertext = ReadText(1026, 7827)
				end
				menu.insertInteractionContent("main", { type = actiontype, text = isplayerownedtarget and ReadText(1001, 7875) or ReadText(1001, 7838), helpOverlayID = "interactmenu_buildship", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonShipConfig("purchase") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "changeformation" then
		if istobedisplayed and IsComponentOperational(convertedComponent) then
			local subordinates = GetSubordinates(convertedComponent)
			if #subordinates > 0 then
				local n = C.GetNumFormationShapes()
				local buf = ffi.new("UIFormationInfo[?]", n)
				n = C.GetFormationShapes(buf, n)
				local formationshapes = {}
				for i = 0, n - 1 do
					table.insert(formationshapes, { name = ffi.string(buf[i].name), shape = ffi.string(buf[i].shape), requiredSkill = buf[i].requiredSkill * 3 })
				end
				table.sort(formationshapes, Helper.sortName)
				local pilot = ConvertIDTo64Bit(GetComponentData(convertedComponent, "assignedpilot"))
				local isplayer = pilot == C.GetPlayerID()
				local adjustedskill = (pilot and (pilot ~= 0)) and math.floor(C.GetEntityCombinedSkill(pilot, nil, isplayer and "playerpilot" or "aipilot") * 15 / 100) or 0
				for _, data in ipairs(formationshapes) do
					menu.insertInteractionContent("formationshape", { type = actiontype, text = data.name, text2 = ((data.requiredSkill <= adjustedskill) and ColorText["text_skills"] or ColorText["text_inactive"]) .. Helper.displaySkill(data.requiredSkill), helpOverlayID = "interactmenu_changeformation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFormationShape(data.shape, subordinates) end, active = data.requiredSkill <= adjustedskill })
				end
			end
		end
	elseif (actiontype == "claim") then
		if istobedisplayed and (#menu.selectedplayerships == 1) and C.IsComponentClass(menu.componentSlot.component, "ship") then
			local canbeclaimed, isdefendingfromboardingoperation = GetComponentData(convertedComponent, "canbeclaimed", "isdefendingfromboardingoperation")
			if canbeclaimed and (not isdefendingfromboardingoperation) then
				local isdocked, hasavailablemarines, maxradarrange = GetComponentData(menu.selectedplayerships[1], "isdocked", "hasavailablemarines", "maxradarrange")
				local active, mouseovertext = true, ""
				if not hasavailablemarines then
					active = false
					mouseovertext = ReadText(1026, 7822)
				elseif C.GetDistanceBetween(menu.componentSlot.component, menu.selectedplayerships[1]) > maxradarrange then
					active = false
					mouseovertext = ReadText(1026, 7802)
				elseif isdocked then
					active = false
					mouseovertext = ReadText(1026, 7817)
				end
				menu.insertInteractionContent((not menu.showPlayerInteractions) and "selected_orders" or "interaction", { type = actiontype, text = ReadText(1010, 5), helpOverlayID = "interactmenu_claim", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonClaim(menu.selectedplayerships[1]) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "configurestation" then
		if istobedisplayed then
			menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 7809), helpOverlayID = "interactmenu_configurestation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStationConfig })
		end
	elseif actiontype == "collect" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Collect"] and menu.componentSlot.component and C.IsComponentClass(menu.componentSlot.component, "drop") then
			local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Collect") .. ReadText(1001, 7867), helpOverlayID = "interactmenu_collect", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollect(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "Collect" } )
		end
	elseif actiontype == "collectdeployable" then
		if (#menu.selectedplayerships > 0) and isplayerownedtarget and menu.possibleorders["CollectDeployables"] and menu.componentSlot.component and GetComponentData(convertedComponent, "isdeployable") then
			local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectDeployables") .. ReadText(1001, 11103), helpOverlayID = "interactmenu_collect_deployable", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectDeployable(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "CollectDeployables" } )
		end
	elseif actiontype == "collectdeployables" then
		if istobedisplayed and isplayerownedtarget and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) then
			if menu.mode ~= "shipconsole" then
				local active, mouseovertext = menu.canCollectCrates(hastargetpilot)
				if menu.data.hastargetorderloop and (not menu.loopableorders["CollectDeployables"]) then
					active = false
					mouseovertext = ReadText(1026, 7851)
				end
				mouseovertext = ReadText(1041, 692) .. (((mouseOverText ~= nil) and (mouseOverText ~= "")) and ("\n\n" .. mouseOverText) or "")
				menu.insertInteractionContent("main_orders", { type = actiontype, text = menu.orderIconText("CollectDeployables") .. ReadText(1001, 7885), helpOverlayID = "interactmenu_collectdeployables", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectDeployables(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext } )
			end
		end
	elseif actiontype == "collectlockbox" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["CollectLockbox"] and menu.componentSlot.component and C.IsComponentClass(menu.componentSlot.component, "lockbox") then
			-- these variables are used to determine if the button should be active and must be initialized to false because the button activates if nil.
			local isnotcapship = false
			local hasactiveguns = false
			local hasinactiveguns = false
			for _, ship in ipairs(menu.selectedplayerships) do
				-- we need to make sure that at least one ship in the selection has all of the requirements. selection will be further filtered down when the orders on the individual ships start.
				isnotcapship = not C.IsComponentClass(ship, "ship_l") and not C.IsComponentClass(ship, "ship_xl")

				--uint32_t GetDefensibleDPS(DPSData* result, UniverseID defensibleid, bool primary, bool secondary, bool lasers, bool missiles, bool turrets, bool includeheat, bool includeinactive);
				local activedpstable = ffi.new("DPSData[?]", 6)
				local numtotalquadrants = C.GetDefensibleDPS(activedpstable, ship, true, true, true, false, false, false, false)
				hasactiveguns = activedpstable[0].dps > 0

				local inactivedpstable = ffi.new("DPSData[?]", 6)
				local numtotalquadrants = C.GetDefensibleDPS(inactivedpstable, ship, true, true, true, false, false, false, true)
				hasinactiveguns = inactivedpstable[0].dps > 0

				if isnotcapship and hasactiveguns then
					break
				end
			end

			local active = isnotcapship and hasactiveguns and menu.hasPlayerShipPilot
			local mouseovertext
			if not isnotcapship then
				mouseovertext = ReadText(1026, 20039)
			elseif not menu.hasPlayerShipPilot then
				mouseovertext = ReadText(1026, 7801)
			elseif not hasactiveguns then
				if hasinactiveguns then
					mouseovertext = ReadText(1026, 7847)
				else
					mouseovertext = ReadText(1026, 20040)
				end
			end

			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectLockbox") .. ReadText(1041, 661), helpOverlayID = "interactmenu_collectlockbox", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectLockbox(false) end, active = active, hidetarget = true, mouseOverText = mouseovertext, orderid = "CollectLockbox" } )
		end
	elseif actiontype == "collectspace" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["CollectDropsInRadius"] then
				local active, mouseovertext = menu.canCollectCrates(menu.hasPlayerShipPilot)
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("CollectDropsInRadius") .. ReadText(1001, 7866), helpOverlayID = "interactmenu_collectspace", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCollectRadius(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "CollectDropsInRadius" } )
			end
		end
	elseif actiontype == "salvagespace" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["SalvageInRadius"] then
				local active, mouseovertext = menu.canSalvage(menu.hasPlayerShipPilot)
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageInRadius") .. ReadText(1041, 871), helpOverlayID = "interactmenu_salvagespace", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageInRadius(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext, orderid = "SalvageInRadius" } )
			end
		end
	elseif actiontype == "crewtransfer" then
		if (#menu.selectedplayerships == 1) and GetComponentData(convertedComponent, "isdock") and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (not C.IsComponentClass(convertedComponent, "ship_xs")) and (C.GetPeopleCapacity(convertedComponent, "", true) > 0) then
			if (not GetComponentData(menu.selectedplayerships[1], "isdeployable")) and (not C.IsComponentClass(menu.selectedplayerships[1], "spacesuit")) then
				if C.IsComponentClass(menu.componentSlot.component, "container") then
					if C.IsComponentClass(menu.componentSlot.component, "station") or isplayerownedtarget then
						local active = true
						local mouseovertext = ""
						if C.IsComponentClass(menu.componentSlot.component, "station") then
							if isplayerownedtarget then
								local tradenpc, shiptrader, isshipyard, iswharf, isequipmentdock = GetComponentData(convertedComponent, "tradenpc", "shiptrader", "isshipyard", "iswharf", "isequipmentdock")
								local canhavetrainees = C.CanControllableHaveAnyTrainees(menu.componentSlot.component)
								if (tradenpc ~= nil) and ((not (isshipyard or iswharf or isequipmentdock)) or (shiptrader ~= nil)) and (not canhavetrainees) then
									active = false
									mouseovertext = ReadText(1026, 3249)
								end
							else
								local nummissionnpcrequests = C.GetNumRequestedMissionNPCs(menu.componentSlot.component)
								active = nummissionnpcrequests > 0
								mouseovertext = active and "" or ReadText(1026, 3248)
							end
						end
						menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "selected_orders", { type = actiontype, text = menu.orderIconText("CrewExchange") .. ReadText(1001, 7880), helpOverlayID = "interactmenu_crewtransfer", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonCrewTransfer(menu.selectedplayerships[1]) end, active = active, mouseOverText = mouseovertext })
					end
				end
			end
		end
	elseif actiontype == "deliverwares" then
		if istobedisplayed and IsComponentOperational(convertedComponent) then
			local nummissionwarerequests = C.GetNumRequestedMissionWares(menu.componentSlot.component)
			local requestbuf = ffi.new("MissionWareDeliveryCounts[?]", nummissionwarerequests)
			nummissionwarerequests = C.GetRequestedMissionWares(requestbuf, nummissionwarerequests, menu.componentSlot.component)
			if nummissionwarerequests == 1 then
				local request = requestbuf[0]

				local buf = ffi.new("MissionWareDeliveryInfo[1]")
				buf[0].numwares = request.numwares
				buf[0].wares = Helper.ffiNewHelper("UIWareAmount[?]", request.numwares)
				C.GetMissionDeliveryWares(buf, request.missionid)

				local wares = {}
				for i = 0, buf[0].numwares - 1 do
					table.insert(wares, { ware = ffi.string(buf[0].wares[i].wareid), amount = buf[0].wares[i].amount })
				end

				local missiondetails = C.GetMissionIDDetails(request.missionid)

				local active = true
				local mouseovertext = ffi.string(missiondetails.missionName)
				local cargo = GetComponentData(convertedComponent, "cargo") or {}
				for _, entry in ipairs(wares) do
					if (cargo[entry.ware] or 0) == 0 then
						active = false
						mouseovertext = mouseovertext .. "\n" .. ColorText["text_error"] .. ReadText(1026, 3406)
						break
					end
				end
				local missionid = request.missionid
				menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = ReadText(1001, 3423), helpOverlayID = "interactmenu_deliverwares", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeliverWares(missionid) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "deployhere" then
		if istobedisplayed and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (not menu.data.hastargetorderloop) then
			if menu.mode ~= "shipconsole" then
				-- force sub section and assume we have no deployables
				menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7818)
				menu.forceSubSection["consumables_military"] = ReadText(1026, 7819)
				-- check if we have deploables
				for _, entry in ipairs(config.consumables) do
					local numconsumable = entry.getnum(menu.componentSlot.component)
					if numconsumable > 0 then
						local consumables = ffi.new("AmmoData[?]", numconsumable)
						numconsumable = entry.getdata(consumables, numconsumable, menu.componentSlot.component)
						for j = 0, numconsumable - 1 do
							if consumables[j].amount > 0 then
								-- clear force if we do have deployables, enabling the isdocked check to set it's own force reason
								menu.forceSubSection["consumables_" .. entry.type] = nil
								break
							end
						end
					end
				end

				local isdocked = GetComponentData(convertedComponent, "isdocked")
				local isinhighway = C.GetContextByClass(menu.componentSlot.component, "highway", false) ~= 0
				if (not isdocked) and (not isinhighway) and (hastargetpilot or istargetplayeroccupiedship) then
					for _, entry in ipairs(config.consumables) do
						menu.addConsumableEntry("consumables", entry, menu.componentSlot.component, menu.buttonDeploy)
					end
				else
					-- only force if not previously forced (i.e. no deployables is a more important reason than being docked)
					if not menu.forceSubSection["consumables_civilian"] then
						if (not hastargetpilot) and (not istargetplayeroccupiedship) then
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7801)
						elseif isinhighway then
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7845)
						else
							menu.forceSubSection["consumables_civilian"] = ReadText(1026, 7817)
						end
					end
					if not menu.forceSubSection["consumables_military"] then
						if (not hastargetpilot) and (not istargetplayeroccupiedship) then
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7801)
						elseif isinhighway then
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7845)
						else
							menu.forceSubSection["consumables_military"] = ReadText(1026, 7817)
						end
					end
				end
			end
		end
	elseif actiontype == "deployat" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if (#menu.selectedplayerships == 1) and menu.possibleorders["DeployObjectAtPosition"] and (menu.numorderloops == 0) then
				-- force sub section and assume we have no deployables
				menu.forceSubSection["selected_consumables_civilian"] = ReadText(1026, 7818)
				menu.forceSubSection["selected_consumables_military"] = ReadText(1026, 7819)
				-- check if we have deploables
				for _, entry in ipairs(config.consumables) do
					local numconsumable = entry.getnum(menu.selectedplayerships[1])
					if numconsumable > 0 then
						local consumables = ffi.new("AmmoData[?]", numconsumable)
						numconsumable = entry.getdata(consumables, numconsumable, menu.selectedplayerships[1])
						for j = 0, numconsumable - 1 do
							if consumables[j].amount > 0 then
								-- clear force if we do have deployables, enabling the isdocked check to set it's own force reason
								menu.forceSubSection["selected_consumables_" .. entry.type] = nil
								break
							end
						end
					end
				end
				if menu.hasPlayerShipPilot then
					for _, entry in ipairs(config.consumables) do
						menu.addConsumableEntry("selected_consumables", entry, menu.selectedplayerships[1], menu.buttonDeployAtPosition)
					end
				else
					-- only force if not previously forced (i.e. no deployables is a more important reason than no pilot)
					if not menu.forceSubSection["selected_consumables_civilian"] then
						menu.forceSubSection["selected_consumables_civilian"] = ReadText(1026, 7830)
					end
					if not menu.forceSubSection["selected_consumables_military"] then
						menu.forceSubSection["selected_consumables_military"] = ReadText(1026, 7830)
					end
				end
			end
		end
	elseif actiontype == "depositinventory" then
		local stationhqlist = {}
		Helper.ffiVLA(stationhqlist, "UniverseID", C.GetNumHQs, C.GetHQs, "player")
		-- show the button once the player gets the HQ since that's a bigger state change.
		-- NB: button requires that ship have a pilot, that that pilot have stuff in his or her pockets, and that the player has an HQ. Otherwise, show the button but keep it inactive.
		if #stationhqlist > 0 then
			if istobedisplayed then
				local hasinventory, haspilot = false, false

				local isdeployable, pilot = GetComponentData(convertedComponent, "isdeployable", "pilot")
				if (not C.IsUnit(menu.componentSlot.component)) and (not isdeployable) then
					if pilot and (pilot ~= 0) then
						haspilot = true
						if next(GetInventory(pilot)) ~= nil then
							hasinventory = true
						end
					end
				end

				if not hasinventory then
					for _, ship in ipairs(menu.selectedplayerships) do
						local isdeployable, pilot = GetComponentData(ship, "isdeployable", "pilot")
						if (not C.IsUnit(ship)) and (not isdeployable) then
							if pilot and (pilot ~= 0) then
								haspilot = true
								if next(GetInventory(pilot)) ~= nil then
									hasinventory = true
									break
								end
							end
						end
					end
				end

				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = menu.orderIconText("DepositInventory") .. ReadText(1041, 651), helpOverlayID = "interactmenu_depositinventory", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDepositInventoryAtHQ() end, active = hasinventory, mouseOverText = (not haspilot) and ReadText(1026, 7801) or ReadText(1026, 7829) })
			end
		end
	elseif actiontype == "dockat" then
		if menu.possibleorders["DockAndWait"] then
			local isalreadydocked = true
			for _, ship in ipairs(menu.selectedplayerships) do
				local parentcontainer = C.GetContextByClass(ship, "container", false)
				if parentcontainer ~= 0 then
					if parentcontainer == menu.componentSlot.component then
						-- check if the ship is at a venture dock
						local parentdockingbay = C.GetContextByClass(ship, "dockarea", false)
						local ventureplatforms = {}
						Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, menu.componentSlot.component)
						for _, platform in ipairs(ventureplatforms) do
							local docks = {}
							Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
							for _, dock in ipairs(docks) do
								if dock == parentdockingbay then
									isalreadydocked = false
									break
								end
							end
							if not isalreadydocked then
								break
							end
						end
						if isalreadydocked then
							-- if there is another order on the queue allow adding the new dock order
							local numorders = C.GetNumOrders(ship)
							if numorders > 0 then
								local currentorders = ffi.new("Order[?]", numorders)
								numorders = C.GetOrders(currentorders, numorders, ship)
								for i = 0, numorders - 1 do
									local orderdef = ffi.string(currentorders[i].orderdef)
									local params = GetOrderParams(ConvertStringTo64Bit(tostring(ship)), i + 1)
									if ((orderdef ~= "DockAndWait") and (orderdef ~= "DockAt")) or (ConvertIDTo64Bit(params[1].value) ~= convertedComponent) then
										isalreadydocked = false
										break
									end
								end
							end
						end
					else
						isalreadydocked = false
						break
					end
				else
					isalreadydocked = false
					break
				end
			end
			local active = (not isalreadydocked) and (menu.numdockingpossible > 0)
			local mouseovertext = ""
			if menu.numdockingpossible == 0 then
				local orderedKeys = Helper.orderedKeys(menu.dockingerrors)
				if orderedKeys[1] then
					mouseovertext = menu.dockingerrors[orderedKeys[1]]
				end
			elseif isalreadydocked then
				mouseovertext = ReadText(1026, 7846)
			end

			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("DockAndWait") .. ReadText(1041, 451), helpOverlayID = "interactmenu_dockat", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDock(false) end, active = active, mouseOverText = mouseovertext, orderid = "DockAndWait" })
		end
	elseif actiontype == "dockatplayer" then
		if istobedisplayed and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (menu.numorderloops == 0) and (not menu.data.hastargetorderloop) then
			if menu.mode ~= "shipconsole" then
				local playercontainer = C.GetPlayerContainerID()
				if playercontainer ~= 0 then
					local convertedPlayerContainer = ConvertStringTo64Bit(tostring(playercontainer))
					if isplayerownedtarget then
						local allinstorage = true
						local allexternallydocked = true
						if C.GetContextByClass(menu.componentSlot.component, "container", false) ~= playercontainer then
							allexternallydocked = false
							allinstorage = false
						elseif (not C.IsShipAtExternalDock(menu.componentSlot.component)) and (not C.IsShipBeingRetrieved(menu.componentSlot.component)) then
							allexternallydocked = false
						end
						if allinstorage or allexternallydocked then
							for _, ship in ipairs(menu.selectedplayerships) do
								if C.GetContextByClass(ship, "container", false) ~= playercontainer then
									allexternallydocked = false
									allinstorage = false
									break
								elseif (not C.IsShipAtExternalDock(ship)) and (not C.IsShipBeingRetrieved(ship)) then
									allexternallydocked = false
								end
							end
						end

						local active = true
						local mouseovertext = ReadText(1026, 20043)
						local isdock, hasshipdockingbays = GetComponentData(convertedPlayerContainer, "isdock", "hasshipdockingbays")
						if allexternallydocked then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7838)
						elseif not hasshipdockingbays then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7837)
						elseif not hastargetpilot then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7801)
						elseif menu.numdockingatplayerpossible == 0 then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7836)
						elseif not isdock then
							active = false
							mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7825)
						end

						menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = menu.orderIconText("DockAndWait") .. (allinstorage and ReadText(1001, 7890) or ReadText(1001, 7837)), helpOverlayID = "interactmenu_dockatplayer", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDockAtPlayer(false) end, hidetarget = true, active = active, mouseOverText = mouseovertext })
					end
				end
			end
		end
	elseif actiontype == "dockrequest" then
		local isshiporstation = C.IsComponentClass(menu.componentSlot.component, "ship") or C.IsComponentClass(menu.componentSlot.component, "station")
		local isdockingbay = C.IsComponentClass(menu.componentSlot.component, "dockingbay")
		if menu.showPlayerInteractions and (isshiporstation or isdockingbay) and (not GetComponentData(convertedComponent, "isdeployable")) and (isdockingbay or (not C.IsUnit(convertedComponent))) then
			local dockcontainer = convertedComponent
			if isdockingbay then
				dockcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(dockcontainer, "container", false)))
			end
			local mouseovertext = Helper.getInputMouseOverText("INPUT_ACTION_DOCK_ACTION")
			if IsDockingPossible(ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())), dockcontainer) then
				local dockrequestreason = ffi.string(C.RequestDockAtReason(dockcontainer, true))
				-- "granted" -> OK
				-- "queued" -> OK
				-- "impossible" -> Should be handled by IsDockingPossible() or the container is wrong or the player does not exist or the playercontrolled object does not exist
				if dockrequestreason == "denied" then -- DOCKINGREQUEST_DENIED
					local isdockingenabled = GetComponentData(dockcontainer, "isdockingenabled")
					if isdockingenabled then
						mouseovertext = ReadText(1026, 7825)
					else
						mouseovertext = ReadText(1026, 7843)
					end
				elseif dockrequestreason == "toofar" then -- DOCKINGREQUEST_TOOFAR
					mouseovertext = ReadText(1026, 7809)
				elseif dockrequestreason == "alreadydocked" then
					mouseovertext = ReadText(1026, 7857)
				end
			else
				mouseovertext = ReadText(1026, 7824)
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = (menu.showPlayerInteractions and (not menu.shown)) and ReadText(1001, 7845) or ReadText(1001, 7888), helpOverlayID = "interactmenu_dockrequest", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonDockRequest, active = C.RequestDockAt(dockcontainer, true), mouseOverText = mouseovertext })
		end
	elseif actiontype == "dropinventory" then
		if istobedisplayed then
			local pilot = ConvertIDTo64Bit(GetComponentData(convertedComponent, "pilot"))
			if pilot and (pilot ~= 0) then
				local inventory = GetInventory(pilot)
				if next(inventory) then

					local onlineitems = OnlineGetUserItems()

					-- kuertee start:
					if not onlineitems then
						onlineitems = {}
					end
					-- kuertee end

					local sortedWares = {}
					for ware, entry in pairs(inventory) do
						local ispersonalupgrade = GetWareData(ware, "ispersonalupgrade")
						if (not ispersonalupgrade) and (not onlineitems[ware]) then
							table.insert(sortedWares, { ware = ware, name = entry.name, amount = entry.amount })
						end
					end
					if #sortedWares > 0 then
						menu.insertInteractionContent("main_orders", { type = actiontype, text = ReadText(1001, 7878), helpOverlayID = "interactmenu_dropinventory", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDropInventory(pilot) end })
					end
				end
			end
		end
	elseif actiontype == "encyclopedia" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 2416), helpOverlayID = "interactmenu_encyclopedia", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonEncyclopedia })
	elseif actiontype == "explore" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Explore"] and menu.componentSlot.component and (C.IsComponentClass(menu.componentSlot.component, "sector") or C.IsComponentClass(menu.componentSlot.component, "highwayentrygate") or C.IsComponentClass(menu.componentSlot.component, "highway") or (C.IsComponentClass(menu.componentSlot.component, "gate") and GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Explore") .. ReadText(1001, 7828), helpOverlayID = "interactmenu_explore", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonExplore(false) end, orderid = "Explore" })
		end
	elseif actiontype == "exploreupdate" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["ExploreUpdate"] and menu.componentSlot.component and (C.IsComponentClass(menu.componentSlot.component, "sector") or C.IsComponentClass(menu.componentSlot.component, "highwayentrygate") or C.IsComponentClass(menu.componentSlot.component, "highway") or (C.IsComponentClass(menu.componentSlot.component, "gate") and GetComponentData(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), "isactive"))) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("ExploreUpdate") .. ReadText(1001, 7829), helpOverlayID = "interactmenu_exploreupdate", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonExploreUpdate(false) end, orderid = "ExploreUpdate" })
		end
	elseif actiontype == "flee" then
		if istobedisplayed and (not istargetplayeroccupiedship) and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			local firstorder
			local n = C.GetNumOrders(menu.componentSlot.component)
			local buf = ffi.new("Order2[?]", n)
			n = C.GetOrders2(buf, n, menu.componentSlot.component)
			if n > 0 then
				firstorder = {}
				firstorder.state = ffi.string(buf[0].state)
				firstorder.statename = ffi.string(buf[0].statename)
				firstorder.orderdef = ffi.string(buf[0].orderdef)
				firstorder.actualparams = tonumber(buf[0].actualparams)
				firstorder.enabled = buf[0].enabled
				firstorder.isinfinite = buf[0].isinfinite
				firstorder.issyncpointreached = buf[0].issyncpointreached
				firstorder.istemporder = buf[0].istemporder
				firstorder.isoverride = buf[0].isoverride

				local orderdefinition = ffi.new("OrderDefinition")
				if firstorder.orderdef ~= nil and C.GetOrderDefinition(orderdefinition, firstorder.orderdef) then
					firstorder.orderdef = {}
					firstorder.orderdef.id = ffi.string(orderdefinition.id)
					firstorder.orderdef.icon = ffi.string(orderdefinition.icon)
					firstorder.orderdef.name = ffi.string(orderdefinition.name)
				else
					firstorder.orderdef = { id = "", icon = "", name = "" }
				end
			end

			if (menu.showPlayerInteractions or (#menu.selectedplayerships == 0)) and firstorder and firstorder.isoverride then
				firstorder.params = GetOrderParams(convertedComponent, 1)

				menu.texts.overrideordername = firstorder.orderdef.name
				local attacker
				if firstorder.orderdef.id == "Flee" then
					if firstorder.params[6] and firstorder.params[6].value then
						local value = ConvertIDTo64Bit(firstorder.params[6].value)
						if value ~= 0 then
							attacker = value
						end
					end
				elseif firstorder.orderdef.id == "Attack" then
					if firstorder.params[1] and firstorder.params[1].value and (firstorder.params[1].type == "object") and (firstorder.params[1].value ~= 0) then
						attacker = firstorder.params[1].value
					end
				elseif firstorder.orderdef.id == "Wait" then
					if firstorder.params[5] and firstorder.params[5].value then
						local value = ConvertIDTo64Bit(firstorder.params[5].value)
						if value ~= 0 then
							attacker = value
						end
					end
				end

				local overrideOrderOptions = {}
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Attack") and firstorder.orderdef.name or ReadText(1001, 11228), script = function () return menu.buttonChangeOverrideOrder("Attack", attacker) end, active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Attack"), mouseOverText = ReadText(1026, 3234) })
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Flee")   and firstorder.orderdef.name or ReadText(1001, 11220), script = function () return menu.buttonChangeOverrideOrder("Flee", attacker) end,   active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Flee"),   mouseOverText = ReadText(1026, 3232) })
					menu.insertInteractionContent("overrideorder", { type = "overrideorder", text = (firstorder.orderdef.id == "Wait")   and firstorder.orderdef.name or ReadText(1001, 11247), script = function () return menu.buttonChangeOverrideOrder("Wait", attacker) end,   active = (attacker ~= nil) and (firstorder.orderdef.id ~= "Wait"),   mouseOverText = ReadText(1026, 3245) })
			else
				local curtime = GetCurTime()

				local hasbeenattacked = false
				local attacker

				local attackinfo = C.GetLastAttackInfo(menu.componentSlot.component)
				if attackinfo.time + 120 >= curtime then
					hasbeenattacked = true
					attacker = attackinfo.attacker
				end
				for _, ship in ipairs(menu.selectedplayerships) do
					local attackinfo = C.GetLastAttackInfo(ship)
					if attackinfo.time + 120 >= curtime then
						hasbeenattacked = true
						if not attacker then
							attacker = attackinfo.attacker
						end
					end
				end

				local active = true
				local mouseovertext = ""
				if (not hastargetpilot) and (not menu.hasPlayerShipPilot) then
					active = false
					mouseovertext = ReadText(1026, 7830)
				elseif not hasbeenattacked then
					active = false
					mouseovertext = ReadText(1026, 7842)
				end
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = menu.orderIconText("Flee") .. ReadText(1041, 551), helpOverlayID = "interactmenu_flee", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFlee(attacker, false) end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "fleetlogo" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 11133), script = menu.buttonChangeLogo })
		end
	elseif actiontype == "fleetmanagement" then
		if istobedisplayed and C.IsComponentClass(menu.componentSlot.component, "controllable") and C.IsFleetManagerPlayerEnabled() then
			local isfleetlead = GetComponentData(convertedComponent, "isfleetlead")
			menu.insertInteractionContent("main_orders", { type = actiontype, text = isfleetlead and ReadText(1001, 11147) or ReadText(1001, 11146), helpOverlayID = "interactmenu_fleetmanagement", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFleetManagement(menu.componentSlot.component, not isfleetlead) end, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "fleetrename" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 7895), script = function () return menu.buttonRename(true) end })
		end
	elseif actiontype == "flyto" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["MoveWait"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("MoveWait") .. ReadText(1041, 251), helpOverlayID = "interactmenu_flyto", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonMoveWait(false) end, orderid = "MoveWait" })
		end
	elseif actiontype == "follow" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["Follow"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Follow") .. ReadText(1001, 7988), helpOverlayID = "interactmenu_follow", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonFollow(false) end, orderid = "Follow" })
		end
	elseif actiontype == "getsupplies" then
		if istobedisplayed and isplayerownedtarget and GetComponentData(convertedComponent, "issupplyship") then
			local active = true
			local mouseovertext = ReadText(1041, 622)
			if menu.hastargetorderloop and (not menu.loopableorders["GetSupplies"]) then
				active = false
				mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7851)
			elseif not hastargetpilot then
				active = false
				mouseovertext = mouseovertext .. "\n\n" .. ReadText(1026, 7801)
			end
			menu.insertInteractionContent("main_orders", { type = actiontype, text = menu.orderIconText("GetSupplies") .. ReadText(1041, 621), script = function () return menu.buttonGetSupplies() end, active = active, mouseOverText = mouseovertext, helpOverlayID = "interact_getsupplies", helpOverlayText = " ", helpOverlayHighlightOnly = true })
		end
	elseif actiontype == "guidance" then
		if (not istargetplayeroccupiedship) and (menu.mode ~= "shipconsole") then
			local text = ReadText(1001, 3256)
			local useoffset = false
			if C.IsComponentClass(menu.componentSlot.component, "sector") then
				text = ReadText(1001, 3242)
				useoffset = true
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = IsSameComponent(GetActiveGuidanceMissionComponent(), convertedComponent) and ReadText(1001, 3243) or text, helpOverlayID = "interactmenu_guidance", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonGuidance(useoffset) end, mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_TOGGLE_GUIDANCE") })
		end
	elseif actiontype == "hire" then
		if GetComponentData(convertedComponent, "primarypurpose") == "build" then
			local stations = GetContainedStationsByOwner("player", nil, true)
			for i = #stations, 1, -1 do
				local buildstorage = GetComponentData(stations[i], "buildstorage")
				if not C.DoesConstructionSequenceRequireBuilder(ConvertIDTo64Bit(stations[i])) then
					table.remove(stations, i)
				elseif C.GetNumAssignedConstructionVessels(ConvertIDTo64Bit(buildstorage)) > 0 then
					table.remove(stations, i)
				end
			end
			if #stations > 0 then
				local section = isplayerownedtarget and "assigningbuilder" or "hiringbuilder"
				local playermoney = GetPlayerMoney()
				local fee = tonumber(C.GetBuilderHiringFee())
				if (not isplayerownedtarget) and (playermoney < fee) then
					menu.forceSubSection[section] = ReadText(1001, 2966)
				elseif GetComponentData(convertedComponent, "isenemy")  then
					menu.forceSubSection[section] = ReadText(1026, 8014)
				elseif C.IsBuilderBusy(menu.componentSlot.component) then
					menu.forceSubSection[section] = ReadText(1026, 7820)
				else
					local mouseover = (not isplayerownedtarget) and (((fee > playermoney) and ColorText["text_error"] or ColorText["text_success"]) .. ReadText(1001, 7940) .. ReadText(1001, 120) .. " " .. ConvertMoneyString(fee, false, true, nil, true) .. " " .. ReadText(1001, 101) .. "\027X") or ""
					for i, station in ipairs(stations) do
						local station64 = ConvertIDTo64Bit(station)
						menu.insertInteractionContent(section, { type = actiontype, text = Helper.convertColorToText(menu.holomapcolor.playercolor) .. ffi.string(C.GetComponentName(station64)) .. " (" .. ffi.string(C.GetObjectIDCode(station64)) .. ")", helpOverlayID = "interactmenu_hire", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDeployToStation(menu.componentSlot.component, false, station64) end, mouseOverText = mouseover })
					end
				end
			end
		end
	elseif actiontype == "intersectordefence" then
		if C.IsComponentClass(convertedComponent, "controllable") then
			local isstation = C.IsComponentClass(convertedComponent, "station")
			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			local subordinates = GetSubordinates(convertedComponent)
			local isfleetcommander = (not commander) and (#subordinates > 0)
			local hasintersectorgroup = C.HasSubordinateAssignment(convertedComponent, "positiondefence")
			--print(tostring(#menu.selectedplayerships == 0) .. tostring(istobedisplayed) .. " " .. tostring(GetComponentData(convertedComponent, "shiptype") == "carrier") .. tostring(isstation and C.CanClaimOwnership(convertedComponent)) .. " " .. tostring(isfleetcommander) .. tostring(hasintersectorgroup))
			if (#menu.selectedplayerships == 0) and istobedisplayed and ((GetComponentData(convertedComponent, "shiptype") == "carrier") or isstation) and (isfleetcommander or hasintersectorgroup) then
				local groups = menu.getSubordinatesInGroups(convertedComponent, isstation, isstation and "defence" or nil, isstation)
				local active = true
				local mouseovertext = nil
				if isstation and (not C.CanClaimOwnership(convertedComponent) or (not hasintersectorgroup and not C.HasSubordinateAssignment(convertedComponent, "defence"))) then
					active = false
					mouseovertext = ReadText(1026, 7869) -- Requires a station with an administration module and subordinates assigned to defend the station.
				end

				menu.insertInteractionContent("interaction", { type = actiontype, text = hasintersectorgroup and ReadText(1001, 11135) or ReadText(1001, 11134), active = active, mouseOverText = mouseovertext, script = function () return menu.buttonSetInterSectorDefence(groups, hasintersectorgroup) end })
			end
		end
	elseif actiontype == "livestream" then
		if (menu.mode ~= "shipconsole") then
			local active = true
			local mouseovertext = Helper.getInputMouseOverText("INPUT_ACTION_CINEMATIC_CAMERA")
			local isinternallystored, isinnormalspace, isinliveview, isfriend, isally = GetComponentData(convertedComponent, "isinternallystored", "isinnormalspace", "isinliveview", "isfriend", "isally")
			if isinternallystored then
				active = false
				mouseovertext = ReadText(1026, 7811)
			elseif not isinnormalspace then
				active = false
				mouseovertext = ReadText(1026, 7809)
			elseif not isinliveview then
				local ismilitary = false
				if C.IsComponentClass(convertedComponent, "station") then
					local iswharf, isshipyard, isdefencestation, istradestation = GetComponentData(convertedComponent, "iswharf", "isshipyard", "isdefencestation", "istradestation")
					--print("iswharf: " .. tostring(iswharf) .. ", isshipyard: " .. tostring(isshipyard) .. ", isdefencestation: " .. tostring(isdefencestation))
					ismilitary = (iswharf or isshipyard or isdefencestation) and not istradestation
				elseif C.IsComponentClass(convertedComponent, "ship") then
					local purpose = GetComponentData(convertedComponent, "primarypurpose")
					ismilitary = (purpose == "fight" or purpose == "auxiliary")
				end
				if not isally and ismilitary then
					active = false
					mouseovertext = ReadText(20218, 17)
				elseif not isfriend then
					active = false
					mouseovertext = ReadText(20218, 15)
				end
			elseif not (C.CanSetPlayerCameraCinematicView() and IsComponentOperational(convertedComponent)) then
				active = false
				mouseovertext = ReadText(1001, 9408)
			end
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 12217), script = menu.buttonLiveStream, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "logicalstationoverview" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001,8401), helpOverlayID = "interactmenu_logicalstationoverview", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStationOverview })
	elseif actiontype == "manageassignments" then
		if istobedisplayed and IsComponentOperational(convertedComponent) and not C.IsUnit(convertedComponent) then
			local commander = C.GetCommander(convertedComponent, 0)
			if (commander.controllableid ~= 0) or (commander.fleetunitid ~= 0) then
				menu.insertInteractionContent("main_assignments", { type = actiontype, text = ReadText(1001, 7810), script = function () menu.buttonRemoveAssignment() end })
				local currentgroup, purpose, shiptype = GetComponentData(convertedComponent, "subordinategroup", "primarypurpose", "shiptype")

				local groups = {}
				local isstation = false
				local isship = false
				if commander.controllableid ~= 0 then
					groups = menu.getSubordinatesInGroups(commander.controllableid, isstation)
					isstation = C.IsComponentClass(commander.controllableid, "station")
					isship = C.IsComponentClass(commander.controllableid, "ship")
				else
					groups = menu.getSubordinatesInFleetUnitGroups(commander.fleetunitid, isstation)
					isship = true
				end

				if isstation and C.CanClaimOwnership(menu.componentSlot.component) then
					menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, isstation, currentgroup)
				end
				-- defence
				menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation, currentgroup)
				-- supplyfleet
				if shiptype == "resupplier" then
					menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
				end
				if isstation then
					-- trading
					menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, currentgroup, (purpose == "mine") and (ColorText["text_warning"] .. ReadText(1026, 8608)) or "")
					if purpose == "mine" then
						-- mining
						menu.insertAssignSubActions("main_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					else
						-- tarding for buildstorage
						menu.insertAssignSubActions("main_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
					if purpose == "salvage" then
						menu.insertAssignSubActions("main_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
				elseif isship then
					-- position defence
					local commandershiptype
					if commander.controllableid ~= 0 then
						commandershiptype = GetComponentData(ConvertStringToLuaID(tostring(commander.controllableid)), "shiptype")
					else
						local unitinfo = C.GetFleetUnitInfo(commander.fleetunitid)
						commandershiptype = GetMacroData(ffi.string(unitinfo.macro), "shiptype")
					end
					local parentcommander = C.GetCommander(commander.controllableid, commander.fleetunitid)
					local isfleetcommander = (parentcommander.controllableid == 0) and (commander.fleetunitid == 0)
					if (commandershiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					end
					menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil, currentgroup)
					menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					if commander.controllableid ~= 0 then
						local buf = ffi.new("Order")
						if C.GetDefaultOrder(buf, commander.controllableid) then
							menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
						end
					end

					-- start: aegs call-back
					if menu.uix_callbacks ["map_rightMenu_shipassignments_insert_02"] then
						local state,main_o,assignment_o,purpose_o
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_rightMenu_shipassignments_insert_02"]) do
							state,main_o,assignment_o,purpose_o = uix_callback (GetComponentData(commander, "macro"))
							if state and purpose == purpose_o then
								menu.insertAssignSubActions(main_o, assignment_o, menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
							end
						end
					end
					-- end: aegs call-back

					if commandershiptype == "resupplier" then
						menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, currentgroup)
					end
				end
			end
			if menu.numshipswithcommander > 1 then
				menu.insertInteractionContent("selected_assignments_all", { type = actiontype, text = ReadText(1001, 7887), script = function () menu.buttonRemoveAssignment(true) end })
			end
			-- manage multiple selected ships with the interacted object as commander
			if (menu.numassignableships == 0) and (#menu.shipswithcurrentcommander > 0) then
				local subordinates = GetSubordinates(convertedComponent)

				local allresupplier = true
				local allmining = true
				local allnomining = true
				local alltugs = true
				for _, ship in ipairs(menu.shipswithcurrentcommander) do
					local purpose, shiptype = GetComponentData(ship, "primarypurpose", "shiptype")
					if shiptype ~= "resupplier" then
						allresupplier = false
					end
					if purpose == "mine" then
						allnomining = false
					end
					if purpose ~= "mine" then
						allmining = false
					end
					if shiptype ~= "tug" then
						alltugs = false
					end
				end

				local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
				local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
				local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, isstation)
				-- defence
				menu.insertAssignSubActions("selected_change_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation)
				-- supplyfleet
				if allresupplier then
					menu.insertAssignSubActions("selected_change_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true)
				end
				if isstation then
					if C.CanClaimOwnership(menu.componentSlot.component) then
						menu.insertAssignSubActions("selected_change_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, isstation)
					end
					-- trading
					menu.insertAssignSubActions("selected_change_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, nil, (not allnomining) and (ColorText["text_warning"] .. ReadText(1026, 8609)) or "")
					if allmining then
						-- mining
						menu.insertAssignSubActions("selected_change_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true)
					elseif allnomining then
						-- trading for buildstorage
						menu.insertAssignSubActions("selected_change_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true)
					end
					if alltugs then
						menu.insertAssignSubActions("selected_change_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true)
					end
				elseif isship then
					-- position defence
					local shiptype = GetComponentData(convertedComponent, "shiptype")
					local parentcommander = ConvertIDTo64Bit(GetCommander(convertedComponent))
					local isfleetcommander = (not parentcommander) and (#subordinates > 0)
					if (shiptype == "carrier") and isfleetcommander then
						menu.insertAssignSubActions("selected_change_assignments_positiondefence", "positiondefence", menu.buttonChangeAssignment, groups, isstation, nil)
					end
					menu.insertAssignSubActions("selected_change_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil)
					menu.insertAssignSubActions("selected_change_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true)
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, menu.componentSlot.component) then
						menu.insertAssignSubActions("selected_change_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true)
					end

					-- start: aegs call-back
					if menu.uix_callbacks ["map_rightMenu_shipassignments_insert_03"] then
						local state,main_o,assignment_o
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_rightMenu_shipassignments_insert_03"]) do
							state,main_o,assignment_o = uix_callback (GetComponentData(convertedComponent, "macro"),allmining,alltugs)
							if state then
								menu.insertAssignSubActions(main_o, assignment_o, menu.buttonChangeAssignment, groups, isstation, true)
							end
						end
					end
					-- end: aegs call-back

					if shiptype == "resupplier" then
						menu.insertAssignSubActions("selected_change_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true)
					end
				end
			end
		end
	elseif actiontype == "markashostile" then
		if (menu.mode ~= "shipconsole") and (not GetComponentData(convertedComponent, "isreallyplayerowned")) then
			local active = true
			local mouseovertext = ""
			if GetComponentData(convertedComponent, "ishostile") then
				active = false
				mouseovertext = ReadText(1026, 7853)
			end
			menu.insertInteractionContent((menu.showPlayerInteractions and (not menu.shown)) and "player_interaction" or "interaction", { type = actiontype, text = ReadText(1001, 11114), helpOverlayID = "interactmenu_markashostile", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonMarkAsHostile, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "mining" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["MiningPlayer"] then
			if menu.offsetcomponent and (menu.offsetcomponent ~= 0) and C.IsComponentClass(menu.offsetcomponent, "sector") then
				local pos = ffi.new("Coord3D", { x = menu.offset.x, y = menu.offset.y, z = menu.offset.z })
				local nummineables = C.GetNumMineablesAtSectorPos(menu.offsetcomponent, pos)
				local mineables = ffi.new("YieldInfo[?]", nummineables)
				nummineables = C.GetMineablesAtSectorPos(mineables, nummineables, menu.offsetcomponent, pos)
				local miningwares = {}
				for i = 0, nummineables - 1 do
					if mineables[i].amount > 10 then
						local ware = ffi.string(mineables[i].wareid)
						table.insert(miningwares, { ware = ware, name = GetWareData(ware, "name"), amount = 0 })
						local entry = miningwares[#miningwares]
						for _, ship in ipairs(menu.selectedplayerships) do
							if GetWareCapacity(ship, ware, true) > 0 then
								entry.amount = entry.amount + 1
							end
						end
					end
				end
				table.sort(miningwares, Helper.sortName)
				local found = false
				for _, entry in ipairs(miningwares) do
					if entry.amount > 0 then
						found = true
						menu.insertInteractionContent("mining", { type = actiontype, text = entry.name, text2 = Helper.convertColorToText(menu.holomapcolor.playercolor) .. ((entry.amount == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), entry.amount)), script = function () return menu.buttonMining(entry.ware, false) end, orderid = "MiningPlayer" })
					end
				end
				if not found then
					menu.forceSubSection["mining"] = ReadText(1026, 7823)
				end
			end
		end
	elseif actiontype == "paintmod" then
		if istobedisplayed then
			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "interaction", { type = actiontype, text = ReadText(1001, 7859), helpOverlayID = "interactmenu_paintmod", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonPaintMod })
		end
	elseif actiontype == "player_docktotrade" then
		local tradeoffers = GetTradeList(convertedComponent)
		if not isplayerownedtarget and menu.possibleorders["Player_DockToTrade"] and (#tradeoffers == 0) and GetComponentData(convertedComponent, "isdock") and (menu.numdockingpossible > 0) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Player_DockToTrade") .. ReadText(1001, 7858), helpOverlayID = "interactmenu_docktotrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerDockToTrade(false) end, orderid = "Player_DockToTrade" })	-- Dock to trade
		end
	elseif actiontype == "proceedwithorders" then
		if istobedisplayed and isplayerownedtarget then
			local iswaitingforsignal = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			if numorders > 0 then
				local orderparams = GetOrderParams(ConvertStringTo64Bit(tostring(menu.componentSlot.component)), 1)
				for i, param in ipairs(orderparams) do
					if param.name == "releasesignal" and type(param.value) == "table" and param.value[1] == "playerownedship_proceed" then
						iswaitingforsignal = true
						break
					end
				end
			end

			local infotext = ""
			if iswaitingforsignal then
				if menu.numwaitingforsignal == 0 then
					-- only the currently targeted ship is affected, show nothing
					infotext = ""
				else
					-- target ship and selected ships
					infotext = " " .. ColorText["text_negative"] .. "(" .. menu.texts.targetShortName .. " + " .. ((menu.numwaitingforsignal == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), menu.numwaitingforsignal)) .. ")"
				end
			elseif menu.numwaitingforsignal > 0 then
				infotext = " " .. ColorText["text_positive"] .. "(" .. ((menu.numwaitingforsignal == 1) and ReadText(1001, 7851) or string.format(ReadText(1001, 7801), menu.numwaitingforsignal)) .. ")"
			end
			if iswaitingforsignal or (menu.numwaitingforsignal > 0) then
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) and (menu.numremovableorders > 0)) and "selected_orders" or "main_orders", { type = actiontype, text = ReadText(1002, 2033) .. infotext, helpOverlayID = "interactmenu_proceedwithorders", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonProceedWithOrders, hidetarget = true })
			end
		end
	elseif actiontype == "protectstation" then
		if #menu.selectedplayerships > 0 and isplayerownedtarget and menu.possibleorders["ProtectStation"] then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("ProtectStation") .. ReadText(1001, 7989), helpOverlayID = "interactmenu_protectstation", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonProtect(false) end, orderid = "ProtectStation" })
		end
	elseif actiontype == "putintostorage" then
		local isdocked = GetComponentData(convertedComponent, "isdocked")
		if istobedisplayed and isdocked then
			local container = C.GetContextByClass(menu.componentSlot.component, "container", false)
			if container ~= 0 then
				-- check if the ship is at a venture dock
				local isatventuredock = false
				local parentdockingbay = C.GetContextByClass(menu.componentSlot.component, "dockarea", false)
				local ventureplatforms = {}
				Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, container)
				for _, platform in ipairs(ventureplatforms) do
					local docks = {}
					Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
					for _, dock in ipairs(docks) do
						if dock == parentdockingbay then
							isatventuredock = true
							break
						end
					end
					if isatventuredock then
						break
					end
				end
				if not isatventuredock then
					local text = ReadText(1001, 11107)
					local active = true
					local mouseovertext = ""
					if not C.IsShipAtExternalDock(menu.componentSlot.component) then
						text = ReadText(1001, 7890)
						if C.IsShipBeingRetrieved(menu.componentSlot.component) then
							active = false
							mouseovertext = ReadText(1026, 7858)
						end
					elseif not C.HasContainerFreeInternalShipStorage(container, menu.componentSlot.component) then
						active = false
						mouseovertext = ReadText(1026, 7849)
					elseif not C.CanPutShipIntoStorage(container, menu.componentSlot.component) then
						active = false
						mouseovertext = ReadText(1026, 7850)
					end

					menu.insertInteractionContent("interaction", { type = actiontype, text = text, script = function () return menu.buttonPutIntoStorage(container, menu.componentSlot.component) end, active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif actiontype == "recallsubs" then
		if istobedisplayed and C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local subordinates = GetSubordinates(convertedComponent)
			if #subordinates > 0 then
				menu.insertInteractionContent("main_orders", { type = actiontype, text = ReadText(1001, 7830), helpOverlayID = "interactmenu_recallsubs", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRecallSubordinates(menu.componentSlot.component, subordinates) end })
			end
		end
	elseif actiontype == "removeallorders" then
		if istobedisplayed and (not GetComponentData(convertedComponent, "isdeployable")) and not C.IsUnit(convertedComponent) then
			local hasremoveableorders = false
			local hasdockandwaitorder = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
			for i = numorders, 1, -1 do
				local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
					hasdockandwaitorder = true
				else
					if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
						hasremoveableorders = true
						break
					end
				end
			end

			local buf = ffi.new("Order")
			if C.GetDefaultOrder(buf, menu.componentSlot.component) and (numorders == 1) and hasdockandwaitorder then
				local mouseovertext = ReadText(1026, 7841)
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 11117), helpOverlayID = "interactmenu_resumeduties", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(false, false, true) end, active = active, mouseOverText = mouseovertext, hidetarget = true })
			else
				local active = hasremoveableorders or (menu.numremovableorders > 0)
				local mouseovertext = active and ReadText(1026, 7841) or ReadText(1026, 7833)
				menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 7832), helpOverlayID = "interactmenu_removeallorders", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(false, false) end, active = active, mouseOverText = mouseovertext, hidetarget = true })
			end
		end
	elseif actiontype == "removeallordersandwait" then
		if istobedisplayed and IsComponentOperational(convertedComponent) and (not GetComponentData(convertedComponent, "isdeployable")) and not C.IsUnit(convertedComponent) then
			local hasremoveableorders = false
			local numorders = C.GetNumOrders(menu.componentSlot.component)
			local currentorders = ffi.new("Order[?]", numorders)
			numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
			for i = numorders, 1, -1 do
				local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
				if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
					-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
				else
					if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
						hasremoveableorders = true
						break
					end
				end
			end
			local currentdefaultorder = ffi.new("Order")
			if C.GetDefaultOrder(currentdefaultorder, menu.componentSlot.component) then
				if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
					hasremoveableorders = true
				end
			end
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
			if hasloop[0] then
				hasremoveableorders = true
			end

			local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
			if commander and (commander ~= 0) and (commander ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))) then
				hasremoveableorders = true
			end

			local numremovableorders = math.max(menu.numremovableorders, menu.numremovabledefaultorders)
			local active = hasremoveableorders or (numremovableorders > 0)
			local mouseovertext = active and ReadText(1026, 7834) or ReadText(1026, 7835)
			menu.insertInteractionContent(((not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0)) and "selected_orders_all" or "main_orders", { type = actiontype, text = ReadText(1001, 7889), helpOverlayID = "interactmenu_removeallordersandwait", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(true, true) end, active = active, hidetarget = true, mouseOverText = mouseovertext })
		end
	elseif actiontype == "removebuildstorage" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 11149), script = function () return menu.buttonRemoveBuildStorage(false) end })
		end
	elseif actiontype == "rename" then
		if istobedisplayed then
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 1114), script = function () return menu.buttonRename(false) end })
		end
	elseif actiontype == "rescueinrange" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			if #menu.selectedplayerships > 0 and menu.possibleorders["RescueInRange"] then
				local active = (C.GetFreePeopleCapacity(menu.selectedplayerships[1]) > 0)
				local mouseovertext = active and "" or ReadText(1026, 7864)
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("RescueInRange") .. ReadText(1041, 901), helpOverlayID = "interactmenu_rescueinrange", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRescueInRange(false) end, hidetarget = true, orderid = "RescueInRange", active = active, mouseOverText = mouseovertext } )
			end
		end
	elseif actiontype == "rescueship" then
		if #menu.selectedplayerships > 0 and menu.possibleorders["RescueShip"] and GetComponentData(convertedComponent, "isreallyplayerowned") then
			local active = (C.GetFreePeopleCapacity(menu.selectedplayerships[1]) > 0)
			local mouseovertext = active and "" or ReadText(1026, 7864)
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("RescueShip") .. ReadText(1041, 891), helpOverlayID = "interactmenu_rescueship", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRescueShip(false) end, orderid = "RescueShip", active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "salvagecollect" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["SalvageCollect"] and C.CanBeTowed(menu.componentSlot.component) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageCollect") .. ReadText(1041, 801), helpOverlayID = "interactmenu_salvagecollect", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageCollect(false) end, orderid = "SalvageCollect" })
		end
	elseif actiontype == "salvagecrush" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["SalvageCrush"] and C.CanBeDismantled(menu.componentSlot.component) then
			menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageCrush") .. ReadText(1041, 831), helpOverlayID = "interactmenu_salvagecrush", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageCrush(false) end, orderid = "SalvageCrush" })
		end
	elseif actiontype == "salvagedeliver" then
		if (menu.possibleorders["SalvageDeliver"] or menu.possibleorders["SalvageDeliver_NoTrade"]) and C.HasContainerProcessingModule(menu.componentSlot.component) and (not GetComponentData(convertedComponent, "isenemy")) then
			local hastowingship = false
			local ware
			local hasloop = ffi.new("bool[1]", 0)
			for _, ship in ipairs(menu.selectedplayerships) do
				if (GetComponentData(ship, "shiptype") == "tug") then
					C.GetOrderQueueFirstLoopIdx(ship, hasloop)
					if hasloop[0] then
						break
					end
				end
				local towedobject = C.GetTowedObject(ship)
				if towedobject ~= 0 then
					local recyclingwares = GetComponentData(ConvertStringTo64Bit(tostring(towedobject)), "recyclingwares")
					if #recyclingwares > 0 then
						hastowingship = true
						ware = recyclingwares[1].ware
						break
					end
				end
			end

			if hastowingship or hasloop[0] then
				local active = true
				if hasloop[0] then
					menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageDeliver_NoTrade") .. ReadText(1041, 811), helpOverlayID = "interactmenu_salvagedeliver", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageDeliver_NoTrade(false) end, active = active, orderid = "SalvageDeliver_NoTrade" })
				else
					local tradeoffers = GetTradesForWare(convertedComponent, ware, true)
					if #tradeoffers == 0 then
						active = false
						mouseovertext = ReadText(1001, 2973)
					end
					menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("SalvageDeliver") .. ReadText(1041, 811), helpOverlayID = "interactmenu_salvagedeliver", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonSalvageDeliver(false, ware, tradeoffers[1]) end, orderid = "SalvageDeliver", active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif (actiontype == "selfdestruct") then
		if GetComponentData(convertedComponent, "isdeployable") then
			local selecteddeployable = convertedComponent
			if #menu.selectedplayerdeployables > 0 then
				selecteddeployable = nil
			end
			menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11127), script = function () return menu.buttonSelfDestructDeployables(selecteddeployable) end })
		end
	elseif actiontype == "sellships" then
		if #menu.selectedplayerships > 0 then
			if not isplayerownedtarget then
				local shiptrader, isdock, iswharf, isshipyard, owner = GetComponentData(convertedComponent, "shiptrader", "isdock", "iswharf", "isshipyard", "owner")
				local doesbuyshipsfromplayer = GetFactionData(owner, "doesbuyshipsfromplayer")
				if shiptrader and isdock and (iswharf or isshipyard) and doesbuyshipsfromplayer then
					local cansell = false
					for _, ship in ipairs(menu.selectedplayerships) do
						if C.CanContainerBuildShip(menu.componentSlot.component, ship) and GetComponentData(ship, "issellable") then
							cansell = true
							break
						end
					end
					if cansell then
						menu.insertInteractionContent("selected_orders", { type = actiontype, text = (#menu.selectedplayerships == 1) and ReadText(1001, 7855) or ReadText(1001, 7856), helpOverlayID = "interactmenu_sellships", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonSellShips })
					end
				end
			end
		end
	elseif actiontype == "showupkeep" then
		if istobedisplayed then
			local found = false
			local numMissions = GetNumMissions()
			for i = 1, numMissions do
				local missionID, name, description, difficulty, threadtype, maintype, subtype, subtypename, faction, reward, rewardtext, _, _, _, _, _, missiontime, _, abortable, disableguidance, associatedcomponent, alertLevel = GetMissionDetails(i)

				if maintype == "upkeep" then
					if associatedcomponent then
						local rawcontainer = C.GetContextByRealClass(ConvertIDTo64Bit(associatedcomponent), "container", true)
						if rawcontainer ~= 0 then
							local container = ConvertStringTo64Bit(tostring(rawcontainer))
							if container == menu.componentSlot.component then
								found = true
								break
							end
						end
					end
				end
			end

			if found then
				menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11123), script = menu.buttonShowUpkeepMissions })
			end
		end
	elseif actiontype == "singletrade" then
		if (#menu.selectedplayerships > 0) and (menu.numorderloops > 0) then
			local owner = GetComponentData(convertedComponent, "owner")
			local hastradeoffers = GetFactionData(owner, "hastradeoffers")

			local active = true
			local mouseOverText = ""
			if not hastradeoffers then
				active = false
				mouseOverText = ReadText(1026, 7866)
			elseif not menu.hasPlayerShipPilot then
				active = false
				mouseOverText = ReadText(1026, 7830)
			end

			local hasbuy, hassell
			local tradeoffers = GetTradeList(convertedComponent, menu.selectedplayerships[1], false)
			for _, tradedata in pairs(tradeoffers) do
				if tradedata.isselloffer then
					hassell = true
				end
				if tradedata.isbuyoffer then
					hasbuy = true
				end
				if hassell and hasbuy then
					break
				end
			end
			if hassell then
				menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleBuy")  .. ReadText(1001, 11112), script = function () return menu.buttonTrade(false, nil, "SingleBuy") end,  active = active, mouseOverText = mouseovertext })
			end
			if hasbuy then
				menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11113), script = function () return menu.buttonTrade(false, nil, "SingleSell") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "stopandholdfire" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7870), helpOverlayID = "interactmenu_stopandholdfire", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonPlayerSquadStopAndHoldFire(true) end, hidetarget = true })	-- Fleet: Stop and hold fire
		end
	elseif actiontype == "tacticalattack" then
		if (#menu.selectedplayerships > 0) and menu.possibleorders["TacticalOrder"] and (not isplayerownedtarget) and C.IsComponentClass(menu.componentSlot.component, "destructible") then
			local fleetcommanders = {}
			for _, ship in ipairs(menu.selectedplayerships) do
				local commander = ConvertIDTo64Bit(GetCommander(ship))
				local subordinates = GetSubordinates(ship)
				if (not commander) and (#subordinates > 0) then
					table.insert(fleetcommanders, ship)
				end
			end
			if #fleetcommanders > 0 then
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("TacticalOrder") .. ReadText(1041, 731), helpOverlayID = "interactmenu_tacticalattack", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonTacticalAttack(fleetcommanders, false) end, orderid = "TacticalOrder" })
			end
		end
	elseif actiontype == "targetview" then
		if menu.mode ~= "shipconsole" then
			local playersector = C.GetContextByClass(C.GetPlayerID(), "sector", false)
			local target = 0
			if C.IsComponentClass(menu.componentSlot.component, "highway") then
				local issuperhighway, entrygate = GetComponentData(convertedComponent, "issuperhighway", "entrygate")
				if issuperhighway then
					target = ConvertIDTo64Bit(entrygate)
				else
					target = menu.componentSlot.component
				end
			else
				target = menu.componentSlot.component
			end
			local targetsector = C.GetContextByClass(target, "sector", false)
			local active = true
			local mouseovertext = Helper.getInputMouseOverText("INPUT_ACTION_TARGET_VIEW")
			if GetComponentData(convertedComponent, "isdockedinternally") then
				active = false
				mouseovertext = ReadText(1026, 7811)
			elseif C.IsExternalViewDisabled() then
				active = false
				mouseovertext = ReadText(1026, 7812)
			elseif (not C.IsPlayerCameraTargetViewPossible(target, true)) or (playersector ~= targetsector) then
				active = false
				mouseovertext = ReadText(1026, 7809)
			elseif target == C.GetPlayerControlledShipID() then
				active = false
				mouseovertext = ReadText(1026, 7810)
			end
			menu.insertInteractionContent("interaction", { type = actiontype, text = ReadText(1001, 7807), script = menu.buttonExternal, active = active, mouseOverText = mouseovertext })
		end
	elseif actiontype == "teleport" then
		local isally, isdeployable = GetComponentData(convertedComponent, "isally", "isdeployable")
		if (isplayerownedtarget or (C.IsComponentClass(menu.componentSlot.component, "station") and isally)) and (not isdeployable) and (not C.IsUnit(menu.componentSlot.component)) then
			if menu.componentSlot.component ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) then
				local active = false
				local mouseovertext = Helper.getInputMouseOverText("INPUT_ACTION_TELEPORT_ACTION")
				local teleportrequest = ffi.string(C.CanTeleportPlayerTo(menu.componentSlot.component, false, (menu.mode == "shipconsole") and isplayerownedtarget))
				if teleportrequest == "granted" then
					active = true
				elseif teleportrequest == "instorage" then
					mouseovertext = ReadText(1026, 7811)
				elseif teleportrequest == "malfunction" then
					mouseovertext = ReadText(1026, 7812)
				elseif teleportrequest == "research" then
					mouseovertext = ReadText(1026, 7813)
				elseif teleportrequest == "range" then
					mouseovertext = ReadText(1026, 7814)
				elseif teleportrequest == "size" then
					mouseovertext = ReadText(1026, 7815)
				elseif teleportrequest == "slot" then
					mouseovertext = ReadText(1026, 7816)
				end
				menu.insertInteractionContent("interaction", { type = actiontype, text = (menu.mode == "shipconsole") and ReadText(1001, 7854) or ReadText(1001, 7808), helpOverlayID = "interactmenu_teleport", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonTeleport, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "travelmode" then
		if istobedisplayed then
			local active = true
			local mouseovertext = ""
			if not C.CanStartTravelMode(menu.componentSlot.component) then
				active = false
				mouseovertext = ReadText(1026, 7855)
			end
			local currentactivity = GetPlayerActivity()

			menu.insertInteractionContent("interaction", { type = actiontype, text = (currentactivity == "travel") and ReadText(1001, 11116) or ReadText(1001, 11115), script = function () return menu.buttonTravelMode(currentactivity ~= "travel") end })
		end
	elseif actiontype == "upgrade" then
		local shiptrader, isdock, issupplyship, owner = GetComponentData(convertedComponent, "shiptrader", "isdock", "issupplyship", "owner")
		local doessellshipstoplayer = GetFactionData(owner, "doessellshipstoplayer")
		if (#menu.selectedplayerships > 0) and menu.possibleorders["Repair"] and isdock and (C.IsComponentClass(menu.componentSlot.component, "station") or issupplyship) and (menu.numorderloops == 0) then
			local active = false
			local haspilot = false
			for _, ship in ipairs(menu.selectedplayerships) do
				local pilot = GetComponentData(ship, "assignedpilot")
				if pilot then
					haspilot = true
					if C.CanContainerEquipShip(menu.componentSlot.component, ship) or (isplayerownedtarget and C.CanContainerSupplyShip(menu.componentSlot.component, ship)) then
						active = true
						break
					end
				end
			end
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if (C.IsComponentClass(menu.componentSlot.component, "station") and shiptrader) or isplayerownedtarget then
				local mouseovertext
				if not doessellshipstoplayer then
					active = false
					mouseovertext = ReadText(1026, 7865)
				elseif not shiptrader then
					active = false
					mouseovertext = ReadText(1026, 7827)
				elseif not haspilot then
					-- no one has a pilot, show that
					mouseovertext = ReadText(1026, 7830)
				elseif (not active) and (#menu.selectedplayerships > 0) then
					-- if the option is inactive, all ships are either capships or not, so only check the first one
					if C.IsComponentClass(menu.selectedplayerships[1], "ship_l") or C.IsComponentClass(menu.selectedplayerships[1], "ship_xl") then
						mouseovertext = issupplyship and ReadText(1026, 7828) or ReadText(1026, 7805)
					else
						mouseovertext = ReadText(1026, 7804)
					end
				end
				menu.insertInteractionContent("selected_orders", { type = actiontype, text = menu.orderIconText("Repair") .. (issupplyship and ReadText(1001, 7876) or ReadText(1001, 7826)), helpOverlayID = "interactmenu_upgrade", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonUpgrade(true) end, active = active, mouseOverText = mouseovertext, orderid = "Repair" })
			end
		end
	elseif actiontype == "upgradeships" then
		local shiptrader, isdock, issupplyship, owner = GetComponentData(convertedComponent, "shiptrader", "isdock", "issupplyship", "owner")
		local doessellshipstoplayer = GetFactionData(owner, "doessellshipstoplayer")
		local dockedships = {}
		if C.IsComponentClass(menu.componentSlot.component, "container") then
			Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, menu.componentSlot.component, "player")
		end

		-- start: aegs call-back
		if menu.uix_callbacks ["map_rightMenu_shipBuilding_insert"] then
			local state,activate_o,text_o,mouseovertext_o
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["map_rightMenu_shipBuilding_insert"]) do
				state,activate_o,text_o,mouseovertext_o = uix_callback (shiptrader,isdock,GetComponentData(convertedComponent, "macro"),doessellshipstoplayer,isplayerownedtarget)
				if state then
					menu.insertInteractionContent("main", { type = actiontype, text = text_o, helpOverlayID = "interactmenu_buildship", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonShipConfig("purchase") end, active = activate_o, mouseOverText = mouseovertext_o })
				end
			end
		end
		-- end: aegs call-back

		if isdock and (C.IsComponentClass(menu.componentSlot.component, "station") or issupplyship) then
			local active = false
			for _, ship in ipairs(dockedships) do
				if C.CanContainerEquipShip(menu.componentSlot.component, ship) or (isplayerownedtarget and C.CanContainerSupplyShip(menu.componentSlot.component, ship)) then
					active = true
					break
				end
			end
			-- don't show option for npcs if they are missing the shiptrader, but do for player objects
			if (C.IsComponentClass(menu.componentSlot.component, "station") and shiptrader) or isplayerownedtarget then
				local mouseovertext
				if not doessellshipstoplayer then
					active = false
					mouseovertext = ReadText(1026, 7865)
				elseif not shiptrader then
					active = false
					mouseovertext = ReadText(1026, 7827)
				elseif not active then
					if #dockedships > 0 then
						-- if the option is inactive, all ships are either capships or not, so only check the first one
						if C.IsComponentClass(dockedships[1], "ship_l") or C.IsComponentClass(dockedships[1], "ship_xl") then
							mouseovertext = ReadText(1026, 7807)
						else
							mouseovertext = ReadText(1026, 7806)
						end
					else
						mouseovertext = ReadText(1026, 7808)
					end
				end
				menu.insertInteractionContent("main", { type = actiontype, text = issupplyship and ReadText(1001, 7877) or ReadText(1001, 7841), helpOverlayID = "interactmenu_upgradeships", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonShipConfig("upgrade") end, active = active, mouseOverText = mouseovertext })
			end
		end
	elseif actiontype == "venturedockat" then
		if menu.possibleorders["DockAndWait"] and GetComponentData(convertedComponent, "isdock") then
			local ventureplatforms = {}
			Helper.ffiVLA(ventureplatforms, "UniverseID", C.GetNumVenturePlatforms, C.GetVenturePlatforms, menu.componentSlot.component)
			for _, platform in ipairs(ventureplatforms) do
				local currentdockareas = {}
				local hasdock = false
				local notdocked = false
				for i = #menu.selectedplayerships, 1, -1 do
					local ship = menu.selectedplayerships[i]
					if C.IsComponentClass(menu.componentSlot.component, "container") then
						local parentdockingbay = C.GetContextByClass(ship, "dockarea", false)
						if parentdockingbay ~= 0 then
							table.insert(currentdockareas, parentdockingbay)
						else
							notdocked = true
						end
						if C.HasVenturerDock(menu.componentSlot.component, ship, platform) then
							hasdock = true
						end
					end
				end
				if hasdock then
					local docks = {}
					local dockindex = {}
					Helper.ffiVLA(docks, "UniverseID", C.GetNumVenturePlatformDocks, C.GetVenturePlatformDocks, platform)
					local counts = {
						["XL_L"] = 0,
						["M_S"] = 0,
					}
					for _, dock in ipairs(docks) do
						dockindex[tostring(dock)] = true
						local docksizes = GetComponentData(ConvertStringTo64Bit(tostring(dock)), "docksizes")
						-- docksizes always return the biggest possible size of a dockingbay contained in the dockarea
						counts["XL_L"] = counts["XL_L"] + (docksizes.docks_xl or 0) + (docksizes.docks_l or 0)
						counts["M_S"]  = counts["M_S"]  + (docksizes.docks_m or 0)  + (docksizes.docks_s or 0)
					end
					local dockstring = ""
					if counts["XL_L"] > 0 then
						if dockstring ~= "" then
							dockstring = dockstring .. " "
						end
						dockstring = dockstring .. "[" .. counts["XL_L"] .. ReadText(1001, 42) .. " " .. ReadText(1001, 7863) .. "]"
					end
					if counts["M_S"] > 0 then
						if dockstring ~= "" then
							dockstring = dockstring .. " "
						end
						dockstring = dockstring .. "[" .. counts["M_S"] .. ReadText(1001, 42) .. " " .. ReadText(1001, 7864) .. "]"
					end

					local isalreadydocked = true
					if notdocked then
						-- some ship is not docked at all
						isalreadydocked = false
					else
						for _, dockarea in ipairs(currentdockareas) do
							if not dockindex[tostring(dockarea)] then
								-- some ship is not docked at this platform
								isalreadydocked = false
								break
							end
						end
					end
					local active = not isalreadydocked
					local mouseovertext = ""
					if isalreadydocked then
						mouseovertext = ReadText(1026, 7846)
					end

					menu.insertInteractionContent("venturedock", { type = actiontype, text = ffi.string(C.GetComponentName(platform)), text2 = dockstring, helpOverlayID = "interactmenu_ventureatdock", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonDock(false, platform) end, active = active, mouseOverText = mouseovertext, orderid = "DockAndWait" })
				end
			end
		end
	elseif actiontype == "venturepatron" then
		menu.insertInteractionContent("main", { type = actiontype, text = ReadText(1001, 11802), script = menu.buttonVenturePatron })
	elseif actiontype == "venturereportname" then
		menu.insertInteractionContent("venturereport", { type = actiontype, text = ReadText(1001, 12114), script = menu.buttonVentureReportShip })
	elseif actiontype == "venturereportusername" then
		menu.insertInteractionContent("venturereport", { type = actiontype, text = ReadText(1001, 12111), script = menu.buttonVentureReportUser })
	elseif actiontype == "wareexchange" then
		if (#menu.selectedplayerships > 0) and isplayerownedtarget and (not GetComponentData(convertedComponent, "isdeployable")) and (not C.IsUnit(convertedComponent)) and (menu.numorderloops == 0) then
			local hasrealship = false
			for _, ship in ipairs(menu.selectedplayerships) do
				if (not GetComponentData(ship, "isdeployable")) and (not C.IsComponentClass(ship, "spacesuit")) then
					hasrealship = true
					break
				end
			end
			if hasrealship then
				local active = menu.showPlayerInteractions or menu.hasPlayerShipPilot
				local mouseovertext = (not active) and ReadText(1026, 7830) or ""
				if menu.showPlayerInteractions then
					local occupiedship = C.GetPlayerOccupiedShipID()

					local isbuilderbusy = false
					local numorders = C.GetNumOrders(menu.componentSlot.component)
					local currentorders = ffi.new("Order[?]", numorders)
					numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
					for i = 1, numorders do
						if ffi.string(currentorders[i - 1].orderdef) == "DeployToStation" then
							if ffi.string(currentorders[i - 1].state) == "critical" then
								isbuilderbusy = true
								break
							end
						end
					end

					if C.GetCommonContext(occupiedship, menu.componentSlot.component, true, true, C.GetContextByClass(occupiedship, "zone", false), false) == 0 then
						active = false
						mouseovertext = ReadText(1026, 7856)
					elseif not GetComponentData(convertedComponent, "assignedaipilot") then
						active = false
						mouseovertext = ReadText(1026, 7830)
					elseif isbuilderbusy then
						active = false
						mouseovertext = ReadText(1001, 7939)
					end
				else
					if C.IsComponentClass(menu.componentSlot.component, "ship") and C.IsBuilderBusy(menu.componentSlot.component) then
						active = false
						mouseovertext = ReadText(1026, 7820)
					end
				end

				if C.IsComponentClass(menu.componentSlot.component, "container") then
					menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "trade_orders", { type = actiontype, text = menu.orderIconText("TradeExchange") .. ReadText(1001, 7820), script = function () return menu.buttonTrade(true) end, active = active, mouseOverText = mouseovertext })
				end
				if menu.buildstorage then
					menu.insertInteractionContent(menu.showPlayerInteractions and "player_interaction" or "trade_orders", { type = actiontype, text = menu.orderIconText("TradeExchange") .. ReadText(1001, 7820), script = function () return menu.buttonTrade(true, menu.buildstorage) end, buildstorage = true, active = active, mouseOverText = mouseovertext })
				end
			end
		end
	elseif actiontype == "withdrawandhold" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7871), script = function () return menu.buttonPlayerSquadWithdrawAndHold(true) end, hidetarget = true })	-- Fleet: Withdraw and hold
		end
	elseif actiontype == "withdrawfromcombat" then
		if istargetinplayersquad or istargetplayeroccupiedship then
			menu.insertInteractionContent("playersquad_orders", { type = actiontype, text = ReadText(1001, 7872), script = function () return menu.buttonPlayerSquadWithdrawFromCombat(true) end, hidetarget = true })	-- Fleet: Withdraw from combat
		end
	elseif actiontype == "cheat_satellite" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place satellite", script = menu.buttonSatelliteCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_navbeacon" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place nav beacon", script = menu.buttonNavBeaconCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_resourceprobe" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Place resource probe", script = menu.buttonResourceProbeCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_takeownership" then
		if not isplayerownedtarget then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Take ownership", script = menu.buttonOwnerCheat }) -- (cheat only)
		end
	elseif actiontype == "cheat_warp" then
		if menu.offsetcomponent and (menu.offsetcomponent ~= 0) then
			menu.insertInteractionContent("cheats", { type = actiontype, text = "Warp here", script = menu.buttonWarpCheat }) -- (cheat only)
		end
	else
		DebugError("Unknown LuaAction type '" .. actiontype .. "'! [Florian]")
	end
end

function menu.prepareData()
	menu.data = {}
	menu.data.convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
	menu.data.istargetinplayersquad = false
	menu.data.istargetplayeroccupiedship = false
	menu.data.hastargetpilot = false
	if (menu.data.convertedComponent ~= 0) then
		menu.data.isplayerownedtarget = GetComponentData(menu.data.convertedComponent, "isplayerowned")
		menu.data.istargetinplayersquad = menu.playerSquad[menu.data.convertedComponent]
		--print("istargetinplayersquad: " .. tostring(menu.data.istargetinplayersquad) .. ", commander: " .. tostring(GetCommander(menu.data.convertedComponent)) .. ", occupiedship: " .. ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())))

		menu.data.istargetplayeroccupiedship = (ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) == menu.data.convertedComponent)
		--print("istargetplayeroccupiedship: " .. tostring(menu.data.istargetplayeroccupiedship) .. ", occupiedship: " .. ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID())) .. ", convertedComponent: " .. tostring(menu.data.convertedComponent))

		menu.data.hastargetpilot = GetComponentData(menu.data.convertedComponent, "assignedpilot") ~= nil

		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local hasloop = ffi.new("bool[1]", 0)
			C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
			menu.data.hastargetorderloop = hasloop[0]
		end
	end
end

function menu.prepareActions()
	menu.checkPlayerActivity = nil
	menu.forceSubSection = {}
	menu.prepareSections()

	menu.prepareData()
	local convertedComponent = menu.data.convertedComponent

	local hasanydisplayed = false
	-- player actions
	if (not menu.fleetunit) and (not menu.selectedfleetunit) and (not menu.componentOrder) and (not menu.syncpoint) and (not menu.syncpointorder) and (not menu.intersectordefencegroup) and (not menu.construction) and (not menu.mission) and (not menu.missionoffer) and (not menu.subordinategroup) and (menu.mode ~= "shipconsole" or (menu.isdockedship)) then
		local isknown = C.IsObjectKnown(menu.componentSlot.component)
		local n = C.GetNumCompSlotPlayerActions(menu.componentSlot)
		if n == 0 then
			return false
		end
		local buf = ffi.new("UIAction[?]", n)
		n = C.GetCompSlotPlayerActions(buf, n, menu.componentSlot)

		local definedactions = {}
		local actions = {}
		for i = 0, n - 1 do
			local actiontype = ffi.string(buf[i].type)
			table.insert(actions, {
				id = buf[i].id,
				text = ffi.string(buf[i].text),
				active = buf[i].ispossible,
				actiontype = actiontype,
				istobedisplayed = buf[i].istobedisplayed,
			})
			definedactions[actiontype] = #actions
		end

		if (not definedactions["lua;behaviourinspection"]) or (not actions[definedactions["lua;behaviourinspection"]].istobedisplayed) or (menu.componentSlot.component == C.GetPlayerControlledShipID()) then
			if menu.behaviourInspectionComponent and (not menu.shown) then
				menu.insertInteractionContent("behaviourinspection", { type = "stopbehaviourinspection", text = ColorText["behaviour_inspection_text"] .. "\27[menu_behaviourinspection_exit]\27X " .. ReadText(1001, 11145), helpOverlayID = "interactmenu_stopbehaviourinspection", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonStopBehaviourInspection })
			end
		end

		for i, action in ipairs(actions) do
			local entry = {}
			entry.id = action.id
			entry.text = action.text
			entry.active = action.active
			local actiontype = action.actiontype
			if (not menu.shown) and (actiontype == "containertrade") then
				entry.script = function () return menu.buttonTrade(false) end
			elseif (not menu.shown) and (actiontype == "info") then
				entry.script = menu.buttonInfo
				entry.helpOverlayID = "interactmenu_info"
				entry.helpOverlayText = " "
				entry.helpOverlayHighlightOnly = true
			elseif (not menu.shown) and (actiontype == "comm") then
				entry.script = menu.buttonComm
			else
				entry.script = function () return menu.buttonPerformPlayerAction(entry.id, actiontype) end
			end

			local basetype, luatype = string.match(actiontype, "(.+);(.+)")
			if (not menu.buildStationMode) or config.buildStationModeAllowedActions[luatype] then
				local istobedisplayed = action.istobedisplayed
				hasanydisplayed = hasanydisplayed or istobedisplayed

				if isknown or (actiontype == "info") or (luatype == "guidance") then
					if basetype == "lua" then
						menu.insertLuaAction(luatype, istobedisplayed)
					elseif istobedisplayed then
						if actiontype == "containertrade" then
							local owner = GetComponentData(convertedComponent, "owner")
							local hastradeoffers = GetFactionData(owner, "hastradeoffers")
							if not hastradeoffers then
								entry.active = false
								entry.mouseOverText = ReadText(1026, 7866)
							end
							if (not menu.showPlayerInteractions) and (#menu.selectedplayerships > 0) then
								if menu.numshipsexcludingspacesuits > 0 then
									if C.IsComponentClass(menu.componentSlot.component, "container") then
										entry.active = entry.active and menu.hasPlayerShipPilot
										entry.mouseOverText = (not menu.hasPlayerShipPilot) and ReadText(1026, 7830) or ""
										if menu.numorderloops == 0 then
											entry.text = menu.orderIconText("TradePerform") .. entry.text
											entry.helpOverlayID = "interactmenu_trade"
											entry.helpOverlayText = " "
											entry.helpOverlayHighlightOnly = true
											menu.insertInteractionContent("trade_orders", entry)
										else
											local hasbuy, hassell
											local tradeoffers = GetTradeList(convertedComponent, menu.selectedplayerships[1], false)
											for _, tradedata in pairs(tradeoffers) do
												if tradedata.isselloffer then
													hassell = true
												end
												if tradedata.isbuyoffer then
													hasbuy = true
												end
												if hassell and hasbuy then
													break
												end
											end
											if hassell then
												menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleBuy")  .. ReadText(1001, 11110), script = function () return menu.buttonTrade(false, nil, "SingleBuy") end,  active = entry.active, mouseOverText = entry.mouseOverText })
											end
											if hasbuy then
												menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11111), script = function () return menu.buttonTrade(false, nil, "SingleSell") end, active = entry.active, mouseOverText = entry.mouseOverText })
											end
										end
									end
									if menu.buildstorage then
										if menu.numorderloops == 0 then
											menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("TradePerform") .. ReadText(1001, 7819), script = function () return menu.buttonTrade(false, menu.buildstorage) end, buildstorage = true, active = entry.active and menu.hasPlayerShipPilot, mouseOverText = (entry.mouseOverText ~= "") and entry.mouseOverText or ((not menu.hasPlayerShipPilot) and ReadText(1026, 7830) or "") })
										else
											menu.insertInteractionContent("trade_orders", { text = menu.orderIconText("SingleSell") .. ReadText(1001, 11111), script = function () return menu.buttonTrade(false, menu.buildstorage, "SingleSell") end, buildstorage = true, active = entry.active, mouseOverText = entry.mouseOverText })
										end
									end
								end
							else
								entry.text = ReadText(1001, 1113)
								if C.IsComponentClass(menu.componentSlot.component, "container") then
									entry.text = menu.orderIconText("TradePerform") .. entry.text
									menu.insertInteractionContent("trade", entry)
								end
								if menu.buildstorage then
									menu.insertInteractionContent("trade", { text = menu.orderIconText("TradePerform") .. ReadText(1001, 1113), script = function () return menu.buttonTrade(false, menu.buildstorage) end, buildstorage = true, active = entry.active, mouseOverText = entry.mouseOverText })
								end
							end
						elseif actiontype == "hack" then
							if menu.showPlayerInteractions then
								menu.insertInteractionContent("player_interaction", entry)
							end
						elseif actiontype == "scan" then
							if menu.showPlayerInteractions then
								if not entry.active then
									if GetPlayerActivity() ~= "scan" then
										entry.mouseOverText = ReadText(1026, 7803)
									else
										entry.mouseOverText = ReadText(1026, 7809)
									end
								else
									entry.mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_SCAN_ACTION")
								end
								entry.helpOverlayID = "interactmenu_scan"
								entry.helpOverlayText = " "
								entry.helpOverlayHighlightOnly = true
								menu.checkPlayerActivity = true
								menu.insertInteractionContent("player_interaction", entry)
							end
						elseif (actiontype == "comm") then
							if not entry.active then
								if C.IsComponentClass(menu.componentSlot.component, "controllable") and GetControlEntity(convertedComponent) then
									entry.mouseOverText = ReadText(1026, 7802)
								else
									entry.mouseOverText = ReadText(1026, 7801)
								end
							else
								entry.mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_COMM_ACTION")
							end
							menu.insertInteractionContent("interaction", entry)
						elseif (actiontype == "detach") then
							if GetComponentData(convertedComponent, "isdeployable") and (#menu.selectedplayerdeployables > 1) then
								local isactive = GetComponentData(convertedComponent, "isactive")
								menu.insertInteractionContent("main", { text = isactive and ReadText(1001, 7883) or ReadText(1001, 7882), text2 = string.format(ReadText(1001, 7884), #menu.selectedplayerdeployables), helpOverlayID = "interactmenu_detach", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonActivateDeployables(isactive) end,  })
							else
								entry.helpOverlayID = "interactmenu_deactivatesatellite"
								entry.helpOverlayText = " "
								entry.helpOverlayHighlightOnly = true
								menu.checkPlayerActivity = true
								menu.insertInteractionContent("main", entry)
							end
						elseif (actiontype == "info") then
							entry.mouseOverText = Helper.getInputMouseOverText("INPUT_ACTION_INFO_ACTION")
							menu.insertInteractionContent("main", entry)
						elseif (actiontype == "matchspeed") then
							if not entry.active then
								entry.mouseOverText = ReadText(1026, 7802)
							else
								entry.mouseOverText = Helper.getInputMouseOverText("INPUT_STATE_MATCH_SPEED")
							end
							menu.insertInteractionContent("main", entry)
						elseif actiontype == "tow" then
							if not entry.active then
								if not C.CanBeTowed(menu.componentSlot.component) then
									entry.mouseOverText = ReadText(1026, 7859)
								else
									entry.mouseOverText = ReadText(1026, 7814)
								end
							end
							menu.insertInteractionContent("main", entry)
						elseif (actiontype == "ejectrecyclable") then
							local scrapbuffer = GetComponentData(convertedComponent, "scrapbuffer")
							entry.mouseOverText = ReadText(20201, 6801) .. ReadText(1001, 120) .. " " .. ConvertIntegerString(scrapbuffer, true, 0, true)
							menu.insertInteractionContent("main_orders", entry)
						else
							menu.insertInteractionContent("main", entry)
						end
					end
				end
			end
		end

		for _, entries in pairs(menu.actions) do
			if #entries > 0 then
				hasanydisplayed = true
			end
		end

		if (not hasanydisplayed) and menu.buildStationMode then
			return false
		end

		if menu.componentMissions and (type(menu.componentMissions) == "table") then
			for _, missionid in ipairs(menu.componentMissions) do
				local missiondetails = C.GetMissionIDDetails(missionid)
				if ffi.string(missiondetails.mainType) ~= "guidance" then
					menu.insertInteractionContent("main", { text = ReadText(1001, 7850) .. " (" .. ffi.string(missiondetails.missionName) .. ")", script = function () return menu.buttonMissionShow(missionid) end, active = true })
				end
			end
		end
	end

	if menu.componentOrder then
		hasanydisplayed = true
		-- orders (not action based at all)
		menu.insertInteractionContent("order", { type = "removethisorder", text = ReadText(1001, 7831), helpOverlayID = "interactmenu_removethisorder", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonRemoveOrder, active = (menu.componentOrder.queueidx > 0) and C.RemoveOrder(menu.componentSlot.component, menu.componentOrder.queueidx, false, true), mouseOverText = (menu.componentOrder.queueidx == 0) and ReadText(1026, 7844) or "" })
		-- Remove all orders
		local hasremoveableorders = false
		local numorders = C.GetNumOrders(menu.componentSlot.component)
		local currentorders = ffi.new("Order[?]", numorders)
		numorders = C.GetOrders(currentorders, numorders, menu.componentSlot.component)
		for i = numorders, 1, -1 do
			local isdocked, isdocking = GetComponentData(convertedComponent, "isdocked", "isdocking")
			if (i == 1) and ((ffi.string(currentorders[0].orderdef) == "DockAndWait") and (isdocked or isdocking)) then
				-- do nothing - removing the dock order would create an undock order ... rather have the ship stay put [Nick]
			else
				if C.RemoveOrder(menu.componentSlot.component, i, false, true) then
					hasremoveableorders = true
					break
				end
			end
		end
		local mouseovertext = hasremoveableorders and ReadText(1026, 7841) or ReadText(1026, 7833)
		menu.insertInteractionContent("order", { type = "removeallorders", text = ReadText(1001, 7832), helpOverlayID = "interactmenu_removeallorders", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = function () return menu.buttonRemoveAllOrders(false, false) end, active = hasremoveableorders, mouseOverText = mouseovertext })

		local currentdefaultorder = ffi.new("Order")
		if C.GetDefaultOrder(currentdefaultorder, menu.componentSlot.component) then
			if (ffi.string(currentdefaultorder.orderdef) ~= "Wait") and (ffi.string(currentdefaultorder.orderdef) ~= "DockAndWait") then
				hasremoveableorders = true
			end
		end
		local hasloop = ffi.new("bool[1]", 0)
		C.GetOrderQueueFirstLoopIdx(menu.componentSlot.component, hasloop)
		if hasloop[0] then
			hasremoveableorders = true
		end

		local commander = ConvertIDTo64Bit(GetCommander(convertedComponent))
		if commander and (commander ~= 0) and (commander ~= ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))) then
			hasremoveableorders = true
		end
		mouseovertext = hasremoveableorders and ReadText(1026, 7834) or ReadText(1026, 7835)
		menu.insertInteractionContent("order", { type = "removeallordersandwait", text = ReadText(1001, 7874), script = function () return menu.buttonRemoveAllOrders(true, true) end, active = hasremoveableorders, mouseOverText = mouseovertext })
	elseif menu.syncpoint then
		hasanydisplayed = true
		menu.insertInteractionContent("syncpoint", { type = "triggersyncpoint", text = ReadText(1001, 3232), script = function () return menu.buttonTriggerSyncPoint() end, active = C.GetNumObjectsWithSyncPoint(menu.syncpoint, true) > 0 })
		menu.insertInteractionContent("syncpoint", { type = "syncpointrelease", text = function () return ReadText(1001, 11297) .. ReadText(1001, 120) .. " " .. (C.GetSyncPointAutoRelease(menu.syncpoint, true) and ReadText(1001, 2617) or ReadText(1001, 2618)) end, script = function () return menu.buttonSyncPointAutoRelease() end })
	elseif menu.syncpointorder then
		hasanydisplayed = true
		menu.insertInteractionContent("order", { type = "removethisorder", text = ReadText(1001, 7831), helpOverlayID = "interactmenu_removethisorder", helpOverlayText = " ", helpOverlayHighlightOnly = true, script = menu.buttonRemoveOrder, active = (menu.syncpointorder.queueidx > 0) and C.RemoveOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, false, true), mouseOverText = (menu.syncpointorder.queueidx == 0) and ReadText(1026, 7844) or "" })
		menu.insertInteractionContent("syncpoint", { type = "triggersyncpoint", text = ReadText(1001, 3232), script = function () return menu.buttonTriggerSyncPoint() end, active = C.GetNumObjectsWithSyncPointFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true) > 0 })
		menu.insertInteractionContent("syncpoint", { type = "syncpointrelease", text = function () return ReadText(1001, 11297) .. ReadText(1001, 120) .. " " .. (C.GetSyncPointAutoReleaseFromOrder(menu.componentSlot.component, menu.syncpointorder.queueidx, true) and ReadText(1001, 2617) or ReadText(1001, 2618)) end, script = function () return menu.buttonSyncPointAutoRelease() end })
	elseif menu.intersectordefencegroup then
		hasanydisplayed = true
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11137), script = function () return menu.buttonSubordinateGroupInterSectorDefence(menu.intersectordefencegroup, true) end })
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11138), checkbox = C.ShouldSubordinateGroupAttackOnSight(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupAttackOnSight(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7860) })
		if C.IsComponentClass(menu.componentSlot.component, "ship") then
			menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11139), checkbox = C.ShouldSubordinateGroupResupplyAtFleet(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupResupplyAtFleet(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7861) })
			menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11140), checkbox = C.ShouldSubordinateGroupReinforceFleet(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupReinforceFleet(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7862) })
		end
		menu.insertInteractionContent("intersectordefencegroup", { text = ReadText(1001, 11142), checkbox = C.ShouldSubordinateGroupRespondToDistressCalls(menu.componentSlot.component, menu.intersectordefencegroup), script = function (_, checked) return menu.checkboxSubordinateGroupRespondToDistressCalls(menu.intersectordefencegroup, checked) end, mouseOverText = ReadText(1026, 7867) })
	elseif menu.mission then
		hasanydisplayed = true
		local missiondetails = C.GetMissionIDDetails(menu.mission)
		if ffi.string(missiondetails.mainType) == "guidance" then
			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3243), script = menu.buttonEndGuidance, active = true })
		else
			local active = menu.mission == C.GetActiveMissionID()
			local buf = {}
			Helper.ffiVLA(buf, "MissionID", C.GetNumMissionThreadSubMissions, C.GetMissionThreadSubMissions, menu.mission)
			for _, submission in ipairs(buf) do
				if submission == C.GetActiveMissionID() then
					active = true
				end
			end

			menu.insertInteractionContent("guidance", { text = active and ReadText(1001, 3413) or ReadText(1001, 3406), script = active and menu.buttonMissionSetInactive or (function () return menu.buttonMissionSetActive(menu.mission) end), active = true })

			local active = missiondetails.abortable
			if missiondetails.threadMissionID ~= 0 then
				local details = C.GetMissionIDDetails(missiondetails.threadMissionID)
				active = active and (ffi.string(details.threadType) ~= "sequential")
			end

			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3407), script = function () return menu.buttonMissionAbort(menu.mission) end, active = active })
			--menu.insertInteractionContent("guidance", { text = ReadText(1001, 7850), script = function () return menu.buttonMissionShow(menu.mission) end, active = true })
			local missionid = menu.mission
			if missiondetails.threadMissionID ~= 0 then
				missionid = ConvertStringTo64Bit(tostring(missiondetails.threadMissionID))
			end
			menu.insertInteractionContent("guidance", { text = ReadText(1001, 3326), script = function () return menu.buttonMissionBriefing(missionid, false) end, active = true })
		end
	elseif menu.missionoffer then
		hasanydisplayed = true
		local active = true
		local mouseovertext
		if C.IsMissionLimitReached(false, false, false) then
			active = false
			mouseovertext = ReadText(1026, 3242)
		end
		menu.insertInteractionContent("guidance", { text = ReadText(1001, 57), script = function () return menu.buttonMissionAccept(menu.missionoffer) end, active = active, mouseOverText = mouseovertext })
		menu.insertInteractionContent("guidance", { text = ReadText(1001, 3326), script = function () return menu.buttonMissionBriefing(menu.missionoffer, true) end, active = true })
	elseif menu.construction then
		hasanydisplayed = true
		-- construction (not action based at all)
		menu.insertInteractionContent("main", { text = ReadText(1001, 7853), script = menu.buttonCancelConstruction, active = C.CanCancelConstruction(menu.componentSlot.component, menu.construction.id) and ((menu.construction.factionid == "player") or GetComponentData(convertedComponent, "isplayerowned")) })
		if menu.construction.amount and (menu.construction.amount > 1) then
			local cancelcount = menu.getCanCancelConstructionCount()
			menu.insertInteractionContent("main", { text = ReadText(1041, 10022), text2 = (cancelcount > 0) and (cancelcount .. ReadText(1001, 42) .. " " .. GetMacroData(menu.construction.macro, "name")) or "", script = menu.buttonCancelAllConstruction, active = (cancelcount > 1) and ((menu.construction.factionid == "player") or GetComponentData(convertedComponent, "isplayerowned")) })
		end
	elseif menu.subordinategroup then
		hasanydisplayed = true
		-- subordinate group (not action based at all)
		local isplayerowned
		local groups
		if menu.componentSlot.component ~= 0 then
			isplayerowned = GetComponentData(convertedComponent, "isplayerowned")
			groups = menu.getSubordinatesInGroups(menu.componentSlot.component, C.IsComponentClass(menu.componentSlot.component, "station"))
		else
			isplayerowned = true
			groups = menu.getSubordinatesInFleetUnitGroups(menu.fleetunit, false)
		end
		menu.groupShips = {}
		if groups[menu.subordinategroup] and #groups[menu.subordinategroup].subordinates then
			menu.groupShips = groups[menu.subordinategroup].subordinates
		end

		local allresupplier = true
		local allmining = true
		local allnomining = true
		local alltugs = true
		for _, shipentry in ipairs(menu.groupShips) do
			if shipentry.component then
				local purpose, shiptype = GetComponentData(shipentry.component, "primarypurpose", "shiptype")
				if shiptype ~= "resupplier" then
					allresupplier = false
				end
				if purpose == "mine" then
					allnomining = false
				end
				if purpose ~= "mine" then
					allmining = false
				end
				if shiptype ~= "tug" then
					alltugs = false
				end
			end
		end

		if isplayerowned then
			-- select
			menu.insertInteractionContent("main", { text = ReadText(1001, 11100), script = menu.buttonSelectSubordinateGroup })
			-- manage assignments
			local isstation, isship
			if menu.fleetunit then
				isstation = false
				isship = true
			else
				isstation = C.IsComponentClass(menu.componentSlot.component, "station")
				isship = C.IsComponentClass(menu.componentSlot.component, "ship")
			end
			-- inter-sector defense
			local commandershiptype
			if menu.componentSlot.component ~= 0 then
				commandershiptype = GetComponentData(convertedComponent, "shiptype")
			else
				local unitinfo = C.GetFleetUnitInfo(menu.fleetunit)
				commandershiptype = GetMacroData(ffi.string(unitinfo.macro), "shiptype")
			end
			local parentcommander = C.GetCommander(menu.componentSlot.component, menu.fleetunit or 0)
			local isfleetcommander = (parentcommander.controllableid == 0) and (parentcommander.fleetunitid == 0)

			if menu.componentSlot.component ~= 0 then
				local hasintersectorgroup = C.HasSubordinateAssignment(convertedComponent, "positiondefence")
				if (#menu.selectedplayerships == 0) and ((commandershiptype == "carrier") or (isstation and not hasintersectorgroup and C.CanClaimOwnership(convertedComponent))) and isfleetcommander then
					local isintersectorgroup = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, menu.subordinategroup)) == "positiondefence"
					menu.insertInteractionContent("main", { text = isintersectorgroup and ReadText(1001, 11137) or ReadText(1001, 11136), script = function () return menu.buttonSubordinateGroupInterSectorDefence(menu.subordinategroup, isintersectorgroup) end })
				end
			end
			-- defence
			menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonChangeAssignment, groups, isstation, isstation)
			-- supplyfleet
			if allresupplier then
				menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonChangeAssignment, groups, isstation, true)
			end
			if isstation then
				-- trading
				menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true, nil, (not allnomining) and (ColorText["text_warning"] .. ReadText(1026, 8607)) or "")
				if allmining then
					-- mining
					menu.insertAssignSubActions("main_assignments_mining", "mining", menu.buttonChangeAssignment, groups, isstation, true)
				elseif allnomining then
					-- trading for buildstorage
					menu.insertAssignSubActions("main_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonChangeAssignment, groups, isstation, true)
				end
				if alltugs then
					menu.insertAssignSubActions("main_assignments_salvage", "salvage", menu.buttonChangeAssignment, groups, isstation, true)
				end
			elseif isship then
				menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonChangeAssignment, groups, isstation, nil)
				menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonChangeAssignment, groups, isstation, true)
				if menu.componentSlot.component ~= 0 then
					local buf = ffi.new("Order")
					if C.GetDefaultOrder(buf, menu.componentSlot.component) then
						menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonChangeAssignment, groups, isstation, true)
					end
				end
				if commandershiptype == "resupplier" then
					menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeAssignment, groups, isstation, true)
				end
			end

			local assignment
			if menu.componentSlot.component ~= 0 then
				assignment = ffi.string(C.GetSubordinateGroupAssignment(menu.componentSlot.component, menu.subordinategroup))
			else
				assignment = ffi.string(C.GetFleetUnitSubordinateGroupAssignment(menu.fleetunit, menu.subordinategroup))
			end
			menu.insertInteractionContent("selected_orders", { text = ReadText(1001, 11122), text2 = string.format(ReadText(1001, 8398), ReadText(20401, menu.subordinategroup)), script = function () return menu.buttonAssignCommander(assignment, menu.subordinategroup) end })
		else
			menu.insertInteractionContent("main", { text = ReadText(1001, 7852), active = false })
		end
	elseif menu.fleetunit then
		hasanydisplayed = true

		-- remove fleetunit
		menu.insertInteractionContent("main", { text = ReadText(1001, 11148), script = menu.buttonRemoveFleetUnit, active = true })

		-- Change assignment
		local shiptype = GetMacroData(menu.fleetunitinfo.macro, "shiptype")
		local commander = C.GetCommander(0, menu.fleetunit)
		local currentgroup = C.GetFleetUnitSubordinateGroup(menu.fleetunit)
		local groups = {}
		if commander.controllableid ~= 0 then
			groups = menu.getSubordinatesInGroups(commander.controllableid, isstation)
		else
			groups = menu.getSubordinatesInFleetUnitGroups(commander.fleetunitid, isstation)
		end
		-- defence
		menu.insertAssignSubActions("main_assignments_defence", "defence", menu.buttonChangeFleetUnitAssignment, groups, false, false, currentgroup)
		-- supplyfleet
		if shiptype == "resupplier" then
			menu.insertAssignSubActions("main_assignments_supplyfleet", "supplyfleet", menu.buttonChangeFleetUnitAssignment, groups, false, true, currentgroup)
		end
		-- position defence
		local commandershiptype
		if commander.controllableid ~= 0 then
			commandershiptype = GetComponentData(ConvertStringToLuaID(tostring(commander.controllableid)), "shiptype")
		else
			local unitinfo = C.GetFleetUnitInfo(commander.fleetunitid)
			commandershiptype = GetMacroData(ffi.string(unitinfo.macro), "shiptype")
		end
		local parentcommander = C.GetCommander(commander.controllableid, commander.fleetunitid)
		local isfleetcommander = (parentcommander.controllableid == 0) and (commander.fleetunitid == 0)
		if (commandershiptype == "carrier") and isfleetcommander then
			menu.insertAssignSubActions("main_assignments_positiondefence", "positiondefence", menu.buttonChangeFleetUnitAssignment, groups, false, nil, currentgroup)
		end
		menu.insertAssignSubActions("main_assignments_attack", "attack", menu.buttonChangeFleetUnitAssignment, groups, false, nil, currentgroup)
		menu.insertAssignSubActions("main_assignments_interception", "interception", menu.buttonChangeFleetUnitAssignment, groups, false, nil, currentgroup)
		menu.insertAssignSubActions("main_assignments_bombardment", "bombardment", menu.buttonChangeFleetUnitAssignment, groups, false, nil, currentgroup)
		menu.insertAssignSubActions("main_assignments_follow", "follow", menu.buttonChangeFleetUnitAssignment, groups, false, true, currentgroup)
		if commander.controllableid ~= 0 then
			local buf = ffi.new("Order")
			if C.GetDefaultOrder(buf, commander.controllableid) then
				menu.insertAssignSubActions("main_assignments_assist", "assist", menu.buttonChangeFleetUnitAssignment, groups, false, true, currentgroup)
			end
		end
		if commandershiptype == "resupplier" then
			menu.insertAssignSubActions("main_assignments_trade", "trade", menu.buttonChangeFleetUnitAssignment, groups, false, true, currentgroup)
		end

		if menu.selectedfleetunit then
			-- reassign
			local fleetlead = C.GetFleetLead(0, menu.fleetunit)
			local selectedfleetlead = C.GetFleetLead(0, menu.selectedfleetunit)

			if fleetlead == selectedfleetlead then
				local unitinfo = C.GetFleetUnitInfo(menu.selectedfleetunit)
				local shiptype, primarypurpose = GetMacroData(ffi.string(unitinfo.macro), "shiptype", "primarypurpose")

				local groups = menu.getSubordinatesInFleetUnitGroups(menu.fleetunit, false)
				-- defence
				menu.insertAssignSubActions("selected_assignments_defence", "defence", menu.buttonAssignFleetUnitCommander, groups, false, false)
				-- supplyfleet
				if shiptype == "resupplier" then
					menu.insertAssignSubActions("selected_assignments_supplyfleet", "supplyfleet", menu.buttonAssignFleetUnitCommander, groups, false, true)
				end
				-- position defence
				local unitinfo = C.GetFleetUnitInfo(menu.fleetunit)
				local commandershiptype = GetMacroData(ffi.string(unitinfo.macro), "shiptype")
				menu.insertAssignSubActions("selected_assignments_attack", "attack", menu.buttonAssignFleetUnitCommander, groups, false)
				menu.insertAssignSubActions("selected_assignments_interception", "interception", menu.buttonAssignFleetUnitCommander, groups, false)
				menu.insertAssignSubActions("selected_assignments_bombardment", "bombardment", menu.buttonAssignFleetUnitCommander, groups, false)
				menu.insertAssignSubActions("selected_assignments_follow", "follow", menu.buttonAssignFleetUnitCommander, groups, false, true)
				if commandershiptype == "resupplier" then
					menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignFleetUnitCommander, groups, false, true)
				end
			end
		elseif menu.numassignableships > 0 then
			local groups = menu.getSubordinatesInFleetUnitGroups(menu.fleetunit, false)
			-- defence
			menu.insertAssignSubActions("selected_assignments_defence", "defence", menu.buttonAssignFleetUnitCommander, groups, false, false)
			-- supplyfleet
			if menu.numassignableresupplyships > 0 then
				menu.insertAssignSubActions("selected_assignments_supplyfleet", "supplyfleet", menu.buttonAssignCommander, groups, isstation, true)
			end
			-- position defence
			local unitinfo = C.GetFleetUnitInfo(menu.fleetunit)
			local commandershiptype = GetMacroData(ffi.string(unitinfo.macro), "shiptype")
			menu.insertAssignSubActions("selected_assignments_attack", "attack", menu.buttonAssignCommander, groups, isstation)
			menu.insertAssignSubActions("selected_assignments_interception", "interception", menu.buttonAssignCommander, groups, isstation)
			menu.insertAssignSubActions("selected_assignments_bombardment", "bombardment", menu.buttonAssignCommander, groups, isstation)
			menu.insertAssignSubActions("selected_assignments_follow", "follow", menu.buttonAssignCommander, groups, isstation, true)
			if commandershiptype == "resupplier" then
				menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignCommander, groups, isstation, true)
			end
		end
	elseif menu.selectedfleetunit then
		hasanydisplayed = true

		-- reassign
		local fleetlead = C.GetFleetLead(menu.componentSlot.component, 0)
		local selectedfleetlead = C.GetFleetLead(0, menu.selectedfleetunit)

		if fleetlead == selectedfleetlead then
			local unitinfo = C.GetFleetUnitInfo(menu.selectedfleetunit)
			local shiptype, primarypurpose = GetMacroData(ffi.string(unitinfo.macro), "shiptype", "primarypurpose")

			local subordinates = GetSubordinates(convertedComponent)

			local isstation = C.IsComponentClass(menu.componentSlot.component, "station")
			local isship = C.IsComponentClass(menu.componentSlot.component, "ship")
			local groups = menu.getSubordinatesInGroups(menu.componentSlot.component, isstation)
			if isstation and C.CanClaimOwnership(menu.componentSlot.component) then
				menu.insertAssignSubActions("selected_assignments_positiondefence", "positiondefence", menu.buttonAssignFleetUnitCommander, groups, isstation, isstation)
			end
			-- defence
			menu.insertAssignSubActions("selected_assignments_defence", "defence", menu.buttonAssignFleetUnitCommander, groups, isstation, isstation)
			-- supplyfleet
			if shiptype == "resupplier" then
				menu.insertAssignSubActions("selected_assignments_supplyfleet", "supplyfleet", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
			end
			if isstation then
				local isminingfleetunit = primarypurpose == "mine"
				-- trading
				menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignFleetUnitCommander, groups, isstation, true, nil, isminingfleetunit and (ColorText["text_warning"] .. ReadText(1026, 8609)) or "")
				-- mining
				if isminingfleetunit then
					menu.insertAssignSubActions("selected_assignments_mining", "mining", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				end
				-- trading for buildstorage
				if not isminingfleetunit then
					menu.insertAssignSubActions("selected_assignments_tradeforbuildstorage", "tradeforbuildstorage", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				end
				if shiptype == "tug" then
					menu.insertAssignSubActions("selected_assignments_salvage", "salvage", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				end
			elseif isship then
				-- position defence
				local commandershiptype = GetComponentData(convertedComponent, "shiptype")
				local parentcommander = ConvertIDTo64Bit(GetCommander(convertedComponent))
				local isfleetcommander = (not parentcommander) and (#subordinates > 0)
				if (commandershiptype == "carrier") and isfleetcommander then
					menu.insertAssignSubActions("selected_assignments_positiondefence", "positiondefence", menu.buttonAssignFleetUnitCommander, groups, isstation)
				end
				menu.insertAssignSubActions("selected_assignments_attack", "attack", menu.buttonAssignFleetUnitCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_interception", "interception", menu.buttonAssignFleetUnitCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_bombardment", "bombardment", menu.buttonAssignFleetUnitCommander, groups, isstation)
				menu.insertAssignSubActions("selected_assignments_follow", "follow", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				local buf = ffi.new("Order")
				if C.GetDefaultOrder(buf, menu.componentSlot.component) then
					menu.insertAssignSubActions("selected_assignments_assist", "assist", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				end
				if commandershiptype == "resupplier" then
					menu.insertAssignSubActions("selected_assignments_trade", "trade", menu.buttonAssignFleetUnitCommander, groups, isstation, true)
				end
			end
		end
	end
	if menu.mode == "shipconsole" then
		hasanydisplayed = true
		-- ship console at dockingbay (not action based at all)
		local shipconsoleparent = menu.isdockedship and C.GetContextByClass(menu.componentSlot.component, "dockingbay", false) or menu.componentSlot.component
		local hasdockingbayref = C.IsComponentClass(shipconsoleparent, "dockingbay")
		local iscontainer = C.IsComponentClass(shipconsoleparent, "container")
		local container = iscontainer and shipconsoleparent or C.GetContextByClass(shipconsoleparent, "container", false)
		local dockedships = {}
		Helper.ffiVLA(dockedships, "UniverseID", C.GetNumDockedShips, C.GetDockedShips, container, "player")
		local hasinternalstorage = false
		for _, dockedship in ipairs(dockedships) do
			if not C.IsShipAtExternalDock(dockedship) then
				if hasdockingbayref then
					hasinternalstorage = C.CanDockAtDockingBay(dockedship, shipconsoleparent)
				else
					hasinternalstorage = C.TakeShipFromInternalStorage(dockedship, false, true)
				end
				if hasinternalstorage then
					break
				end
			end
		end
		menu.insertInteractionContent("shipconsole", { text = ReadText(1001, 7879), script = menu.buttonRequestShip, active = hasinternalstorage and (not iscontainer), mouseOverText = (not hasinternalstorage) and ReadText(1026, 7831) or (iscontainer and ReadText(1026, 7832) or "") })
	end
	return hasanydisplayed
end

function menu.prepareTexts()
	menu.texts = {}
	menu.colors = {}

	if menu.componentSlot.component ~= 0 then
		local convertedComponent = ConvertStringTo64Bit(tostring(menu.componentSlot.component))
		menu.buildstorage = ConvertIDTo64Bit(GetComponentData(convertedComponent, "buildstorage"))
		local playerObject = C.GetPlayerObjectID()

		local idcode = ""
		if C.IsComponentClass(menu.componentSlot.component, "object") then
			idcode = " (" .. ffi.string(C.GetObjectIDCode(menu.componentSlot.component)) .. ")"
		end
		local sectorprefix = ""
		if C.IsComponentClass(menu.componentSlot.component, "sector") then
			sectorprefix = ReadText(20001, 201) .. ReadText(1001, 120) .. " "
		end
		local gatedestination = ""
		if C.IsComponentClass(menu.componentSlot.component, "gate") then
			local gatedestinationid = GetComponentData(convertedComponent, "destination")
			if gatedestinationid then
				gatedestinationid = ConvertStringTo64Bit(tostring(GetComponentData(gatedestinationid, "sectorid")))
				gatedestination = ReadText(1001, 120) .. " " .. Helper.unlockInfo(GetComponentData(convertedComponent, "isactive") and C.IsInfoUnlockedForPlayer(gatedestinationid, "name"), ffi.string(C.GetComponentName(gatedestinationid)))
			end
			idcode = ""
		end
		local iswreck = C.IsComponentWrecked(menu.componentSlot.component)
		local name_unlocked = IsInfoUnlockedForPlayer(convertedComponent, "name")
		menu.texts.targetShortName = iswreck and ReadText(1001, 27) or Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.componentSlot.component)))
		menu.texts.targetName = sectorprefix .. Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.componentSlot.component)) .. gatedestination .. idcode)
		local isplayerowned, isenemy, ishostile = GetComponentData(convertedComponent, "isplayerowned", "isenemy", "ishostile")
		menu.colors.target = Color["text_normal"]
		if iswreck then
			menu.colors.target = Color["text_inactive"]
		elseif isplayerowned then
			menu.colors.target = (menu.componentSlot.component == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
		elseif ishostile then
			menu.colors.target = menu.holomapcolor.hostilecolor
		elseif isenemy then
			menu.colors.target = menu.holomapcolor.enemycolor
		end
		menu.texts.targetName = Helper.convertColorToText(menu.colors.target) .. menu.texts.targetName
		if C.IsComponentClass(menu.componentSlot.component, "ship") then
			menu.texts.targetBaseName = Helper.unlockInfo(name_unlocked, GetComponentData(convertedComponent, "basename"))
		end

		if menu.construction then
			if menu.construction.component ~= 0 then
				menu.texts.constructionName = ffi.string(C.GetComponentName(menu.construction.component))
			elseif menu.construction.macro ~= "" then
				menu.texts.constructionName = GetMacroData(menu.construction.macro, "name")
			end
		end

		if C.IsComponentClass(menu.componentSlot.component, "controllable") then
			local commander = C.GetCommander(convertedComponent, 0)
			if (commander.controllableid ~= 0) or (commander.fleetunitid ~= 0) then
				if commander.controllableid ~= 0 then
					local commander64 = ConvertIDTo64Bit(GetCommander(convertedComponent))
					menu.texts.commanderShortName = Helper.unlockInfo(IsInfoUnlockedForPlayer(commander64, "name"), ffi.string(C.GetComponentName(commander.controllableid)))
					local idcode = ""
					if C.IsComponentClass(commander.controllableid, "object") then
						idcode = " (" .. ffi.string(C.GetObjectIDCode(commander.controllableid)) .. ")"
					end
					menu.texts.commanderName = sectorprefix .. Helper.unlockInfo(IsInfoUnlockedForPlayer(commander64, "name"), ffi.string(C.GetComponentName(commander.controllableid)) .. idcode)
					menu.colors.commander = GetComponentData(commander64, "isplayerowned") and ((commander64 == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor) or Color["text_normal"]
				else
					local info = C.GetFleetUnitInfo(commander.fleetunitid)
					menu.texts.commanderShortName = ffi.string(info.name)
					menu.texts.commanderName = sectorprefix .. menu.texts.commanderShortName .. " (" .. ffi.string(info.idcode) .. ")"
					menu.colors.commander = Color["text_player_inactive"]
				end
				menu.texts.commanderShortName = Helper.convertColorToText(menu.colors.commander) .. menu.texts.commanderShortName
				menu.texts.commanderName = Helper.convertColorToText(menu.colors.commander) .. menu.texts.commanderName
			end
		end

		menu.texts.selectedFullNames = ""
		if #menu.selectedplayerships > 0 then
			menu.texts.selectedName = GetComponentData(menu.selectedplayerships[1], "name")
			if #menu.selectedplayerships > 1 then
				menu.texts.selectedName = string.format(ReadText(1001, 7801), #menu.selectedplayerships)
			end
			menu.colors.selected = (menu.selectedplayerships[1] == playerObject) and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
			local first = true
			for _, selectedcomponent in ipairs(menu.selectedplayerships) do
				local isCurrentPlayerObject = (selectedcomponent == playerObject)
				local color = isCurrentPlayerObject and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
				menu.texts.selectedFullNames = menu.texts.selectedFullNames .. (first and "" or "\n") .. Helper.convertColorToText(color) .. GetComponentData(selectedcomponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")" .. (isCurrentPlayerObject and (" (" .. ReadText(1001, 7836) .. ")") or "")
				first = false
			end
		elseif menu.selectedfleetunit then
			local info = C.GetFleetUnitInfo(menu.selectedfleetunit)
			menu.texts.selectedName = ffi.string(info.name)
			menu.colors.selected = Color["text_player_inactive"]
			menu.texts.selectedFullNames = menu.texts.selectedName .. " (" .. ffi.string(info.idcode) .. ")"
		end
		-- count the interacted object here too
		if isplayerowned and C.IsRealComponentClass(menu.componentSlot.component, "ship") then
			menu.texts.selectedNameAll = string.format(ReadText(1001, 7801), #menu.selectedplayerships + 1)
			local isCurrentPlayerObject = (convertedComponent == playerObject)
			local color = isCurrentPlayerObject and menu.holomapcolor.currentplayershipcolor or menu.holomapcolor.playercolor
			menu.texts.selectedFullNamesAll = menu.texts.selectedFullNames .. "\n" .. Helper.convertColorToText(color) .. GetComponentData(convertedComponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(convertedComponent)) .. ")" .. ((isCurrentPlayerObject) and (" (" .. ReadText(1001, 7836) .. ")") or "")
		end

		if #menu.selectedotherobjects > 0 then
			menu.texts.otherName = GetComponentData(menu.selectedotherobjects[1], "name")
			if #menu.selectedotherobjects > 1 then
				menu.texts.otherName = string.format(ReadText(1001, 11105), #menu.selectedotherobjects)
			end
			menu.texts.otherFullNames = ""
			local first = true
			for _, selectedcomponent in ipairs(menu.selectedotherobjects) do
				local color = Color["text_normal"]
				menu.texts.otherFullNames = menu.texts.otherFullNames .. (first and "" or "\n") .. Helper.convertColorToText(color) .. GetComponentData(selectedcomponent, "name") .. " (" .. ffi.string(C.GetObjectIDCode(selectedcomponent)) .. ")"
				first = false
			end
		end

		if menu.buildstorage then
			local name_unlocked = IsInfoUnlockedForPlayer(menu.buildstorage, "name")
			menu.texts.buildstorageName = Helper.unlockInfo(name_unlocked, ffi.string(C.GetComponentName(menu.buildstorage)))
			menu.texts.buildstorageFullName = Helper.convertColorToText(menu.colors.target) .. menu.texts.buildstorageName .. " (" .. ffi.string(C.GetObjectIDCode(menu.buildstorage)) .. ")"
		end

		menu.texts.ventureName = ""
		menu.colors.venture = Color["text_player"]
		if #menu.ventureships > 0 then
			menu.texts.ventureName = GetComponentData(menu.ventureships[1], "name")
			if #menu.ventureships > 1 then
				menu.texts.ventureName = string.format(ReadText(1001, 7801), #menu.ventureships)
			end
		end
	elseif menu.syncpoint then
		menu.texts.targetShortName = ReadText(1001, 3237) .. ReadText(1001, 120) .. " " .. Helper.getSyncPointName(menu.syncpoint)
	elseif menu.fleetunit then
		local info = C.GetFleetUnitInfo(menu.fleetunit)
		menu.fleetunitinfo = {
			name = ffi.string(info.name),
			idcode = ffi.string(info.idcode),
			macro = ffi.string(info.macro),
			buildtaskid = info.buildtaskid,
			replacementid = inforeplacementid,
		}

		menu.texts.targetShortName = menu.fleetunitinfo.name
		menu.texts.targetName = menu.fleetunitinfo.name .. " (" .. ffi.string(info.idcode) .. ")"
		menu.colors.target = Color["text_inactive"]
		if (menu.fleetunitinfo.replacementid ~= 0) or (menu.fleetunitinfo.buildtaskid ~= 0) then
			menu.colors.target = Color["text_player_inactive"]
		end

		if menu.selectedfleetunit then
			local info = C.GetFleetUnitInfo(menu.selectedfleetunit)
			menu.texts.selectedName = ffi.string(info.name)
			menu.colors.selected = Color["text_player_inactive"]
			menu.texts.selectedFullNames = menu.texts.selectedName .. " (" .. ffi.string(info.idcode) .. ")"
		end
	elseif menu.mission then
		local missiondetails = C.GetMissionIDDetails(menu.mission)
		menu.texts.targetShortName = ffi.string(missiondetails.missionName)
	elseif menu.missionoffer then
		menu.texts.targetShortName = GetMissionOfferDetails(ConvertStringToLuaID(menu.missionoffer))
	end
end

function menu.areTurretsArmed(defensible)
	local turrets = {}
	local numslots = tonumber(C.GetNumUpgradeSlots(defensible, "", "turret"))
	for j = 1, numslots do
		local groupinfo = C.GetUpgradeSlotGroup(defensible, "", "turret", j)
		if (ffi.string(groupinfo.path) == "..") and (ffi.string(groupinfo.group) == "") then
			local current = C.GetUpgradeSlotCurrentComponent(defensible, "turret", j)
			if current ~= 0 then
				table.insert(turrets, current)
			end
		end
	end

	local turretgroups = {}
	local n = C.GetNumUpgradeGroups(defensible, "")
	local buf = ffi.new("UpgradeGroup2[?]", n)
	n = C.GetUpgradeGroups2(buf, n, defensible, "")
	for i = 0, n - 1 do
		if (ffi.string(buf[i].path) ~= "..") or (ffi.string(buf[i].group) ~= "") then
			local group = { context = buf[i].contextid, path = ffi.string(buf[i].path), group = ffi.string(buf[i].group) }
			local groupinfo = C.GetUpgradeGroupInfo2(defensible, "", group.context, group.path, group.group, "turret")
			if (groupinfo.count > 0) then
				group.operational = groupinfo.operational
				group.currentmacro = ffi.string(groupinfo.currentmacro)
				group.slotsize = ffi.string(groupinfo.slotsize)
				table.insert(turretgroups, group)
			end
		end
	end

	local alldisarmed = true
	for i, turret in ipairs(turrets) do
		if C.IsWeaponArmed(turret) then
			alldisarmed = false
			break
		end
	end
	for i, group in ipairs(turretgroups) do
		if group.operational > 0 then
			if C.IsTurretGroupArmed(defensible, group.context, group.path, group.group) then
				alldisarmed = false
				break
			end
		end
	end
	return not alldisarmed
end

function menu.orderIconText(orderid)
	if menu.orderdefs[orderid] and (menu.orderdefs[orderid].icon ~= "") then
		return "\27[" .. menu.orderdefs[orderid].icon .. "] "
	end
	return ""
end

-- update
menu.updateInterval = 0.1

function menu.onUpdate()
	local curTime = getElapsedTime()
	if menu.mode ~= "shipconsole" then
		if (GetControllerInfo() ~= "gamepad") or C.IsMouseEmulationActive() then
			local curpos = table.pack(GetLocalMousePosition())
			if curpos[1] and ((curpos[1] < menu.mouseOutBox.x1) or (curpos[1] > menu.mouseOutBox.x2)) then
				menu.onCloseElement("close")
				return
			elseif curpos[2] and ((curpos[2] > menu.mouseOutBox.y1) or (curpos[2] < menu.mouseOutBox.y2)) then
				menu.onCloseElement("close")
				return
			end
		end
	elseif C.IsComponentClass(menu.componentSlot.component, "dockingbay") then
		if (not menu.dockingbayReserveTime) or (menu.dockingbayReserveTime < curTime) then
			C.SetDockingBayReservation(menu.componentSlot.component, 5.0)
			menu.dockingbayReserveTime = curTime + 4.0
		end
	end

	if menu.checkPlayerActivity then
		local playerActivity = GetPlayerActivity()
		if playerActivity ~= menu.currentActivity then
			if (playerActivity == "scan") or (menu.currentActivity == "scan") then
				if not menu.prepareActions() then
					-- no actions found
					menu.onCloseElement("close")
					return
				end
				menu.refresh = true
			end
			menu.currentActivity = playerActivity
		end
	end

	if menu.pendingSubSection and (menu.lastSubSectionTime + config.subsectionDelay < curTime) then
		if menu.pendingSubSection == -1 then
			menu.subsection = nil
		else
			menu.subsection = menu.pendingSubSection
		end
		menu.pendingSubSection = nil
		menu.refresh = true
	end

	if menu.refresh then
		menu.refresh = nil
		menu.lock = curTime
		menu.selectedRows.contentTable = Helper.currentTableRow[menu.contentTable]
		menu.topRows.contentTable = GetTopRow(menu.contentTable)
		menu.draw()
		return
	end
	if menu.lock and (menu.lock + 0.1 < curTime) then
		menu.lock = nil
	end

	menu.frame:update()
end


-- helper hooks

function menu.onButtonOver(uitable, row, col, button)
	if uitable == menu.contentTable then
		local data = menu.rowDataMap[uitable][row]
		if (not menu.lock) or (menu.subsection and (type(data) == "table") and (menu.subsection.id ~= data.id)) then
			menu.handleSubSectionOption(data, false)
		else
			menu.lock = nil
		end
	end
end

function menu.onCloseElement(dueToClose, layer, allowAutoMenu)
	if dueToClose == "back" then
		if menu.subsection then
			menu.subsection = nil
			menu.refresh = true
			return
		end
	end

	if menu.interactMenuID then
		C.NotifyInteractMenuHidden(menu.interactMenuID, true)
	end
	if menu.shown then
		Helper.closeMenu(menu, dueToClose, allowAutoMenu, false)
	else
		Helper.resetUpdateHandler()
		Helper.clearFrame(menu, config.layer)
		if Helper.interactMenuCallbacks.onTableMouseOut then
			Helper.interactMenuCallbacks.onTableMouseOut(menu.currentOverTable)
		end
		Helper.resetInteractMenuCallbacks()
	end
	menu.cleanup()
end

function menu.onRowChanged()
	menu.lock = getElapsedTime()
end

function menu.onTableMouseOut(uitable, row)
	menu.pendingSubSection = nil
	if not menu.shown then
		if Helper.interactMenuCallbacks.onTableMouseOut then
			Helper.interactMenuCallbacks.onTableMouseOut(uitable, row)
		end
	end
end

function menu.onTableMouseOver(uitable, row)
	if not menu.shown then
		menu.currentOverTable = uitable
		if Helper.interactMenuCallbacks.onTableMouseOver then
			Helper.interactMenuCallbacks.onTableMouseOver(uitable, row)
		end
	end
end

function menu.viewCreated(layer, ...)
	menu.contentTable = ...
end

-- kuetee start:
function menu.Existence_Query()
	AddUITriggeredEvent("UIX_Interact_Menu_Present", "")
end

local newCustomGroupId
local newCustomGroupText
function menu.Add_Custom_Actions_Group_Id(_, id)
	newCustomGroupId = id
	if newCustomGroupId and newCustomGroupText then
		menu.Add_Custom_Actions_Group(newCustomGroupId, newCustomGroupText)
		newCustomGroupId = nil
		newCustomGroupText = nil
	end
end

function menu.Add_Custom_Actions_Group_Text(_, text)
	newCustomGroupText = text
	if newCustomGroupId and newCustomGroupText then
		menu.Add_Custom_Actions_Group(newCustomGroupId, newCustomGroupText)
		newCustomGroupId = nil
		newCustomGroupText = nil
	end
end

function menu.Add_Custom_Actions_Group(id, text)
	local customActionsSection
	local customActionsSection_isFound = false
	local customActionsSection_isAddTo = string.find(id, "actions_")
	local customOrdersSection
	local customOrdersSection_isFound = false
	local customOrdersSection_isAddTo = string.find(id, "orders_")
	if (not customActionsSection_isAddTo) and (not customOrdersSection_isAddTo) then
		customActionsSection_isAddTo = true
		customOrdersSection_isAddTo = true
	end
	Helper.debugText("Add_Custom_Actions_Group id: " .. tostring(id) .. " text: " .. tostring(text))
	for _, section in ipairs(config.sections) do
		if section.id == "custom_actions" or section.id == "custom_orders" then
			Helper.debugText("Add_Custom_Actions_Group    section.id: ", section.id)
			if section.id == "custom_actions" then
				customActionsSection = section
			else
				customOrdersSection = section
			end
			for _, subsection in ipairs(section.subsections) do
				Helper.debugText("Add_Custom_Actions_Group        subsection.id: ", subsection.id)
				if subsection.id == id then
					if section.id == "custom_actions" then
						customActionsSection_isFound = true
					else
						customOrdersSection_isFound = true
					end
					Helper.debugText("Add_Custom_Actions_Group customActionsSection.subsections", customActionsSection.subsections)
				end
			end
		end
	end
	Helper.debugText("Add_Custom_Actions_GroupcustomActionsSection_isFound: ", customActionsSection_isFound)
	Helper.debugText("Add_Custom_Actions_GroupcustomOrdersSection_isFound: ", customOrdersSection_isFound)
	if customActionsSection and customActionsSection_isAddTo and (not customActionsSection_isFound) then
		table.insert (customActionsSection.subsections, {id = id, text = text})
		Helper.debugText("Add_Custom_Actions_Group customActionsSection.subsections", customActionsSection.subsections)
	end
	if customOrdersSection and customOrdersSection_isAddTo and (not customOrdersSection_isFound) then
		table.insert (customOrdersSection.subsections, {id = id, text = text})
		Helper.debugText("Add_Custom_Actions_Group customOrdersSection.subsections", customOrdersSection.subsections)
	end
end

menu.uix_callbackCount = 0
function menu.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if menu.uix_callbacks [callbackName] == nil then
        menu.uix_callbacks [callbackName] = {}
    end
    if not menu.uix_callbacks[callbackName][id] then
        if not id then
            menu.uix_callbackCount = menu.uix_callbackCount + 1
            id = "_" .. tostring(menu.uix_callbackCount)
        end
        menu.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function menu.deregisterCallback(callbackName, callbackFunction, id)
	if not menu.uix_callbacks_toDeregister[callbackName] then
		menu.uix_callbacks_toDeregister[callbackName] = {}
	end
	if id then
		table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
	else
		if menu.uix_callbacks[callbackName] then
			for id, func in pairs(menu.uix_callbacks[callbackName]) do
				if func == callbackFunction then
					table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
				end
			end
		end
	end
	if not menu.uix_isDeregisterQueued then
		menu.uix_isDeregisterQueued = true
		Helper.addDelayedOneTimeCallbackOnUpdate(menu.deregisterCallbacksNow, true, getElapsedTime() + 1)
	end
end

function menu.deregisterCallbacksNow()
	menu.uix_isDeregisterQueued = nil
	for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
		if menu.uix_callbacks[callbackName] then
			for _, id in ipairs(ids) do
				if menu.uix_callbacks[callbackName][id] then
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix registerCallback (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
					end
					menu.uix_callbacks[callbackName][id] = nil
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix registerCallback (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
					end
				else
					Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
				end
			end
		end
	end
	menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function menu.updateCallback(callbackName, id, callbackFunction)
	if not menu.uix_callbacks_toUpdate[callbackName] then
		menu.uix_callbacks_toUpdate[callbackName] = {}
	end
	if id then
		table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
	end
	if not menu.uix_isUpdateQueued then
		menu.uix_isUpdateQueued = true
		Helper.addDelayedOneTimeCallbackOnUpdate(menu.updateCallbacksNow, true, getElapsedTime() + 1)
	end
end

function menu.updateCallbacksNow()
	menu.uix_isUpdateQueued = nil
	for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
		if menu.uix_callbacks[callbackName] then
			for _, updateData in ipairs(updateDatas) do
				if menu.uix_callbacks[callbackName][updateData.id] then
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
					end
					menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
					end
				else
					Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
				end
			end
		end
	end
end
-- kuertee end

init()
local menu = Helper.getMenu("OptionsMenu")
if menu.uix_callbacks then
	-- OptionsMenu already UIX initialised by stand-alone UIX mod, do not continue with this file.
	Helper.debugText_forced("gameoptions_uix.lua already loaded by stand-alone UIX mod.")
	return
end

local ModLua = {}

local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[]]

--- config ---

local config = {
	contextLayer = 2,
	optionsLayer = 4,
	topLevelLayer = 5,

	backarrow = "table_arrow_inv_left",
	backarrowOffsetX = 3,

	font = "Zekton outlined",
	fontBold = "Zekton bold outlined",

	headerFontSize = 13,
	infoFontSize = 9,
	standardFontSize = 10,

	headerTextHeight = 34,
	subHeaderTextHeight = 22,
	standardTextHeight = 19,
	infoTextHeight = 16,

	headerTextOffsetX = 5,
	standardTextOffsetX = 5,
	infoTextOffsetX = 5,

	idleTime = 10,

	saveReloadInterval = 60,

	hubFadeOutTime = 2,
	hubFadeOutHoldDuration = 0.1,

	numRecommendedGamestarts = 2,

	minGamestartInfoRows = 8,
}

config.frame = {
	x = C.IsVRMode() and 100 or 0,
	y = 0,
	width = 800,
	widthExtraWide = 1220,
	height = 1080,
	bgTexture = "optionsmenu_bg",
	fgTexture = "", --C.IsVRMode() and "" or "optionsMenu_fg",
}

config.table = {
	x = 45,
	y = 45,
	width = 710,
	widthExtraWide = 1130,
	widthWithExtraInfo = 370,
	height = 980,
	arrowColumnWidth = 20,
	infoColumnWidth = 330,
}

config.headerTextProperties = {
	font = config.fontBold,
	fontsize = config.headerFontSize,
	x = config.headerTextOffsetX,
	y = 6,
	minRowHeight = config.headerTextHeight,
	titleColor = Color["row_title"],
}

config.subHeaderTextProperties = {
	font = config.fontBold,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = 2,
	minRowHeight = config.subHeaderTextHeight,
	halign = "center",
	titleColor = Color["row_title"],
}

config.subHeaderLeftTextProperties = {
	font = config.fontBold,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = 2,
	minRowHeight = config.subHeaderTextHeight,
	titleColor = Color["row_title"],
}

config.infoTextProperties = {
	font = config.font,
	fontsize = config.infoFontSize,
	x = config.infoTextOffsetX,
	y = 2,
	wordwrap = true,
	minRowHeight = config.infoTextHeight,
	titleColor = Color["row_title"],
}

config.warningTextProperties = {
	font = config.font,
	fontsize = config.infoFontSize,
	x = config.infoTextOffsetX,
	y = 2,
	wordwrap = true,
	minRowHeight = config.infoTextHeight,
}

config.standardTextProperties = {
	font = config.font,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = 2,
}

config.standardRightTextProperties = {
	font = config.font,
	fontsize = config.standardFontSize,
	halign = "right",
	x = config.standardTextOffsetX,
	y = 2,
}

config.disabledTextProperties = {
	font = config.font,
	fontsize = config.standardFontSize,
	x = config.standardTextOffsetX,
	y = 2,
	color = Color["text_inactive"],
}

config.input = {
	controltextpage = {
		["actions"] = 1005,
		["states"]  = 1006,
		["ranges"]  = 1007,
	},
	modifiers = {
		[1] = { id = "shift",		   name = ReadText(1001, 12644),   offset = 256 },
		[2] = { id = "ctrl",			name = ReadText(1001, 12645),   offset = 512 },
		[3] = { id = "joystickmod1",	name = ReadText(1001, 12745),   offset = 1024,  controller = true },
		[4] = { id = "joystickmod2",	name = ReadText(1001, 12746),   offset = 2048,  controller = true },
	},
	iscontrollermodifier = {
		["joystickmod1"] = true,
		["joystickmod2"] = true,
	},
	modifierFilter = 256,
	forbiddenKeys = {
		[1]   = true, -- Escape
		[211] = true, -- Delete
		[466] = true, -- Shift+Insert
		[467] = true, -- Shift+Delete
		[557] = true, -- Ctrl+X
		[558] = true, -- Ctrl+C
		[559] = true, -- Ctrl+V
		[722] = true, -- Ctrl+Insert
	},
	forbiddenMouseButtons = {
		[2]  = true, -- LMB doubleclick
		[4]  = true, -- RMB doubleclick
		[6]  = true, -- MMB doubleclick
		[8]  = true, -- Side1 MB doubleclick
		[10] = true, -- Side2 MB doubleclick
	},
	cheatControls = {
		["actions"]   = { [120] = true, [121] = true },
		["states"]	= {},
		["ranges"]	= {},
		["functions"] = {},
	},
}
	-- Define input functions here (serveral actions, states or ranges which can only be changed at the same time)
	-- entry: [keycode] = { ["actions"] = { action1, action2, ... }, ["states"] = {}, ["name"] = name for display }
	config.input.controlFunctions = {
		[1] = {
		["name"] = ReadText(1005, 16),  -- "Menu back"
		--["name"] = ReadText(1001, 2669),  -- "Back"
		["definingcontrol"] = {"actions", 16},
		["actions"] = { 16, 103, 375 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 3, 4, 5 },
	},
	[2] = {
		["name"] = ReadText(1001, 2670),	-- "Close"
		["definingcontrol"] = {"actions", 19},
		["actions"] = { 19, 104, 326 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 3, 4, 5 },
	},
	[3] = {
		["name"] = ReadText(1001, 5102),
		["definingcontrol"] = {"states", 22},
		["actions"] = { 124 },
		["states"] = { 1, 22, 23 },
		["ranges"] = {},
		["contexts"]= { 1, 2 },
	},
	[4] = {
		["name"] = ReadText(1006, 12),
		["definingcontrol"] = {"states", 12},
		["actions"] = {},
		["states"] = { 12 },
		["ranges"] = {},
		["contexts"]= { 2 },
	},
	[5] = {
		["name"] = ReadText(1005, 128),
		["definingcontrol"] = {"actions", 128},
		["actions"] = { 128, 163 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[6] = {
		["name"] = ReadText(1005, 129),
		["definingcontrol"] = {"actions", 129},
		["actions"] = { 129, 164 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[7] = {
		["name"] = ReadText(1006, 10),
		["definingcontrol"] = {"states", 10},
		["actions"] = { 218 },
		["states"] = { 10 },
		["ranges"] = {},
		["contexts"]= { 2 },
	},
	[8] = {
		["name"] = ReadText(1006, 11),
		["definingcontrol"] = {"states", 11},
		["actions"] = { 217 },
		["states"] = { 11 },
		["ranges"] = {},
		["contexts"]= { 2 },
	},
	[9] = {
		["name"] = ReadText(1005, 179),
		["definingcontrol"] = {"actions", 179},
		["actions"] = { 179, 208 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[10] = {
		["name"] = ReadText(1005, 175),
		["definingcontrol"] = {"actions", 175},
		["actions"] = { 175, 211 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2 },
	},
	[11] = {
		["name"] = ReadText(1005, 180),
		["definingcontrol"] = {"actions", 180},
		["actions"] = { 180, 231 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2 },
	},
	[12] = {
		["name"] = ReadText(1005, 182),
		["definingcontrol"] = {"actions", 182},
		["actions"] = { 182, 232 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2 },
	},
	[13] = {
		["name"] = ReadText(1005, 113),
		["definingcontrol"] = {"actions", 113},
		["actions"] = { 113, 312 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[14] = {
		["name"] = ReadText(1005, 314),
		["definingcontrol"] = {"actions", 314},
		["actions"] = { 314, 315 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[15] = {
		["name"] = ReadText(1005, 319),
		["definingcontrol"] = {"actions", 319},
		["actions"] = { 319, 222 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[16] = {
		["name"] = ReadText(1005, 303),
		["definingcontrol"] = {"actions", 303},
		["actions"] = { 303, 322 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[17] = {
		["name"] = ReadText(1005, 225),
		["definingcontrol"] = {"actions", 225},
		["actions"] = { 225, 323 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[18] = {
		["name"] = ReadText(1005, 363),
		["definingcontrol"] = {"actions", 363},
		["actions"] = { 332, 363 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[19] = {
		["name"] = ReadText(1005, 364),
		["definingcontrol"] = {"actions", 364},
		["actions"] = { 364, 365 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[20] = {
		["name"] = ReadText(1005, 209),
		["definingcontrol"] = {"actions", 209},
		["actions"] = { 209, 369 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[21] = {
		["name"] = ReadText(1005, 316),
		["definingcontrol"] = {"actions", 316},
		["actions"] = { 316, 370 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[22] = {
		["name"] = ReadText(1005, 320),
		["definingcontrol"] = {"actions", 320},
		["actions"] = { 320, 373 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[23] = {
		["name"] = ReadText(1005, 210),
		["definingcontrol"] = {"actions", 210},
		["actions"] = { 210, 372 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 1, 2, 10 },
	},
	[24] = {
		["name"] = ReadText(1005, 368),
		["definingcontrol"] = {"actions", 368},
		["actions"] = { 368, 378 },
		["states"] = {},
		["ranges"] = {},
		["contexts"]= { 9 },
	},
}

config.input.controlsorder = {
	["space"] = {
		[1] = {
			["title"] = ReadText(1001, 4865),   -- "Steering: Analog"
			["mappable"] = true,
			{ "ranges", 21, nil, ReadText(1026, 2629) },
			{ "ranges", 22, nil, ReadText(1026, 2630) },
			{ "ranges", 2 },
			{ "ranges", 5 },
			{ "ranges", 6 },
			{ "ranges", 4, { 1, 2 } },
			{ "ranges", 10, { 1, 2 }, nil, true, mousewheelonly = true },
			{ "states", 90, { 1, 2 } },
			{ "ranges", 32, 2, ReadText(1026, 2629), true },
			{ "ranges", 33, 2, ReadText(1026, 2630), true },
			{ "ranges", 30, 2, nil, true },
		},
		[2] = {
			["title"] = ReadText(1001, 4866),   -- "Steering: Digital"
			["mappable"] = true,
			{ "states", 4, { 1, 2 } },
			{ "states", 5, { 1, 2 } },
			{ "states", 2, { 1, 2 } },
			{ "states", 3, { 1, 2 } },
			{ "states", 112, { 1, 2 } },
			{ "states", 113, { 1, 2 } },
			{ "states", 114, { 1, 2 } },
			{ "states", 115, { 1, 2 } },
			{ "states", 8, { 1, 2 } },
			{ "states", 9, { 1, 2 } },
			{ "states", 6, { 1, 2 } },
			{ "states", 7, { 1, 2 } },
			{ "states", 116, { 1, 2 } },
			{ "states", 117, { 1, 2 } },
			{ "states", 118, { 1, 2 } },
			{ "states", 119, { 1, 2 } },
			{ "states", 13, { 1, 2 } },
			{ "states", 14, { 1, 2 } },
			{ "states", 15, { 1, 2 } },
			{ "states", 16, { 1, 2 } },
			{ "states", 91, { 1, 2 } },
			{ "actions", 123, { 1, 2 } },
			{ "states", 17, { 1, 2 } },
			{ "states", 18, { 1, 2 } },
			{ "states", 19, { 1, 2 } },
			{ "states", 20, { 1, 2 } },
			{ "actions", 7, { 1, 2 }, ReadText(1026, 2600) },
			{ "actions", 324, { 1, 2 }, ReadText(1026, 2692) },
			{ "actions", 221, { 1, 2 }, ReadText(1026, 2601) },
			{ "states", 133, { 1, 2 } },
			{ "actions", 261, { 1, 2 } },
			{ "actions", 330, { 1, 2 } },
		},
		[3] = {
			["title"] = ReadText(1001, 2663),   -- "Weapons"
			["mappable"] = true,
			{ "states", 24, { 1, 2 } },
			{ "states", 48, { 1, 2 } },
			{ "states", 25, { 1, 2 } },
			{ "actions", 8, { 1, 2 } },
			{ "actions", 9, { 1, 2 } }, -- "Previous weapon"
			{ "actions", 10, { 1, 2 } },
			{ "actions", 11, { 1, 2 } },	-- "Previous missile"
			{ "actions", 331, { 1, 2 } },
			{ "actions", 321, { 1, 2 } },   -- "Next ammo"
			{ "actions", 307, { 1, 2 } },
			{ "actions", 139, { 1, 2 } },
			{ "actions", 140, { 1, 2 } },
			{ "actions", 141, { 1, 2 } },
			{ "actions", 142, { 1, 2 } },
			{ "actions", 149, { 1, 2 } },
			{ "actions", 150, { 1, 2 } },
			{ "actions", 151, { 1, 2 } },
			{ "actions", 152, { 1, 2 } },
		},
		[4] = {
			["title"] = ReadText(1002, 1001),   -- "Modes"
			["mappable"] = true,
			{ "states", 84, display = function () return C.IsVROculusTouchActive() or C.IsVRViveControllerActive() end },
			{ "functions", 16 },
			{ "actions", 304, { 1, 2 } },
			{ "actions", 305, { 1, 2 } },
			{ "functions", 17, nil, ReadText(1026, 2610) },
		},
		[5] = {
			["title"] = ReadText(1001, 7245),   -- "Menu Access"
			["mappable"] = true,
			{ "states", 126, { 1, 2 } },
			{ "states", 127, { 1, 2 } },
			{ "actions", 317, { 1, 2 } },
			{ "functions", 13 },
			{ "functions", 14 },
			{ "functions", 20 },
			{ "functions", 18 },
			{ "functions", 22 },
			{ "functions", 21 },
			{ "functions", 23 },
			{ "functions", 3 },
			{ "functions", 5, nil, ReadText(1026, 2602) },
			{ "functions", 6, nil, ReadText(1026, 2603) },
			{ "actions", 327, { 1, 2 }, ReadText(1026, 2651) },
			{ "functions", 19, nil, ReadText(1026, 2667) },
			{ "actions", 216, 10 },
			{ "actions", 371, 10 },
		},
		[6] = {
			["title"] = ReadText(1001, 2600),   -- "Options Menu"
			["mappable"] = true,
			{ "actions", 132, { 1, 2 } },
			{ "actions", 160, { 1, 2 } },
			{ "actions", 161, { 1, 2 } },
			{ "actions", 162, { 1, 2 } },
			{ "actions", 130, { 1, 2 } },
			{ "actions", 131, { 1, 2 } },
		},
		[7] = {
			["title"] = ReadText(1001, 4860),   -- "Camera"
			["mappable"] = true,
			{ "states", 81, { 1, 2, 9 } },
			{ "functions", 11, { 1, 2, 9 }, ReadText(1026, 2605) },
			{ "actions", 181, { 1, 2, 9 }, ReadText(1026, 2606) },
			{ "functions", 12, { 1, 2, 9 }, ReadText(1026, 2607) },
			{ "actions", 262, { 1, 2, 9 } },
			{ "actions", 353, { 1, 2, 9 } },
			{ "states", 70, 9 },
			{ "states", 71, 9 },
			{ "states", 72, { 1, 2, 9 } },
			{ "states", 73, { 1, 2, 9 } },
			{ "states", 74, { 1, 2, 9 } },
			{ "states", 75, { 1, 2, 9 } },
			{ "states", 76, { 1, 2, 9 } },
			{ "states", 77, { 1, 2, 9 } },
			{ "states", 78, { 1, 2, 9 } },
			{ "states", 79, { 1, 2, 9 } },
			{ "actions", 184, { 1, 2, 9 } },
			{ "actions", 318, { 1, 2, 9 } },
			{ "functions", 24, 9 },
			{ "actions", 366, { 1, 2 } },
			{ "actions", 367, { 1, 2 } },
		},
		[8] = {
			["title"] = ReadText(1001, 12696),  --"Target Management (Mouse)"
			["mappable"] = true,
			["mouseonly"] = true,
			["filter"] = { [""] = true, ["keyboard"] = true },
			["compassmenusupport"] = false,
			{ "states", 130, 7 },
			{ "states", 131, 8 },
		},
		[9] = {
			["title"] = ReadText(1001, 7282),   --"Target Management"
			["mappable"] = true,
			{ "actions", 167, { 1, 2 } },
			{ "actions", 168, { 1, 2 }, ReadText(1026, 2604) }, -- "Target Object" (near crosshair)
			{ "functions", 3 },
			{ "actions", 289, { 1, 2 } },
			{ "actions", 169, { 1, 2 } },
			{ "actions", 170, { 1, 2 } },
			{ "actions", 213, { 1, 2 } },
			{ "actions", 214, { 1, 2 } },
			{ "actions", 275, { 1, 2 } },
		},
		[10] = {
			["title"] = ReadText(1001, 12655),  --"Accessibility"
			["mappable"] = true,
			{ "actions", 374, { 1, 2 }, ReadText(1026, 2675) },
		},
		[11] = {
			["title"] = ReadText(1001, 2664),   --"Misc"
			["mappable"] = true,
			{ "functions", 10 },
			{ "actions", 277, { 1, 2 } },
			{ "actions", 178, { 1, 2 }, ReadText(1026, 2609) },
			{ "functions", 9 },
			{ "functions", 15 },
			{ "actions", 117, { 1, 2 } },
			{ "actions", 120, { 1, 2 } },
			{ "actions", 219, { 1, 2 } },
			{ "states", 80, { 1, 2 }, ReadText(1026, 2612) },
			{ "actions", 260, { 1, 2 } },
			{ "actions", 325, { 1, 2 } },
			{ "actions", 328, { 1, 2 } },
			{ "actions", 329, { 1, 2 } },
			{ "actions", 343, { 1, 2 } },
			{ "actions", 344, { 1, 2 } },
			{ "actions", 345, { 1, 2 } },
			{ "actions", 346, { 1, 2 } },
			{ "actions", 347, { 1, 2 } },
			{ "actions", 348, { 1, 2 } },
			{ "actions", 349, { 1, 2 } },
			{ "actions", 350, { 1, 2 } },
			{ "actions", 351, { 1, 2 } },
			{ "actions", 352, { 1, 2 } },
			{ "actions", 377, { 1, 2 }, ReadText(1026, 4809) },
		},
		[12] = {
			["title"] = ReadText(1001, 4815),   -- "Expert Settings - Use with Caution!"
			["mappable"] = true,
			{ "actions", 310, { 1, 2 } },
			{ "states", 96, { 1, 2 } },
			{ "actions", 137, { 1, 2 } },
			{ "actions", 121, { 1, 2 } },
			{ "actions", 166, { 1, 2 } },
			{ "actions", 224, { 1, 2 } },
			{ "actions", 306, { 1, 2 } },
			{ "actions", 223, { 1, 2 }, ReadText(1026, 2611) },
		},
	},
	["menus"] = {
		[1] = {
			["title"] = ReadText(1001, 7296),   -- "Menus - Analog"
			["mappable"] = true,
			{ "ranges", 23, { 2, 6 } },
			{ "ranges", 24, { 2, 6 } },
			{ "ranges", 25, 2 },
			{ "ranges", 26, 2 },
			{ "ranges", 27, 2 },
			{ "ranges", 28, 2 },
		},
		[2] = {
			["title"] = ReadText(1001, 2665),   -- "Menus - Digital"
			["mappable"] = false,
			{ "actions", 21, 2 },
			{ "actions", 20, 2 },
			{ "functions", 7 },
			{ "functions", 8 },
			{ "functions", 4, nil, nil, nil, true },
			{ "states", 97, 2 },
			{ "actions", 18, 2 },
			{ "actions", 17, 2 },
			{ "actions", 22, 2 },
			{ "actions", 308, 2 },
			{ "actions", 309, 2 },
			{ "functions", 1, nil, nil, nil, true },
			{ "functions", 2, nil, nil, nil, true },
			{ "states", 128, 2 },
			{ "states", 129, 2 },
			{ "states", 92, 6 },
			{ "states", 93, 6 },
			{ "states", 94, 6 },
			{ "states", 99, { 2, 6 } },
			{ "states", 100, { 2, 6 } },
			{ "states", 101, { 2, 6 } },
			{ "states", 102, { 2, 6 } },
			{ "states", 103, { 2, 6 } },
			{ "states", 104, { 2, 6 } },
			{ "states", 105, { 2, 6 } },
			{ "states", 106, { 2, 6 } },
			{ "states", 39, 6 },
			{ "states", 40, 6 },
			{ "states", 41, 6 },
			{ "states", 42, 6 },
			{ "states", 43, 6 },
			{ "states", 44, 6 },
			{ "states", 45, 6 },
			{ "states", 46, 6 },
			{ "states", 37, 6 },
			{ "states", 38, 6 },
		},
		[3] = {
			["title"] = ReadText(1001, 2666),
			["mappable"] = false,
			{ "states", 1, 3 },
			{ "actions", 294, 3 },
			{ "actions", 376, 9, nil, nil, nil, true },
			{ "actions", 97, 3 },
			{ "actions", 98, 3 },
			{ "actions", 99, 3 },
			{ "actions", 100, 3 },
			{ "actions", 101, 3 },
			{ "actions", 102, 3 },
			{ "actions", 198, 3 },
			{ "actions", 199, 3 },
			{ "actions", 200, 3 },
			{ "actions", 201, 3 },
			{ "actions", 202, 3 },
			{ "actions", 203, 3 },
			{ "actions", 299, 3 },
			{ "actions", 300, 3 },
			{ "actions", 301, 3 },
			{ "actions", 302, 3 },
			{ "ranges", 11, { 3 } },
			{ "ranges", 12, { 3 } },
		},
		[4] = {
			["title"] = ReadText(1001, 3245),   -- "Map"
			["mappable"] = true,
			{ "actions", 216, 2 },  -- "Target Object" (in map)
			{ "actions", 264, 2 },
			{ "actions", 265, 2 },
			{ "actions", 222, 2 },
			{ "actions", 263, 2 },
		},
		[5] = {
			["title"] = ReadText(1001, 12665),
			["mappable"] = false,
			{ "ranges", 36, 5 },
			{ "ranges", 37, 5 },
		},
		[6] = {
			["title"] = ReadText(1001, 2664),
			["mappable"] = false,
			{ "actions", 336, 7 },
			{ "actions", 337, 7 },
		},
		[7] = {
			["title"] = ReadText(1001, 11788),
			["mappable"] = true,
			{ "states", 98, 2 },
			{ "states", 121, 2 },
			{ "states", 122, 2 },
			{ "states", 123, 2 },
		},
	},
	["firstperson"] = {
		[1] = {
			["title"] = ReadText(1001, 12689),
			["mappable"] = true,
			{ "ranges", 15 },
			{ "ranges", 16 },
			{ "ranges", 13 },
			{ "ranges", 14 },
		},
		[2] = {
			["title"] = ReadText(1001, 12690),
			["mappable"] = true,
			{ "states", 26 },
			{ "states", 27 },
			{ "states", 32 },
			{ "states", 33 },
			{ "states", 87 },
			{ "states", 30 },
			{ "states", 31 },
			{ "states", 28 },
			{ "states", 29 },
			{ "states", 34 },
			{ "states", 35 },
			{ "states", 36 },
			{ "actions", 220 },
			{ "functions", 3 },
		},
	},
}

config.input.directInputHookDefinitions = {
	{"keyboardInput", 1, 0},
	{"mouseaxesInputPosSgn", 18, 1},
	{"mouseaxesInputNegSgn", 18, -1},
	{"mousebuttonsInput", 19, 0},
	{"oculustouchaxesInputPosSgn", 20, 1},
	{"oculustouchaxesInputNegSgn", 20, -1},
	{"oculusremoteaxesInputPosSgn", 21, 1},
	{"oculusremoteaxesInputNegSgn", 21, -1},
	{"viverightaxesInputPosSgn", 22, 1},
	{"viverightaxesInputNegSgn", 22, -1},
	{"viveleftaxesInputPosSgn", 23, 1},
	{"viveleftaxesInputNegSgn", 23, -1},
	{"oculustouchbuttonsInput", 24, 0},
	{"oculusremotebuttonsInput", 25, 0},
	{"viverightbuttonsInput", 26, 0},
	{"viveleftbuttonsInput", 27, 0},
}
for i = 1, 8 do
	table.insert(config.input.directInputHookDefinitions, {"joyaxesInputPosSgn" .. i, i + 1, 1})
	table.insert(config.input.directInputHookDefinitions, {"joyaxesInputNegSgn" .. i, i + 1, -1})
	table.insert(config.input.directInputHookDefinitions, {"joybuttonsInput" .. i, i + 9, 0})
end

config.input.directInputHooks = {}
for i, entry in ipairs(config.input.directInputHookDefinitions) do
	table.insert(config.input.directInputHooks, function (_, keycode) menu.remapInput(entry[2], keycode, entry[3]) end)
end

config.input.filters = {
	{ id = "", sources = {} },
	{ id = "keyboard",	  sources = { [1] = true, [18] = true, [19] = true } },
	{ id = "controller_1",  sources = { [2] = true, [10] = true } },
	{ id = "controller_2",  sources = { [3] = true, [11] = true } },
	{ id = "controller_3",  sources = { [4] = true, [12] = true } },
	{ id = "controller_4",  sources = { [5] = true, [13] = true } },
	{ id = "controller_5",  sources = { [6] = true, [14] = true } },
	{ id = "controller_6",  sources = { [7] = true, [15] = true } },
	{ id = "controller_7",  sources = { [8] = true, [16] = true } },
	{ id = "controller_8",  sources = { [9] = true, [17] = true } },
}

config.ventureDLCStates = {
	[0] = "valid",
	[1] = "userdisabled",
	[2] = "userskipped",
	[3] = "notpossible",
	[4] = "updatedisabled",
	[5] = "updateskipped",
	[6] = "updatenotpossible",
	[7] = "usercanceled",
	[8] = "unknownerror",
}

config.inputfeedback = {
	options = {
		{ id = "off",			   text = ReadText(1001, 12641),   icon = "", displayremoveoption = false },
		{ id = "text",			  text = ReadText(1001, 12633),   icon = "", displayremoveoption = false },
		{ id = "voice",			 text = ReadText(1001, 12634),   icon = "", displayremoveoption = false },
		{ id = "textandvoice",	  text = ReadText(1001, 12635),   icon = "", displayremoveoption = false },
	},
	textoptions = {
		{ id = "off",			   text = ReadText(1001, 12641),   icon = "", displayremoveoption = false },
		{ id = "ticker",			text = ReadText(1001, 12629),   icon = "", displayremoveoption = false },
		{ id = "controlmessage",	text = ReadText(1001, 12630),   icon = "", displayremoveoption = false },
	},
	voiceoptions = {
		{ id = "off",			   text = ReadText(1001, 12641),   icon = "", displayremoveoption = false },
		{ id = "on",				text = ReadText(1001, 12642),   icon = "", displayremoveoption = false },
	},
}

config.optionDefinitions = {
	["main"] = {
		name = function () return menu.isStartmenu and ReadText(1001, 2681) or ReadText(1001, 2600) end,
		info = function () return ReadText(1001, 2655) .. ReadText(1001, 120) .. " " .. GetVersionString() .. "\n" .. ffi.string(C.GetBuildVersionSuffix()) .. (C.IsGameModified() and (ColorText["text_warning"] .. "(" .. ReadText(1001, 8901) .. ")") or "") end,
		[1] = {
			id = "onlineseason",
			name = function () return menu.nameOnlineSeason() end,
			callback = function () return menu.callbackOnlineSeason() end,
			selectable = function () return menu.selectableOnlineSeason() end,
			wordwrap = true,
			display = function () return C.IsVentureSeasonSupported() and (not C.IsTimelinesScenario()) and (ffi.string(C.GetGameStartName()) ~= "x4ep1_gamestart_hub") end,
		},
		[2] = {
			id = "continue",
			name = function () return menu.nameContinue() end,
			mouseOverText = function () return menu.isStartmenu and ReadText(1026, 4803) or "" end,
			callback = function () return menu.callbackContinue() end,
			selectable = function () return menu.selectableContinue() end,
			wordwrap = true,
		},
		[3] = {
			id = "load",
			name = function () return (menu.autoReloadSave or C.IsSaveListLoadingComplete()) and ReadText(1001, 2604) or ReadText(1001, 7203) end,
			mouseOverText = ReadText(1026, 4804),
			submenu = "load",
			selectable = function () return C.IsSaveListLoadingComplete() and C.HasSavegame() end,
		},
		[4] = {
			id = "save",
			name = ReadText(1001, 2605),
			submenu = "save",
			selectable = IsSavingPossible,
			display = function () return not menu.isStartmenu end,
			mouseOverText = function () return menu.saveMouseOverText() end,
		},
		[5] = {
			id = "line",
			linecolor = Color["row_background"],
		},
		[6] = {
			id = "tutorials",
			name = ReadText(1001, 12660),
			prefixicon = function () return menu.prefixIconTopLevel("tutorials") end,
			mouseOverText = ReadText(1026, 4805),
			submenu = "tutorials",
		},
		[7] = {
			id = "timelines",
			name = ReadText(1001, 12661),
			prefixicon = function () return menu.prefixIconTopLevel("timelines") end,
			mouseOverText = ReadText(1026, 2696) .. "\n\n" .. ReadText(1026, 2681),
			submenu = "timelines",
			selectable = function () return ffi.string(C.GetGameStartName()) ~= "x4ep1_gamestart_hub" end,
		},
		[8] = {
			id = "new",
			name = ReadText(1001, 12662),
			prefixicon = function () return menu.prefixIconTopLevel("new") end,
			submenu = "new",
			mouseOverText = ReadText(1026, 4801) .. "\n\n" .. ReadText(1026, 4802),
		},
		[9] = {
			id = "multiplayer",
			name = ReadText(1001,7283),
			submenu = "multiplayer",
			display = C.IsNetworkEngineEnabled,
		},
		[10] = {
			id = "line",
			linecolor = Color["row_background"],
		},
		[11] = {
			id = "settings",
			name = function () return menu.nameSettings() end,
			submenu = "settings",
		},
		[12] = {
			id = "credits",
			name = ReadText(1001, 4811),
			submenu = "credits",
			display = function () return menu.isStartmenu end,
		},
		[13] = {
			id = "returntohub",
			name = function () return menu.nameReturnToHub() end,
			prefixicon = function () return "menu_recommended", Color["gamestart_recommended"] end,
			callback = function () return menu.callbackReturnToHub() end,
			display = function () return (not menu.isStartmenu) and C.IsTimelinesScenario() end,
		},
		[14] = {
			id = "exit",
			name = ReadText(1001, 11791),
			submenu = "exit",
			display = function () return not menu.isStartmenu end,
		},
		[15] = {
			id = "quit",
			name = ReadText(1001, 4876),
			submenu = "quit",
		},
	},
	["timelines"] = {
		name = ReadText(1021, 67),
		[1] = {
			id = "timelines_start",
			name = function () return (ffi.string(C.GetUserData("timelines_scenarios_finished")) ~= "") and ReadText(1001, 12620) or ReadText(1001, 12619) end,
			callback = function () return menu.callbackTimelines() end,
			selectable = function () return (not C.HasExtension("ego_dlc_timelines", false)) or C.IsExtensionEnabled("ego_dlc_timelines", false) end,
			mouseOverText = function () return (ffi.string(C.GetUserData("timelines_scenarios_finished")) ~= "") and ReadText(1026, 2698) or ReadText(1026, 2697) end,
		},
		[2] = {
			id = "timelines_reset",
			name = ReadText(1001, 12621),
			submenu = "timelines_reset",
			selectable = function () return C.IsExtensionEnabled("ego_dlc_timelines", false) and (ffi.string(C.GetUserData("timelines_scenarios_finished")) ~= "") end,
			mouseOverText = ReadText(1026, 2699)
		},
	},
	["load"] = {
		name = ReadText(1001, 2604)
	},
	["save"] = {
		name = ReadText(1001, 2605)
	},
	["saveoffline"] = {
		name = ReadText(1001, 11712)
	},
	["multiplayer"] = {
		name = ReadText(1001,7283),
		[1] = {
			id = "multiplayer_server",
			name = ReadText(1001,7284),
			submenu = "multiplayer_server",
		},
		[2] = {
			id = "lobby",
			name = ReadText(1001,7285),
			submenu = "lobby",
		},
	},
	["online"] = {
		[1] = {
			id = "language",
			name = ReadText(1001, 11765),
			info = ReadText(1001, 11766),
			valuetype = "dropdown",
			value = function () return menu.valueOnlinePreferredLanguage() end,
			callback = function (id, option) return menu.callbackOnlinePreferredLanguage(id, option) end,
		},
		[2] = {
			id = "visitornames",
			name = ReadText(1001, 7298),
			info = ReadText(1001, 7297),
			valuetype = "button",
			value = function () return C.GetVisitorNamesShownOption() and ReadText(1001, 2617) or ReadText(1001, 2618) end,
			callback = function () return menu.callbackOnlineVisitorNames() end,
			display = function () return C.AreVenturesEnabled() end,
		},
		[3] = {
			id = "acceptinvitations",
			name = ReadText(1001, 11763),
			info = ReadText(1001, 11764),
			valuetype = "button",
			value = function () return menu.valueOnlineAllowInvites() end,
			callback = function () return menu.callbackOnlineAllowInvites() end,
			display = function () return C.IsVentureSeasonSupported() and OnlineHasSession() end,
		},
		[4] = {
			id = "acceptprivatemessages",
			name = ReadText(1001, 11772),
			info = ReadText(1001, 11773),
			valuetype = "button",
			value = function () return menu.valueOnlineAllowPrivateMessages() end,
			callback = function () return menu.callbackOnlineAllowPrivateMessages() end,
			display = function () return C.IsVentureSeasonSupported() and OnlineHasSession() end,
		},
		[5] = {
			id = "seasonupdates",
			name = ReadText(1001, 11309),
			valuetype = "dropdown",
			value = function () return menu.valueOnlineSeasonUpdates() end,
			callback = function (id, option) return menu.callbackOnlineSeasonUpdates(id, option) end,
			display = function () return false end,
		},
		[6] = {
			id = "operationupdates",
			name = ReadText(1001, 11310),
			valuetype = "dropdown",
			value = function () return menu.valueOnlineOperationUpdates() end,
			callback = function (id, option) return menu.callbackOnlineOperationUpdates(id, option) end,
			display = function () return false end,
		},
		[7] = {
			id = "promotion",
			name = ReadText(1001, 11311),
			valuetype = "dropdown",
			value = function () return menu.valueOnlinePromotion() end,
			callback = function (id, option) return menu.callbackOnlinePromotion(id, option) end,
			display = function () return false end,
		},
		[8] = {
			id = "seasonsummary",
			name = ReadText(1001, 11312),
			valuetype = "dropdown",
			value = function () return menu.valueOnlineSeasonSummary() end,
			callback = function (id, option) return menu.callbackOnlineSeasonSummary(id, option) end,
			display = function () return false end,
		},
	},
	["extensionsettings"] = {
		name = function () return menu.nameExtensionSettings() end,
		warning = function () return menu.warningExtensionSettings() end,
		[1] = {
			id = "enable",
			name = function () return menu.nameExtensionSettingEnabled() end,
			value = function () return menu.valueExtensionSettingEnabled() end,
			callback = function () return menu.callbackExtensionSettingEnabled() end,
		},
		[2] = {
			id = "sync",
			name = ReadText(1001, 4824),
			value = function () return menu.valueExtensionSettingSync() end,
			callback = function () return menu.callbackExtensionSettingSync() end,
			display = function () return menu.selectedExtension.isworkshop end,
		},
		[3] = {
			id = "workshop",
			name = ReadText(1001, 4828),
			callback = function () return menu.callbackExtensionSettingWorkshop() end,
			display = function () return menu.selectedExtension.isworkshop end,
		},
	},
	["settings"] = {
		name = ReadText(1001, 2679),
		warning = function () return menu.warningSettings() end,
		[1] = {
			id = "online",
			name = function () return menu.nameOnline() end,
			submenu = "online",

			-- kuertee start:
			-- selectable = C.IsOnlineEnabled,
			selectable = function () return false end,
			-- kuertee end

			mouseOverText = function () return C.IsOnlineEnabled() and (ReadText(1026, 4806) .. "\n\n" .. ReadText(1026, 4807)) or ReadText(1001, 11592) end,
		},
		[2] = {
			id = "extensions",
			name = function () return menu.nameExtension() end,
			mouseOverText = ReadText(1026, 4808),
			submenu = "extensions",
			display = function () return not C.IsDemoVersion() end,
		},
		[3] = {
			id = "bonus",
			name = ReadText(1001, 4800),
			submenu = "bonus",
			display = function () return false end, -- hidden, not needed in X4
		},
		[4] = {
			id = "line",
		},
		[5] = {
			id = "display",
			name = function () return menu.nameDisplay() end,
			submenu = "display",
		},
		[6] = {
			id = "gfx",
			name = function () return menu.nameGfx() end,
			submenu = "gfx",
		},
		[7] = {
			id = "sfx",
			name = ReadText(1001, 2611),
			submenu = "sfx",
		},
		[8] = {
			id = "game",
			name = ReadText(1001, 2613),
			submenu = "game",
		},
		[9] = {
			id = "accessibility",
			name = function () return menu.nameAccessibility() end,
			submenu = "accessibility",
		},
		[10] = {
			id = "input",
			name = function () return menu.nameInput() end,
			submenu = "input",
		},
		[11] = {
			id = "privacy",
			name = ReadText(1001, 4870),
			submenu = "privacy",
		},
		[12] = {
			id = "language",
			name = function () return menu.nameLanguage() end,
			submenu = "language",
			display = function () return menu.isStartmenu and C.IsLanguageSettingEnabled() end
		},
		[13] = {
			id = "line",
		},
		[14] = {
			id = "defaults",
			name = ReadText(1001, 8981),
			submenu = "defaults",
		},
	},
	["display"] = {
		name = ReadText(1001, 12771),
		warning = function () return menu.warningDisplay() end,
		[1] = {
			id = "fullscreen",
			name = function () return C.IsVRVersion() and ReadText(1001, 7213) or ReadText(1001, 4817) end,
			mouseOverText = ReadText(1026, 4826),
			valuetype = "dropdown",
			value = function () return menu.valueGfxFullscreen() end,
			callback = function (id, option) return menu.callbackGfxFullscreen(id, option) end,
			selectable = function () return menu.selectableGfxFullscreen() end,
		},
		[2] = {
			id = "hmd_resolution",
			name = ReadText(1001, 2619),
			value = function () return menu.valueGfxHMDResolution() end,
			display = C.IsVRVersion,
		},
		[3] = {
			-- non-VR case
			id = "resolution",
			name = ReadText(1001, 2619),
			mouseOverText = ReadText(1026, 4821),
			valuetype = "dropdown",
			value = function () return menu.valueGfxResolution() end,
			callback = function (id, option) return menu.callbackGfxResolution(id, option) end,
			display = function () return not C.IsVRVersion() end,
			selectable = function () return menu.selectableGfxResolution() end,
		},
		[4] = {
			id = "antialias",
			name = ReadText(1001, 2620),
			mouseOverText = function () return (not C.GetDLSSOption(false)) and ReadText(1026, 4822) or (ColorText["text_error"] ..  ReadText(1026, 4813)) end,
			valuetype = "dropdown",
			value = function () return menu.valueGfxAA() end,
			callback = function (id, option) return menu.callbackGfxAA(id, option) end,
			selectable = function () return not C.GetDLSSOption(false) end,
		},
		[5] = {
			id = "fsr1",
			name = ReadText(1001, 11726),
			mouseOverText = function () return menu.mouseOverTextGfxUpscaling() end,
			valuetype = "dropdown",
			value = function () return menu.valueGfxFSR1() end,
			callback = function (id, option) return menu.callbackGfxFSR1(id, option) end,
			selectable = function () return menu.selectableGfxUpscaling() == 0 end,
		},
		[6] = {
			id = "dlss",
			name = ReadText(1001, 12735),
			mouseOverText = ReadText(1026, 4824),
			valuetype = "dropdown",
			value = function () return menu.valueGfxDLSS() end,
			callback = function (id, option) return menu.callbackGfxDLSS(id, option) end,
			display = C.IsDLSSSupported,
		},
		[7] = {
			id = "dlssmode",
			name = "	" .. ReadText(1001, 12736),
			mouseOverText = ReadText(1026, 4825),
			valuetype = "dropdown",
			value = function () return menu.valueGfxDLSSMode() end,
			callback = function (id, option) return menu.callbackGfxDLSSMode(id, option) end,
			selectable = function () return C.GetDLSSOption(false) end,
			display = C.IsDLSSSupported,
		},
		[8] = {
			id = "adaptivesampling",
			name = ReadText(1001, 7221),
			valuetype = "dropdown",
			value = function () return menu.valueGfxAdaptiveSampling() end,
			callback = function (id, option) return menu.callbackGfxAdaptiveSampling(id, option) end,
			display = C.IsVRVersion,
		},
		[9] = {
			id = "hmd_fullscreen",
			name = ReadText(1001, 4817),
			value = function () return ReadText(1001, 2622), Color["text_normal"] end,
			display = C.IsVRVersion,
		},
		[10] = {
			id = "hmd_sdk",
			name = ReadText(1001, 7214),
			value = function () return ffi.string(C.GetTrackerSDKOption()), Color["text_normal"] end,
			display = C.IsVRVersion,
		},
		[11] = {
			id = "line",
			display = C.IsVRVersion,
		},
		[12] = {
			id = "hmd_adapter",
			name = ReadText(1001, 2623),
			value = function () return ffi.string(C.GetTrackerNameOption()), Color["text_normal"] end,
			display = C.IsVRVersion,
		},
		[13] = {
			id = "screendisplay",
			name = ReadText(1001, 7210),
			valuetype = "button",
			value = function () return C.GetScreenDisplayOption() and ReadText(1001, 12641) or ReadText(1001, 12642) end,
			callback = function () return menu.callbackGfxScreenDisplay() end,
			display = C.IsVRVersion,
		},
		[14] = {
			-- VR case
			id = "resolution",
			name = ReadText(1001, 7211),
			valuetype = "dropdown",
			value = function () return menu.valueGfxResolution() end,
			callback = function (id, option) return menu.callbackGfxResolution(id, option) end,
			display = C.IsVRVersion,
			selectable = function () return menu.selectableGfxResolution() end,
		},
		[15] = {
			id = "autogpu",
			name = ReadText(1001, 11709),
			mouseOverText = ReadText(1026, 4827),
			valuetype = "button",
			value = function () return C.IsGPUAutomaticallySelected() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGfxAutoGPU() end,
		},
		[16] = {
			id = "gpu",
			name = ReadText(1001, 8920),
			mouseOverText = ReadText(1026, 4828),
			valuetype = "dropdown",
			value = function () return menu.valueGfxGPU() end,
			callback = function (id, option) return menu.callbackGfxGPU(id, option) end,
			selectable = function () return menu.selectableGfxGPU() end,
		},
		[17] = {
			id = "adapter",
			name = ReadText(1001, 8921),
			mouseOverText = ReadText(1026, 4829),
			valuetype = "dropdown",
			value = function () return menu.valueGfxAdapter() end,
			callback = function (id, option) return menu.callbackGfxAdapter(id, option) end,
			selectable = function () return menu.selectableGfxAdapter() end,
		},
		[18] = {
			id = "presentmode",
			name = ReadText(1001, 7268),
			mouseOverText = ReadText(1026, 4830),
			valuetype = "dropdown",
			value = function () return menu.valueGfxPresentMode() end,
			callback = function (id, option) return menu.callbackGfxPresentMode(id, option) end,
		},
		[19] = {
			id = "lut",
			name = ReadText(1001, 7238),
			mouseOverText = ReadText(1026, 4831),
			valuetype = "dropdown",
			value = function () return menu.valueGfxLUT(false) end,
			callback = function (id, option) return menu.callbackGfxLUT(id, option) end,
		},
		[20] = {
			id = "gamma",
			name = ReadText(1001, 2629),
			mouseOverText = ReadText(1026, 4832),
			valuetype = "slidercell",
			value = function () return menu.valueGfxGamma() end,
			callback = function (value) return menu.callbackGfxGamma(value) end,
		},
		[21] = {
			id = "fov",
			name = ReadText(1001, 4814),
			mouseOverText = ReadText(1026, 4833),
			valuetype = "slidercell",
			value = function () return menu.valueGfxFOV() end,
			callback = function (value) return menu.callbackGfxFOV(value) end,
		},
		[22] = {
			id = "line",
		},
		[23] = {
			id = "display_defaults",
			name = ReadText(1001, 12772),
			submenu = "display_defaults",
		},
	},
	["gfx"] = {
		name = ReadText(1001, 2606),
		warning = function () return menu.warningGfx() end,
		[1] = {
			id = "gfx_preset",
			name = ReadText(1001, 4840),
			mouseOverText = ReadText(1026, 4834),
			valuetype = "dropdown",
			value = function () return menu.valueGfxPreset() end,
			callback = function (id, option) return menu.callbackGfxPreset(id, option) end,
		},
		[2] = {
			id = "texturequality",
			name = ReadText(1001, 8900),
			mouseOverText = ReadText(1026, 4835),
			valuetype = "dropdown",
			value = function () return menu.valueGfxTexture() end,
			callback = function (id, option) return menu.callbackGfxTexture(id, option) end,
		},
		[3] = {
			id = "shadows",
			name = ReadText(1001, 2625),
			mouseOverText = ReadText(1026, 4836),
			valuetype = "dropdown",
			value = function () return menu.valueGfxShadows() end,
			callback = function (id, option) return menu.callbackGfxShadows(id, option) end,
		},
		[4] = {
			id = "softshadows",
			name = ReadText(1001, 4841),
			mouseOverText = ReadText(1026, 4837),
			valuetype = "button",
			value = function () return GetSoftShadowsOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGfxSoftShadows() end,
		},
		[5] = {
			id = "ssao",
			name = ReadText(1001, 2626),
			mouseOverText = ReadText(1026, 4838),
			valuetype = "dropdown",
			value = function () return menu.valueGfxSSAO() end,
			callback = function (id, option) return menu.callbackGfxSSAO(id, option) end,
		},
		[6] = {
			id = "glow",
			name = ReadText(1001, 11752),
			mouseOverText = ReadText(1026, 4839),
			valuetype = "dropdown",
			value = function () return menu.valueGfxGlow() end,
			callback = function (id, option) return menu.callbackGfxGlow(id, option) end,
		},
		[7] = {
			id = "uiglow",
			name = ReadText(1001, 11779),
			mouseOverText = ReadText(1026, 4840),
			valuetype = "dropdown",
			value = function () return menu.valueGfxUIGlow() end,
			callback = function (id, option) return menu.callbackGfxUIGlow(id, option) end,
		},
		[8] = {
			id = "uiglowintensity",
			name = ReadText(1001, 12701),
			mouseOverText = ReadText(1026, 4841),
			valuetype = "slidercell",
			value = function () return menu.valueGfxUIGlowIntensity() end,
			callback = function (value) return menu.callbackGfxUIGlowIntensity(value) end,
		},
		[9] = {
			id = "chromaticaberration",
			name = ReadText(1001, 8987),
			mouseOverText = ReadText(1026, 4842),
			valuetype = "button",
			value = function () return C.GetChromaticAberrationOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGfxChromaticAberration() end,
		},
		[10] = {
			id = "distortion",
			name = ReadText(1001, 4822),
			mouseOverText = ReadText(1026, 4843),
			valuetype = "button",
			value = function () return GetDistortionOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGfxDistortion() end,
		},
		[11] = {
			id = "pom",
			name = ReadText(1001, 11731),
			mouseOverText = ReadText(1026, 4844),
			valuetype = "dropdown",
			value = function () return menu.valueGfxPOM() end,
			callback = function (id, option) return menu.callbackGfxPOM(id, option) end,
		},
		[12] = {
			id = "lod",
			name = ReadText(1001, 2628),
			mouseOverText = ReadText(1026, 4845),
			valuetype = "slidercell",
			value = function () return menu.valueGfxLOD() end,
			callback = function (value) return menu.callbackGfxLOD(value) end,
		},
		[13] = {
			id = "effectdist",
			name = ReadText(1001, 2699),
			mouseOverText = ReadText(1026, 4846),
			valuetype = "slidercell",
			value = function () return menu.valueGfxEffectDistance() end,
			callback = function (value) return menu.callbackGfxEffectDistance(value) end,
		},
		[14] = {
			id = "shaderquality",
			name = ReadText(1001, 2680),
			valuetype = "dropdown",
			value = function () return menu.valueGfxShaderQuality() end,
			callback = function (id, option) return menu.callbackGfxShaderQuality(id, option) end,
			display = function () return false end, -- TEMP hidden until we get shaders with different quality
		},
		[15] = {
			id = "radar",
			name = ReadText(1001, 1706),
			mouseOverText = ReadText(1026, 4847),
			valuetype = "dropdown",
			value = function () return menu.valueGfxRadar() end,
			callback = function (id, option) return menu.callbackGfxRadar(id, option) end,
		},
		[16] = {
			id = "ssr",
			name = ReadText(1001, 7288),
			mouseOverText = ReadText(1026, 4848),
			valuetype = "dropdown",
			value = function () return menu.valueGfxSSR() end,
			callback = function (id, option) return menu.callbackGfxSSR(id, option) end,
		},
		[17] = {
			id = "envmapprobes",
			name = ReadText(1001, 11733),
			mouseOverText = ReadText(1026, 4849),
			valuetype = "dropdown",
			value = function () return menu.valueGfxEnvMapProbes() end,
			callback = function (id, option) return menu.callbackGfxEnvMapProbes(id, option) end,
		},
		[18] = {
			id = "volumetric",
			name = ReadText(1001, 8990),
			mouseOverText = ReadText(1026, 4850),
			valuetype = "dropdown",
			value = function () return menu.valueGfxVolumetric() end,
			callback = function (id, option) return menu.callbackGfxVolumetric(id, option) end,
		},
		[19] = {
			id = "line",
		},
		[20] = {
			id = "envmapprobesinsideglassfade",
			name = ReadText(1001, 11754),
			mouseOverText = ReadText(1026, 4851),
			valuetype = "slidercell",
			value = function () return menu.valueGfxEnvMapProbesInsideGlassFade() end,
			callback = function (value) return menu.callbackGfxEnvMapProbesInsideGlassFade(value) end,
		},
		[21] = {
			id = "capturehq",
			name = ReadText(1001, 4816),
			mouseOverText = ReadText(1026, 4852),
			valuetype = "button",
			value = function () return GetCaptureHQOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGfxCaptureHQ() end,
		},
		[22] = {
			id = "line",
		},
		[23] = {
			id = "gfx_defaults",
			name = ReadText(1001, 8982),
			submenu = "gfx_defaults",
		},
	},
	["sfx"] = {
		name = ReadText(1001, 2611),
		[1] = {
			id = "sounddevice",
			name = ReadText(1001, 8960),
			valuetype = "dropdown",
			value = function () return menu.valueSfxDevice() end,
			callback = function (id, option) return menu.callbackSfxDevice(id, option) end,
		},
		[2] = {
			id = "sound",
			name = ReadText(1001, 2630),
			valuetype = "button",
			value = function () return GetSoundOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackSfxSound() end,
		},
		[3] = {
			id = "master",
			name = ReadText(1001, 2631),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("master") end,
			callback = function (value) return menu.callbackSfxSetting("master", value) end,
		},
		[4] = {
			id = "music",
			name = ReadText(1001, 2632),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("music") end,
			callback = function (value) return menu.callbackSfxSetting("music", value) end,
		},
		[5] = {
			id = "voice",
			name = ReadText(1001, 2633),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("voice") end,
			callback = function (value) return menu.callbackSfxSetting("voice", value) end,
		},
		[6] = {
			id = "ambient",
			name = ReadText(1001, 2634),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("ambient") end,
			callback = function (value) return menu.callbackSfxSetting("ambient", value) end,
		},
		[7] = {
			id = "ui",
			name = ReadText(1001, 2635),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("ui") end,
			callback = function (value) return menu.callbackSfxSetting("ui", value) end,
		},
		[8] = {
			id = "effect",
			name = ReadText(1001, 2636),
			valuetype = "slidercell",
			value = function () return menu.valueSfxSetting("effect") end,
			callback = function (value) return menu.callbackSfxSetting("effect", value) end,
		},
		[9] = {
			id = "line",
		},
		[10] = {
			id = "sfx_defaults",
			name = ReadText(1001, 8983),
			submenu = "sfx_defaults",
		},
	},
	["game"] = {
		name = ReadText(1001, 2613),
		[1] = {
			id = "header",
			name = ReadText(1001, 8974),
		},
		[2] = {
			id = "autosave",
			name = ReadText(1001, 407),
			valuetype = "button",
			value = function () return GetAutosaveOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameAutosave() end,
		},
		[3] = {
			id = "autosaveinterval",
			name = ReadText(1001, 8930),
			mouseOverText = ReadText(1026, 2641),
			valuetype = "dropdown",
			value = function () return menu.valueGameAutosaveInterval() end,
			callback = function (id, option) return menu.callbackGameAutosaveInterval(id, option) end,
			selectable = GetAutosaveOption,
		},
		[4] = {
			id = "header",
			name = ReadText(1001, 11706),
		},
		[5] = {
			id = "emergencyeject",
			name = ReadText(1001, 11705),
			mouseOverText = ReadText(1026, 3267),
			valuetype = "button",
			value = function () return C.GetEmergencyEjectOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameEmergencyEject() end,
		},
		[6] = {
			id = "header",
			name = ReadText(1001, 8973),
		},
		[7] = {
			id = "autoroll",
			name = ReadText(1001, 2644),
			valuetype = "button",
			value = function () return GetAutorollOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameAutoroll() end,
		},
		[8] = {
			id = "collision",
			name = ReadText(1001, 2698),
			valuetype = "button",
			value = function () return GetCollisionAvoidanceAssistOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameCollision() end,
		},
		[9] = {
			id = "boost",
			name = ReadText(1001, 2646),
			valuetype = "button",
			value = function () return GetBoostToggleOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameBoost() end,
		},
		[10] = {
			id = "aimassist",
			name = ReadText(1001, 2696),
			valuetype = "dropdown",
			value = function () return menu.valueGameAimAssist() end,
			callback = function (id, option) return menu.callbackGameAimAssist(id, option) end,
		},
		[11] = {
			id = "stopshipinmenu",
			name = ReadText(1001, 4884),
			valuetype = "button",
			value = function () return GetStopShipInMenuOption() and ReadText(1001, 12641) or ReadText(1001, 12642) end,
			callback = function () return menu.callbackGameStopInMenu() end,
		},
		[12] = {
			id = "header",
			name = ReadText(1001, 8972),
		},
		[13] = {
			id = "subtitles",
			name = ReadText(1001, 2643),
			valuetype = "dropdown",
			value = function () return menu.valueGameSubtitles() end,
			callback = function (id, option) return menu.callbackGameSubtitles(id, option) end,
		},
		[14] = {
			id = "speaktargetname",
			name = ReadText(1001, 8924),
			valuetype = "button",
			value = function () return C.GetSpeakTargetNameOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameSpeakTargetName() end,
		},
		[15] = {
			id = "inputfeedback",
			name = ReadText(1001, 12632),
			valuetype = "dropdown",
			value = function () return menu.valueGameInputFeedback() end,
			callback = function (id, option) return menu.callbackGameInputFeedback(id, option) end,
		},
		[16] = {
			id = "mouselook",
			name = ReadText(1001, 4895),
			valuetype = "button",
			value = function () return GetMouseLookToggleOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameMouselook() end,
		},
		[17] = {
			id = "rumble",
			name = ReadText(1001, 2678),
			valuetype = "slidercell",
			value = function () return menu.valueGameRumble() end,
			callback = function (value) return menu.callbackGameRumble(value) end,
		},
		[18] = {
			id = "forceshoottocursor",
			name = ReadText(1001, 7218),
			valuetype = "button",
			value = function () return C.GetForceShootingAtCursorOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameShootAtCursor() end,
			display = C.IsVRVersion,
		},
		[19] = {
			id = "mouseover",
			name = ReadText(1001, 4882),
			valuetype = "button",
			value = function () return C.GetMouseOverTextOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameMouseOver() end,
		},
		[20] = {
			id = "radardisplay",
			name = ReadText(1001, 7258),
			valuetype = "dropdown",
			value = function () return menu.valueGameRadar() end,
			callback = function (id, option) return menu.callbackGameRadar(id, option) end,
		},
		[21] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[22] = {
			id = "uiscale",
			name = ReadText(1001, 7209),
			mouseOverText = ReadText(1026, 2626),
			valuetype = "slidercell",
			value = function () return menu.valueGameUIScale() end,
			callback = function (value) return menu.callbackGameUIScale(value) end,
			confirmline = {
				positive = function () return menu.callbackGameUIScaleConfirm() end,
				pos_name = ReadText(1001, 2821),
				pos_selectable = function () return menu.selectableGameUIScaleConfirm() end,
				negative = function () return menu.callbackGameUIScaleReset() end,
				neg_name = ReadText(1001, 3318),
				neg_selectable = function () return menu.selectableGameUIScaleConfirm() end,
			},
		},
		[23] = {
			id = "hudscale",
			name = ReadText(1001, 12624),
			mouseOverText = ReadText(1026, 2671),
			valuetype = "dropdown",
			value = function () return menu.valueGameHUDScale() end,
			callback = function (id, option) return menu.callbackGameHUDScale(id, option) end,
		},
		[24] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[25] = {
			id = "menuwidthscale",
			name = ReadText(1001, 11792),
			mouseOverText = ReadText(1026, 2669),
			valuetype = "slidercell",
			value = function () return menu.valueGameMenuWidthScale() end,
			callback = function (value) return menu.callbackGameMenuWidthScale(value) end,
			confirmline = {
				positive = function () return menu.callbackGameMenuWidthScaleConfirm() end,
				pos_name = ReadText(1001, 2821),
				pos_selectable = function () return menu.selectableGameMenuWidthScaleConfirm() end,
				negative = function () return menu.callbackGameMenuWidthScaleReset() end,
				neg_name = ReadText(1001, 3318),
				neg_selectable = function () return menu.selectableGameMenuWidthScaleConfirm() end,
			},
		},
		[26] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[27] = {
			id = "controlmodemessages",
			name = ReadText(1001, 4861),
			valuetype = "button",
			value = function () return GetSteeringNoteOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameControlModeMessages() end,
		},
		[28] = {
			id = "resetuserquestions",
			name = ReadText(1001, 8985),
			mouseOverText = ReadText(1026, 2652),
			valuetype = "confirmation",
			value = ReadText(1001, 8986),
			callback = function () return menu.callbackGameResetUserQuestions() end,
			selectable = function () return menu.selectableGameResetUserQuestions() end,
			inactive_text = ReadText(1026, 2653),
		},
		[29] = {
			id = "enemywarning_nearby",
			name = ReadText(1001, 11729),
			valuetype = "sounddropdown",
			value = function () return menu.valueGameEnemyNearby() end,
			callback = function (id, option) return menu.callbackGameEnemyNearby(id, option) end,
		},
		[30] = {
			id = "enemywarning_attack",
			name = ReadText(1001, 11730),
			valuetype = "sounddropdown",
			value = function () return menu.valueGameEnemyAttack() end,
			callback = function (id, option) return menu.callbackGameEnemyAttack(id, option) end,
		},
		[31] = {
			id = "startmenu_background",
			name = ReadText(1001, 11761),
			valuetype = "dropdown",
			value = function () return menu.valueGameStartmenuBackground() end,
			callback = function (id, option) return menu.callbackGameStartmenuBackground(id, option) end,
			display = function () return menu.isStartmenu end,
		},
		[32] = {
			id = "velocityindicator",
			name = ReadText(1001, 12773),
			valuetype = "button",
			value = function () return C.GetVelocityIndicatorOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameVelocityIndicator() end,
		},
		[33] = {
			id = "header",
			name = ReadText(1001, 4860),
		},
		[34] = {
			id = "thirdpersonflight",
			name = ReadText(1001, 11785),
			valuetype = "dropdown",
			value = function () return menu.valueGameThirdPersonFlight() end,
			callback = function (id, option) return menu.callbackThirdPersonFlight(id, option) end,
			display = function () return false end, -- hidden due to not being used for the moment
		},
		[35] = {
			id = "cockpitcamera",
			name = ReadText(1001, 7289),
			valuetype = "slidercell",
			value = function () return menu.valueGameCockpitCamera() end,
			callback = function (value) return menu.callbackGameCockpitCamera(value) end,
		},
		[36] = {
			id = "autozoomreset",
			name = ReadText(1001, 12702),
			valuetype = "button",
			value = function () return C.GetAutoZoomResetOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackGameAutoZoomReset() end,
		},
		[37] = {
			id = "header",
			name = ReadText(1001, 2661),
		},
		[38] = {
			id = "game_defaults",
			name = ReadText(1001, 8984),
			submenu = "game_defaults",
		},
	},
	["accessibility"] = {
		name = ReadText(1001, 8994),
		[1] = {
			id = "signalleakindicator",
			name = ReadText(1001, 8995),
			valuetype = "button",
			value = function () return C.GetSignalLeakIndicatorOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackAccessibilitySignalLeak() end,
		},
		[2] = {
			id = "longrangescanindicator",
			name = ReadText(1001, 8996),
			valuetype = "button",
			value = function () return C.GetLongRangeScanIndicatorOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackAccessibilityLongRangeScan() end,
		},
		[3] = {
			id = "globallightscale",
			name = ReadText(1001, 11755),
			valuetype = "slidercell",
			value = function () return menu.valueAccessibilityGlobalLightScale() end,
			callback = function (value) return menu.callbackAccessibilityGlobalLightScale(value) end,
		},
		[4] = {
			id = "lut",
			name = ReadText(1001, 7238),
			valuetype = "dropdown",
			value = function () return menu.valueGfxLUT(true) end,
			callback = function (id, option) return menu.callbackGfxLUT(id, option) end,
			display = function () return false end, -- TODO Florian
		},
		[5] = {
			id = "reducedspeedmode",
			name = ReadText(1001, 12654),
			mouseOverText = ReadText(1026, 2676),
			valuetype = "slidercell",
			value = function () return menu.valueAccessibilityReducedSpeedMode() end,
			callback = function (value) return menu.callbackAccessibilityReducedSpeedMode(value) end,
		},
		[6] = {
			id = "stardustintensity",
			name = ReadText(1001, 12763),
			valuetype = "slidercell",
			value = function () return menu.valueAccessibilityStardustIntensity() end,
			callback = function (value) return menu.callbackAccessibilityStardustIntensity(value) end,
		},
		[7] = {
			id = "line",
		},
		[8] = {
			id = "colorlibrary",
			name = function () return menu.nameColorBlind() end,
			submenu = "colorlibrary",
		},
		[9] = {
			id = "inputfeedback",
			name = ReadText(1001, 12628),
			submenu = "inputfeedback",
		},
		[10] = {
			id = "line",
		},
		[11] = {
			id = "accessibility_defaults",
			name = ReadText(1001, 8998),
			submenu = "accessibility_defaults",
		},
	},
	["input"] = {
		name = ReadText(1001, 2656),
		warning = function () return menu.warningInput() end,
		[1] = {
			id = "header",
			name = ReadText(1001, 7227),
			display = C.IsVROculusTouchActive,
		},
		[2] = {
			id = "vrtouch_space",
			name = ReadText(1001, 12686),
			submenu = "vrtouch_space",
			display = C.IsVROculusTouchActive,
		},
		[3] = {
			id = "vrtouch_firstperson",
			name = ReadText(1001, 12687),
			submenu = "vrtouch_firstperson",
			display = C.IsVROculusTouchActive,
		},
		[4] = {
			id = "vrtouch_menus",
			name = ReadText(1001, 2660),
			submenu = "vrtouch_menus",
			display = C.IsVROculusTouchActive,
		},
		[5] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
			display = C.IsVROculusTouchActive,
		},
		[6] = {
			id = "header",
			name = ReadText(1001, 7228),
			display = C.IsVRViveControllerActive,
		},
		[7] = {
			id = "vrvive_space",
			name = ReadText(1001, 12686),
			submenu = "vrvive_space",
			display = C.IsVRViveControllerActive,
		},
		[8] = {
			id = "vrvive_firstperson",
			name = ReadText(1001, 12687),
			submenu = "vrvive_firstperson",
			display = C.IsVRViveControllerActive,
		},
		[9] = {
			id = "vrvive_menus",
			name = ReadText(1001, 2660),
			submenu = "vrvive_menus",
			display = C.IsVRViveControllerActive,
		},
		[10] = {
			id = "vrvive_pointingdevice",
			name = ReadText(1001, 7224),
			valuetype = "dropdown",
			value = function () return menu.valueInputVivePointingDevice() end,
			callback = function (id, option) return menu.callbackInputVivePointingDevice(id, option) end,
			display = C.IsVRViveControllerActive,
		},
		[11] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
			display = C.IsVRViveControllerActive,
		},
		[12] = {
			id = "header",
			name = function () return (C.IsVROculusTouchActive() or C.IsVRViveControllerActive()) and ReadText(1001, 7229) or ReadText(1001, 2656) end,
		},
		[13] = {
			id = "keyboard_space",
			name = ReadText(1001, 12686),
			submenu = "keyboard_space",
		},
		[14] = {
			id = "keyboard_firstperson",
			name = ReadText(1001, 12687),
			submenu = "keyboard_firstperson",
		},
		[15] = {
			id = "keyboard_menus",
			name = ReadText(1001, 2660),
			submenu = "keyboard_menus",
		},
		[16] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[17] = {
			id = "header",
			name = ReadText(1001, 4857),
		},
		[18] = {
			id = "profile_load",
			name = ReadText(1001, 12684),
			submenu = "profile_load",
		},
		[19] = {
			id = "profile_save",
			name = ReadText(1001, 12685),
			submenu = "profile_save",
		},
		[20] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[21] = {
			id = "header",
			name = ReadText(1001, 12691),
		},
		[22] = {
			id = "joysticks",
			name = ReadText(1001, 4856),
			submenu = "joysticks",
		},
		[23] = {
			id = "joystick_invert",
			name = ReadText(1001, 12678),
			submenu = "joystick_invert",
		},
		[24] = {
			id = "joystick_sensitivity",
			name = ReadText(1001, 12680),
			submenu = "joystick_sensitivity",
		},
		[25] = {
			id = "joystick_deadzone",
			name = ReadText(1001, 4835),
			valuetype = "slidercell",
			value = function () return menu.valueInputJoystickDeadzone() end,
			callback = function(value) return menu.callbackInputJoystickDeadzone(value) end,
		},
		[26] = {
			id = "joystick_bidirectional_throttle",
			name = ReadText(1001, 7261),
			mouseOverText = ReadText(1026, 2683),
			valuetype = "button",
			value = function () return C.IsThrottleBidirectional() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputJoystickBidirectionalThrottle() end,
		},
		[27] = {
			id = "gamepadmode",
			name = ReadText(1001, 4867),
			mouseOverText = ReadText(1026, 2684),
			valuetype = "dropdown",
			value = function () return menu.valueInputGamepadMode() end,
			callback = function (id, option) return menu.callbackInputGamepadMode(id, option) end,
		},
		[28] = {
			id = "joystick_steering_adaptive",
			name = ReadText(1001, 12682),
			mouseOverText = ReadText(1026, 2682),
			valuetype = "button",
			value = function () return C.IsJoystickSteeringAdapative() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputJoystickSteeringAdaptive() end,
		},
		[29] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[30] = {
			id = "header",
			name = ReadText(1001, 12692),
		},
		[31] = {
			id = "mouse_invert",
			name = ReadText(1001, 12679),
			submenu = "mouse_invert",
		},
		[32] = {
			id = "mouse_sensitivity",
			name = ReadText(1001, 12681),
			submenu = "mouse_sensitivity",
		},
		[33] = {
			id = "mouse_capture",
			name = ReadText(1001, 4820),
			valuetype = "button",
			value = function () return GetConfineMouseOption() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputMouseCapture() end,
		},
		[34] = {
			id = "mouse_steering_adaptive",
			name = ReadText(1001, 12683),
			mouseOverText = ReadText(1026, 2682),
			valuetype = "button",
			value = function () return C.IsMouseSteeringAdapative() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputMouseSteeringAdaptive() end,
		},
		[35] = {
			id = "mouse_steering_persistent",
			name = ReadText(1001, 11768),
			mouseOverText = ReadText(1026, 2685),
			valuetype = "button",
			value = function () return C.IsMouseSteeringPersistent() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputMouseSteeringPersistent() end,
		},
		[36] = {
			id = "mouse_steering_line",
			name = ReadText(1001, 11769),
			mouseOverText = ReadText(1026, 2686),
			valuetype = "button",
			value = function () return C.IsMouseSteeringLineEnabled() and ReadText(1001, 12642) or ReadText(1001, 12641) end,
			callback = function () return menu.callbackInputMouseSteeringLine() end,
		},
		[37] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
		},
		[38] = {
			id = "header",
			name = ReadText(1001, 12729),
			display = C.IsOpenTrackEnabled,
		},
		[39] = {
			id = "tracker_support_opentrack",
			name = ReadText(1001, 12730),
			mouseOverText = ReadText(1026, 4810),
			valuetype = "button",
			value = function () return menu.valueInputOpenTrackSupport() end,
			callback = function () return menu.callbackInputOpenTrackSupport() end,
			display = C.IsOpenTrackEnabled,
		},
		[40] = {
			id = "tracker_support_opentrack_info",
			name = "",
			value = function () return menu.valueInputOpenTrackStatus() end,
			display = C.GetOpenTrackSupportOption,
			interactive = false,
		},
		[41] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
			display = C.IsOpenTrackEnabled,
		},
		[42] = {
			id = "header",
			name = function () return ffi.string(C.GetActiveHeadTrackerName()) end,
			display = C.IsActiveHeadTrackerAvailable,
		},
		[43] = {
			id = "tracker_mode",
			name = ReadText(1001, 8941),
			valuetype = "dropdown",
			value = function () return menu.valueInputTrackerMode() end,
			callback = function (id, option) return menu.callbackInputTrackerMode(id, option) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("mode") end,
		},
		[44] = {
			id = "tracker_headfilterstrength",
			name = ReadText(1001, 8954),
			mouseOverText = ReadText(1026, 2647),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerHeadFilterStrength() end,
			callback = function(value) return menu.callbackInputTrackerHeadFilterStrength(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("filterstrength") end,
		},
		[45] = {
			id = "tracker_anglefactor",
			name = ReadText(1001, 8950),
			mouseOverText = ReadText(1026, 2644),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerAngleFactor() end,
			callback = function(value) return menu.callbackInputTrackerAngleFactor(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("anglefactor") end,
		},
		[46] = {
			id = "tracker_deadzoneangle",
			name = ReadText(1001, 8952),
			mouseOverText = ReadText(1026, 2645),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerDeadzoneAngle() end,
			callback = function(value) return menu.callbackInputTrackerDeadzoneAngle(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("deadzoneangle") end,
		},
		[47] = {
			id = "tracker_positionfactor",
			name = ReadText(1001, 8958),
			mouseOverText = ReadText(1026, 2650),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerPositionFactor() end,
			callback = function(value) return menu.callbackInputTrackerPositionFactor(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("positionfactor") end,
		},
		[48] = {
			id = "tracker_deadzoneposition",
			name = ReadText(1001, 8953),
			mouseOverText = ReadText(1026, 2646),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerDeadzonePosition() end,
			callback = function(value) return menu.callbackInputTrackerDeadzonePosition(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("deadzoneposition") end,
		},
		[49] = {
			id = "tracker_gazefilterstrength",
			name = ReadText(1001, 8955),
			mouseOverText = ReadText(1026, 2648),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerGazeFilterStrength() end,
			callback = function(value) return menu.callbackInputTrackerGazeFilterStrength(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("gazefilterstrength") end,
		},
		[50] = {
			id = "tracker_gazeanglefactor",
			name = ReadText(1001, 8951),
			mouseOverText = ReadText(1026, 2644),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerGazeAngleFactor() end,
			callback = function(value) return menu.callbackInputTrackerGazeAngleFactor(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("gazeanglefactor") end,
		},
		[51] = {
			id = "tracker_gazedeadzone",
			name = ReadText(1001, 8949),
			mouseOverText = ReadText(1026, 2649),
			valuetype = "slidercell",
			value = function () return menu.valueInputTrackerGazeDeadzone() end,
			callback = function(value) return menu.callbackInputTrackerGazeDeadzone(value) end,
			display = function () return C.IsActiveHeadTrackerAvailable() and C.IsActiveHeadTrackerSettingSupported("gazedeadzone") end,
		},
		[52] = {
			id = "line",
			linecolor = Color["row_background"],
			lineheight = 4,
			display = C.IsActiveHeadTrackerAvailable,
		},
		[53] = {
			id = "header",
			name = function () return ReadText(1001, 4815) end,
		},
		[54] = {
			id = "input_modifiers",
			name = ReadText(1001, 12643),
			submenu = "input_modifiers",
		},
	},
	["joystick_invert"] = {
		name = ReadText(1001, 2674) .. ReadText(1001, 120) .. " " .. ReadText(1001, 2675),
		[1] = {
			id = "header",
			name = ReadText(1001, 2662),
		},
		[2] = {
			id = "invert_steering_yaw",
			name = ReadText(config.input.controltextpage.ranges, 1),
			valuetype = "button",
			value = function () return menu.valueInputInvert(1) end,
			callback = function () return menu.callbackInputInvert(1, "invert_steering_yaw") end,
		},
		[3] = {
			id = "invert_steering_pitch",
			name = ReadText(config.input.controltextpage.ranges, 2),
			valuetype = "button",
			value = function () return menu.valueInputInvert(2) end,
			callback = function () return menu.callbackInputInvert(2, "invert_steering_pitch") end,
		},
		[4] = {
			id = "invert_steering_roll",
			name = ReadText(config.input.controltextpage.ranges, 3),
			valuetype = "button",
			value = function () return menu.valueInputInvert(3) end,
			callback = function () return menu.callbackInputInvert(3, "invert_steering_roll") end,
		},
		[5] = {
			id = "invert_throttle",
			name = ReadText(config.input.controltextpage.ranges, 4),
			valuetype = "button",
			value = function () return menu.valueInputInvert(4) end,
			callback = function () return menu.callbackInputInvert(4, "invert_throttle") end,
		},
		[6] = {
			id = "invert_strafe_left_right",
			name = ReadText(config.input.controltextpage.ranges, 5),
			valuetype = "button",
			value = function () return menu.valueInputInvert(5) end,
			callback = function () return menu.callbackInputInvert(5, "invert_strafe_left_right") end,
		},
		[7] = {
			id = "invert_strafe_up_down",
			name = ReadText(config.input.controltextpage.ranges, 6),
			valuetype = "button",
			value = function () return menu.valueInputInvert(6) end,
			callback = function () return menu.callbackInputInvert(6, "invert_strafe_up_down") end,
		},
		[8] = {
			id = "header",
			name = ReadText(1001, 12688),
		},
		[9] = {
			id = "invert_fp_yaw",
			name = ReadText(config.input.controltextpage.ranges, 13),
			valuetype = "button",
			value = function () return menu.valueInputInvert(13) end,
			callback = function () return menu.callbackInputInvert(13, "invert_fp_yaw") end,
		},
		[10] = {
			id = "invert_fp_pitch",
			name = ReadText(config.input.controltextpage.ranges, 14),
			valuetype = "button",
			value = function () return menu.valueInputInvert(14) end,
			callback = function () return menu.callbackInputInvert(14, "invert_fp_pitch") end,
		},
		[11] = {
			id = "invert_fp_walk",
			name = ReadText(config.input.controltextpage.ranges, 15),
			valuetype = "button",
			value = function () return menu.valueInputInvert(15) end,
			callback = function () return menu.callbackInputInvert(15, "invert_fp_walk") end,
		},
		[12] = {
			id = "invert_fp_strafe",
			name = ReadText(config.input.controltextpage.ranges, 16),
			valuetype = "button",
			value = function () return menu.valueInputInvert(16) end,
			callback = function () return menu.callbackInputInvert(16, "invert_fp_strafe") end,
		},
		[13] = {
			id = "header",
			name = ReadText(1001, 4836),
		},
		[14] = {
			id = "invert_controllermouse_x",
			name = ReadText(config.input.controltextpage.ranges, 23),
			valuetype = "button",
			value = function () return menu.valueInputInvert(23) end,
			callback = function () return menu.callbackInputInvert(23, "invert_controllermouse_x") end,
		},
		[15] = {
			id = "invert_controllermouse_y",
			name = ReadText(config.input.controltextpage.ranges, 24),
			valuetype = "button",
			value = function () return menu.valueInputInvert(24) end,
			callback = function () return menu.callbackInputInvert(24, "invert_controllermouse_y") end,
		},
		[16] = {
			id = "invert_compassmenu_x",
			name = ReadText(config.input.controltextpage.ranges, 36),
			valuetype = "button",
			value = function () return menu.valueInputInvert(36) end,
			callback = function () return menu.callbackInputInvert(36, "invert_compassmenu_x") end,
		},
		[17] = {
			id = "invert_compassmenu_y",
			name = ReadText(config.input.controltextpage.ranges, 37),
			valuetype = "button",
			value = function () return menu.valueInputInvert(37) end,
			callback = function () return menu.callbackInputInvert(37, "invert_compassmenu_y") end,
		},
	},
	["joystick_sensitivity"] = {
		name = ReadText(1001, 2674) .. ReadText(1001, 120) .. " " .. ReadText(1001, 2684),
		[1] = {
			id = "header",
			name = ReadText(1001, 12688),
		},
		[2] = {
			id = "sensitivity_fp_yaw",
			name = ReadText(config.input.controltextpage.ranges, 13),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(13) end,
			callback = function (value) return menu.callbackInputSensitivity(13, "sensitivity_fp_yaw", value) end,
		},
		[3] = {
			id = "sensitivity_fp_pitch",
			name = ReadText(config.input.controltextpage.ranges, 14),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(14) end,
			callback = function (value) return menu.callbackInputSensitivity(14, "sensitivity_fp_pitch", value) end,
		},
	},
	["mouse_invert"] = {
		name = ReadText(1001, 2683) .. ReadText(1001, 120) .. " " .. ReadText(1001, 2675),
		[1] = {
			id = "header",
			name = ReadText(1001, 2662),
		},
		[2] = {
			id = "invert_mouse_pitch",
			name = ReadText(1001, 8975),
			valuetype = "button",
			value = function () return menu.valueInputMouseSteeringInvert("invert_mouse_pitch") end,
			callback = function () return menu.callbackInputMouseSteeringInvert("invert_mouse_pitch") end,
		},
		[3] = {
			id = "invert_mouse_yaw",
			name = ReadText(1001, 8976),
			valuetype = "button",
			value = function () return menu.valueInputMouseSteeringInvert("invert_mouse_yaw") end,
			callback = function () return menu.callbackInputMouseSteeringInvert("invert_mouse_yaw") end,
		},
		[4] = {
			id = "invert_mouse_roll",
			name = ReadText(1001, 8977),
			valuetype = "button",
			value = function () return menu.valueInputMouseSteeringInvert("invert_mouse_roll") end,
			callback = function () return menu.callbackInputMouseSteeringInvert("invert_mouse_roll") end,
		},
		[5] = {
			id = "invert_direct_mouse_steering_yaw",
			name = ReadText(config.input.controltextpage.ranges, 29),
			valuetype = "button",
			value = function () return menu.valueInputInvert(29) end,
			callback = function () return menu.callbackInputInvert(29, "invert_direct_mouse_steering_yaw") end,
		},
		[6] = {
			id = "invert_direct_mouse_steering_pitch",
			name = ReadText(config.input.controltextpage.ranges, 30),
			valuetype = "button",
			value = function () return menu.valueInputInvert(30) end,
			callback = function () return menu.callbackInputInvert(30, "invert_direct_mouse_steering_pitch") end,
		},
		[7] = {
			id = "invert_direct_mouse_steering_roll",
			name = ReadText(config.input.controltextpage.ranges, 31),
			valuetype = "button",
			value = function () return menu.valueInputInvert(31) end,
			callback = function () return menu.callbackInputInvert(31, "invert_direct_mouse_steering_roll") end,
		},
		[8] = {
			id = "header",
			name = ReadText(1001, 12688),
		},
		[9] = {
			id = "invert_fp_mouse_yaw",
			name = ReadText(config.input.controltextpage.ranges, 7),
			valuetype = "button",
			value = function () return menu.valueInputInvert(7) end,
			callback = function () return menu.callbackInputInvert(7, "invert_fp_mouse_yaw") end,
		},
		[10] = {
			id = "invert_fp_mouse_pitch",
			name = ReadText(config.input.controltextpage.ranges, 8),
			valuetype = "button",
			value = function () return menu.valueInputInvert(8) end,
			callback = function () return menu.callbackInputInvert(8, "invert_fp_mouse_pitch") end,
		},
	},
	["mouse_sensitivity"] = {
		name = ReadText(1001, 2683) .. ReadText(1001, 120) .. " " .. ReadText(1001, 2684),
		[1] = {
			id = "header",
			name = ReadText(1001, 2662),
		},
		[2] = {
			id = "sensitivity_direct_mouse_steering_yaw",
			name = ReadText(config.input.controltextpage.ranges, 29),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(29) end,
			callback = function (value) return menu.callbackInputSensitivity(29, "sensitivity_direct_mouse_steering_yaw", value) end,
		},
		[3] = {
			id = "sensitivity_direct_mouse_steering_pitch",
			name = ReadText(config.input.controltextpage.ranges, 30),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(30) end,
			callback = function (value) return menu.callbackInputSensitivity(30, "sensitivity_direct_mouse_steering_pitch", value) end,
		},
		[4] = {
			id = "sensitivity_direct_mouse_steering_roll",
			name = ReadText(config.input.controltextpage.ranges, 31),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(31) end,
			callback = function (value) return menu.callbackInputSensitivity(31, "sensitivity_direct_mouse_steering_roll", value) end,
		},
		[5] = {
			id = "header",
			name = ReadText(1001, 12688),
		},
		[6] = {
			id = "sensitivity_fp_mouse_yaw",
			name = ReadText(config.input.controltextpage.ranges, 7),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(7) end,
			callback = function (value) return menu.callbackInputSensitivity(7, "sensitivity_fp_mouse_yaw", value) end,
		},
		[7] = {
			id = "sensitivity_fp_mouse_pitch",
			name = ReadText(config.input.controltextpage.ranges, 8),
			valuetype = "slidercell",
			value = function () return menu.valueInputSensitivity(8) end,
			callback = function (value) return menu.callbackInputSensitivity(8, "sensitivity_fp_mouse_pitch", value) end,
		},
	},
	["privacy"] = {
		name = ReadText(1001, 4870),
		[1] = {
			id = "crashreport",
			name = ReadText(1001, 4871),
			info = ReadText(1001, 4874),
			valuetype = "button",
			value = function () return GetCrashReportOption() and ReadText(1001, 2617) or ReadText(1001, 2618) end,
			callback = function () return menu.callbackPrivacyCrash() end,
		},
		[2] = {
			id = "senduserid",
			name = ReadText(1001, 4873),
			info = ReadText(1001, 4875),
			valuetype = "button",
			value = function () return GetPersonalizedCrashReportsOption() and ReadText(1001, 2617) or ReadText(1001, 2618) end,
			callback = function () return menu.callbackPrivacyUserID() end,
			display = C.AllowPersonalizedData
		},
		[3] = {
			id = "policy",
			name = ReadText(1001, 7292),
			info = ReadText(1001, 7293),
			valuetype = "button",
			value = "\27[mm_externallink]",
			callback = function () return menu.buttonPrivacyPolicy() end,
			selectable = C.CanOpenWebBrowser,
		},
	},
}

config.DLSSmodes = {
	["off"] = ReadText(1001, 12641),
	["auto"] = ReadText(1001, 12737),
	["quality"] = ReadText(1001, 12738),
	["balanced"] = ReadText(1001, 12739),
	["performance"] = ReadText(1001, 12740),
	["ultra_performance"] = ReadText(1001, 12741),
	["dlaa"] = ReadText(1001, 12742),
}

-- kuertee start: rewrites

local OldFuncs = {}
menu.uix_callbacks = {}

function ModLua.rewriteFunctions()
	OldFuncs.loadSaveCallback = menu.loadSaveCallback
	menu.loadSaveCallback = ModLua.loadSaveCallback
	OldFuncs.addSavegameRow = menu.addSavegameRow
	menu.addSavegameRow = ModLua.addSavegameRow
	OldFuncs.cleanup = menu.cleanup
	menu.cleanup = ModLua.cleanup
	OldFuncs.submenuHandler = menu.submenuHandler
	menu.submenuHandler = ModLua.submenuHandler
	OldFuncs.loadGameCallback = menu.loadGameCallback
	menu.loadGameCallback = ModLua.loadGameCallback
	OldFuncs.callbackDeleteSave = menu.callbackDeleteSave
	menu.callbackDeleteSave = ModLua.callbackDeleteSave
	OldFuncs.displayOptions = menu.displayOptions
	menu.displayOptions = ModLua.displayOptions
	OldFuncs.extensionSorter = menu.extensionSorter
	menu.extensionSorter = ModLua.extensionSorter
	OldFuncs.displayExtensions = menu.displayExtensions
	menu.displayExtensions = ModLua.displayExtensions
	OldFuncs.displayExtensionRow = menu.displayExtensionRow
	menu.displayExtensionRow = ModLua.displayExtensionRow
	OldFuncs.displaySavegameOptions = menu.displaySavegameOptions
	menu.displaySavegameOptions = ModLua.displaySavegameOptions
	OldFuncs.onUpdate = menu.onUpdate
	menu.onUpdate = ModLua.onUpdate
	OldFuncs.newGameCallback = menu.newGameCallback
	menu.newGameCallback = ModLua.newGameCallback
end

function ModLua.loadSaveCallback(_, filename)
	if (type(filename) ~= "string") or (not C.IsSaveValid(filename)) then
		DebugError("Lua Event 'loadSave' got an invalid filename '" .. tostring(filename) .. "'.")
		return
	end
	C.SkipNextStartAnimation()
	menu.delayedLoadGame = filename

	-- kuertee start: callback
	-- Helper.addDelayedOneTimeCallbackOnUpdate(function () LoadGame(filename) end, true, getElapsedTime() + 0.1)
	Helper.addDelayedOneTimeCallbackOnUpdate(
		function ()
			if menu.uix_callbacks ["loadGameCallback_preLoadGame"] then
				for uix_id, uix_callback in pairs (menu.uix_callbacks ["loadGameCallback_preLoadGame"]) do
					uix_callback(filename)
				end
			end
			LoadGame(filename)
		end
		, true, getElapsedTime() + 0.1)
	-- kuertee end: callback

	menu.displayInit()
end

-- kuertee start:
-- function ModLua.addSavegameRow(ftable, savegame, name, slot)
-- kuertee end
function ModLua.addSavegameRow(ftable, savegame, name, slot, idx, maxIdx)
	-- kuertee start: callback
	local isAddSaveGameToList = true
	savegame.uix_isDisplayedInList = true
	if menu.uix_callbacks ["addSavegameRow_isListSaveGame"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_isListSaveGame"]) do
			isAddSaveGameToList = uix_callback(ftable, savegame, name, slot)
			if not isAddSaveGameToList then
				break
			end
		end
		if not isAddSaveGameToList then
			savegame.uix_isDisplayedInList = nil
			return 0
		end
	end
	-- kuertee end: callback

	-- kuertee start: callback
	if menu.uix_callbacks ["addSavegameRow_changeSaveGameDisplayName"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_changeSaveGameDisplayName"]) do
			name = uix_callback(ftable, savegame, name, slot) or name
		end
	end
	-- kuertee end: callback

	-- kuertee start: callback
	if menu.uix_callbacks ["addSavegameRow_preSaveGameRowAdd"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_preSaveGameRowAdd"]) do
			uix_callback(ftable, savegame, name, slot, idx, maxIdx, config)
		end
	end
	-- kuertee end: callback

	local invalid = false
	if menu.currentOption == "load" then
		invalid = savegame.error or savegame.invalidgameid or savegame.invalidversion or savegame.invalidpatches
	end

	local row = ftable:addRow(savegame, {  })
	if menu.preselectOption == nil then
		menu.preselectOption = savegame.filename
	end
	if savegame.filename == menu.preselectOption then
		ftable:setSelectedRow(row.index)
		menu.selectedOption = savegame
	end

	if slot then
		row[2]:createText(slot, (not invalid) and config.standardTextProperties or config.disabledTextProperties)
		row[2].properties.halign = "right"
	end

	local nametruncated = TruncateText(name, config.fontBold, Helper.scaleFont(config.font, config.standardFontSize), row[3]:getWidth() - Helper.scaleX(config.standardTextOffsetX))
	local mouseovertext = ""
	if nametruncated ~= name then
		mouseovertext = name
	end

	local isonlinesaveinofflineslot = IsCheatVersion() and savegame.isonline and not savegame.isonlinesavefilename

	local height = Helper.scaleY(config.standardTextHeight) + Helper.borderSize

	-- kuertee start: callback
	local uix_isAddRowHeightForExtraInfo = nil
	if menu.uix_callbacks ["addSavegameRow_getRowHeightForExtraInfo"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_getRowHeightForExtraInfo"]) do
			uix_isAddRowHeightForExtraInfo = uix_isAddRowHeightForExtraInfo or uix_callback(ftable, savegame, name, slot)
		end
	end
	if uix_isAddRowHeightForExtraInfo ~= false then
	-- kuertee end: callback

	if invalid or savegame.modified or isonlinesaveinofflineslot then
		height = 2 * Helper.scaleY(config.standardTextHeight) + Helper.borderSize
	end

	-- kuertee start: callback
end
	-- kuertee end: callback

	local warningicon = ""
	if savegame.isonline then
		if C.IsClientModified() or (not OnlineHasSession()) or (C.GetVentureDLCStatus() ~= 0) then
			warningicon = ColorText["icon_warning"] .. "\27[workshop_error]\27X"
		end
	end

	local icon = row[3]:createIcon("solid", { width = row[3]:getWidth(), height = height, color = Color["icon_transparent"], scaling = false, mouseOverText = mouseovertext }):setText(warningicon .. nametruncated, (not invalid) and config.standardTextProperties or config.disabledTextProperties)

	-- kuertee start: callback
	local uix_isBoldFileName = nil
	if menu.uix_callbacks ["addSavegameRow_getIsBoldFilename"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_getIsBoldFilename"]) do
			uix_isBoldFileName = uix_isBoldFileName or uix_callback(ftable, savegame, name, slot)
		end
	end
	if uix_isBoldFileName ~= false then
	-- kuertee end: callback

	row[3].properties.text.font = config.fontBold

	-- kuertee start: callback
end
	-- kuertee end: callback

	row[3].properties.text.scaling = true

	-- kuertee start:
	if uix_isAddRowHeightForExtraInfo ~= false then
	-- kuertee end

	if invalid then
		icon:setText2(function () return menu.errorSavegame(savegame) end, (not invalid) and config.standardTextProperties or config.disabledTextProperties)
		row[3].properties.text2.y = config.standardTextHeight
		row[3].properties.text2.scaling = true
	elseif savegame.modified then
		icon:setText2(ColorText["text_warning"] .. ReadText(1001, 8901) .. "\27X", (not invalid) and config.standardTextProperties or config.disabledTextProperties)
		row[3].properties.text2.y = config.standardTextHeight
		row[3].properties.text2.scaling = true
	elseif isonlinesaveinofflineslot then
		icon:setText2(ColorText["text_online_save"] .. ReadText(1001, 11570) .. "\27X", (not invalid) and config.standardTextProperties or config.disabledTextProperties)
		row[3].properties.text2.y = config.standardTextHeight
		row[3].properties.text2.scaling = true
	end

	-- kuertee start:
end
	-- kuertee end

	row[4]:setColSpan(2):createText(savegame.error and "" or savegame.time, (not invalid) and config.standardTextProperties or config.disabledTextProperties)
	row[4].properties.halign = "right"

	-- kuertee start: callback
	-- return row:getHeight()
	local maxRowHeight = row:getHeight()
	if menu.uix_callbacks ["addSavegameRow_postSaveGameRowAdd"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["addSavegameRow_postSaveGameRowAdd"]) do
			maxRowHeight = math.max(maxRowHeight, uix_callback(ftable, savegame, name, slot, idx, maxIdx, config))
		end
	end
	-- kuertee end: callback

	return maxRowHeight
end

function ModLua.cleanup()
	if not menu.isStartmenu then
		if menu.paused then
			Unpause()
			menu.paused = nil
		end
		if menu.hasInputModeChangedRegistered then
			unregisterForEvent("inputModeChanged", getElement("Scene.UIContract"), menu.onInputModeChanged)
			menu.hasInputModeChangedRegistered = nil
		end
	end

	C.ResetEncryptedDirectInputData()
	if menu.onlineData then
		menu.onlineData.password = ""
	end

	menu.currentOption = nil
	menu.selectedOption = nil
	menu.preselectOption = nil
	menu.preselectTopRow = nil
	menu.preselectCol = nil
	menu.animationDelay = nil

	menu.selectedRows = {}
	menu.selectedCols = {}
	menu.topRows = {}

	menu.history = {}
	menu.savegames = nil
	menu.onlinesave = nil
	menu.languagedata = {}
	menu.remapControl = nil
	menu.directInputActive = nil
	menu.lobby = {}
	menu.updateServers = nil
	menu.selectedExtension = {}
	menu.curDropDownOption = {}
	menu.idleTimer = nil

	menu.controls = {}

	menu.contextFrame = nil

	menu.titleTable = nil
	menu.optionTable = nil
	menu.infoTable = nil
	menu.rendertarget = nil

	menu.width = nil
	menu.widthExtraWide = nil
	menu.height = nil
	menu.frameOffsetX = nil
	menu.frameOffsetXExtraWide = nil
	menu.frameOffsetY = nil

	menu.table = {}

	-- kuertee start: callback
	if menu.uix_callbacks ["cleanup"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["cleanup"]) do
			uix_callback()
		end
	end
	-- kuertee end: callback
end

function ModLua.submenuHandler(optionParameter)
	menu.userQuestion = nil

	if optionParameter == nil then
		DebugError("Invalid call to menu.submenuHandler(): ")
		DebugError(TraceBack())
		return
	end

	AddUITriggeredEvent(menu.name, "menu_" .. optionParameter)

	if optionParameter ~= "main" then
		C.HidePromo()
	end

	-- kuertee start: callback
	if menu.uix_callbacks ["submenuHandler_preDisplayOptions"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["submenuHandler_preDisplayOptions"]) do
			uix_callback(optionParameter)
		end
	end
	-- kuertee end: callback

	if optionParameter == "main" then
		if menu.isStartmenu then
			C.ShowPromo()
		end
		menu.displayOptions(optionParameter)
	elseif optionParameter == "new" then
		menu.displayNewGame(false, false, false)
	elseif optionParameter == "tutorials" then
		menu.displayNewGame(false, false, true)
	elseif optionParameter == "load" then
		menu.displaySavegameOptions(optionParameter)
	elseif optionParameter == "save" then
		menu.displaySavegameOptions(optionParameter)
	elseif optionParameter == "saveoffline" then
		menu.displaySavegameOptions(optionParameter)
	elseif optionParameter == "multiplayer_server" then
		menu.displayNewGame(true, false, false)
	elseif optionParameter == "new_timelines" then
		menu.displayNewGame(false, true, false)
	elseif optionParameter == "lobby" then
		menu.displayLobby()
	elseif optionParameter == "online" then
		__CORE_GAMEOPTIONS_PRIVACYPOLICY = false
		menu.displayOnlineLogin()
	elseif optionParameter == "extensions" then
		menu.displayExtensions()
	elseif optionParameter == "bonus" then
		menu.displayBonusContent()
	elseif optionParameter == "defaults" then
		menu.displayUserQuestion(ReadText(1001, 2653), function () return menu.callbackDefaults() end)
	elseif optionParameter == "gfx_defaults" then
		menu.displayUserQuestion(ReadText(1001, 2653), function () return menu.callbackGfxDefaults() end)
	elseif optionParameter == "sfx_defaults" then
		menu.displayUserQuestion(ReadText(1001, 2653), function () return menu.callbackSfxDefaults() end)
	elseif optionParameter == "game_defaults" then
		menu.displayUserQuestion(ReadText(1001, 2653), function () return menu.callbackGameDefaults() end)
	elseif optionParameter == "accessibility_defaults" then
		menu.displayUserQuestion(ReadText(1001, 2653), function () return menu.callbackAccessibilityDefaults() end)
	elseif optionParameter == "timelines_reset" then
		menu.displayUserQuestion(ReadText(1001, 12622), function () return menu.callbackResetTimelines() end, nil, nil, nil, nil, nil, ReadText(1001, 12623))
	elseif  (optionParameter == "vrtouch_space") or
		(optionParameter == "vrtouch_firstperson") or
		(optionParameter == "vrtouch_menus") or
		(optionParameter == "vrvive_space") or
		(optionParameter == "vrvive_firstperson") or
		(optionParameter == "vrvive_menus") or
		(optionParameter == "keyboard_space") or
		(optionParameter == "keyboard_firstperson") or
		(optionParameter == "keyboard_menus")
		then
			menu.displayControls(optionParameter)
		elseif optionParameter == "joysticks" then
			menu.displayJoysticks()
		elseif optionParameter == "profile_load" then
			menu.displayInputProfiles(optionParameter)
		elseif optionParameter == "profile_save" then
			menu.displayInputProfiles(optionParameter)
		elseif optionParameter == "language" then
			menu.displayLanguageOptions()
		elseif optionParameter == "onlineseason" then
			menu.displayOnlineSeason(optionParameter)
		elseif optionParameter == "credits" then
			menu.displayCredits(optionParameter)
		elseif optionParameter == "idle" then
			menu.displayCredits(optionParameter)
		elseif optionParameter == "exit" then
			menu.displayUserQuestion(ReadText(1001, 2645), function () return menu.callbackExit(false) end, nil, nil, nil, nil, nil, Helper.isOnlineGame() and ReadText(1001, 11710) or nil)
		elseif optionParameter == "quit" then
			menu.displayUserQuestion(ReadText(1001, 4876), function () return menu.callbackExit(true) end)
		elseif optionParameter == "privacy" then
			menu.displayOptionsInfo(optionParameter)
		elseif optionParameter == "mapeditor" then
			menu.displayMapEditor()
		elseif optionParameter == "colorlibrary" then
			menu.displayColorLibrary()
		elseif optionParameter == "inputfeedback" then
			menu.displayInputFeedback()
		elseif optionParameter == "input_modifiers" then
			menu.displayInputModifiers()
		elseif optionParameter == "timelines" then
			menu.displayTimelines()
		elseif config.optionDefinitions[optionParameter] then
			menu.displayOptions(optionParameter)
		end
	end

	function ModLua.loadGameCallback(filename, checked)
		local playerinventory = GetPlayerInventory()
		local onlineitems = OnlineGetUserItems()

	-- kuertee start:
	if not onlineitems then
		onlineitems = {}
	end
	-- kuertee end

	local hasnotuploadeditems = false
	for ware, waredata in Helper.orderedPairs(playerinventory) do
		local isbraneitem, isoperationvolatile, isseasonvolatile, isventureuploadallowed = GetWareData(ware, "isbraneitem", "isoperationvolatile", "isseasonvolatile", "isventureuploadallowed")
		if isbraneitem then
			local serveramount = 0
			if onlineitems[ware] then
				serveramount = onlineitems[ware].amount
			end
			if isventureuploadallowed and (waredata.amount > serveramount) then
				hasnotuploadeditems = true
				break
			end
		end
	end

	if (not checked) and (not menu.isStartmenu) and Helper.isOnlineGame() and hasnotuploadeditems then
		table.insert(menu.history, 1, { optionParameter = menu.currentOption, topRow = GetTopRow(menu.optionTable), selectedOption = filename })
		menu.displayUserQuestion(ReadText(1001, 2604) .. " - " .. ReadText(1001, 7720), function () return menu.loadGameCallback(filename, true) end, nil, nil, nil, nil, nil, ReadText(1001, 11707))
	else
		-- kuertee start: callback
		-- Helper.addDelayedOneTimeCallbackOnUpdate(function () LoadGame(filename) end, true, getElapsedTime() + 0.1)
		Helper.addDelayedOneTimeCallbackOnUpdate(
			function ()
				if menu.uix_callbacks ["loadGameCallback_preLoadGame"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["loadGameCallback_preLoadGame"]) do
						uix_callback(filename)
					end
				end
				LoadGame(filename)
			end
			, true, getElapsedTime() + 0.1)
		-- kuertee end: callback

		menu.displayInit()
	end
end

function ModLua.callbackDeleteSave(filename)
	C.DeleteSavegame(filename)

	menu.savegames = nil
	menu.onlinesave = nil
	C.ReloadSaveList()
	menu.onCloseElement("back")

	-- kuertee start: callback
	if menu.uix_callbacks ["callbackDeleteSave_onDeleteSave"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["callbackDeleteSave_onDeleteSave"]) do
			uix_callback(filename)
		end
	end
	-- kuertee end: callback
end

function ModLua.displayOptions(optionParameter)
	-- remove old data
	Helper.clearDataForRefresh(menu, config.optionsLayer)
	menu.selectedOption = nil

	menu.currentOption = optionParameter
	local options = config.optionDefinitions[optionParameter]

	-- kuertee start: callback
	if menu.uix_callbacks ["displayOptions_modifyOptions"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["displayOptions_modifyOptions"]) do
			options = uix_callback(options)
		end
	end
	-- kuertee end: callback

	local frame = menu.createOptionsFrame()

	local ftable = frame:addTable(5, { tabOrder = 1, x = menu.table.x, y = menu.table.y, width = menu.table.width, maxVisibleHeight = menu.table.height })
	ftable:setColWidth(1, menu.table.arrowColumnWidth, false)
	ftable:setColWidth(3, menu.table.infoColumnWidth / 2, false)
	ftable:setColWidth(4, menu.table.infoColumnWidth / 2 - Helper.scaleY(config.infoTextHeight) - Helper.borderSize, false)
	ftable:setColWidth(5, Helper.scaleY(config.infoTextHeight), false)
	ftable:setDefaultColSpan(3, 3)
	ftable:setDefaultCellProperties("button", { height = config.standardTextHeight })
	ftable:setDefaultComplexCellProperties("button", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
	ftable:setDefaultCellProperties("dropdown", { height = config.standardTextHeight })
	ftable:setDefaultComplexCellProperties("dropdown", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })
	ftable:setDefaultCellProperties("slidercell", { height = config.standardTextHeight })
	ftable:setDefaultComplexCellProperties("slidercell", "text", { x = config.standardTextOffsetX, fontsize = config.standardFontSize })

	-- title
	local row = ftable:addRow(menu.currentOption ~= "main", { fixed = true })
	row[1]:setBackgroundColSpan(5)
	local colOffset = 1
	if menu.currentOption ~= "main" then
		row[1]:createButton({ height = config.headerTextHeight }):setIcon(config.backarrow, { x = config.backarrowOffsetX })
		row[1].handlers.onClick = function () return menu.onCloseElement("back") end
		colOffset = 0
	end
	if options.info then
		row[2 - colOffset]:setColSpan(2 + colOffset):createText(options.name, config.headerTextProperties)
		row[4]:setColSpan(2):createText(options.info, config.infoTextProperties)
	else
		row[2 - colOffset]:setColSpan(4 + colOffset):createText(options.name, config.headerTextProperties)
	end

	-- warning
	if options.warning then
		local warning, warningFont = options.warning()
		local row = ftable:addRow(false, { fixed = true })
		row[1]:setColSpan(5):createText(function () local text = options.warning() return text end, config.warningTextProperties)
		if warningFont then
			row[1].properties.font = warningFont
		end
	end

	-- options
	for optionIdx, option in ipairs(options) do
		menu.displayOption(ftable, option)
	end

	ftable:setTopRow(menu.preselectTopRow)
	menu.preselectTopRow = nil
	menu.preselectOption = nil

	frame:display()
end

function ModLua.extensionSorter(a, b)
	local agroup = menu.getExtensionGroup(a)
	local bgroup = menu.getExtensionGroup(b)
	if agroup ~= bgroup then
		return agroup < bgroup
	end
	if agroup == 1 then
		local aisminidlc = string.find(a.id, "^ego_dlc_mini_")
		local bisminidlc = string.find(b.id, "^ego_dlc_mini_")
		if aisminidlc ~= bisminidlc then
			return not aisminidlc	   -- non-mini DLC before mini DLC
		end
		return Helper.sortDate(a, b)	-- sort DLC of either type by date
	end

	-- kuertee start: sort by enabled then by name
	-- return Helper.sortName(a, b)		-- sort other extensions by name
	if a.enabled and b.enabled then
		return a.name < b.name
	elseif a.enabled then
		return true
	elseif b.enabled then
		return false
	else
		return a.name < b.name
	end
	-- kuertee end: sort by enabled then by name
end

function ModLua.displayExtensions()
	-- remove old data
	Helper.clearDataForRefresh(menu, config.optionsLayer)
	menu.selectedOption = nil

	menu.currentOption = "extensions"

	local frame = menu.createOptionsFrame(true)

	local infowidth = menu.table.width - menu.table.widthWithExtraInfo - Helper.borderSize

	local titletable = frame:addTable(2, { tabOrder = 2, x = menu.table.x, y = menu.table.y, width = menu.table.widthExtraWide, skipTabChange = true })
	titletable:setColWidth(1, menu.table.arrowColumnWidth, false)

	-- title
	local row = titletable:addRow(true, { fixed = true })
	row[1]:setBackgroundColSpan(2)
	row[1]:createButton({ height = config.headerTextHeight }):setIcon(config.backarrow, { x = config.backarrowOffsetX })
	row[1].handlers.onClick = function () return menu.onCloseElement("back") end
	row[2]:createText(ReadText(1001, 2697), config.headerTextProperties)

	-- warning
	local row = titletable:addRow(false, { fixed = true })
	row[2]:createText(menu.warningExtensions, config.warningTextProperties)

	local offsety = titletable.properties.y + titletable:getVisibleHeight() + Helper.borderSize
	local height = menu.table.height - offsety

	local optiontable = frame:addTable(7, { tabOrder = 1, x = menu.table.x, y = offsety, width = menu.table.widthExtraWide - infowidth - Helper.borderSize, maxVisibleHeight = height })
	optiontable:setColWidth(1, menu.table.arrowColumnWidth, false)
	optiontable:setColWidthPercent(2, 40)
	optiontable:setColWidthPercent(4, 13)
	optiontable:setColWidthPercent(6, 10)
	optiontable:setColWidth(7, menu.table.arrowColumnWidth, false)

	local extensions = GetExtensionList()
	menu.extensionSettings = GetAllExtensionSettings()

	local addline = false
	if IsSteamworksEnabled() then
		addline = true

		local row = optiontable:addRow("globalsync", {  })
		row[2]:createText(ReadText(1001, 4830), config.standardTextProperties)
		row[6]:createButton({  }):setText(function () local text = menu.valueExtensionGlobalSync() return text end, { fontsize = config.standardFontSize, halign = "center", color = function () local _, color = menu.valueExtensionGlobalSync() return color end })
		row[6].handlers.onClick = menu.buttonExtensionGlobalSync

		local row = optiontable:addRow("workshop", {  })
		row[2]:setColSpan(5):createText(ReadText(1001, 4831), config.standardTextProperties)
	end

	if #extensions > 0 then
		addline = true

		local row = optiontable:addRow( "defaults", {  })
		row[2]:setColSpan(6):createText(ReadText(1001, 2647), config.standardTextProperties)
		if menu.preselectOption == "defaults" then
			optiontable:setSelectedRow(row.index)
		end
	end

	if addline then
		local row = optiontable:addRow(false, {  })
		row[2]:setColSpan(6):createText(" ", { fontsize = 1, height = Helper.borderSize, cellBGColor = Color["row_separator"] })
	end

	local row = optiontable:addRow("uisecurity", {  })
	row[2]:createText(ReadText(1001, 12723), config.standardTextProperties)
	row[2].properties.mouseOverText = ReadText(1001, 12725)
	row[6]:createButton({ mouseOverText = ReadText(1001, 12725) }):setText(function () return GetUISafeModeOption() and ReadText(1001, 2648) or ReadText(1001, 2649) end, { fontsize = config.standardFontSize, halign = "center" })
	row[6].handlers.onClick = menu.buttonExtensionUISecurityMode

	local row = optiontable:addRow(false, {  })
	row[2]:setColSpan(6):createText(" ", { fontsize = 1, height = Helper.borderSize, cellBGColor = Color["row_separator"] })

	row = optiontable:addRow(false, {  })
	row[2]:createText(ReadText(1001, 8999), config.subHeaderLeftTextProperties)
	row[3]:createText(ReadText(1001, 4823), config.subHeaderLeftTextProperties)
	row[4]:createText(ReadText(1001, 2655), config.subHeaderLeftTextProperties)
	row[5]:createText(ReadText(1001, 2691), config.subHeaderLeftTextProperties)
	if #extensions > 0 then
		table.sort(extensions, menu.extensionSorter)
		local lastextensiongroup
		for _, extension in ipairs(extensions) do
			local extensiongroup = menu.getExtensionGroup(extension)
			if lastextensiongroup and extensiongroup ~= lastextensiongroup then
				-- add separators between extension groups
				row = optiontable:addRow(false, {  })
				row[2]:setColSpan(6):createText(" ", { fontsize = 1, height = Helper.borderSize, cellBGColor = Color["row_separator"] })
			end
			menu.displayExtensionRow(optiontable, extension, menu.extensionSettings[extension.index])
			lastextensiongroup = extensiongroup
		end
	else
		local row = optiontable:addRow(false, {  })
		row[2]:setColSpan(2):createText(ReadText(1001, 2693), config.disabledTextProperties)
	end

	optiontable:setTopRow(menu.preselectTopRow)
	menu.preselectTopRow = nil
	menu.preselectOption = nil

	local offsetx = menu.table.x + menu.table.widthExtraWide - infowidth
	local infotable = frame:addTable(1, { tabOrder = 0, x = offsetx, y = offsety, width = infowidth, maxVisibleHeight = height })

	local row = infotable:addRow(false, { bgColor = Color["optionsmenu_cell_background"] })
	row[1]:createText(menu.descriptionExtension, { scaling = false, width = infowidth, height = height, wordwrap = true, fontsize = Helper.scaleFont(config.font, config.infoFontSize) })

	titletable.properties.nextTable = optiontable.index
	optiontable.properties.prevTable = titletable.index

	frame:display()
end

function ModLua.displayExtensionRow(ftable, extension, extensionSetting)
	local row = ftable:addRow(extension, {  })
	if extension.id == menu.preselectOption then
		ftable:setSelectedRow(row.index)
	end

	local textcolor = Color["text_normal"]
	if extension.error and extension.enabled then
		textcolor = Color["text_error"]
	elseif extension.warning then
		textcolor = Color["text_warning"]

	-- kuertee start: gray disabled extensions
elseif not extension.enabled then
	textcolor = Helper.color.grey
	-- kuertee end

end

row[2]:createText(extension.name, config.standardTextProperties)
row[2].properties.color = textcolor
row[3]:createText(extension.id, config.standardTextProperties)
row[4]:createText(extension.version, config.standardTextProperties)
row[4].properties.halign = "right"
row[5]:createText(extension.date, config.standardTextProperties)
row[5].properties.halign = "right"
row[6]:createButton({ }):setText(function() return menu.valueExtensionStatus(extension) end, { fontsize = config.standardFontSize, halign = "center", color = function () local _, color = menu.valueExtensionStatus(extension); return color end })
row[6].handlers.onClick = function () return menu.callbackExtensionSettingEnabled(extension) end
row[7]:createButton({ }):setText("...", { fontsize = config.standardFontSize, halign = "center" })
row[7].handlers.onClick = function () menu.selectedExtension = extension; menu.openSubmenu("extensionsettings", extension.id) end
end

function ModLua.displaySavegameOptions(optionParameter)
	-- remove old data
	Helper.clearDataForRefresh(menu, config.optionsLayer)
	menu.selectedOption = nil

	menu.currentOption = optionParameter
	local options = config.optionDefinitions[optionParameter]

	while not C.IsSaveListLoadingComplete() do
		-- wait until loading the savegame list is complete
	end
	menu.savegames = GetSaveList(Helper.validSaveFilenames)

	-- kuertee start: callback
	if menu.uix_callbacks ["displaySavegameOptions_onGetSaveGames"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySavegameOptions_onGetSaveGames"]) do
			uix_callback(optionParameter)
		end
	end
	-- kuertee end: callback

	menu.onlinesave = nil
	for _, save in ipairs(menu.savegames) do
		if save.isonline and (save.filename == "online_save") then
			menu.onlinesave = save
			break
		end
	end
	if next(menu.savegames) then

		-- table.sort(menu.savegames, function (a, b) return a.rawtime > b.rawtime end)
		-- kuertee start: callback
		if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
			for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
				uix_callback(menu.savegames, "rawtime", true)
			end
		else
			table.sort(menu.savegames, function (a, b) return a.rawtime > b.rawtime end)
		end
		-- kuertee end: callback

	end

	local usedsavegamenames = {}
	local autosaves = {}
	local customsaves = {}
	local sortablesaves = {}
	local quicksavegame
	for i, savegame in ipairs(menu.savegames) do
		savegame.displayedname = menu.getExplicitSavegameName(savegame) or savegame.location
		if savegame.filename == "quicksave" then
			savegame.displayedname = ((savegame.description ~= "") and savegame.description or savegame.location) .. " (" .. ReadText(1001, 400) .. ")"
			quicksavegame = i
			if menu.currentOption == "load" then
				table.insert(sortablesaves, savegame)
			end
		elseif string.find(savegame.filename, "autosave_", 1, true) == 1 then
			savegame.displayedname = string.format("%s (%s)", (savegame.description ~= "") and savegame.description or savegame.location, ReadText(1001, 406))
			table.insert(autosaves, savegame)
			if menu.currentOption == "load" then
				table.insert(sortablesaves, savegame)
			end
		elseif savegame.isonlinesavefilename then
			if savegame.isonline then
				if savegame ~= menu.onlinesave then
					-- TODO: Online autosave support
				end
			end
			-- TODO: handle offline savegame on online slot?
		elseif IsCheatVersion() and string.find(savegame.filename, "customsave[_-]", 1) == 1 then
			-- allow loading savegames with custom file names
			table.insert(customsaves, savegame)
		else
			usedsavegamenames[savegame.filename] = i
			table.insert(sortablesaves, savegame)
		end
	end

	local frame = menu.createOptionsFrame(true)

	-- list
	local ftable = frame:addTable(5, { tabOrder = 1, x = menu.table.x, y = 0, width = menu.table.widthExtraWide / 2, maxVisibleHeight = menu.table.height })
	ftable:setColWidth(1, menu.table.arrowColumnWidth, false)
	ftable:setColWidth(2, 2 * Helper.scaleY(config.infoTextHeight), false)
	ftable:setColWidthPercent(4, 25)
	ftable:setColWidth(5, Helper.scaleY(config.infoTextHeight), false)

	local maxRowHeight = 0

	local isonline = Helper.isOnlineGame()
	local showonlinesave = C.IsVentureExtensionSupported() and menu.onlinesave and ((menu.currentOption == "load") or isonline) and (menu.currentOption ~= "saveoffline")

	if showonlinesave then
		local row = ftable:addRow({ titlerow = "reload2" }, { fixed = true })
		if menu.preselectOption == "reload2" then
			ftable:setSelectedRow(row.index)
		end
		row[2]:setColSpan(3):createText(ReadText(1001, 11570), config.subHeaderTextProperties)
		row[5]:createButton({ height = config.infoTextHeight, width = config.infoTextHeight }):setIcon("menu_reload", {  })
		row[5].handlers.onClick = menu.buttonReloadSaveGames

		maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, menu.onlinesave, menu.onlinesave.displayedname))

		local row = ftable:addRow(nil, {  })
		row[2]:setColSpan(3):setBackgroundColSpan(4):createText(ReadText(1001, 11711), config.subHeaderTextProperties)
		row[5]:createText(" ", config.subHeaderTextProperties)
	end

	local nameSortButton
	if isonline and (menu.currentOption == "save") and (not menu.showofflinesaves) then
		local row = ftable:addRow({ submenu = "saveoffline" }, {  })
		if menu.preselectOption == "saveoffline" then
			ftable:setSelectedRow(row.index)
		end
		row[2]:setColSpan(4):createText(ReadText(1001, 11713), config.standardTextProperties)
	else
		-- reload
		local arrowWidth = Helper.scaleY(config.infoTextHeight)
		local row = ftable:addRow({ titlerow = "reload" }, { fixed = not showonlinesave })
		if menu.preselectOption == "reload" then
			ftable:setSelectedRow(row.index)
		end
		row[2]:createButton({ height = config.infoTextHeight }):setIcon((menu.saveSort == "slot_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = (row[2]:getColSpanWidth() - arrowWidth) / 2, color = ((menu.saveSort == "slot") or (menu.saveSort == "slot_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[2].handlers.onClick = function () menu.saveSort = (menu.saveSort == "slot") and "slot_inv" or "slot"; menu.refresh() end
		nameSortButton = row[3]:createButton({ height = config.infoTextHeight }):setText(ReadText(1001, 2809)):setIcon((menu.saveSort == "name_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[3]:getColSpanWidth() + Helper.scrollbarWidth - arrowWidth, color = ((menu.saveSort == "name") or (menu.saveSort == "name_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[3].handlers.onClick = function () menu.saveSort = (menu.saveSort == "name") and "name_inv" or "name"; menu.refresh() end
		row[4]:setColSpan(showonlinesave and 2 or 1):createButton({ height = config.infoTextHeight }):setText(ReadText(1001, 2691)):setIcon((menu.saveSort == "date_inv") and "table_arrow_inv_up" or "table_arrow_inv_down", { scaling = false, width = arrowWidth, height = arrowWidth, x = row[4]:getColSpanWidth() - arrowWidth, color = ((menu.saveSort == "date") or (menu.saveSort == "date_inv")) and Color["icon_normal"] or Color["icon_hidden"] })
		row[4].handlers.onClick = function () menu.saveSort = (menu.saveSort == "date") and "date_inv" or "date"; menu.refresh() end
		if not showonlinesave then
			row[5]:createButton({ height = config.infoTextHeight, width = config.infoTextHeight }):setIcon("menu_reload", {  })
			row[5].handlers.onClick = menu.buttonReloadSaveGames
		end
		maxRowHeight = math.max(maxRowHeight, row:getHeight())

		if (menu.saveSort == "slot") or (menu.saveSort == "slot_inv") then
			if menu.currentOption == "load" then
				if quicksavegame then
					local savegame = menu.savegames[quicksavegame]
					maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, savegame.displayedname))
				end
				if #autosaves > 0 then
					table.sort(autosaves, function (a, b) return a.rawtime > b.rawtime end)
					for i, savegame in ipairs(autosaves) do
						if i <= 3 then
							maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, savegame.displayedname))
						end
					end
				end
			end

			-- kuertee start: more save games
			-- local startIdx = (menu.saveSort == "slot_inv") and 10 or 1
			-- local endIdx = (menu.saveSort == "slot_inv") and 1 or 10
			-- local direction = (menu.saveSort == "slot_inv") and -1 or 1
			local startIdx = (menu.saveSort == "slot_inv") and Helper.maxSaveFiles or 1
			local endIdx = (menu.saveSort == "slot_inv") and 1 or Helper.maxSaveFiles
			local direction = (menu.saveSort == "slot_inv") and -1 or 1
			-- kuertee end: more save games

			for i = startIdx, endIdx, direction do
				local savegamestring = string.format("%03d", i)
				if usedsavegamenames["save_" .. savegamestring] then
					local savegame = menu.savegames[usedsavegamenames["save_" .. savegamestring]]
					maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, savegame.displayedname, i))
				else

					-- kuertee start: callback
					local isShowUnusedSaveFile = true
					if menu.uix_callbacks ["displaySavegameOptions_isShowUnusedSaveGame"] then
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySavegameOptions_isShowUnusedSaveGame"]) do
							isShowUnusedSaveFile = uix_callback(i)
							if not isShowUnusedSaveFile then
								goto continue
							end
						end
					end
					-- kuertee end: callback

					local row = ftable:addRow({ empty = savegamestring }, {  })
					if string.format("save_%03d", i) == menu.preselectOption then
						ftable:setSelectedRow(row.index)
						menu.selectedOption = { empty = savegamestring }
					end
					row[2]:createText(i, ((menu.currentOption == "save") or (menu.currentOption == "saveoffline")) and config.standardTextProperties or config.disabledTextProperties)
					row[2].properties.halign = "right"
					row[3]:setColSpan(3):createText(ReadText(1001, 4812), { scaling = false, font = config.font, fontsize = Helper.scaleFont(config.font, config.standardFontSize), x = Helper.scaleX(config.standardTextOffsetX), y = Helper.scaleY(2), color = (menu.currentOption == "load") and Color["text_inactive"] or nil, minRowHeight = Helper.scaleY(config.standardTextHeight) + Helper.borderSize })
					maxRowHeight = math.max(maxRowHeight, row:getHeight())
				end

				-- kuertee start: callback
				::continue::
				-- kuertee end: callback
			end
		else
			if menu.saveSort == "date" then

				-- table.sort(sortablesaves, function (a, b) return a.rawtime > b.rawtime end)
				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
						uix_callback(sortablesaves, "rawtime", true)
					end
				else
					table.sort(sortablesaves, function (a, b) return a.rawtime > b.rawtime end)
				end
				-- kuertee end: callback

			elseif menu.saveSort == "date_inv" then

				-- table.sort(sortablesaves, function (a, b) return a.rawtime < b.rawtime end)
				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
						uix_callback(sortablesaves, "rawtime", false)
					end
				else
					table.sort(sortablesaves, function (a, b) return a.rawtime < b.rawtime end)
				end
				-- kuertee end: callback

			elseif menu.saveSort == "name" then

				-- table.sort(sortablesaves, function (a, b) return a.displayedname < b.displayedname end)
				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
						uix_callback(sortablesaves, "displayedname", true)
					end
				else
					table.sort(sortablesaves, function (a, b) return a.displayedname < b.displayedname end)
				end
				-- kuertee end: callback

			elseif menu.saveSort == "name_inv" then

				-- table.sort(sortablesaves, function (a, b) return a.displayedname > b.displayedname end)
				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
						uix_callback(sortablesaves, "displayedname", false)
					end
				else
					table.sort(sortablesaves, function (a, b) return a.displayedname < b.displayedname end)
				end
				-- kuertee end: callback
			end
			for i, savegame in ipairs(sortablesaves) do
				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_preSaveGameRowAdd"] then
					if next(menu.uix_callbacks["displaySaveGameOptions_preSaveGameRowAdd"]) and (not menu.uix_isWarn_displaySaveGameOptions_preSaveGameRowAdd) then
						menu.uix_isWarn_displaySaveGameOptions_preSaveGameRowAdd = true
						Helper.debugText_forced("NOTE: gameoptions_uix displaySaveGameOptions_preSaveGameRowAdd call back is obsolete.")
						Helper.debugText_forced("Use addSavegameRow_preSaveGameRowAdd.")
						Helper.debugText_forced("displaySaveGameOptions_preSaveGameRowAdd exists only for backward-compatibility.")
					end
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_preSaveGameRowAdd"]) do
						maxRowHeight = math.max(maxRowHeight, uix_callback(ftable, savegame, savegame.displayedname, i, #sortablesaves, config))
					end
				end
				-- kuertee end: callback

				local idx = tonumber(string.match(savegame.filename, "^save_(%d+)"))

				-- kuertee start:
				-- maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, savegame.displayedname, idx))
				maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, savegame.displayedname, idx, i, #sortablesaves))
				-- kuertee end

				-- kuertee start: callback
				if menu.uix_callbacks ["displaySaveGameOptions_postSaveGameRowAdd"] then
					if next(menu.uix_callbacks["displaySaveGameOptions_postSaveGameRowAdd"]) and (not menu.uix_isWarn_displaySaveGameOptions_postSaveGameRowAdd) then
						menu.uix_isWarn_displaySaveGameOptions_postSaveGameRowAdd = true
						Helper.debugText_forced("NOTE: gameoptions_uix displaySaveGameOptions_postSaveGameRowAdd call back is obsolete.")
						Helper.debugText_forced("Use addSavegameRow_postSaveGameRowAdd.")
						Helper.debugText_forced("displaySaveGameOptions_postSaveGameRowAdd exists only for backward-compatibility.")
					end
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_postSaveGameRowAdd"]) do
						maxRowHeight = math.max(maxRowHeight, uix_callback(ftable, savegame, savegame.displayedname, i, #sortablesaves))
					end
				end
				-- kuertee end: callback
			end

			-- kuertee start: more save games
			-- for i = 1, 10 do
			for i = 1, Helper.maxSaveFiles do
			-- kuertee end: more save games

			local savegamestring = string.format("%03d", i)
			if not usedsavegamenames["save_" .. savegamestring] then

					-- kuertee start: callback
					local isShowUnusedSaveFile = true
					if menu.uix_callbacks ["displaySavegameOptions_isShowUnusedSaveGame"] then
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySavegameOptions_isShowUnusedSaveGame"]) do
							isShowUnusedSaveFile = uix_callback(i)
							if not isShowUnusedSaveFile then
								goto continue
							end
						end
					end
					-- kuertee end: callback

					local row = ftable:addRow({ empty = savegamestring }, {  })
					if string.format("save_%03d", i) == menu.preselectOption then
						ftable:setSelectedRow(row.index)
						menu.selectedOption = { empty = savegamestring }
					end
					row[2]:createText(i, ((menu.currentOption == "save") or (menu.currentOption == "saveoffline")) and config.standardTextProperties or config.disabledTextProperties)
					row[2].properties.halign = "right"
					row[3]:setColSpan(3):createText(ReadText(1001, 4812), { scaling = false, font = config.font, fontsize = Helper.scaleFont(config.font, config.standardFontSize), x = Helper.scaleX(config.standardTextOffsetX), y = Helper.scaleY(2), color = (menu.currentOption == "load") and Color["text_inactive"] or nil, minRowHeight = Helper.scaleY(config.standardTextHeight) + Helper.borderSize })
					maxRowHeight = math.max(maxRowHeight, row:getHeight())

					-- kuertee start: callback
					::continue::
					-- kuertee end: callback
				end
			end
		end
	end

	local customsavetitlerow
	if (menu.currentOption == "load") and (#customsaves > 0) and IsCheatVersion() then
		customsavetitlerow = ftable:addRow(nil, {  })
		customsavetitlerow[2]:setColSpan(4):createText("Custom Saves", config.subHeaderTextProperties) -- (cheat only)
		-- sort by name, but don't care whether customsave prefix is followed by _ or -
		local prefixlen = string.len("customsave_")
		if menu.saveSort == "date" then
			table.sort(customsaves, function (a, b) return a.rawtime > b.rawtime end)
		elseif menu.saveSort == "date_inv" then
			table.sort(customsaves, function (a, b) return a.rawtime < b.rawtime end)
		elseif (menu.saveSort == "name_inv") then
			table.sort(customsaves, function (a, b) return string.lower(string.sub(a.filename, prefixlen + 1)) > string.lower(string.sub(b.filename, prefixlen + 1)) end)
		else
			table.sort(customsaves, function (a, b) return string.lower(string.sub(a.filename, prefixlen + 1)) < string.lower(string.sub(b.filename, prefixlen + 1)) end)
		end
		for i, savegame in ipairs(customsaves) do
			local entry = string.format("%s - %s", string.sub(savegame.filename, prefixlen + 1), savegame.displayedname)
			savegame.displayedname = entry
			maxRowHeight = math.max(maxRowHeight, menu.addSavegameRow(ftable, savegame, entry))
		end
	end

	local titletable = frame:addTable(4, { tabOrder = 3, x = menu.table.x, y = menu.table.y, width = menu.table.widthExtraWide, maxVisibleHeight = menu.table.height, skipTabChange = true })
	titletable:setColWidth(1, menu.table.arrowColumnWidth, false)
	titletable:setColWidth(2, ftable.properties.width - menu.table.arrowColumnWidth - Helper.scaleY(config.infoTextHeight) - 2 * Helper.borderSize, false)
	titletable:setColWidth(3, Helper.scaleY(config.infoTextHeight), false)

	-- title
	local row = titletable:addRow({ titlerow = "title" }, { fixed = true })
	if menu.preselectOption == "title" then
		titletable:setSelectedRow(row.index)
	end
	row[1]:setBackgroundColSpan(4):createButton({ height = config.headerTextHeight }):setIcon(config.backarrow, { x = config.backarrowOffsetX })
	row[1].handlers.onClick = function () return menu.onCloseElement("back") end
	row[2]:setColSpan(3):createText(options.name, config.headerTextProperties)

	local offsety = titletable.properties.y + titletable:getFullHeight() + Helper.borderSize
	ftable.properties.y = offsety
	ftable.properties.maxVisibleHeight = math.max(menu.table.height - offsety, maxRowHeight + Helper.borderSize + (customsavetitlerow and (customsavetitlerow:getHeight() + Helper.borderSize) or 0))
	if ftable:hasScrollBar() then
		if (not isonline) or (menu.currentOption ~= "save") then
			nameSortButton.properties.icon.x = nameSortButton.properties.icon.x - Helper.scrollbarWidth
		end
	end

	ftable:setTopRow(menu.preselectTopRow)
	menu.preselectTopRow = nil
	menu.preselectOption = nil

	titletable.properties.nextTable = ftable.index
	ftable.properties.prevTable = titletable.index

	-- infos
	local buttontable = frame:addTable(4, { tabOrder = 2, x = menu.table.x + ftable.properties.width + Helper.borderSize, y = offsety, width = ftable.properties.width - Helper.borderSize, maxVisibleHeight = menu.table.height - offsety, highlightMode = "off" })
	buttontable:setColWidthPercent(2, 16)
	buttontable:setColWidthPercent(3, 16)
	local row = buttontable:addRow(nil, {  })
	row[1]:setColSpan(4):createText(" ")
	-- save name
	local row = buttontable:addRow((menu.currentOption == "save") or (menu.currentOption == "saveoffline"), {  })
	row[1]:setColSpan(2):createText(ReadText(1001, 8970) .. ReadText(1001, 120))
	if (menu.currentOption == "save") or (menu.currentOption == "saveoffline") then
		menu.saveNameEditBox = row[3]:setColSpan(2):createEditBox({ height = config.standardTextHeight, description = ReadText(1001, 8970), active = function () return (menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and (not menu.selectedOption.isonline) end }):setText(menu.savegameName, { fontsize = config.standardFontSize, halign = "right" }):setHotkey("INPUT_STATE_DETAILMONITOR_Y", { displayIcon = true, x = 0 })
		row[3].handlers.onEditBoxActivated = function (widget) menu.noupdate = true end
		row[3].handlers.onEditBoxDeactivated = function (_, text, textchanged) menu.noupdate = nil end
		row[3].handlers.onTextChanged = menu.editboxSaveName
	else
		row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil)) and menu.selectedOption.displayedname or "" end, config.standardRightTextProperties)
	end
	local inforows = {}
	-- player name
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 2809) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil)) and menu.selectedOption.playername or "" end, config.standardRightTextProperties)
	-- money
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 2003) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and menu.selectedOption.playername) and (ConvertMoneyString(menu.selectedOption.money, false, true, 0, true, false).. " " .. ReadText(1001, 101)) or "" end, config.standardRightTextProperties)
	-- location
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 2943) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and menu.selectedOption.playername) and menu.selectedOption.location or "" end, config.standardRightTextProperties)
	-- game time
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 8969) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and menu.selectedOption.playername) and ConvertTimeString(menu.selectedOption.playtime, "%d" .. ReadText(1001, 104) .. " %H" .. ReadText(1001, 102) .. " %M" .. ReadText(1001, 103)) or "" end, config.standardRightTextProperties)
	-- version
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 2655) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(menu.savegameInfoVersion, config.standardRightTextProperties)
	-- gamestart
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(2):createText(ReadText(1001, 8988) .. ReadText(1001, 120))
	row[3]:setColSpan(2):createText(function () return ((menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and menu.selectedOption.gamestart) and menu.selectedOption.gamestart or "" end, config.standardRightTextProperties)
	-- errors
	local row = buttontable:addRow(nil, {  })
	table.insert(inforows, row)
	row[1]:setColSpan(4):createText(menu.errorSavegameInfo(), { color = (menu.currentOption == "load") and Color["text_error"] or Color["text_warning"], wordwrap = true })
	-- buttons
	local row = buttontable:addRow(true, {  })
	if menu.currentOption == "load" then
		row[1]:createButton({ bgColor = function () return menu.isValidSaveSelected() and Color["button_background_default"] or Color["button_background_inactive"] end, highlightColor = function () return menu.isValidSaveSelected() and Color["button_highlight_default"] or Color["button_highlight_inactive"] end }):setText(ReadText(1001, 8966), { halign = "center", color = function () return menu.isValidSaveSelected() and Color["text_normal"] or Color["text_inactive"] end })
		row[1].handlers.onClick = function () if menu.isValidSaveSelected() then menu.loadGameCallback(menu.selectedOption.filename, false) end end
	else
		row[1]:createButton({ active = function () return (menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and (menu.selectedOption.titlerow == nil) and (menu.selectedOption.submenu == nil) end }):setText(function () local isempty = menu.selectedOption and menu.selectedOption.empty; local isonlinesave = menu.selectedOption and menu.selectedOption.isonline; return (Helper.isOnlineGame() and (not isonlinesave)) and (isempty and ReadText(1001, 11701) or ReadText(1001, 11702)) or (isempty and ReadText(1001, 8967) or ReadText(1001, 8968)) end, { halign = "center" })
		row[1].handlers.onClick = menu.buttonOverwriteSave
	end
	row[4]:createButton({ active = function () return (menu.selectedOption ~= nil) and (next(menu.selectedOption) ~= nil) and (menu.selectedOption.titlerow == nil) and (menu.selectedOption.submenu == nil) and (not menu.selectedOption.empty) end }):setText(ReadText(1001, 8931), { halign = "center" }):setHotkey("INPUT_STATE_DETAILMONITOR_X", { displayIcon = true })
	row[4].handlers.onClick = menu.buttonDeleteSave

	if buttontable:hasScrollBar() then
		buttontable.properties.highlightMode = "grey"
		for _, row in ipairs(inforows) do
			row.rowdata = true
		end
	end

	ftable.properties.nextHorizontalTable = buttontable.index
	buttontable.properties.prevHorizontalTable = ftable.index

	frame:display()
end

function ModLua.onUpdate()
	local curtime = getElapsedTime()

	-- kuertee start: callback
	if menu.uix_callbacks ["onUpdate_start"] then
		for uix_id, uix_callback in pairs (menu.uix_callbacks ["onUpdate_start"]) do
			uix_callback(curtime)
		end
	end
	-- kuertee end: callback

	if menu.animationDelay ~= nil then
		if (not menu.animationDelay[3]) and (curtime > menu.animationDelay[1] - menu.animationDelay[4]) then
			menu.animationDelay[3] = true
			C.FadeScreen2(menu.animationDelay[4], 0, menu.animationDelay[5] or 0)
			C.StopVoiceSequence()
			if menu.isStartmenu then
				C.StartStartMenuBGMusic()
			end
		end
		if curtime > menu.animationDelay[1] then
			if menu.currentOption == "multiplayer_server" then
				C.NewMultiplayerGame(menu.animationDelay[2].id)
			else

				-- kuertee start: callback
				if menu.uix_callbacks ["newGameCallback_preNewGame"] then
					for uix_id, uix_callback in pairs (menu.uix_callbacks ["newGameCallback_preNewGame"]) do
						uix_callback(menu.animationDelay[2].id)
					end
				end
				-- kuertee end: callback

				NewGame(menu.animationDelay[2].id)
			end
			menu.closeMenu("close")
		end
	elseif C.IsTradeShowVersion() and (menu.currentOption ~= "idle") and (menu.idleTimer + config.idleTime < curtime) then
		if menu.isStartmenu then
			menu.openSubmenu("idle", menu.selectedOption.id)
		end
	else
		if (not menu.noupdate) and menu.delayedRefresh and (menu.delayedRefresh < curtime) then
			menu.delayedRefresh = nil
			if menu.currentOption ~= "question" then
				menu.refresh()
				return
			end
		end

		if menu.lastSaveUpdateTime + config.saveReloadInterval < curtime then
			menu.autoReloadSave = menu.nameContinue()
			menu.lastSaveUpdateTime = curtime
			menu.savegames = nil
			menu.onlinesave = nil
			C.ReloadSaveList()
			if (menu.currentOption == "save") or (menu.currentOption == "load") or (menu.currentOption == "saveoffline") then
				menu.delayedRefresh = curtime
				return
			end
		end

		local saveloadingcompleted = false
		if menu.savegames == nil then
			if C.IsSaveListLoadingComplete() then
				menu.savegames = GetSaveList(Helper.validSaveFilenames)
				menu.onlinesave = nil
				for _, save in ipairs(menu.savegames) do
					if save.isonline and (save.filename == "online_save") then
						menu.onlinesave = save
						if menu.allBasicTutorialsDone then
							break
						end
					end
					if save.rawversion < 700 then
						menu.allBasicTutorialsDone = true
						if menu.onlinesave then
							break
						end
					end
				end
				if next(menu.savegames) then

					-- table.sort(menu.savegames, function (a, b) return a.rawtime > b.rawtime end)
					-- kuertee start: callback
					if menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"] then
						for uix_id, uix_callback in pairs (menu.uix_callbacks ["displaySaveGameOptions_sortSaveGames"]) do
							uix_callback(menu.savegames, "rawtime", true)
						end
					else
						table.sort(menu.savegames, function (a, b) return a.rawtime > b.rawtime end)
					end
					-- kuertee end: callback

				end
				saveloadingcompleted = true
				menu.autoReloadSave = nil
			end
		end

		if (menu.currentOption == "main") or (menu.currentOption == "sandbox") then
			if saveloadingcompleted then
				-- rebuild the menu (since the current rows are simple (aka: fontstring/unselectable) rows and we cannot just reset them to selectable ones
				-- TODO: #Florian - add support to change whether a row is selectable or not and then replace rebuilding the menu here with simply adjusting the two relevant rows
				menu.preselectOption = Helper.getCurrentRowData(menu, menu.optionTable).id
				menu.submenuHandler(menu.currentOption)
				return
			end
		elseif (menu.currentOption == "new") or (menu.currentOption == "multiplayer_server") or (menu.currentOption == "new_timelines") or (menu.currentOption == "tutorials") then
			if menu.playNewGameCutscene and menu.playNewGameCutscene.movie then
				if not menu.playNewGameCutscene.cutsceneid then
					menu.playNewGameCutscene.cutscenedesc = CreateCutsceneDescriptor(menu.playNewGameCutscene.movie, {})
					menu.playNewGameCutscene.cutsceneid = StartCutscene(menu.playNewGameCutscene.cutscenedesc, GetRenderTargetTexture(menu.rendertarget))
					if menu.playNewGameCutscene.movievoice ~= "" then
						C.StartVoiceSequence2(menu.playNewGameCutscene.movievoice, 0, menu.selectedOption.id)
					end
				end
			end
			if menu.newGameCutsceneTimer and (menu.newGameCutsceneTimer + 1 < curtime) then
				menu.newGameCutsceneTimer = nil
				if menu.selectedOption and (menu.selectedOption.cutscene ~= "") then
					menu.playNewGameCutscene = { id = menu.selectedOption.id, movie = menu.selectedOption.cutscene, movievoice = menu.selectedOption.cutscenevoice }
					menu.refresh()
				end
			end
		elseif menu.currentOption == "lobby" then
			if menu.updateServers then
				menu.drawLobby()
				menu.updateServers = false
			end
		elseif menu.currentOption == "online" then
			if menu.onlineRefresh then
				menu.onlineRefresh = nil
				menu.preselectTopRow = GetTopRow(menu.optionTable)
				menu.preselectOption = menu.preselectOption or Helper.currentTableRow[menu.optionTable]
				menu.displayOnlineLogin()
			end
			if menu.activatePasswordEditBox then
				SelectRow(menu.optionTable, 5)
				Helper.activateEditBox(menu.optionTable, 5, 7)
				menu.activatePasswordEditBox = nil
			end
		elseif menu.currentOption == "credits" then
			if not menu.cutsceneid then
				menu.cutscenedesc = CreateCutsceneDescriptor("credits_movie", {})
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, GetRenderTargetTexture(menu.rendertarget))
				if menu.isStartmenu then
					C.SetSceneCameraActive(false)
					C.StopStartMenuBGMusic()
					Unpause(true)
				end
			end
		elseif menu.currentOption == "idle" then
			if not menu.cutsceneid then
				menu.cutscenedesc = CreateCutsceneDescriptor("idle_movie", {})
				menu.cutsceneid = StartCutscene(menu.cutscenedesc, GetRenderTargetTexture(menu.rendertarget))
				C.StopStartMenuBGMusic()
			end
		elseif menu.currentOption == "question" then
			if menu.questionEditBox then
				ActivateEditBox(menu.questionEditBox.id)
				menu.questionEditBox = nil
			end
		end
		if menu.userQuestion and menu.userQuestion.timer then
			if curtime >= menu.userQuestion.timer then
				if menu.userQuestion.negCallback then
					menu.userQuestion.negCallback()
					menu.userQuestion = nil
				else
					menu.onCloseElement("back")
				end
			end
		end

		if menu.remapControl and menu.remapControl.modifier then
			if menu.directInputActive and (C.IsShiftPressed() or C.IsControlPressed()) then
				menu.unregisterDirectInput()
				menu.remapControl = nil

				-- show popup
				menu.contextMenuMode = "info"
				menu.contextMenuData = { width = Helper.scaleX(400), height = Helper.scaleY(200), y = Helper.scaleY(300), infotitle = ReadText(1001, 12656), infotext = ReadText(1001, 12657) }

				menu.createContextMenu()
			end
		end

		menu.optionsFrame:update()
		if menu.contextFrame then
			menu.contextFrame:update()
		end
	end
end

function ModLua.newGameCallback(option, checked)
	if menu.playNewGameCutscene and menu.playNewGameCutscene.cutsceneid then
		StopCutscene(menu.playNewGameCutscene.cutsceneid)
		C.StopVoiceSequence()
		if menu.playNewGameCutscene.cutscenedesc then
			ReleaseCutsceneDescriptor(menu.playNewGameCutscene.cutscenedesc)
		end
		menu.playNewGameCutscene = {}
	end
	if menu.isStartmenu and (option.intro ~= "") then
		-- use non-zero holdtime to prevent the fade-out ending too early before calling NewGame(), which would result in instant fade-in
		menu.animationDelay = { getElapsedTime() + option.introlength + option.introfadeoutlength, option, false, option.introfadeoutlength, 1.0 }
		menu.displayEmptyMenu()
		C.StartIntroAnimation(option.intro)
		if option.introvoice ~= "" then
			C.StartVoiceSequence2(option.introvoice, 0, option.id)
		end
	else
		if option.customeditor then
			table.insert(menu.history, 1, { optionParameter = menu.currentOption, topRow = GetTopRow(menu.optionTable), selectedOption = option.id })
			__CORE_GAMEOPTIONS_RESTOREINFO.returnhistory = menu.history
			Helper.closeMenuAndOpenNewMenu(menu, "CustomGameMenu", { 0, 0, option.id, menu.currentOption == "multiplayer_server", option.id == "custom_creative", menu.paused ~= nil })
			menu.cleanup()
		elseif option.mapeditor then
			menu.mapEditorSettings = {
				gamestartid = option.id,
				sectors = { all = true },
			}
			menu.openSubmenu("mapeditor", option.id)
		else
			local playerinventory = GetPlayerInventory()
			local onlineitems = OnlineGetUserItems()

			-- kuertee start:
			if not onlineitems then
				onlineitems = {}
			end
			-- kuertee end

			local hasnotuploadeditems = false
			for ware, waredata in Helper.orderedPairs(playerinventory) do
				local isbraneitem, isoperationvolatile, isseasonvolatile, isventureuploadallowed = GetWareData(ware, "isbraneitem", "isoperationvolatile", "isseasonvolatile", "isventureuploadallowed")
				if isbraneitem then
					local serveramount = 0
					if onlineitems[ware] then
						serveramount = onlineitems[ware].amount
					end
					if isventureuploadallowed and (waredata.amount > serveramount) then
						hasnotuploadeditems = true
						break
					end
				end
			end

			if (not checked) and (not menu.isStartmenu) and Helper.isOnlineGame() and hasnotuploadeditems then
				table.insert(menu.history, 1, { optionParameter = menu.currentOption, topRow = GetTopRow(menu.optionTable), selectedOption = option.id })
				menu.displayUserQuestion(ReadText(1001, 2603) .. " - " .. ReadText(1001, 7720), function () return menu.newGameCallback(option, true) end, nil, nil, nil, nil, nil, ReadText(1001, 11707))
			else
				if menu.currentOption == "multiplayer_server" then
					Helper.addDelayedOneTimeCallbackOnUpdate(function () C.NewMultiplayerGame(option.id) end, true, getElapsedTime() + 0.1)
				elseif option.tutorial then
					local value = 1
					if menu.isStartmenu or C.IsTutorial() then
						value = 0
					elseif C.IsTimelinesScenario() or (ffi.string(C.GetGameStartName()) == "x4ep1_gamestart_hub") then
						value = 2
					end
					if value == 1 then
						Helper.addDelayedOneTimeCallbackOnUpdate(function () Helper.closeMenuAndOpenNewMenu(menu, "UserQuestionMenu", { 0, 0, "starttutorial", { option.id, 1 } }); menu.cleanup() end, true, getElapsedTime() + 0.1)
						return
					else

						-- kuertee start: callback
						-- Helper.addDelayedOneTimeCallbackOnUpdate(function () C.SetUserData("tutorial_started_from", tostring(value)); NewGame(option.id) end, true, getElapsedTime() + 0.1)
						Helper.addDelayedOneTimeCallbackOnUpdate(
							function ()
								C.SetUserData("tutorial_started_from", tostring(value));
								if menu.uix_callbacks ["newGameCallback_preNewGame"] then
									for uix_id, uix_callback in pairs (menu.uix_callbacks ["newGameCallback_preNewGame"]) do
										uix_callback(option.id)
									end
								end
								NewGame(option.id)
							end
							, true, getElapsedTime() + 0.1)
						-- kuertee end: callback

					end
				else

					-- kuertee start: callback
					Helper.addDelayedOneTimeCallbackOnUpdate(
						function ()
							if menu.uix_callbacks ["newGameCallback_preNewGame"] then
								for uix_id, uix_callback in pairs (menu.uix_callbacks ["newGameCallback_preNewGame"]) do
									uix_callback(option.id)
								end
							end
							NewGame(option.id) 
						end
						, true, getElapsedTime() + 0.1)
					-- kuertee end: callback

				end
				menu.displayInit()
			end
		end
	end
end

ModLua.rewriteFunctions()

-- kuertee end: rewrites

-- kuertee start: new funcs

function ModLua.addNewFunctions()
	menu.registerCallback = ModLua.registerCallback
	menu.deregisterCallback = ModLua.deregisterCallback
	menu.updateCallback = ModLua.updateCallback
end

menu.uix_callbackCount = 0
function ModLua.registerCallback(callbackName, callbackFunction, id)
	-- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
	-- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
	-- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
	-- note 4: search for the callback names to see where they are executed.
	-- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
	if menu.uix_callbacks [callbackName] == nil then
		menu.uix_callbacks [callbackName] = {}
	end
	if not menu.uix_callbacks[callbackName][id] then
		if not id then
			menu.uix_callbackCount = menu.uix_callbackCount + 1
			id = "_" .. tostring(menu.uix_callbackCount)
		end
		menu.uix_callbacks[callbackName][id] = callbackFunction
		if Helper.isDebugCallbacks then
			Helper.debugText_forced(menu.name .. " uix registerCallback: menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
		end
	else
		Helper.debugText_forced(menu.name .. " uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
	end
end

menu.uix_isDeregisterQueued = nil
menu.uix_callbacks_toDeregister = {}
function ModLua.deregisterCallback(callbackName, callbackFunction, id)
	if not menu.uix_callbacks_toDeregister[callbackName] then
		menu.uix_callbacks_toDeregister[callbackName] = {}
	end
	if id then
		table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
	else
		if menu.uix_callbacks[callbackName] then
			for id, func in pairs(menu.uix_callbacks[callbackName]) do
				if func == callbackFunction then
					table.insert(menu.uix_callbacks_toDeregister[callbackName], id)
				end
			end
		end
	end
	if not menu.uix_isDeregisterQueued then
		menu.uix_isDeregisterQueued = true
		Helper.addDelayedOneTimeCallbackOnUpdate(ModLua.deregisterCallbacksNow, true, getElapsedTime() + 1)
	end
end

function ModLua.deregisterCallbacksNow()
	menu.uix_isDeregisterQueued = nil
	for callbackName, ids in pairs(menu.uix_callbacks_toDeregister) do
		if menu.uix_callbacks[callbackName] then
			for _, id in ipairs(ids) do
				if menu.uix_callbacks[callbackName][id] then
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
					end
					menu.uix_callbacks[callbackName][id] = nil
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][id]))
					end
				else
					Helper.debugText_forced(menu.name .. " uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
				end
			end
		end
	end
	menu.uix_callbacks_toDeregister = {}
end

menu.uix_isUpdateQueued = nil
menu.uix_callbacks_toUpdate = {}
function ModLua.updateCallback(callbackName, id, callbackFunction)
	if not menu.uix_callbacks_toUpdate[callbackName] then
		menu.uix_callbacks_toUpdate[callbackName] = {}
	end
	if id then
		table.insert(menu.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
	end
	if not menu.uix_isUpdateQueued then
		menu.uix_isUpdateQueued = true
		Helper.addDelayedOneTimeCallbackOnUpdate(ModLua.updateCallbacksNow, true, getElapsedTime() + 1)
	end
end

function ModLua.updateCallbacksNow()
	menu.uix_isUpdateQueued = nil
	for callbackName, updateDatas in pairs(menu.uix_callbacks_toUpdate) do
		if menu.uix_callbacks[callbackName] then
			for _, updateData in ipairs(updateDatas) do
				if menu.uix_callbacks[callbackName][updateData.id] then
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (pre): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
					end
					menu.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
					if Helper.isDebugCallbacks then
						Helper.debugText_forced(menu.name .. " uix updateCallbacksNow (post): menu.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(menu.uix_callbacks[callbackName][updateData.id]))
					end
				else
					Helper.debugText_forced(menu.name .. " uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
				end
			end
		end
	end
end

ModLua.addNewFunctions()

-- kuertee end: new funcs
if Helper.uix_callbacks then
    -- OptionsMenu already UIX initialised by stand-alone UIX mod, do not continue with this file.
    Helper.debugText_forced("helper_uix.lua already loaded by stand-alone UIX mod.")
    return
end

local ModLua = {}

local ffi = require("ffi")
local C = ffi.C
ffi.cdef[[]]

-- kuertee start: colour backward compatibility
Helper.standardColor = { r = 255, g = 255, b = 255, a = 100 }
Helper.defaultHeaderBackgroundColor = { r = 0, g = 0, b = 0, a = 60 }
Helper.defaultSimpleBackgroundColor = { r = 66, g = 92, b = 111, a = 60 }
Helper.defaultTitleBackgroundColor = { r = 49, g = 69, b = 83, a = 60 }
Helper.defaultArrowRowBackgroundColor = { r = 83, g = 116, b = 139, a = 60 }
Helper.defaultUnselectableBackgroundColor = { r = 35, g = 53, b = 71, a = 60 }
Helper.defaultUnselectableFontColor = { r = 163, g = 193, b = 227, a = 100 }
Helper.defaultButtonBackgroundColor = { r = 49, g = 69, b = 83, a = 60 }
Helper.defaultUnselectableButtonBackgroundColor = { r = 31, g = 31, b = 31, a = 100 }
Helper.defaultButtonHighlightColor = { r = 71, g = 136, b = 184, a = 100 }
Helper.defaultUnselectableButtonHighlightColor = { r = 80, g = 80, b = 80, a = 100 }
Helper.defaultCheckBoxBackgroundColor = { r = 66, g = 92, b = 111, a = 100 }
Helper.defaultEditBoxBackgroundColor = { r = 49, g = 69, b = 83, a = 60 }
Helper.defaultSliderCellBackgroundColor = { r = 22, g = 34, b = 41, a = 60 }
Helper.defaultSliderCellInactiveBackgroundColor = { r = 40, g = 40, b = 40, a = 60 }
Helper.defaultSliderCellValueColor = { r = 99, g = 138, b = 166, a = 100 }
Helper.defaultSliderCellPositiveValueColor = { r = 29, g = 216, b = 35, a = 30 }
Helper.defaultSliderCellNegativeValueColor = { r = 216, g = 68, b = 29, a = 30 }
Helper.defaultStatusBarValueColor = { r = 71, g = 136, b = 184, a = 100 }
Helper.defaultStatusBarPosChangeColor = { r = 20, g = 222, b = 20, a = 30 }
Helper.defaultStatusBarNegChangeColor = { r = 236, g = 53, b = 0, a = 30 }
Helper.defaultStatusBarMarkerColor = { r = 151, g = 192, b = 223, a = 100 }
Helper.defaultBoxTextBoxColor = { r = 49, g = 69, b = 83, a = 60 }
Helper.defaultFlowchartOutlineColor = { r = 90, g = 146, b = 186, a = 100 }			-- light cyan
Helper.defaultFlowchartBackgroundColor = { r = 25, g = 25, b = 25, a = 100 }			-- dark grey
Helper.defaultFlowchartValueColor = { r = 0, g = 116, b = 153, a = 100 }				-- cyan
Helper.defaultFlowchartSlider1Color = { r = 225, g = 149, b = 0, a = 100 }			-- orange
Helper.defaultFlowchartDiff1Color = { r = 89, g = 52, b = 0, a = 100 }				-- brown
Helper.defaultFlowchartSlider2Color = { r = 66, g = 171, b = 61, a = 100 }			-- green
Helper.defaultFlowchartDiff2Color = { r = 4, g = 89, b = 0, a = 100 }					-- dark green
Helper.defaultFlowchartConnector1Color = { r = 255, g = 220, b = 0, a = 100 }			-- yellow
Helper.defaultFlowchartConnector2Color = { r = 0, g = 154, b = 204, a = 100 }			-- light cyan
Helper.defaultFlowchartConnector3Color = { r = 224, g = 79, b = 0, a = 100 }			-- dark orange
Helper.defaultFlowchartConnector4Color = { r = 255, g = 153, b = 255, a = 100 }		-- pink
Helper.defaultTitleTrapezoidBackgroundColor = { r = 66, g = 92, b = 111, a = 100 }
Helper.statusRed = {r = 255, g = 0, b = 0, a = 100}
Helper.statusOrange = {r = 255, g = 64, b = 0, a = 100}
Helper.statusYellow = {r = 255, g = 255, b = 0, a = 100}
Helper.statusGreen = {r = 0, g = 255, b = 0, a = 100}
-- kuertee end: colour backward compatibility

-- kuertee start: colour backward compatibility
Helper.color = {
	black = { r = 0, g = 0, b = 0, a = 100 },
	slidervalue = { r = 71, g = 136, b = 184, a = 100 },
	green = { r = 0, g = 255, b = 0, a = 100 },
	playergreen = { r = 170, g = 255, b = 139, a = 100 },
	grey = { r = 128, g = 128, b = 128, a = 100 },
	lightgreen = { r = 100, g = 225, b = 0, a = 100 },
	lightgrey = { r = 192, g = 192, b = 192, a = 100 },
	orange = { r = 255, g = 192, b = 0, a = 100 },
	darkorange = { r = 128, g = 95, b = 0, a = 100 },
	red = { r = 255, g = 0, b = 0, a = 100 },
	semitransparent = { r = 0, g = 0, b = 0, a = 95 },
	transparent60 = { r = 0, g = 0, b = 0, a = 60 },
	transparent = { r = 0, g = 0, b = 0, a = 0 },
	white = { r = 255, g = 255, b = 255, a = 100 },
	yellow = { r = 144, g = 144, b = 0, a = 100 },
	brightyellow = { r = 255, g = 255, b = 0, a = 100 },
	warning = { r = 192, g = 192, b = 0, a = 100 },
	done = { r = 38, g = 61, b = 78, a = 100 },
	available = { r = 7, g = 29, b = 46, a = 100 },
	darkgrey = { r = 32, g = 32, b = 32, a = 100 },
	mission = { r = 255, g = 190, b = 0, a = 100 },
	warningorange = { r = 255, g = 138, b = 0, a = 100 },
	blue = { r = 90, g = 146, b = 186, a = 100 },
	changedvalue = { r = 255, g = 236, b = 81, a = 100 },
	cyan = { r = 46, g = 209, b = 255, a = 100 },
	checkboxgroup = { r = 0, g = 102, b = 238, a = 60 },
	unselectable = { r = 32, g = 32, b = 32, a = 100 },
	cover = { r = 231, g = 244, b = 70, a = 100 },
	textred = { r = 255, g = 80, b = 80, a = 100 },
	grey64 = { r = 64, g = 64, b = 64, a = 100 },
	illegal = { r = 255, g = 64, b = 0, a = 100 },
	illegaldark = { r = 128, g = 32, b = 0, a = 100 },
}
-- kuertee end: colour backward compatibility

local origreadtext = ReadText
ReadText = function(page, line) 
	-- kuertee start:
	if page and line then
		local refstr = page .. "-" .. line
		local text = Helper.texts[refstr]
		if not text then
			text = origreadtext(page, line)
			Helper.texts[refstr] = text
		end
		return text
	else
		return ""
	end
	-- kuertee end
end

-- kuertee start: more save games
-- for i = 1, 10 do
Helper.maxSaveFiles = 20
for i = 1, Helper.maxSaveFiles do
-- kuertee end: more save games
	Helper.validSaveFilenames[string.format("save_%03d", i)] = true
end

-- kuertee start: rewrites

local OldFuncs = {}
Helper.uix_callbacks = {}

function ModLua.rewriteFunctions()
	OldFuncs.onUpdate = Helper.onUpdate
	Helper.onUpdate = ModLua.onUpdate
	OldFuncs.getPassedTime = Helper.getPassedTime
	Helper.getPassedTime = ModLua.getPassedTime
	OldFuncs.checkTopLevelConditions = Helper.checkTopLevelConditions
	Helper.checkTopLevelConditions = ModLua.checkTopLevelConditions
	OldFuncs.createLSOStorageNode = Helper.createLSOStorageNode
	Helper.createLSOStorageNode = ModLua.createLSOStorageNode
	OldFuncs.updateLSOStorageNode = Helper.updateLSOStorageNode
	Helper.updateLSOStorageNode = ModLua.updateLSOStorageNode
	OldFuncs.onExpandLSOStorageNode = Helper.onExpandLSOStorageNode
	Helper.onExpandLSOStorageNode = ModLua.onExpandLSOStorageNode
	OldFuncs.checkboxSetTradeRuleOverride = Helper.checkboxSetTradeRuleOverride
	Helper.checkboxSetTradeRuleOverride = ModLua.checkboxSetTradeRuleOverride
	OldFuncs.dropdownTradeRule = Helper.dropdownTradeRule
	Helper.dropdownTradeRule = ModLua.dropdownTradeRule
	OldFuncs.onCollapseLSOStorageNode = Helper.onCollapseLSOStorageNode
	Helper.onCollapseLSOStorageNode = ModLua.onCollapseLSOStorageNode
	OldFuncs.getLimitedWareAmount = Helper.getLimitedWareAmount
	Helper.getLimitedWareAmount = ModLua.getLimitedWareAmount
	OldFuncs.getLimitedWareAmount = Helper.getLimitedWareAmount
	Helper.getLimitedWareAmount = ModLua.getLimitedWareAmount
end

function ModLua.onUpdate()
	-- call registered onUpdate callbacks
	if #onUpdateOneTimeCallbacks > 0 then
		-- clear list of one-time callbacks before calling them
		local currentcallbacks = onUpdateOneTimeCallbacks
		onUpdateOneTimeCallbacks = {}
		for _, callback in ipairs(currentcallbacks) do
			callback()
		end
	end
	if onUpdateHandler then
		onUpdateHandler()
	end
	if onChatUpdateHandler then
		onChatUpdateHandler()
	end

	-- kuertee start: callback
	if Helper.uix_callbacks ["onUpdate"] then
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onUpdate"]) do
			name = uix_callback ()
		end
	end
	-- kuertee end: callback
end

function ModLua.getPassedTime(time)
	local passedtime = C.GetCurrentGameTime() - time
	if passedtime < 0 then
		print("Helper.getPassedTime(): given time is in the future. Returning empty result")
		return ""
	end

	-- kuertee start:
	if passedtime < 60 * 60 then
		local timeformat = ReadText(1001, 209)
		return ConvertTimeString(passedtime, timeformat)
	end
	-- kuertee end

	local timeformat = ReadText(1001, 211)
	if passedtime < 3600 then
		timeformat = ReadText(1001, 213)
	elseif passedtime < 3600 * 24 then
		timeformat = ReadText(1001, 212)
	end

	return ConvertTimeString(passedtime, timeformat)
end

function ModLua.checkTopLevelConditions(entry)
	local isdocked = false
	local currentplayership = ConvertStringTo64Bit(tostring(C.GetPlayerOccupiedShipID()))
	if currentplayership ~= 0 then
		if GetComponentData(currentplayership, "isdocked") then
			isdocked = true
		end
	else
		local currentcontainer = ConvertStringTo64Bit(tostring(C.GetContextByClass(C.GetPlayerID(), "container", false)))
		if (not C.IsComponentClass(currentcontainer, "ship")) or GetComponentData(currentcontainer, "isdocked") then
			isdocked = true
		end
	end

	if (entry.needsdock ~= nil) and (entry.needsdock ~= isdocked) then
		return false
	end
	if (entry.demo ~= nil) and (entry.demo ~= C.IsDemoVersion()) then
		return false
	end
	if (entry.canresearch ~= nil) and (entry.canresearch ~= C.CanResearch()) then
		return false
	end
	if (entry.canterraform ~= nil) then
		local stationhqlist = {}
		Helper.ffiVLA(stationhqlist, "UniverseID", C.GetNumHQs, C.GetHQs, "player")
		local hq = stationhqlist[1] or 0

		if hq == 0 then
			return not entry.canterraform
		end

		local hqcluster = C.GetContextByClass(hq, "cluster", false)
		return GetComponentData(ConvertStringTo64Bit(tostring(hqcluster)), "hasterraforming") and (C.GetNumTerraformingProjects(hqcluster, false) > 0)
	end
	if (entry.isonline ~= nil) and (entry.isonline ~= (C.AreVenturesCompatible() and (C.IsVentureSeasonSupported() or C.WasSessionOnline()))) then
		return false
	end
	if (entry.istimelinescenario ~= nil) and (entry.istimelinescenario ~= (C.IsTimelinesScenario() or (ffi.string(C.GetGameStartName()) == "x4ep1_gamestart_hub"))) then
		return false
	end

	-- kuertee start: callback
	if Helper.uix_callbacks ["checkTopLevelConditions_get_is_entry_available"] then
		local isAvailable = true
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["checkTopLevelConditions_get_is_entry_available"]) do
			isAvailable = uix_callback (entry)
			if isAvailable ~= true then
				return false
			end
		end
	end
	-- kuertee end: callback

	return true
end

function ModLua.createLSOStorageNode(menu, container, ware, planned, hasstorage, iscargo)
	local storageinfo_amounts  = C.IsInfoUnlockedForPlayer(container, "storage_amounts")
	local storageinfo_warelist = C.IsInfoUnlockedForPlayer(container, "storage_warelist")
	local storageinfo_capacity = C.IsInfoUnlockedForPlayer(container, "storage_capacity")

	local name, transporttype = GetWareData(ware, "name", "transport")

	-- kuertee start: callback
	if Helper.uix_callbacks ["createLSOStorageNode_get_ware_name"] then
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["createLSOStorageNode_get_ware_name"]) do
			name = uix_callback (ware)
		end
	end
	-- kuertee end: callback

	local cargo, isplayerowned = GetComponentData(container, "cargo", "isplayerowned")
	local productionlimit = 0
	if C.IsComponentClass(container, "container") then
		productionlimit = GetWareProductionLimit(container, ware)
	end
	local hasrestrictions = Helper.isTradeRestricted(container, ware)

	local shownamount = storageinfo_amounts and cargo[ware] or 0
	local shownmax = storageinfo_capacity and math.max(shownamount, productionlimit) or shownamount
	local buylimit, selllimit
	if isplayerowned then
		if C.HasContainerBuyLimitOverride(container, ware) then
			buylimit = math.max(0, math.min(shownmax, C.GetContainerBuyLimit(container, ware)))
		end
		if C.HasContainerSellLimitOverride(container, ware) then
			selllimit = math.max(buylimit or 0, math.min(shownmax, C.GetContainerSellLimit(container, ware)))
		end
	end

	local warenode = {
		cargo = iscargo,
		ware = ware,
		text = Helper.unlockInfo(storageinfo_warelist, name),
		type = transporttype,
		planned = planned,
		hasstorage = hasstorage,
		row = iscargo and 1 or nil,
		col = iscargo and 1 or nil,
		numrows = iscargo and 1 or nil,
		numcols = iscargo and 1 or nil,
		-- storage module
		{
			properties = {
				value = shownamount,
				max = shownmax,
				step = 1,
				slider1 = buylimit,
				slider2 = selllimit,
				helpOverlayID = "station_overview_storage_" .. ware,
				helpOverlayText = " ",
				helpOverlayHighlightOnly = true,
				uiTriggerID = "storage_" .. ware,
			},
			isstorage = true,
			expandedTableNumColumns = 3,
			expandHandler = function (...) return Helper.onExpandLSOStorageNode(menu, container, ...) end,
			collapseHandler = function (...) return Helper.onCollapseLSOStorageNode(menu, ...) end,
			sliderHandler = function (...) return Helper.onSliderChangedLSOStorageNode(container, ...) end,
			color = (not hasstorage) and Color["lso_node_inactive"] or nil,
			statuscolor = (not iscargo) and ((not hasstorage) and Color["icon_error"] or (hasrestrictions and Color["icon_warning"] or nil) or nil),
			statusIcon = (not iscargo) and ((not hasstorage) and "lso_warning" or (hasrestrictions and "lso_error" or nil) or nil),
		}
	}
	return warenode
end

function ModLua.updateLSOStorageNode(menu, node, container, ware)
	local hasrestrictions = Helper.isTradeRestricted(container, ware)
	local hasstorage = node.customdata.nodedata.hasstorage
	local edgecolor = Color["flowchart_edge_default"]

	local statusicon = hasrestrictions and "lso_error" or nil
	local statusiconmouseovertext = hasrestrictions and (ColorText["text_warning"] .. ReadText(1026, 8404)) or ""
	local statuscolor = hasrestrictions and Color["icon_warning"] or nil

	if not hasstorage then
		statusicon = "lso_warning"
		statuscolor = Color["icon_error"]
		statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8416)
	elseif menu.resourcesmissing[ware] then
		statusicon = "lso_warning"
		statuscolor = Color["icon_error"]
		statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8437)
	elseif menu.storagemissing[ware] then
		statusicon = "lso_warning"
		statuscolor = Color["icon_error"]
		statusiconmouseovertext = ColorText["text_error"] .. ReadText(1001, 8438)
	end

	if not statusicon then
		if C.IsComponentClass(container, "container") then
			if HasContainerStockLimitOverride(container, ware) then
				statusicon = "lso_override"
				statuscolor = Color["flowchart_node_default"]
				statusiconmouseovertext = ReadText(1026, 8410)

				local currentlimit = GetWareProductionLimit(container, ware)
				local defaultlimit = C.GetContainerWareMaxProductionStorageForTime(container, ware, 7200, true)
				local waretype = Helper.getContainerWareType(container, ware)
				if (waretype ~= "trade") and (currentlimit < defaultlimit) then
					statuscolor = Color["icon_warning"]
					statusiconmouseovertext = ColorText["text_warning"] .. ReadText(1001, 8467)
				end
			end
		end
	end

	if not C.IsInfoUnlockedForPlayer(container, "storage_amounts") then
		statusicon = nil
		statusbgicon = nil
	end

	if menu.storagemissing[ware] then
		edgecolor = Color["lso_node_error"]
	end

	local storageinfo_amounts = C.IsInfoUnlockedForPlayer(container, "storage_amounts")
	local amount = 0
	if storageinfo_amounts then
		amount = GetComponentData(container, "cargo")[ware] or 0
	end
	local max = 0
	if C.IsComponentClass(container, "controllable") then
		max = math.max(amount, GetWareProductionLimit(container, ware))
	end
	if max < node.properties.value then
		node:updateValue(amount)
	end
	if max > node.properties.max then
		node:updateMaxValue(max)
	end
	if node.properties.slider1 >= 0 then
		local slider1 = math.max(0, math.min(max, C.GetContainerBuyLimit(container, ware)))
		node:updateSlider1(slider1)
	end
	if node.properties.slider2 >= 0 then
		local slider2 = math.max(0, math.min(max, C.GetContainerSellLimit(container, ware)))
		node:updateSlider2(slider2)
	end
	if max < node.properties.max then
		node:updateMaxValue(max)
	end
	node:updateValue(amount)

	-- kuertee start: callback
	if Helper.uix_callbacks ["updateLSOStorageNode_pre_update_expanded_node"] then
		-- function widgetPrototypes.flowchartnode:updateStatus(text, icon, bgicon, color, mouseovertext)
		local status_text = nil
		local status_icon = statusicon
		local status_bgicon = nil
		local status_color = statuscolor
		local status_mouseovertext = statusiconmouseovertext
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["updateLSOStorageNode_pre_update_expanded_node"]) do
			status_text, status_icon, status_bgicon, status_color, status_mouseovertext = uix_callback(menu, node, container, ware, status_text, status_icon, status_bgicon, status_color, status_mouseovertext)
		end
		node:updateStatus(status_text, status_icon, status_bgicon, status_color, status_mouseovertext)
	else

		node:updateStatus(nil, statusicon, nil, statuscolor, statusiconmouseovertext)
	end
	-- kuertee end: callback

	for _, edge in ipairs(node.incomingEdges) do
		menu.updateEdgeColorRecursively(edge, edgecolor)
	end
end

function ModLua.onExpandLSOStorageNode(menu, container, _, ftable, _, nodedata)
	if not menu.wareReservationRegistered then
		RegisterEvent("newWareReservation", menu.newWareReservationCallback)
		menu.wareReservationRegistered = true
	end

	local storagename, minprice, maxprice, isprocessed = GetWareData(nodedata.ware, "storagename", "minprice", "maxprice", "isprocessed")
	local storageinfo_capacity =	C.IsInfoUnlockedForPlayer(container, "storage_capacity")
	local storageinfo_amounts =		C.IsInfoUnlockedForPlayer(container, "storage_amounts")

	local waretype = Helper.getContainerWareType(container, nodedata.ware)

	local reservations = {}
	local n = C.GetNumContainerWareReservations2(container, false, false, true)
	local buf = ffi.new("WareReservationInfo2[?]", n)
	n = C.GetContainerWareReservations2(buf, n, container, false, false, true)
	for i = 0, n - 1 do
		local issupply = buf[i].issupply
		if not issupply then
			local ware = ffi.string(buf[i].ware)
			local buyflag = buf[i].isbuyreservation and "selloffer" or "buyoffer" -- sic! Reservation to buy -> container is selling
			local invbuyflag = buf[i].isbuyreservation and "buyoffer" or "selloffer"
			local tradedeal = buf[i].tradedealid
			if not Helper.dirtyreservations[tostring(tradedeal)] then
				if reservations[ware] then
					table.insert(reservations[ware][buyflag], { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal, issupply = issupply })
				else
					reservations[ware] = { [buyflag] = { { reserver = buf[i].reserverid, amount = buf[i].amount, eta = buf[i].eta, tradedeal = tradedeal, issupply = buf[i].issupply } }, [invbuyflag] = {} }
				end
			end
		end
	end
	for _, data in pairs(reservations) do
		table.sort(data.buyoffer, Helper.sortETA)
		table.sort(data.selloffer, Helper.sortETA)
	end

	ftable:setColWidthPercent(2, 30)
	ftable:setColWidth(3, Helper.scaleY(Helper.standardButtonHeight), false)
	local row
	if storageinfo_amounts then
		if nodedata.hasstorage and (not nodedata.planned) then
			local shown = false
			if menu.resourcesmissing[nodedata.ware] then
				shown = true
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(ReadText(1001, 8437), { color = Color["text_error"] })
			end
			if menu.storagemissing[nodedata.ware] then
				shown = true
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(ReadText(1001, 8438), { color = Color["text_error"] })
			end
			if shown then
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText("")
			end
		end
	end

	local limitslider
	if isprocessed then
		-- resource buffer
		row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(ReadText(20206, 1301), { halign = "right" })
		-- amount
		row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(function () return Helper.getResourceBufferAmount(container, nodedata.ware, storageinfo_amounts) end, { halign = "right" })
	else
		-- storage
		row = ftable:addRow(nil, {  })
		row[1]:createText(ReadText(1001, 2415) .. ReadText(1001, 120))
		row[2]:setColSpan(2):createText(storagename, { halign = "right" })
		-- missing storage type
		if not nodedata.hasstorage then
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 8416), { color = Color["text_error"], wordwrap = true })
		end
		if C.IsComponentClass(container, "container") then
			if not isprocessed then
				-- amount
				row = ftable:addRow(nil, {  })
				row[1]:createText(ReadText(1001, 6521) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () return Helper.getStorageAmount(container, nodedata, storageinfo_amounts, storageinfo_capacity) end, { halign = "right", mouseOverText = function () return Helper.getStorageAmount(container, nodedata, storageinfo_amounts, storageinfo_capacity, 0, true) end })

				ftable:addEmptyRow(Helper.standardTextHeight / 2)

				row = ftable:addRow(nil, {  })
				row[1]:createText(ReadText(1001, 1600) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () local production = C.GetContainerWareProduction(container, nodedata.ware, false); return Helper.unlockInfo(storageinfo_amounts, (production > 0) and ConvertIntegerString(production, true, 3, true, true) or "-") end, { halign = "right" })
				row = ftable:addRow(nil, {  })
				row[1]:createText(ReadText(1001, 1609) .. " / " .. ReadText(1001, 102) .. ReadText(1001, 120))
				row[2]:setColSpan(2):createText(function () local consumption = C.GetContainerWareConsumption(container, nodedata.ware, false) + Helper.getWorkforceConsumption(container, nodedata.ware); return Helper.unlockInfo(storageinfo_amounts, (consumption > 0) and ConvertIntegerString(consumption, true, 3, true, true) or "-") end, { halign = "right" })
				ftable:addEmptyRow(Helper.standardTextHeight / 2)
			end

			if nodedata.hasstorage and (not nodedata.planned) and GetComponentData(container, "isplayerowned") then
				local currentlimit = GetWareProductionLimit(container, nodedata.ware)
				if (not nodedata.cargo) or (currentlimit > 0) then
					local haslimitoverride = HasContainerStockLimitOverride(container, nodedata.ware)
					-- Automatically allocated capacity
					local n = C.GetNumContainerStockLimitOverrides(container)
					if n > 0 then
						local name, capacity = "", 0
						local n = C.GetNumCargoTransportTypes(container, true)
						local buf = ffi.new("StorageInfo[?]", n)
						n = C.GetCargoTransportTypes(buf, n, container, true, false)
						for i = 0, n - 1 do
							if ffi.string(buf[i].transport) == nodedata.type then
								name = ffi.string(buf[i].name)
								capacity = buf[i].capacity
								break
							end
						end

						row = ftable:addRow(nil, {  })
						row[1]:setColSpan(3):createText(ReadText(1001, 8444) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8403) })
						row = ftable:addRow(nil, {  })
						row[1]:createText(name)
						row[2]:setColSpan(2):createText(
							function()
								local total = 0
								local n = C.GetNumContainerStockLimitOverrides(container)
								local buf = ffi.new("UIWareInfo[?]", n)
								n = C.GetContainerStockLimitOverrides(buf, n, container)
								for i = 0, n - 1 do
									local ware = ffi.string(buf[i].ware)
									local transporttype, volume = GetWareData(ware, "transport", "volume")
									if transporttype == nodedata.type then
										total = total + buf[i].amount * volume
									end
								end
								local available = math.max(0, capacity - total)
								local color = Color["text_normal"]
								if available == 0 then
									color = Color["text_error"]
								elseif available < 0.1 * capacity then
									color = Color["text_warning"]
								end
								return Helper.unlockInfo(storageinfo_amounts, Helper.convertColorToText(color) .. ConvertIntegerString(available, true, 3, true, true) .. " " .. ReadText(1001, 110))
							end,
							{ halign = "right" }
						)
					end
					-- automatic storage level
					local row = ftable:addRow("autostoragecheckbox", {  })
					if menu.selectedRowData["nodeTable"] == "autostoragecheckbox" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(2):createText(ReadText(1001, 8439) .. ReadText(1001, 120))
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageLevelOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
					if haslimitoverride then
						-- price
						local row = ftable:addRow("autostorageslider", {  })
						if menu.selectedRowData["nodeTable"] == "autostorageslider" then
							menu.selectedRows["nodeTable"] = row.index
							menu.selectedRowData["nodeTable"] = nil
						end
						local max = GetWareCapacity(container, nodedata.ware)
						limitslider = row[1]:setColSpan(3):createSliderCell({
							height = Helper.standardTextHeight,
							bgColor = haslimitoverride and Color["slider_background_default"] or Color["slider_background_inactive"],
							valueColor = haslimitoverride and Color["slider_value"] or Color["slider_value_inactive"],
							min = 0,
							minSelect = 1,
							max = max,
							start = math.max(1, math.min(max, currentlimit)),
							hideMaxValue = true,
							readOnly = not haslimitoverride,
							forceArrows = true,
						})
					end
				end
			end
		end
	end
	if nodedata.hasstorage and (not nodedata.planned) and GetComponentData(container, "isplayerowned") then
		Helper.LSOStorageNodeBuySlider = nil
		Helper.LSOStorageNodeSellSlider = nil
		-- buy offer
		if (waretype == "resource") or (waretype == "intermediate") or (waretype == "product") or (waretype == "trade") then
			-- kuertee start: callback
			if Helper.uix_callbacks ["onExpandLSOStorageNode_pre_buy_offer_title"] then
				for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onExpandLSOStorageNode_pre_buy_offer_title"]) do
					uix_callback(menu, container, ftable, nodedata)
				end
			end
			-- kuertee end: callback

			local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, true))))
			local haspriceoverride = HasContainerWarePriceOverride(container, nodedata.ware, true)
			local istradewarebought = C.GetContainerWareIsBuyable(container, nodedata.ware)
			local currentlimit = C.GetContainerBuyLimit(container, nodedata.ware)
			local haslimitoverride = C.HasContainerBuyLimitOverride(container, nodedata.ware)
			-- title
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 8309), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			if (waretype == "resource") or (waretype == "intermediate") or istradewarebought or haslimitoverride then
				-- automatic buy limit
				local row = ftable:addRow("autobuylimitcheckbox", {  })
				if menu.selectedRowData["nodeTable"] == "autobuylimitcheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if (waretype == "product") and istradewarebought then
					-- Valid case, but we need to hide it from the player
					currentlimit = math.max(1, currentlimit)
					Helper.setBuyLimit(menu, container, nodedata.ware, currentlimit)
					haslimitoverride = true
				end
				if (waretype == "product") then
					row[1]:setColSpan(3):createText(ReadText(1001, 11281) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8401) })
				else
					if haslimitoverride then
						row[1]:setColSpan(2):createText(ReadText(1001, 11281) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8401) })
					else
						row[1]:setColSpan(2):createText(ReadText(1001, 8440), { mouseOverText = ReadText(1026, 8408) })
					end
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxBuyLimitOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
				end
				-- buy limit
				local row = ftable:addRow("autobuylimitslider", {  })
				if menu.selectedRowData["nodeTable"] == "autobuylimitslider" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				local max = GetWareProductionLimit(container, nodedata.ware)
				Helper.LSOStorageNodeBuySlider = { ware = nodedata.ware, widget = row[1]:setColSpan(3):createSliderCell({
					height = Helper.standardTextHeight,
					bgColor = haslimitoverride and Color["slider_background_default"] or Color["slider_background_inactive"],
					valueColor = haslimitoverride and Color["slider_value"] or Color["slider_value_inactive"],
					min = 0,
					minSelect = max == 0 and 0 or 1,
					max = max,
					start = math.min(max, currentlimit),
					hideMaxValue = true,
					readOnly = not haslimitoverride,
					forceArrows = true,
				})}
				-- automatic pricing
				local row = ftable:addRow("autobuypricecheckbox", {  })
				if menu.selectedRowData["nodeTable"] == "autobuypricecheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if haspriceoverride then
					row[1]:setColSpan(2):createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
				else
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
					row[2]:createText(function () return ConvertMoneyString(math.max(minprice, math.min(maxprice, GetContainerWarePrice(container, nodedata.ware, true))), true, true, 2, true) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				end
				row[3]:createCheckBox(not haspriceoverride, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageWarePriceOverride(menu, container, nodedata.ware, row.index, true, currentprice, checked) end
				if haspriceoverride then
					-- price
					local row = ftable:addRow("autobuypriceslider", {  })
					if menu.selectedRowData["nodeTable"] == "autobuypriceslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						bgColor = haslimitoverride and Color["slider_background_default"] or Color["slider_background_inactive"],
						valueColor = haspriceoverride and Color["slider_value"] or Color["slider_value_inactive"],
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
						forceArrows = true,
					})
					row[1].handlers.onSliderCellChanged = function(_, value) return Helper.slidercellStorageWarePriceOverride(container, nodedata.ware, true, value) end
					row[1].handlers.onSliderCellActivated = function (id) menu.noupdate = true end
					row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
				end
				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(container, "buy", nodedata.ware)
				local traderuleid = C.GetContainerTradeRuleID(container, "buy", nodedata.ware)
				local row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = ftable:addRow("buytraderule_global", {  })
				row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
				row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function(_, checked) return Helper.checkboxSetTradeRuleOverride(menu, container, "buy", nodedata.ware, checked) end
				-- current
				local row = ftable:addRow("buytraderule_current", {  })
				row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return Helper.dropdownTradeRule(menu, container, "buy", nodedata.ware, id) end
				row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
				row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[3].handlers.onClick = function () return Helper.buttonEditTradeRule(menu, C.GetContainerTradeRuleID(container, "buy", nodedata.ware)) end
			end
			-- create / remove offer
			if (waretype == "trade") or (waretype == "product") then
				row = ftable:addRow("tradebuy", {  })
				if menu.selectedRowData["nodeTable"] == "trade" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if waretype == "trade" then
					row[1]:setColSpan(3):createButton({  }):setText(istradewarebought and ReadText(1001, 8407) or ReadText(1001, 8406), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageBuyTradeWare(menu, container, nodedata.ware, istradewarebought) end
				elseif waretype == "product" then
					row[1]:setColSpan(3):createButton({  }):setText((haslimitoverride or istradewarebought) and ReadText(1001, 8407) or ReadText(1001, 8406), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageBuyProductWare(menu, container, nodedata.ware, haslimitoverride or istradewarebought, currentlimit) end
				end
			end
			-- reservations
			if reservations[nodedata.ware] and (#reservations[nodedata.ware].buyoffer > 0) then
				-- title
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(string.format(ReadText(1001, 7994), GetWareData(nodedata.ware, "name")) .. ReadText(1001, 120), { wordwrap = true })
				for i, reservation in ipairs(reservations[nodedata.ware].buyoffer) do
					row = ftable:addRow("buyreservation" .. i, {  })
					if menu.selectedRowData["nodeTable"] == "buyreservation" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
					local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"

					-- kuertee start: callback
					-- row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					if Helper.uix_callbacks ["onExpandLSOStorageNode_list_incoming_trade"] then
						for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onExpandLSOStorageNode_list_incoming_trade"]) do
							uix_callback (row, name, reservation, isplayerowned)
						end
					else
						row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					end
					-- kuertee end: callback

					row[2]:createText(ConvertIntegerString(reservation.amount, true, 3, false), { halign = "right" })
					row[3]:createButton({ active = function () return Helper.buttonCancelTradeActive(menu, container, reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
					row[3].handlers.onClick = function () return Helper.buttonCancelTrade(menu, container, reservation.tradedeal) end
				end
			end
		end

		-- sell offer
		if (not isprocessed) and ((waretype == "resource") or (waretype == "product") or (waretype == "intermediate") or (waretype == "trade")) then
			-- kuertee start: callback
			if Helper.uix_callbacks ["onExpandLSOStorageNode_pre_sell_offer_title"] then
				for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onExpandLSOStorageNode_pre_sell_offer_title"]) do
					uix_callback(menu, container, ftable, nodedata)
				end
			end
			-- kuertee end: callback

			local currentprice = math.max(minprice, math.min(maxprice, RoundTotalTradePrice(GetContainerWarePrice(container, nodedata.ware, false))))
			local haspriceoverride = HasContainerWarePriceOverride(container, nodedata.ware, false)
			local istradewaresold = C.GetContainerWareIsSellable(container, nodedata.ware)
			local currentlimit = C.GetContainerSellLimit(container, nodedata.ware)
			local haslimitoverride = C.HasContainerSellLimitOverride(container, nodedata.ware)
			-- title
			row = ftable:addRow(nil, {  })
			row[1]:setColSpan(3):createText(ReadText(1001, 8308), Helper.subHeaderTextProperties)
			row[1].properties.halign = "center"
			if (waretype == "product") or (waretype == "intermediate") or istradewaresold or haslimitoverride then
				-- automatic sell limit
				local row = ftable:addRow("autoselllimitcheckbox", {  })
				if menu.selectedRowData["nodeTable"] == "autoselllimitcheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if (waretype == "resource") and istradewaresold then
					-- Valid case, but we need to hide it from the player
					Helper.setSellLimit(menu, container, nodedata.ware, currentlimit)
					haslimitoverride = true
				end
				if (waretype == "resource") then
					row[1]:setColSpan(3):createText(ReadText(1001, 11282 ) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8402) })
				else
					if haslimitoverride then
						row[1]:setColSpan(2):createText(ReadText(1001, 11282) .. ReadText(1001, 120), { mouseOverText = ReadText(1026, 8402) })
					else
						row[1]:setColSpan(2):createText(ReadText(1001, 8441), { mouseOverText = ReadText(1026, 8409) })
					end
					row[3]:createCheckBox(not haslimitoverride, { height = Helper.standardButtonHeight })
					row[3].handlers.onClick = function (_, checked) return Helper.checkboxSellLimitOverride(menu, container, nodedata.ware, row.index, currentlimit, checked) end
				end
				-- sell limit
				local row = ftable:addRow("autoselllimitslider", {  })
				if menu.selectedRowData["nodeTable"] == "autoselllimitslider" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				local max = GetWareProductionLimit(container, nodedata.ware)
				Helper.LSOStorageNodeSellSlider = { ware = nodedata.ware, widget = row[1]:setColSpan(3):createSliderCell({
					height = Helper.standardTextHeight,
					bgColor = haslimitoverride and Color["slider_background_default"] or Color["slider_background_inactive"],
					valueColor = haslimitoverride and Color["slider_value"] or Color["slider_value_inactive"],
					min = 0,
					minSelect = max == 0 and 0 or 1,
					max = max,
					start = math.min(max, currentlimit),
					hideMaxValue = true,
					readOnly = not haslimitoverride,
					forceArrows = true,
				})}
				-- automatic pricing
				local row = ftable:addRow("autosellpricecheckbox", {  })
				if menu.selectedRowData["nodeTable"] == "autosellpricecheckbox" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if haspriceoverride then
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
				else
					row[1]:createText(ReadText(1001, 8402) .. ReadText(1001, 120), { wordwrap = true })
					row[2]:createText(function () return ConvertMoneyString(math.max(minprice, math.min(maxprice, GetContainerWarePrice(container, nodedata.ware, false))), true, true, 2, true) .. " " .. ReadText(1001, 101) end, { halign = "right" })
				end
				row[3]:createCheckBox(not haspriceoverride, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function (_, checked) return Helper.checkboxStorageWarePriceOverride(menu, container, nodedata.ware, row.index, false, currentprice, checked) end
				if haspriceoverride then
					-- price
					local row = ftable:addRow("autosellpriceslider", {  })
					if menu.selectedRowData["nodeTable"] == "autosellpriceslider" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					row[1]:setColSpan(3):createSliderCell({
						height = Helper.standardTextHeight,
						bgColor = haslimitoverride and Color["slider_background_default"] or Color["slider_background_inactive"],
						valueColor = haspriceoverride and Color["slider_value"] or Color["slider_value_inactive"],
						min = minprice,
						max = maxprice,
						start = currentprice,
						hideMaxValue = true,
						suffix = ReadText(1001, 101),
						readOnly = not haspriceoverride,
						forceArrows = true,
					})
					row[1].handlers.onSliderCellChanged = function(_, value) return Helper.slidercellStorageWarePriceOverride(container, nodedata.ware, false, value) end
					row[1].handlers.onSliderCellActivated = function (id) menu.noupdate = true end
					row[1].handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
				end
				-- trade rule
				local hasownlist = C.HasContainerOwnTradeRule(container, "sell", nodedata.ware)
				local traderuleid = C.GetContainerTradeRuleID(container, "sell", nodedata.ware)
				local row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(ReadText(1001, 11013) .. ReadText(1001, 120), textproperties)
				-- global
				local row = ftable:addRow("selltraderule_global", {  })
				row[1]:setColSpan(2):createText(ReadText(1001, 11025) .. ReadText(1001, 120), textproperties)
				row[3]:createCheckBox(not hasownlist, { height = Helper.standardButtonHeight })
				row[3].handlers.onClick = function(_, checked) return Helper.checkboxSetTradeRuleOverride(menu, container, "sell", nodedata.ware, checked) end
				-- current
				local row = ftable:addRow("selltraderule_current", {  })
				row[1]:setColSpan(2):createDropDown(Helper.traderuleOptions, { startOption = (traderuleid ~= 0) and traderuleid or -1, active = hasownlist }):setTextProperties({ fontsize = config.mapFontSize })
				row[1].handlers.onDropDownConfirmed = function (_, id) return Helper.dropdownTradeRule(menu, container, "sell", nodedata.ware, id) end
				row[1].handlers.onDropDownActivated = function () menu.noupdate = true end
				row[3]:createButton({ mouseOverText = ReadText(1026, 8407) }):setIcon("menu_edit")
				row[3].handlers.onClick = function () return Helper.buttonEditTradeRule(menu, C.GetContainerTradeRuleID(container, "sell", nodedata.ware)) end
			end
			-- create / remove offer
			if (waretype == "trade") or (waretype == "resource") then
				row = ftable:addRow("tradesell", {  })
				if menu.selectedRowData["nodeTable"] == "trade" then
					menu.selectedRows["nodeTable"] = row.index
					menu.selectedRowData["nodeTable"] = nil
				end
				if waretype == "trade" then
					row[1]:setColSpan(3):createButton({  }):setText(istradewaresold and ReadText(1001, 8405) or ReadText(1001, 8404), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageSellTradeWare(menu, container, nodedata.ware, istradewaresold) end
				elseif waretype == "resource" then
					row[1]:setColSpan(3):createButton({  }):setText((haslimitoverride or istradewaresold) and ReadText(1001, 8405) or ReadText(1001, 8404), { halign = "center" })
					row[1].handlers.onClick = function () return Helper.buttonStorageSellResourceWare(menu, container, nodedata.ware, haslimitoverride or istradewaresold, currentlimit) end
				end
			end
			-- reservations
			if reservations[nodedata.ware] and (#reservations[nodedata.ware].selloffer > 0) then
				-- title
				row = ftable:addRow(nil, {  })
				row[1]:setColSpan(3):createText(string.format(ReadText(1001, 7993), GetWareData(nodedata.ware, "name")) .. ReadText(1001, 120), { wordwrap = true })
				for i, reservation in ipairs(reservations[nodedata.ware].selloffer) do
					row = ftable:addRow("sellreservation" .. i, {  })
					if menu.selectedRowData["nodeTable"] == "sellreservation" then
						menu.selectedRows["nodeTable"] = row.index
						menu.selectedRowData["nodeTable"] = nil
					end
					local isplayerowned = GetComponentData(ConvertStringTo64Bit(tostring(reservation.reserver)), "isplayerowned")
					local name = (isplayerowned and ColorText["text_player"] or "") .. ffi.string(C.GetComponentName(reservation.reserver)) .. " (" .. ffi.string(C.GetObjectIDCode(reservation.reserver)) .. ")\27X"

					-- kuertee start: callback
					-- row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					if Helper.uix_callbacks ["onExpandLSOStorageNode_list_incoming_trade"] then
						for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onExpandLSOStorageNode_list_incoming_trade"]) do
							uix_callback (row, name, reservation, isplayerowned)
						end
					else
						row[1]:createText(function () return Helper.getETAString(name, reservation.eta) end, { font = Helper.standardFontMono })
					end
					-- kuertee end: callback

					row[2]:createText(ConvertIntegerString(reservation.amount, true, 3, false), { halign = "right" })
					row[3]:createButton({ active = function () return Helper.buttonCancelTradeActive(menu, container, reservation.tradedeal) end, mouseOverText = ReadText(1026, 7924) }):setText("X", { halign = "center" })
					row[3].handlers.onClick = function () return Helper.buttonCancelTrade(menu, container, reservation.tradedeal) end
				end
			end
		end

		-- buy/sell slider hooks
		if limitslider then
			limitslider.handlers.onSliderCellChanged = function (_, value) return Helper.slidercellStorageLevelOverride(menu, container, nodedata.ware, value, Helper.LSOStorageNodeBuySlider, Helper.LSOStorageNodeSellSlider) end
			limitslider.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			limitslider.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
		if Helper.LSOStorageNodeBuySlider then
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellChanged = function(_, value) return Helper.slidercellBuyLimitOverride(menu, container, nodedata.ware, value, Helper.LSOStorageNodeSellSlider) end
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			Helper.LSOStorageNodeBuySlider.widget.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
		if Helper.LSOStorageNodeSellSlider then
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellChanged = function(_, value) return Helper.slidercellSellLimitOverride(menu, container, nodedata.ware, value, Helper.LSOStorageNodeBuySlider) end
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellActivated = function (id) menu.noupdate = true end
			Helper.LSOStorageNodeSellSlider.widget.handlers.onSliderCellDeactivated = function (id) menu.noupdate = false end
		end
	end

	if menu.selectedRowData["nodeTable"] then
		menu.selectedCols["nodeTable"] = nil
	end
	menu.restoreTableState("nodeTable", ftable)

	-- kuertee start: callback
	if Helper.uix_callbacks ["onExpandLSOStorageNode"] then
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onExpandLSOStorageNode"]) do
			uix_callback(menu, container, ftable, nodedata)
		end
	end
	-- kuertee end: callback
end

function ModLua.checkboxSetTradeRuleOverride(menu, container, type, ware, checked)
	if checked then
		C.SetContainerTradeRule(container, -1, type, ware, false)
	else
		local currentid = C.GetContainerTradeRuleID(container, type, ware or "")
		C.SetContainerTradeRule(container, (currentid ~= 0) and currentid or -1, type, ware, true)
	end

	if (type == "buy") or (type == "sell") then

		-- kuertee start: callback
		if Helper.uix_callbacks ["checkboxSetTradeRuleOverride_pre_update_expanded_node"] then
			-- function widgetPrototypes.flowchartnode:updateStatus(text, icon, bgicon, color, mouseovertext)
			local status_text = nil
			local status_icon = Helper.isTradeRestricted(container, ware) and "lso_error" or nil
			local status_bgicon = nil
			local status_color = Color["icon_warning"]
			local status_mouseovertext
			for uix_id, uix_callback in pairs (Helper.uix_callbacks ["checkboxSetTradeRuleOverride_pre_update_expanded_node"]) do
				status_text, status_icon, status_bgicon, status_color, status_mouseovertext = uix_callback(menu, container, type, ware, checked, status_text, status_icon, status_bgicon, status_color, status_mouseovertext)
			end
			menu.expandedNode:updateStatus(status_text, status_icon, status_bgicon, status_color, status_mouseovertext)
		else

			menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(container, ware) and "lso_error" or nil, nil, Color["icon_warning"])
		end
		-- kuertee end: callback

	end
	menu.updateExpandedNode()
end

function  ModLua.dropdownTradeRule(menu, container, type, ware, id)
	C.SetContainerTradeRule(container, tonumber(id), type, ware, true)

	if (type == "buy") or (type == "sell") then

		-- kuertee start: callback
		if Helper.uix_callbacks ["dropdownTradeRule_pre_update_expanded_node"] then
			-- function widgetPrototypes.flowchartnode:updateStatus(text, icon, bgicon, color, mouseovertext)
			local status_text = nil
			local status_icon = Helper.isTradeRestricted(container, ware) and "lso_error" or nil
			local status_bgicon = nil
			local status_color = Color["icon_warning"]
			local status_mouseovertext = nil
			for uix_id, uix_callback in pairs (Helper.uix_callbacks ["dropdownTradeRule_pre_update_expanded_node"]) do
				status_text, status_icon, status_bgicon, status_color, status_mouseovertext = uix_callback(menu, container, type, ware, id, status_text, status_icon, status_bgicon, status_color, status_mouseovertext)
			end
			menu.expandedNode:updateStatus(status_text, status_icon, status_bgicon, status_color, mouseOverText)
		else

			menu.expandedNode:updateStatus(nil, Helper.isTradeRestricted(container, ware) and "lso_error" or nil, nil, Color["icon_warning"])
		end
		-- kuertee end: callback

	end
	menu.noupdate = false
end

function ModLua.onCollapseLSOStorageNode(menu, nodedata)
	UnregisterEvent("newWareReservation", menu.newWareReservationCallback)
	menu.wareReservationRegistered = nil
	Helper.LSOStorageNodeBuySlider = nil
	Helper.LSOStorageNodeSellSlider = nil

	-- kuertee start: callback
	if Helper.uix_callbacks ["onCollapseLSOStorageNode"] then
		for uix_id, uix_callback in pairs (Helper.uix_callbacks ["onCollapseLSOStorageNode"]) do
			uix_callback (menu, nodedata)
		end
	end
	-- kuertee end: callback
end

function ModLua.getLimitedWareAmount(ware)

	-- kuertee start: do not fail when modified
	-- if C.IsGameModified() then
	-- 	return tonumber(ffi.string(C.GetUserData("limited_blueprint_" .. ware))) or 0
	-- end
	-- kuertee end: do not fail when modified

	return tonumber(ffi.string(C.GetUserDataSigned("limited_blueprint_" .. ware))) or 0
end

ModLua.rewriteFunctions()

-- kuertee end: rewrites

-- kuertee start: new funcs

function ModLua.addNewFunctions()
	Helper.registerCallback = ModLua.registerCallback
	Helper.deregisterCallback = ModLua.deregisterCallback
	Helper.updateCallback = ModLua.updateCallback
	Helper.debugText = ModLua.debugText
	Helper.debugText_forced = ModLua.debugText_forced
	Helper.setDebugCallbacks = ModLua.setDebugCallbacks
end

Helper.uix_callbackCount = 0
function ModLua.registerCallback(callbackName, callbackFunction, id)
    -- note 1: format is generally [function name]_[action]. e.g.: in kuertee_menu_transporter, "display_on_set_room_active" overrides the room's active property with the return of the callback.
    -- note 2: events have the word "_on_" followed by a PRESENT TENSE verb. e.g.: in kuertee_menu_transporter, "display_on_set_buttontable" is called after all of the rows of buttontable are set.
    -- note 3: new callbacks can be added or existing callbacks can be edited. but commit your additions/changes to the mod's GIT repository.
    -- note 4: search for the callback names to see where they are executed.
    -- note 5: if a callback requires a return value, return it in an object var. e.g. "display_on_set_room_active" requires a return of {active = true | false}.
    if Helper.uix_callbacks [callbackName] == nil then
        Helper.uix_callbacks [callbackName] = {}
    end
    if not Helper.uix_callbacks[callbackName][id] then
        if not id then
            Helper.uix_callbackCount = Helper.uix_callbackCount + 1
            id = "_" .. tostring(Helper.uix_callbackCount)
        end
        Helper.uix_callbacks[callbackName][id] = callbackFunction
        if Helper.isDebugCallbacks then
            Helper.debugText_forced("Helper uix registerCallback: Helper.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(Helper.uix_callbacks[callbackName][id]))
        end
    else
        Helper.debugText_forced("Helper uix registerCallback: callback at " .. callbackName .. " with id " .. tostring(id) .. " was already previously registered")
    end
end

Helper.uix_isDeregisterQueued = nil
Helper.uix_callbacks_toDeregister = {}
function ModLua.deregisterCallback(callbackName, callbackFunction, id)
    if not Helper.uix_callbacks_toDeregister[callbackName] then
        Helper.uix_callbacks_toDeregister[callbackName] = {}
    end
    if id then
        table.insert(Helper.uix_callbacks_toDeregister[callbackName], id)
    else
        if Helper.uix_callbacks[callbackName] then
            for id, func in pairs(Helper.uix_callbacks[callbackName]) do
                if func == callbackFunction then
                    table.insert(Helper.uix_callbacks_toDeregister[callbackName], id)
                end
            end
        end
    end
    if not Helper.uix_isDeregisterQueued then
        Helper.uix_isDeregisterQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(ModLua.deregisterCallbacksNow, true, getElapsedTime() + 1)
    end
end

function ModLua.deregisterCallbacksNow()
    Helper.uix_isDeregisterQueued = nil
    for callbackName, ids in pairs(Helper.uix_callbacks_toDeregister) do
        if Helper.uix_callbacks[callbackName] then
            for _, id in ipairs(ids) do
                if Helper.uix_callbacks[callbackName][id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced("Helper uix deregisterCallbacksNow (pre): Helper.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(Helper.uix_callbacks[callbackName][id]))
                    end
                    Helper.uix_callbacks[callbackName][id] = nil
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced("Helper uix deregisterCallbacksNow (post): Helper.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(id) .. "]: " .. tostring(Helper.uix_callbacks[callbackName][id]))
                    end
                else
                    Helper.debugText_forced("Helper uix deregisterCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
    Helper.uix_callbacks_toDeregister = {}
end

Helper.uix_isUpdateQueued = nil
Helper.uix_callbacks_toUpdate = {}
function ModLua.updateCallback(callbackName, id, callbackFunction)
    if not Helper.uix_callbacks_toUpdate[callbackName] then
        Helper.uix_callbacks_toUpdate[callbackName] = {}
    end
    if id then
        table.insert(Helper.uix_callbacks_toUpdate[callbackName], {id = id, callbackFunction = callbackFunction})
    end
    if not Helper.uix_isUpdateQueued then
        Helper.uix_isUpdateQueued = true
        Helper.addDelayedOneTimeCallbackOnUpdate(ModLua.updateCallbacksNow, true, getElapsedTime() + 1)
    end
end

function ModLua.updateCallbacksNow()
    Helper.uix_isUpdateQueued = nil
    for callbackName, updateDatas in pairs(Helper.uix_callbacks_toUpdate) do
        if Helper.uix_callbacks[callbackName] then
            for _, updateData in ipairs(updateDatas) do
                if Helper.uix_callbacks[callbackName][updateData.id] then
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced("Helper uix updateCallbacksNow (pre): Helper.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(Helper.uix_callbacks[callbackName][updateData.id]))
                    end
                    Helper.uix_callbacks[callbackName][updateData.id] = updateData.callbackFunction
                    if Helper.isDebugCallbacks then
                        Helper.debugText_forced("Helper uix updateCallbacksNow (post): Helper.uix_callbacks[" .. tostring(callbackName) .. "][" .. tostring(updateData.id) .. "]: " .. tostring(Helper.uix_callbacks[callbackName][updateData.id]))
                    end
                else
                    Helper.debugText_forced("Helper uix updateCallbacksNow: callback at " .. callbackName .. " with id " .. tostring(id) .. " doesn't exist")
                end
            end
        end
    end
end

function ModLua.debugText(data1, data2, indent, isForced)
	local isDebug = false
	if isDebug == true or isForced == true then
		if indent == nil then
			indent = ""
		end
		if data1 then
			if not data2 then
				DebugError ("uix: " .. indent .. tostring (data1))
			else
				DebugError ("uix: " .. indent .. tostring (data1) .. " = " .. tostring(data2))
			end
		end
		indent = indent .. "  "
		if type(data1) == "table" then
			for key, value in pairs(data1) do
				Helper.debugText(key, value, indent, isForced)
			end
		end
		if data2 then
			if type(data2) == "table" then
				Helper.debugText(data2, nil, indent, isForced)
			end
		end
	end
end

function ModLua.debugText_forced(data1, data2, indent)
	return Helper.debugText(data1, data2, indent, true)
end

Helper.isDebugCallbacks = nil
function ModLua.setDebugCallbacks(isOn)
	if isOn == true then
		Helper.isDebugCallbacks = true
	else
		Helper.isDebugCallbacks = nil
	end
end

ModLua.addNewFunctions()

-- kuertee end: new funcs
